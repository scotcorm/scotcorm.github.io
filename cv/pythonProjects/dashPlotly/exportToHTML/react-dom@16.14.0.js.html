<html>
<head>
<title>react-dom@16.14.0.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-dom@16.14.0.js</font>
</center></td></tr></table>
<pre><span class="s0">/** @license React v16.14.0 
 * react-dom.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">(</span><span class="s3">function </span><span class="s1">(global, factory) {</span>
  <span class="s3">typeof </span><span class="s1">exports === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">module !== </span><span class="s2">'undefined' </span><span class="s1">? factory(exports, require(</span><span class="s2">'react'</span><span class="s1">)) :</span>
  <span class="s3">typeof </span><span class="s1">define === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s1">, </span><span class="s2">'react'</span><span class="s1">], factory) :</span>
  <span class="s1">(global = global || self, factory(global.ReactDOM = {}, global.React));</span>
<span class="s1">}(</span><span class="s3">this</span><span class="s1">, (</span><span class="s3">function </span><span class="s1">(exports, React) { </span><span class="s2">'use strict'</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; </span><span class="s0">// Prevent newer renderers from RTE when used with older react package versions.</span>
  <span class="s0">// Current owner and dispatcher used to share the same ref,</span>
  <span class="s0">// but PR #14548 split them out to better support the react-debug-tools package.</span>

  <span class="s3">if </span><span class="s1">(!ReactSharedInternals.hasOwnProperty(</span><span class="s2">'ReactCurrentDispatcher'</span><span class="s1">)) {</span>
    <span class="s1">ReactSharedInternals.ReactCurrentDispatcher = {</span>
      <span class="s1">current: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!ReactSharedInternals.hasOwnProperty(</span><span class="s2">'ReactCurrentBatchConfig'</span><span class="s1">)) {</span>
    <span class="s1">ReactSharedInternals.ReactCurrentBatchConfig = {</span>
      <span class="s1">suspense: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">// by calls to these methods by a Babel plugin.</span>
  <span class="s0">//</span>
  <span class="s0">// In PROD (or in packages without access to React internals),</span>
  <span class="s0">// they are left as they are instead.</span>

  <span class="s3">function </span><span class="s1">warn(format) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_len = arguments.length, args = </span><span class="s3">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key = </span><span class="s4">1</span><span class="s1">; _key &lt; _len; _key++) {</span>
        <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">'warn'</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">error(format) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s3">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
        <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">'error'</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">printWarning(level, format, args) {</span>
    <span class="s0">// When changing this logic, you might want to also</span>
    <span class="s0">// update consoleWithStackDev.www.js as well.</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hasExistingStack = args.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">args[args.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; args[args.length - </span><span class="s4">1</span><span class="s1">].indexOf(</span><span class="s2">'</span><span class="s5">\n    </span><span class="s2">in'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!hasExistingStack) {</span>
        <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
        <span class="s3">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

        <span class="s3">if </span><span class="s1">(stack !== </span><span class="s2">''</span><span class="s1">) {</span>
          <span class="s1">format += </span><span class="s2">'%s'</span><span class="s1">;</span>
          <span class="s1">args = args.concat([stack]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s3">function </span><span class="s1">(item) {</span>
        <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ item;</span>
      <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

      <span class="s1">argsWithFormat.unshift(</span><span class="s2">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
      <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
      <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

      <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s0">// --- Welcome to debugging React ---</span>
        <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
        <span class="s0">// to find the callsite that caused this warning to fire.</span>
        <span class="s3">var </span><span class="s1">argIndex = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">message = </span><span class="s2">'Warning: ' </span><span class="s1">+ format.replace(/%s/g, </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">return </span><span class="s1">args[argIndex++];</span>
        <span class="s1">});</span>
        <span class="s3">throw new </span><span class="s1">Error(message);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!React) {</span>
    <span class="s1">{</span>
      <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.&quot; </span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">invokeGuardedCallbackImpl = </span><span class="s3">function </span><span class="s1">(name, func, context, a, b, c, d, e, f) {</span>
    <span class="s3">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">func.apply(context, funcArgs);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s3">this</span><span class="s1">.onError(error);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s0">// In DEV mode, we swap out invokeGuardedCallback for a special version</span>
    <span class="s0">// that plays more nicely with the browser's DevTools. The idea is to preserve</span>
    <span class="s0">// &quot;Pause on exceptions&quot; behavior. Because React wraps all user-provided</span>
    <span class="s0">// functions in invokeGuardedCallback, and the production version of</span>
    <span class="s0">// invokeGuardedCallback uses a try-catch, all user exceptions are treated</span>
    <span class="s0">// like caught exceptions, and the DevTools won't pause unless the developer</span>
    <span class="s0">// takes the extra step of enabling pause on caught exceptions. This is</span>
    <span class="s0">// unintuitive, though, because even though React has caught the error, from</span>
    <span class="s0">// the developer's perspective, the error is uncaught.</span>
    <span class="s0">//</span>
    <span class="s0">// To preserve the expected &quot;Pause on exceptions&quot; behavior, we don't use a</span>
    <span class="s0">// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake</span>
    <span class="s0">// DOM node, and call the user-provided callback from inside an event handler</span>
    <span class="s0">// for that fake event. If the callback throws, the error is &quot;captured&quot; using</span>
    <span class="s0">// a global event handler. But because the error happens in a different</span>
    <span class="s0">// event loop context, it does not interrupt the normal program flow.</span>
    <span class="s0">// Effectively, this gives us try-catch behavior without actually using</span>
    <span class="s0">// try-catch. Neat!</span>
    <span class="s0">// Check that the browser supports the APIs we need to implement our special</span>
    <span class="s0">// DEV version of invokeGuardedCallback</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">window.dispatchEvent === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">document !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">document.createEvent === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">fakeNode = document.createElement(</span><span class="s2">'react'</span><span class="s1">);</span>

      <span class="s3">var </span><span class="s1">invokeGuardedCallbackDev = </span><span class="s3">function </span><span class="s1">(name, func, context, a, b, c, d, e, f) {</span>
        <span class="s0">// If document doesn't exist we know for sure we will crash in this method</span>
        <span class="s0">// when we call document.createEvent(). However this can cause confusing</span>
        <span class="s0">// errors: https://github.com/facebookincubator/create-react-app/issues/3482</span>
        <span class="s0">// So we preemptively throw with a better message instead.</span>
        <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">document !== </span><span class="s2">'undefined'</span><span class="s1">)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">evt = document.createEvent(</span><span class="s2">'Event'</span><span class="s1">); </span><span class="s0">// Keeps track of whether the user-provided callback threw an error. We</span>
        <span class="s0">// set this to true at the beginning, then set it to false right after</span>
        <span class="s0">// calling the function. If the function errors, `didError` will never be</span>
        <span class="s0">// set to false. This strategy works even if the browser is flaky and</span>
        <span class="s0">// fails to call our global error handler, because it doesn't rely on</span>
        <span class="s0">// the error event at all.</span>

        <span class="s3">var </span><span class="s1">didError = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Keeps track of the value of window.event so that we can reset it</span>
        <span class="s0">// during the callback to let user code access window.event in the</span>
        <span class="s0">// browsers that support it.</span>

        <span class="s3">var </span><span class="s1">windowEvent = window.event; </span><span class="s0">// Keeps track of the descriptor of window.event to restore it after event</span>
        <span class="s0">// dispatching: https://github.com/facebook/react/issues/13688</span>

        <span class="s3">var </span><span class="s1">windowEventDescriptor = Object.getOwnPropertyDescriptor(window, </span><span class="s2">'event'</span><span class="s1">); </span><span class="s0">// Create an event handler for our fake event. We will synchronously</span>
        <span class="s0">// dispatch our fake event using `dispatchEvent`. Inside the handler, we</span>
        <span class="s0">// call the user-provided callback.</span>

        <span class="s3">var </span><span class="s1">funcArgs = Array.prototype.slice.call(arguments, </span><span class="s4">3</span><span class="s1">);</span>

        <span class="s3">function </span><span class="s1">callCallback() {</span>
          <span class="s0">// We immediately remove the callback from event listeners so that</span>
          <span class="s0">// nested `invokeGuardedCallback` calls do not clash. Otherwise, a</span>
          <span class="s0">// nested call would trigger the fake event handlers of any call higher</span>
          <span class="s0">// in the stack.</span>
          <span class="s1">fakeNode.removeEventListener(evtType, callCallback, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// We check for window.hasOwnProperty('event') to prevent the</span>
          <span class="s0">// window.event assignment in both IE &lt;= 10 as they throw an error</span>
          <span class="s0">// &quot;Member not found&quot; in strict mode, and in Firefox which does not</span>
          <span class="s0">// support window.event.</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">window.event !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; window.hasOwnProperty(</span><span class="s2">'event'</span><span class="s1">)) {</span>
            <span class="s1">window.event = windowEvent;</span>
          <span class="s1">}</span>

          <span class="s1">func.apply(context, funcArgs);</span>
          <span class="s1">didError = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Create a global error event handler. We use this to capture the value</span>
        <span class="s0">// that was thrown. It's possible that this error handler will fire more</span>
        <span class="s0">// than once; for example, if non-React code also calls `dispatchEvent`</span>
        <span class="s0">// and a handler for that event throws. We should be resilient to most of</span>
        <span class="s0">// those cases. Even if our error event handler fires more than once, the</span>
        <span class="s0">// last error event is always used. If the callback actually does error,</span>
        <span class="s0">// we know that the last error event is the correct one, because it's not</span>
        <span class="s0">// possible for anything else to have happened in between our callback</span>
        <span class="s0">// erroring and the code that follows the `dispatchEvent` call below. If</span>
        <span class="s0">// the callback doesn't error, but the error event was fired, we know to</span>
        <span class="s0">// ignore it because `didError` will be false, as described above.</span>


        <span class="s3">var </span><span class="s1">error; </span><span class="s0">// Use this to track whether the error event is ever called.</span>

        <span class="s3">var </span><span class="s1">didSetError = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">isCrossOriginError = </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">function </span><span class="s1">handleWindowError(event) {</span>
          <span class="s1">error = event.error;</span>
          <span class="s1">didSetError = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(error === </span><span class="s3">null </span><span class="s1">&amp;&amp; event.colno === </span><span class="s4">0 </span><span class="s1">&amp;&amp; event.lineno === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">isCrossOriginError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(event.defaultPrevented) {</span>
            <span class="s0">// Some other error handler has prevented default.</span>
            <span class="s0">// Browsers silence the error report if this happens.</span>
            <span class="s0">// We'll remember this to later decide whether to log it or not.</span>
            <span class="s3">if </span><span class="s1">(error != </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">error === </span><span class="s2">'object'</span><span class="s1">) {</span>
              <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">error._suppressLogging = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s3">catch </span><span class="s1">(inner) {</span><span class="s0">// Ignore.</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Create a fake event type.</span>


        <span class="s3">var </span><span class="s1">evtType = </span><span class="s2">&quot;react-&quot; </span><span class="s1">+ (name ? name : </span><span class="s2">'invokeguardedcallback'</span><span class="s1">); </span><span class="s0">// Attach our event handlers</span>

        <span class="s1">window.addEventListener(</span><span class="s2">'error'</span><span class="s1">, handleWindowError);</span>
        <span class="s1">fakeNode.addEventListener(evtType, callCallback, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Synchronously dispatch our fake event. If the user-provided function</span>
        <span class="s0">// errors, it will trigger our global error handler.</span>

        <span class="s1">evt.initEvent(evtType, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">fakeNode.dispatchEvent(evt);</span>

        <span class="s3">if </span><span class="s1">(windowEventDescriptor) {</span>
          <span class="s1">Object.defineProperty(window, </span><span class="s2">'event'</span><span class="s1">, windowEventDescriptor);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(didError) {</span>
          <span class="s3">if </span><span class="s1">(!didSetError) {</span>
            <span class="s0">// The callback errored, but the error event never fired.</span>
            <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'An error was thrown inside one of your components, but React ' </span><span class="s1">+ </span><span class="s2">&quot;doesn't know what it was. This is likely due to browser &quot; </span><span class="s1">+ </span><span class="s2">'flakiness. React does its best to preserve the &quot;Pause on ' </span><span class="s1">+ </span><span class="s2">'exceptions&quot; behavior of the DevTools, which requires some ' </span><span class="s1">+ </span><span class="s2">&quot;DEV-mode only tricks. It's possible that these don't work in &quot; </span><span class="s1">+ </span><span class="s2">'your browser. Try triggering the error in production mode, ' </span><span class="s1">+ </span><span class="s2">'or switching to a modern browser. If you suspect that this is ' </span><span class="s1">+ </span><span class="s2">'actually an issue with React, please file an issue.'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isCrossOriginError) {</span>
            <span class="s1">error = </span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">&quot;A cross-origin error was thrown. React doesn't have access to &quot; </span><span class="s1">+ </span><span class="s2">'the actual error object in development. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-crossorigin-error for more information.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s3">this</span><span class="s1">.onError(error);</span>
        <span class="s1">} </span><span class="s0">// Remove our event listeners</span>


        <span class="s1">window.removeEventListener(</span><span class="s2">'error'</span><span class="s1">, handleWindowError);</span>
      <span class="s1">};</span>

      <span class="s1">invokeGuardedCallbackImpl = invokeGuardedCallbackDev;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;</span>

  <span class="s3">var </span><span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Used by event system to capture/rethrow the first error.</span>

  <span class="s3">var </span><span class="s1">hasRethrowError = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">rethrowError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">reporter = {</span>
    <span class="s1">onError: </span><span class="s3">function </span><span class="s1">(error) {</span>
      <span class="s1">hasError = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">caughtError = error;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Call a function while guarding against errors that happens within it. 
   * Returns an error if it throws, otherwise null. 
   * 
   * In production, this is implemented using a try-catch. The reason we don't 
   * use a try-catch directly is so that we can swap out a different 
   * implementation in DEV mode. 
   * 
   * @param {String} name of the guard to use for logging or debugging 
   * @param {Function} func The function to invoke 
   * @param {*} context The context to use when calling the function 
   * @param {...*} args Arguments for function 
   */</span>

  <span class="s3">function </span><span class="s1">invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {</span>
    <span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">invokeGuardedCallbackImpl$1.apply(reporter, arguments);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Same as invokeGuardedCallback, but instead of returning an error, it stores 
   * it in a global so it can be rethrown by `rethrowCaughtError` later. 
   * TODO: See if caughtError and rethrowError can be unified. 
   * 
   * @param {String} name of the guard to use for logging or debugging 
   * @param {Function} func The function to invoke 
   * @param {*} context The context to use when calling the function 
   * @param {...*} args Arguments for function 
   */</span>

  <span class="s3">function </span><span class="s1">invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {</span>
    <span class="s1">invokeGuardedCallback.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>

    <span class="s3">if </span><span class="s1">(hasError) {</span>
      <span class="s3">var </span><span class="s1">error = clearCaughtError();</span>

      <span class="s3">if </span><span class="s1">(!hasRethrowError) {</span>
        <span class="s1">hasRethrowError = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">rethrowError = error;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * During execution of guarded functions we will capture the first error which 
   * we will rethrow to be handled by the top level error handler. 
   */</span>

  <span class="s3">function </span><span class="s1">rethrowCaughtError() {</span>
    <span class="s3">if </span><span class="s1">(hasRethrowError) {</span>
      <span class="s3">var </span><span class="s1">error = rethrowError;</span>
      <span class="s1">hasRethrowError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">rethrowError = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">hasCaughtError() {</span>
    <span class="s3">return </span><span class="s1">hasError;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">clearCaughtError() {</span>
    <span class="s3">if </span><span class="s1">(hasError) {</span>
      <span class="s3">var </span><span class="s1">error = caughtError;</span>
      <span class="s1">hasError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">error;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">getFiberCurrentPropsFromNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">getInstanceFromNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">getNodeFromInstance = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {</span>
    <span class="s1">getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;</span>
    <span class="s1">getInstanceFromNode = getInstanceFromNodeImpl;</span>
    <span class="s1">getNodeFromInstance = getNodeFromInstanceImpl;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!getNodeFromInstance || !getInstanceFromNode) {</span>
        <span class="s1">error(</span><span class="s2">'EventPluginUtils.setComponentTree(...): Injected ' </span><span class="s1">+ </span><span class="s2">'module is missing getNodeFromInstance or getInstanceFromNode.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">validateEventDispatches;</span>

  <span class="s1">{</span>
    <span class="s1">validateEventDispatches = </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">var </span><span class="s1">dispatchListeners = event._dispatchListeners;</span>
      <span class="s3">var </span><span class="s1">dispatchInstances = event._dispatchInstances;</span>
      <span class="s3">var </span><span class="s1">listenersIsArr = Array.isArray(dispatchListeners);</span>
      <span class="s3">var </span><span class="s1">listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">instancesIsArr = Array.isArray(dispatchInstances);</span>
      <span class="s3">var </span><span class="s1">instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {</span>
        <span class="s1">error(</span><span class="s2">'EventPluginUtils: Invalid `event`.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Dispatch the event to the listener. 
   * @param {SyntheticEvent} event SyntheticEvent to handle 
   * @param {function} listener Application-level callback 
   * @param {*} inst Internal component instance 
   */</span>


  <span class="s3">function </span><span class="s1">executeDispatch(event, listener, inst) {</span>
    <span class="s3">var </span><span class="s1">type = event.type || </span><span class="s2">'unknown-event'</span><span class="s1">;</span>
    <span class="s1">event.currentTarget = getNodeFromInstance(inst);</span>
    <span class="s1">invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);</span>
    <span class="s1">event.currentTarget = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Standard/simple iteration through an event's collected dispatches. 
   */</span>

  <span class="s3">function </span><span class="s1">executeDispatchesInOrder(event) {</span>
    <span class="s3">var </span><span class="s1">dispatchListeners = event._dispatchListeners;</span>
    <span class="s3">var </span><span class="s1">dispatchInstances = event._dispatchInstances;</span>

    <span class="s1">{</span>
      <span class="s1">validateEventDispatches(event);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(Array.isArray(dispatchListeners)) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dispatchListeners.length; i++) {</span>
        <span class="s3">if </span><span class="s1">(event.isPropagationStopped()) {</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Listeners and Instances are two parallel arrays that are always in sync.</span>


        <span class="s1">executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(dispatchListeners) {</span>
      <span class="s1">executeDispatch(event, dispatchListeners, dispatchInstances);</span>
    <span class="s1">}</span>

    <span class="s1">event._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">event._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">FunctionComponent = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ClassComponent = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IndeterminateComponent = </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// Before we know whether it is function or class</span>

  <span class="s3">var </span><span class="s1">HostRoot = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Root of a host tree. Could be nested inside another node.</span>

  <span class="s3">var </span><span class="s1">HostPortal = </span><span class="s4">4</span><span class="s1">; </span><span class="s0">// A subtree. Could be an entry point to a different renderer.</span>

  <span class="s3">var </span><span class="s1">HostComponent = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HostText = </span><span class="s4">6</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Fragment = </span><span class="s4">7</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Mode = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ContextConsumer = </span><span class="s4">9</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ContextProvider = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ForwardRef = </span><span class="s4">11</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Profiler = </span><span class="s4">12</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SuspenseComponent = </span><span class="s4">13</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">MemoComponent = </span><span class="s4">14</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SimpleMemoComponent = </span><span class="s4">15</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LazyComponent = </span><span class="s4">16</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IncompleteClassComponent = </span><span class="s4">17</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DehydratedFragment = </span><span class="s4">18</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SuspenseListComponent = </span><span class="s4">19</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">FundamentalComponent = </span><span class="s4">20</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ScopeComponent = </span><span class="s4">21</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Block = </span><span class="s4">22</span><span class="s1">;</span>

  <span class="s0">/** 
   * Injectable ordering of event plugins. 
   */</span>
  <span class="s3">var </span><span class="s1">eventPluginOrder = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s0">/** 
   * Injectable mapping from names to event plugin modules. 
   */</span>

  <span class="s3">var </span><span class="s1">namesToPlugins = {};</span>
  <span class="s0">/** 
   * Recomputes the plugin list using the injected plugins and plugin ordering. 
   * 
   * @private 
   */</span>

  <span class="s3">function </span><span class="s1">recomputePluginOrdering() {</span>
    <span class="s3">if </span><span class="s1">(!eventPluginOrder) {</span>
      <span class="s0">// Wait until an `eventPluginOrder` is injected.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pluginName </span><span class="s3">in </span><span class="s1">namesToPlugins) {</span>
      <span class="s3">var </span><span class="s1">pluginModule = namesToPlugins[pluginName];</span>
      <span class="s3">var </span><span class="s1">pluginIndex = eventPluginOrder.indexOf(pluginName);</span>

      <span class="s3">if </span><span class="s1">(!(pluginIndex &gt; -</span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;`.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(plugins[pluginIndex]) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!pluginModule.extractEvents) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;` does not.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">plugins[pluginIndex] = pluginModule;</span>
      <span class="s3">var </span><span class="s1">publishedEvents = pluginModule.eventTypes;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">eventName </span><span class="s3">in </span><span class="s1">publishedEvents) {</span>
        <span class="s3">if </span><span class="s1">(!publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: Failed to publish event `&quot; </span><span class="s1">+ eventName + </span><span class="s2">&quot;` for plugin `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;`.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Publishes an event so that it can be dispatched by the supplied plugin. 
   * 
   * @param {object} dispatchConfig Dispatch configuration for the event. 
   * @param {object} PluginModule Plugin publishing the event. 
   * @return {boolean} True if the event was successfully published. 
   * @private 
   */</span>


  <span class="s3">function </span><span class="s1">publishEventForPlugin(dispatchConfig, pluginModule, eventName) {</span>
    <span class="s3">if </span><span class="s1">(!!eventNameDispatchConfigs.hasOwnProperty(eventName)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same event name, `&quot; </span><span class="s1">+ eventName + </span><span class="s2">&quot;`.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">eventNameDispatchConfigs[eventName] = dispatchConfig;</span>
    <span class="s3">var </span><span class="s1">phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;</span>

    <span class="s3">if </span><span class="s1">(phasedRegistrationNames) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">phaseName </span><span class="s3">in </span><span class="s1">phasedRegistrationNames) {</span>
        <span class="s3">if </span><span class="s1">(phasedRegistrationNames.hasOwnProperty(phaseName)) {</span>
          <span class="s3">var </span><span class="s1">phasedRegistrationName = phasedRegistrationNames[phaseName];</span>
          <span class="s1">publishRegistrationName(phasedRegistrationName, pluginModule, eventName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(dispatchConfig.registrationName) {</span>
      <span class="s1">publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Publishes a registration name that is used to identify dispatched events. 
   * 
   * @param {string} registrationName Registration name to add. 
   * @param {object} PluginModule Plugin publishing the event. 
   * @private 
   */</span>


  <span class="s3">function </span><span class="s1">publishRegistrationName(registrationName, pluginModule, eventName) {</span>
    <span class="s3">if </span><span class="s1">(!!registrationNameModules[registrationName]) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: More than one plugin attempted to publish the same registration name, `&quot; </span><span class="s1">+ registrationName + </span><span class="s2">&quot;`.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">registrationNameModules[registrationName] = pluginModule;</span>
    <span class="s1">registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">lowerCasedName = registrationName.toLowerCase();</span>
      <span class="s1">possibleRegistrationNames[lowerCasedName] = registrationName;</span>

      <span class="s3">if </span><span class="s1">(registrationName === </span><span class="s2">'onDoubleClick'</span><span class="s1">) {</span>
        <span class="s1">possibleRegistrationNames.ondblclick = registrationName;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Registers plugins so that they can extract and dispatch events. 
   */</span>

  <span class="s0">/** 
   * Ordered list of injected plugins. 
   */</span>


  <span class="s3">var </span><span class="s1">plugins = [];</span>
  <span class="s0">/** 
   * Mapping from event name to dispatch config 
   */</span>

  <span class="s3">var </span><span class="s1">eventNameDispatchConfigs = {};</span>
  <span class="s0">/** 
   * Mapping from registration name to plugin module 
   */</span>

  <span class="s3">var </span><span class="s1">registrationNameModules = {};</span>
  <span class="s0">/** 
   * Mapping from registration name to event name 
   */</span>

  <span class="s3">var </span><span class="s1">registrationNameDependencies = {};</span>
  <span class="s0">/** 
   * Mapping from lowercase registration names to the properly cased version, 
   * used to warn in the case of missing event handlers. Available 
   * only in true. 
   * @type {Object} 
   */</span>

  <span class="s3">var </span><span class="s1">possibleRegistrationNames =  {} ; </span><span class="s0">// Trust the developer to only use possibleRegistrationNames in true</span>

  <span class="s0">/** 
   * Injects an ordering of plugins (by plugin name). This allows the ordering 
   * to be decoupled from injection of the actual plugins so that ordering is 
   * always deterministic regardless of packaging, on-the-fly injection, etc. 
   * 
   * @param {array} InjectedEventPluginOrder 
   * @internal 
   */</span>

  <span class="s3">function </span><span class="s1">injectEventPluginOrder(injectedEventPluginOrder) {</span>
    <span class="s3">if </span><span class="s1">(!!eventPluginOrder) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Clone the ordering so it cannot be dynamically mutated.</span>


    <span class="s1">eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);</span>
    <span class="s1">recomputePluginOrdering();</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Injects plugins to be used by plugin event system. The plugin names must be 
   * in the ordering injected by `injectEventPluginOrder`. 
   * 
   * Plugins can be injected as part of page initialization or on-the-fly. 
   * 
   * @param {object} injectedNamesToPlugins Map from names to plugin modules. 
   * @internal 
   */</span>

  <span class="s3">function </span><span class="s1">injectEventPluginsByName(injectedNamesToPlugins) {</span>
    <span class="s3">var </span><span class="s1">isOrderingDirty = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">pluginName </span><span class="s3">in </span><span class="s1">injectedNamesToPlugins) {</span>
      <span class="s3">if </span><span class="s1">(!injectedNamesToPlugins.hasOwnProperty(pluginName)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">pluginModule = injectedNamesToPlugins[pluginName];</span>

      <span class="s3">if </span><span class="s1">(!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {</span>
        <span class="s3">if </span><span class="s1">(!!namesToPlugins[pluginName]) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;EventPluginRegistry: Cannot inject two different event plugins using the same name, `&quot; </span><span class="s1">+ pluginName + </span><span class="s2">&quot;`.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">namesToPlugins[pluginName] = pluginModule;</span>
        <span class="s1">isOrderingDirty = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isOrderingDirty) {</span>
      <span class="s1">recomputePluginOrdering();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">canUseDOM = !!(</span><span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">window.document !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">window.document.createElement !== </span><span class="s2">'undefined'</span><span class="s1">);</span>

  <span class="s3">var </span><span class="s1">ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>
  <span class="s3">var </span><span class="s1">_assign = ReactInternals.assign;</span>

  <span class="s3">var </span><span class="s1">PLUGIN_EVENT_SYSTEM = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IS_REPLAYED = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IS_FIRST_ANCESTOR = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">6</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">restoreImpl = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">restoreTarget = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">restoreQueue = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">restoreStateOfTarget(target) {</span>
    <span class="s0">// We perform this translation at the end of the event loop so that we</span>
    <span class="s0">// always receive the correct fiber here</span>
    <span class="s3">var </span><span class="s1">internalInstance = getInstanceFromNode(target);</span>

    <span class="s3">if </span><span class="s1">(!internalInstance) {</span>
      <span class="s0">// Unmounted</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">restoreImpl === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">stateNode = internalInstance.stateNode; </span><span class="s0">// Guard against Fiber being unmounted.</span>

    <span class="s3">if </span><span class="s1">(stateNode) {</span>
      <span class="s3">var </span><span class="s1">_props = getFiberCurrentPropsFromNode(stateNode);</span>

      <span class="s1">restoreImpl(internalInstance.stateNode, internalInstance.type, _props);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">setRestoreImplementation(impl) {</span>
    <span class="s1">restoreImpl = impl;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">enqueueStateRestore(target) {</span>
    <span class="s3">if </span><span class="s1">(restoreTarget) {</span>
      <span class="s3">if </span><span class="s1">(restoreQueue) {</span>
        <span class="s1">restoreQueue.push(target);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">restoreQueue = [target];</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">restoreTarget = target;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">needsStateRestore() {</span>
    <span class="s3">return </span><span class="s1">restoreTarget !== </span><span class="s3">null </span><span class="s1">|| restoreQueue !== </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">restoreStateIfNeeded() {</span>
    <span class="s3">if </span><span class="s1">(!restoreTarget) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">target = restoreTarget;</span>
    <span class="s3">var </span><span class="s1">queuedTargets = restoreQueue;</span>
    <span class="s1">restoreTarget = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">restoreQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">restoreStateOfTarget(target);</span>

    <span class="s3">if </span><span class="s1">(queuedTargets) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; queuedTargets.length; i++) {</span>
        <span class="s1">restoreStateOfTarget(queuedTargets[i]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">enableProfilerTimer = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Trace which interactions trigger each commit.</span>

  <span class="s3">var </span><span class="s1">enableDeprecatedFlareAPI = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Experimental Host Component support.</span>

  <span class="s3">var </span><span class="s1">enableFundamentalAPI = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Experimental Scope support.</span>
  <span class="s3">var </span><span class="s1">warnAboutStringRefs = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">// the renderer. Such as when we're dispatching events or if third party</span>
  <span class="s0">// libraries need to call batchedUpdates. Eventually, this API will go away when</span>
  <span class="s0">// everything is batched by default. We'll then have a similar API to opt-out of</span>
  <span class="s0">// scheduled work and instead do synchronous work.</span>
  <span class="s0">// Defaults</span>

  <span class="s3">var </span><span class="s1">batchedUpdatesImpl = </span><span class="s3">function </span><span class="s1">(fn, bookkeeping) {</span>
    <span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">discreteUpdatesImpl = </span><span class="s3">function </span><span class="s1">(fn, a, b, c, d) {</span>
    <span class="s3">return </span><span class="s1">fn(a, b, c, d);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">flushDiscreteUpdatesImpl = </span><span class="s3">function </span><span class="s1">() {};</span>

  <span class="s3">var </span><span class="s1">batchedEventUpdatesImpl = batchedUpdatesImpl;</span>
  <span class="s3">var </span><span class="s1">isInsideEventHandler = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isBatchingEventUpdates = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">finishEventHandler() {</span>
    <span class="s0">// Here we wait until all updates have propagated, which is important</span>
    <span class="s0">// when using controlled components within layers:</span>
    <span class="s0">// https://github.com/facebook/react/issues/1698</span>
    <span class="s0">// Then we restore state of any controlled component.</span>
    <span class="s3">var </span><span class="s1">controlledComponentsHavePendingUpdates = needsStateRestore();</span>

    <span class="s3">if </span><span class="s1">(controlledComponentsHavePendingUpdates) {</span>
      <span class="s0">// If a controlled event was fired, we may need to restore the state of</span>
      <span class="s0">// the DOM node back to the controlled value. This is necessary when React</span>
      <span class="s0">// bails out of the update without touching the DOM.</span>
      <span class="s1">flushDiscreteUpdatesImpl();</span>
      <span class="s1">restoreStateIfNeeded();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">batchedUpdates(fn, bookkeeping) {</span>
    <span class="s3">if </span><span class="s1">(isInsideEventHandler) {</span>
      <span class="s0">// If we are currently inside another batch, we need to wait until it</span>
      <span class="s0">// fully completes before restoring state.</span>
      <span class="s3">return </span><span class="s1">fn(bookkeeping);</span>
    <span class="s1">}</span>

    <span class="s1">isInsideEventHandler = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">batchedUpdatesImpl(fn, bookkeeping);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">isInsideEventHandler = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">finishEventHandler();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">batchedEventUpdates(fn, a, b) {</span>
    <span class="s3">if </span><span class="s1">(isBatchingEventUpdates) {</span>
      <span class="s0">// If we are currently inside another batch, we need to wait until it</span>
      <span class="s0">// fully completes before restoring state.</span>
      <span class="s3">return </span><span class="s1">fn(a, b);</span>
    <span class="s1">}</span>

    <span class="s1">isBatchingEventUpdates = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">batchedEventUpdatesImpl(fn, a, b);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">isBatchingEventUpdates = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">finishEventHandler();</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This is for the React Flare event system</span>
  <span class="s3">function </span><span class="s1">discreteUpdates(fn, a, b, c, d) {</span>
    <span class="s3">var </span><span class="s1">prevIsInsideEventHandler = isInsideEventHandler;</span>
    <span class="s1">isInsideEventHandler = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">discreteUpdatesImpl(fn, a, b, c, d);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">isInsideEventHandler = prevIsInsideEventHandler;</span>

      <span class="s3">if </span><span class="s1">(!isInsideEventHandler) {</span>
        <span class="s1">finishEventHandler();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">flushDiscreteUpdatesIfNeeded(timeStamp) {</span>
    <span class="s0">// event.timeStamp isn't overly reliable due to inconsistencies in</span>
    <span class="s0">// how different browsers have historically provided the time stamp.</span>
    <span class="s0">// Some browsers provide high-resolution time stamps for all events,</span>
    <span class="s0">// some provide low-resolution time stamps for all events. FF &lt; 52</span>
    <span class="s0">// even mixes both time stamps together. Some browsers even report</span>
    <span class="s0">// negative time stamps or time stamps that are 0 (iOS9) in some cases.</span>
    <span class="s0">// Given we are only comparing two time stamps with equality (!==),</span>
    <span class="s0">// we are safe from the resolution differences. If the time stamp is 0</span>
    <span class="s0">// we bail-out of preventing the flush, which can affect semantics,</span>
    <span class="s0">// such as if an earlier flush removes or adds event listeners that</span>
    <span class="s0">// are fired in the subsequent flush. However, this is the same</span>
    <span class="s0">// behaviour as we had before this change, so the risks are low.</span>
    <span class="s3">if </span><span class="s1">(!isInsideEventHandler &amp;&amp; (!enableDeprecatedFlareAPI  )) {</span>
      <span class="s1">flushDiscreteUpdatesImpl();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {</span>
    <span class="s1">batchedUpdatesImpl = _batchedUpdatesImpl;</span>
    <span class="s1">discreteUpdatesImpl = _discreteUpdatesImpl;</span>
    <span class="s1">flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;</span>
    <span class="s1">batchedEventUpdatesImpl = _batchedEventUpdatesImpl;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">DiscreteEvent = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">UserBlockingEvent = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ContinuousEvent = </span><span class="s4">2</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactInternals$1 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>
  <span class="s3">var </span><span class="s1">_ReactInternals$Sched = ReactInternals$1.Scheduler,</span>
      <span class="s1">unstable_cancelCallback = _ReactInternals$Sched.unstable_cancelCallback,</span>
      <span class="s1">unstable_now = _ReactInternals$Sched.unstable_now,</span>
      <span class="s1">unstable_scheduleCallback = _ReactInternals$Sched.unstable_scheduleCallback,</span>
      <span class="s1">unstable_shouldYield = _ReactInternals$Sched.unstable_shouldYield,</span>
      <span class="s1">unstable_requestPaint = _ReactInternals$Sched.unstable_requestPaint,</span>
      <span class="s1">unstable_getFirstCallbackNode = _ReactInternals$Sched.unstable_getFirstCallbackNode,</span>
      <span class="s1">unstable_runWithPriority = _ReactInternals$Sched.unstable_runWithPriority,</span>
      <span class="s1">unstable_next = _ReactInternals$Sched.unstable_next,</span>
      <span class="s1">unstable_continueExecution = _ReactInternals$Sched.unstable_continueExecution,</span>
      <span class="s1">unstable_pauseExecution = _ReactInternals$Sched.unstable_pauseExecution,</span>
      <span class="s1">unstable_getCurrentPriorityLevel = _ReactInternals$Sched.unstable_getCurrentPriorityLevel,</span>
      <span class="s1">unstable_ImmediatePriority = _ReactInternals$Sched.unstable_ImmediatePriority,</span>
      <span class="s1">unstable_UserBlockingPriority = _ReactInternals$Sched.unstable_UserBlockingPriority,</span>
      <span class="s1">unstable_NormalPriority = _ReactInternals$Sched.unstable_NormalPriority,</span>
      <span class="s1">unstable_LowPriority = _ReactInternals$Sched.unstable_LowPriority,</span>
      <span class="s1">unstable_IdlePriority = _ReactInternals$Sched.unstable_IdlePriority,</span>
      <span class="s1">unstable_forceFrameRate = _ReactInternals$Sched.unstable_forceFrameRate,</span>
      <span class="s1">unstable_flushAllWithoutAsserting = _ReactInternals$Sched.unstable_flushAllWithoutAsserting;</span>

  <span class="s0">// A reserved attribute.</span>
  <span class="s0">// It is handled by React separately and shouldn't be written to the DOM.</span>
  <span class="s3">var </span><span class="s1">RESERVED = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// A simple string attribute.</span>
  <span class="s0">// Attributes that aren't in the whitelist are presumed to have this type.</span>

  <span class="s3">var </span><span class="s1">STRING = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// A string attribute that accepts booleans in React. In HTML, these are called</span>
  <span class="s0">// &quot;enumerated&quot; attributes with &quot;true&quot; and &quot;false&quot; as possible values.</span>
  <span class="s0">// When true, it should be set to a &quot;true&quot; string.</span>
  <span class="s0">// When false, it should be set to a &quot;false&quot; string.</span>

  <span class="s3">var </span><span class="s1">BOOLEANISH_STRING = </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// A real boolean attribute.</span>
  <span class="s0">// When true, it should be present (set either to an empty string or its name).</span>
  <span class="s0">// When false, it should be omitted.</span>

  <span class="s3">var </span><span class="s1">BOOLEAN = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// An attribute that can be used as a flag as well as with a value.</span>
  <span class="s0">// When true, it should be present (set either to an empty string or its name).</span>
  <span class="s0">// When false, it should be omitted.</span>
  <span class="s0">// For any other value, should be present with that value.</span>

  <span class="s3">var </span><span class="s1">OVERLOADED_BOOLEAN = </span><span class="s4">4</span><span class="s1">; </span><span class="s0">// An attribute that must be numeric or parse as a numeric.</span>
  <span class="s0">// When falsy, it should be removed.</span>

  <span class="s3">var </span><span class="s1">NUMERIC = </span><span class="s4">5</span><span class="s1">; </span><span class="s0">// An attribute that must be positive numeric or parse as a positive numeric.</span>
  <span class="s0">// When falsy, it should be removed.</span>

  <span class="s3">var </span><span class="s1">POSITIVE_NUMERIC = </span><span class="s4">6</span><span class="s1">;</span>

  <span class="s0">/* eslint-disable max-len */</span>
  <span class="s3">var </span><span class="s1">ATTRIBUTE_NAME_START_CHAR = </span><span class="s2">&quot;:A-Z_a-z</span><span class="s5">\\</span><span class="s2">u00C0-</span><span class="s5">\\</span><span class="s2">u00D6</span><span class="s5">\\</span><span class="s2">u00D8-</span><span class="s5">\\</span><span class="s2">u00F6</span><span class="s5">\\</span><span class="s2">u00F8-</span><span class="s5">\\</span><span class="s2">u02FF</span><span class="s5">\\</span><span class="s2">u0370-</span><span class="s5">\\</span><span class="s2">u037D</span><span class="s5">\\</span><span class="s2">u037F-</span><span class="s5">\\</span><span class="s2">u1FFF</span><span class="s5">\\</span><span class="s2">u200C-</span><span class="s5">\\</span><span class="s2">u200D</span><span class="s5">\\</span><span class="s2">u2070-</span><span class="s5">\\</span><span class="s2">u218F</span><span class="s5">\\</span><span class="s2">u2C00-</span><span class="s5">\\</span><span class="s2">u2FEF</span><span class="s5">\\</span><span class="s2">u3001-</span><span class="s5">\\</span><span class="s2">uD7FF</span><span class="s5">\\</span><span class="s2">uF900-</span><span class="s5">\\</span><span class="s2">uFDCF</span><span class="s5">\\</span><span class="s2">uFDF0-</span><span class="s5">\\</span><span class="s2">uFFFD&quot;</span><span class="s1">;</span>
  <span class="s0">/* eslint-enable max-len */</span>

  <span class="s3">var </span><span class="s1">ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">-.0-9</span><span class="s5">\\</span><span class="s2">u00B7</span><span class="s5">\\</span><span class="s2">u0300-</span><span class="s5">\\</span><span class="s2">u036F</span><span class="s5">\\</span><span class="s2">u203F-</span><span class="s5">\\</span><span class="s2">u2040&quot;</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ROOT_ATTRIBUTE_NAME = </span><span class="s2">'data-reactroot'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">VALID_ATTRIBUTE_NAME_REGEX = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^[' </span><span class="s1">+ ATTRIBUTE_NAME_START_CHAR + </span><span class="s2">'][' </span><span class="s1">+ ATTRIBUTE_NAME_CHAR + </span><span class="s2">']*$'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>
  <span class="s3">var </span><span class="s1">illegalAttributeNameCache = {};</span>
  <span class="s3">var </span><span class="s1">validatedAttributeNameCache = {};</span>
  <span class="s3">function </span><span class="s1">isAttributeNameSafe(attributeName) {</span>
    <span class="s3">if </span><span class="s1">(hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {</span>
      <span class="s1">validatedAttributeNameCache[attributeName] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">illegalAttributeNameCache[attributeName] = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">error(</span><span class="s2">'Invalid attribute name: `%s`'</span><span class="s1">, attributeName);</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {</span>
    <span class="s3">if </span><span class="s1">(propertyInfo !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">propertyInfo.type === RESERVED;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isCustomComponentTag) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(name.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; (name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'o' </span><span class="s1">|| name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'O'</span><span class="s1">) &amp;&amp; (name[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'n' </span><span class="s1">|| name[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'N'</span><span class="s1">)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {</span>
    <span class="s3">if </span><span class="s1">(propertyInfo !== </span><span class="s3">null </span><span class="s1">&amp;&amp; propertyInfo.type === RESERVED) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value) {</span>
      <span class="s3">case </span><span class="s2">'function'</span><span class="s1">: </span><span class="s0">// $FlowIssue symbol is perfectly valid here</span>

      <span class="s3">case </span><span class="s2">'symbol'</span><span class="s1">:</span>
        <span class="s0">// eslint-disable-line</span>
        <span class="s3">return true</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'boolean'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(isCustomComponentTag) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(propertyInfo !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">!propertyInfo.acceptsBooleans;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">prefix = name.toLowerCase().slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">5</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">prefix !== </span><span class="s2">'data-' </span><span class="s1">&amp;&amp; prefix !== </span><span class="s2">'aria-'</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {</span>
    <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isCustomComponentTag) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(propertyInfo !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(propertyInfo.type) {</span>
        <span class="s3">case </span><span class="s1">BOOLEAN:</span>
          <span class="s3">return </span><span class="s1">!value;</span>

        <span class="s3">case </span><span class="s1">OVERLOADED_BOOLEAN:</span>
          <span class="s3">return </span><span class="s1">value === </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">NUMERIC:</span>
          <span class="s3">return </span><span class="s1">isNaN(value);</span>

        <span class="s3">case </span><span class="s1">POSITIVE_NUMERIC:</span>
          <span class="s3">return </span><span class="s1">isNaN(value) || value &lt; </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getPropertyInfo(name) {</span>
    <span class="s3">return </span><span class="s1">properties.hasOwnProperty(name) ? properties[name] : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL) {</span>
    <span class="s3">this</span><span class="s1">.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;</span>
    <span class="s3">this</span><span class="s1">.attributeName = attributeName;</span>
    <span class="s3">this</span><span class="s1">.attributeNamespace = attributeNamespace;</span>
    <span class="s3">this</span><span class="s1">.mustUseProperty = mustUseProperty;</span>
    <span class="s3">this</span><span class="s1">.propertyName = name;</span>
    <span class="s3">this</span><span class="s1">.type = type;</span>
    <span class="s3">this</span><span class="s1">.sanitizeURL = sanitizeURL;</span>
  <span class="s1">} </span><span class="s0">// When adding attributes to this list, be sure to also add them to</span>
  <span class="s0">// the `possibleStandardNames` module to ensure casing and incorrect</span>
  <span class="s0">// name warnings.</span>


  <span class="s3">var </span><span class="s1">properties = {}; </span><span class="s0">// These props are reserved by React. They shouldn't be written to the DOM.</span>

  <span class="s3">var </span><span class="s1">reservedProps = [</span><span class="s2">'children'</span><span class="s1">, </span><span class="s2">'dangerouslySetInnerHTML'</span><span class="s1">, </span><span class="s0">// TODO: This prevents the assignment of defaultValue to regular</span>
  <span class="s0">// elements (not just inputs). Now that ReactDOMInput assigns to the</span>
  <span class="s0">// defaultValue property -- do we need this?</span>
  <span class="s2">'defaultValue'</span><span class="s1">, </span><span class="s2">'defaultChecked'</span><span class="s1">, </span><span class="s2">'innerHTML'</span><span class="s1">, </span><span class="s2">'suppressContentEditableWarning'</span><span class="s1">, </span><span class="s2">'suppressHydrationWarning'</span><span class="s1">, </span><span class="s2">'style'</span><span class="s1">];</span>

  <span class="s1">reservedProps.forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, RESERVED, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// A few React string attributes have a different name.</span>
  <span class="s0">// This is a mapping from React prop names to the attribute names.</span>

  <span class="s1">[[</span><span class="s2">'acceptCharset'</span><span class="s1">, </span><span class="s2">'accept-charset'</span><span class="s1">], [</span><span class="s2">'className'</span><span class="s1">, </span><span class="s2">'class'</span><span class="s1">], [</span><span class="s2">'htmlFor'</span><span class="s1">, </span><span class="s2">'for'</span><span class="s1">], [</span><span class="s2">'httpEquiv'</span><span class="s1">, </span><span class="s2">'http-equiv'</span><span class="s1">]].forEach(</span><span class="s3">function </span><span class="s1">(_ref) {</span>
    <span class="s3">var </span><span class="s1">name = _ref[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">attributeName = _ref[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are &quot;enumerated&quot; HTML attributes that accept &quot;true&quot; and &quot;false&quot;.</span>
  <span class="s0">// In React, we let users pass `true` and `false` even though technically</span>
  <span class="s0">// these aren't boolean attributes (they are coerced to strings).</span>

  <span class="s1">[</span><span class="s2">'contentEditable'</span><span class="s1">, </span><span class="s2">'draggable'</span><span class="s1">, </span><span class="s2">'spellCheck'</span><span class="s1">, </span><span class="s2">'value'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, BOOLEANISH_STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name.toLowerCase(), </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are &quot;enumerated&quot; SVG attributes that accept &quot;true&quot; and &quot;false&quot;.</span>
  <span class="s0">// In React, we let users pass `true` and `false` even though technically</span>
  <span class="s0">// these aren't boolean attributes (they are coerced to strings).</span>
  <span class="s0">// Since these are SVG attributes, their attribute names are case-sensitive.</span>

  <span class="s1">[</span><span class="s2">'autoReverse'</span><span class="s1">, </span><span class="s2">'externalResourcesRequired'</span><span class="s1">, </span><span class="s2">'focusable'</span><span class="s1">, </span><span class="s2">'preserveAlpha'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, BOOLEANISH_STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are HTML boolean attributes.</span>

  <span class="s1">[</span><span class="s2">'allowFullScreen'</span><span class="s1">, </span><span class="s2">'async'</span><span class="s1">, </span><span class="s0">// Note: there is a special case that prevents it from being written to the DOM</span>
  <span class="s0">// on the client side because the browsers are inconsistent. Instead we call focus().</span>
  <span class="s2">'autoFocus'</span><span class="s1">, </span><span class="s2">'autoPlay'</span><span class="s1">, </span><span class="s2">'controls'</span><span class="s1">, </span><span class="s2">'default'</span><span class="s1">, </span><span class="s2">'defer'</span><span class="s1">, </span><span class="s2">'disabled'</span><span class="s1">, </span><span class="s2">'disablePictureInPicture'</span><span class="s1">, </span><span class="s2">'formNoValidate'</span><span class="s1">, </span><span class="s2">'hidden'</span><span class="s1">, </span><span class="s2">'loop'</span><span class="s1">, </span><span class="s2">'noModule'</span><span class="s1">, </span><span class="s2">'noValidate'</span><span class="s1">, </span><span class="s2">'open'</span><span class="s1">, </span><span class="s2">'playsInline'</span><span class="s1">, </span><span class="s2">'readOnly'</span><span class="s1">, </span><span class="s2">'required'</span><span class="s1">, </span><span class="s2">'reversed'</span><span class="s1">, </span><span class="s2">'scoped'</span><span class="s1">, </span><span class="s2">'seamless'</span><span class="s1">, </span><span class="s0">// Microdata</span>
  <span class="s2">'itemScope'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, BOOLEAN, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name.toLowerCase(), </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are the few React props that we set as DOM properties</span>
  <span class="s0">// rather than attributes. These are all booleans.</span>

  <span class="s1">[</span><span class="s2">'checked'</span><span class="s1">, </span><span class="s0">// Note: `option.selected` is not updated if `select.multiple` is</span>
  <span class="s0">// disabled with `removeAttribute`. We have special logic for handling this.</span>
  <span class="s2">'multiple'</span><span class="s1">, </span><span class="s2">'muted'</span><span class="s1">, </span><span class="s2">'selected' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, BOOLEAN, </span><span class="s3">true</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are HTML attributes that are &quot;overloaded booleans&quot;: they behave like</span>
  <span class="s0">// booleans, but can also accept a string value.</span>

  <span class="s1">[</span><span class="s2">'capture'</span><span class="s1">, </span><span class="s2">'download' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, OVERLOADED_BOOLEAN, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are HTML attributes that must be positive numbers.</span>

  <span class="s1">[</span><span class="s2">'cols'</span><span class="s1">, </span><span class="s2">'rows'</span><span class="s1">, </span><span class="s2">'size'</span><span class="s1">, </span><span class="s2">'span' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, POSITIVE_NUMERIC, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name, </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These are HTML attributes that must be numbers.</span>

  <span class="s1">[</span><span class="s2">'rowSpan'</span><span class="s1">, </span><span class="s2">'start'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, NUMERIC, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">name.toLowerCase(), </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">});</span>
  <span class="s3">var </span><span class="s1">CAMELIZE = /[\-\:]([a-z])/g;</span>

  <span class="s3">var </span><span class="s1">capitalize = </span><span class="s3">function </span><span class="s1">(token) {</span>
    <span class="s3">return </span><span class="s1">token[</span><span class="s4">1</span><span class="s1">].toUpperCase();</span>
  <span class="s1">}; </span><span class="s0">// This is a list of all SVG attributes that need special casing, namespacing,</span>
  <span class="s0">// or boolean value assignment. Regular attributes that just accept strings</span>
  <span class="s0">// and have the same names are omitted, just like in the HTML whitelist.</span>
  <span class="s0">// Some of these attributes can be hard to find. This list was created by</span>
  <span class="s0">// scraping the MDN documentation.</span>


  <span class="s1">[</span><span class="s2">'accent-height'</span><span class="s1">, </span><span class="s2">'alignment-baseline'</span><span class="s1">, </span><span class="s2">'arabic-form'</span><span class="s1">, </span><span class="s2">'baseline-shift'</span><span class="s1">, </span><span class="s2">'cap-height'</span><span class="s1">, </span><span class="s2">'clip-path'</span><span class="s1">, </span><span class="s2">'clip-rule'</span><span class="s1">, </span><span class="s2">'color-interpolation'</span><span class="s1">, </span><span class="s2">'color-interpolation-filters'</span><span class="s1">, </span><span class="s2">'color-profile'</span><span class="s1">, </span><span class="s2">'color-rendering'</span><span class="s1">, </span><span class="s2">'dominant-baseline'</span><span class="s1">, </span><span class="s2">'enable-background'</span><span class="s1">, </span><span class="s2">'fill-opacity'</span><span class="s1">, </span><span class="s2">'fill-rule'</span><span class="s1">, </span><span class="s2">'flood-color'</span><span class="s1">, </span><span class="s2">'flood-opacity'</span><span class="s1">, </span><span class="s2">'font-family'</span><span class="s1">, </span><span class="s2">'font-size'</span><span class="s1">, </span><span class="s2">'font-size-adjust'</span><span class="s1">, </span><span class="s2">'font-stretch'</span><span class="s1">, </span><span class="s2">'font-style'</span><span class="s1">, </span><span class="s2">'font-variant'</span><span class="s1">, </span><span class="s2">'font-weight'</span><span class="s1">, </span><span class="s2">'glyph-name'</span><span class="s1">, </span><span class="s2">'glyph-orientation-horizontal'</span><span class="s1">, </span><span class="s2">'glyph-orientation-vertical'</span><span class="s1">, </span><span class="s2">'horiz-adv-x'</span><span class="s1">, </span><span class="s2">'horiz-origin-x'</span><span class="s1">, </span><span class="s2">'image-rendering'</span><span class="s1">, </span><span class="s2">'letter-spacing'</span><span class="s1">, </span><span class="s2">'lighting-color'</span><span class="s1">, </span><span class="s2">'marker-end'</span><span class="s1">, </span><span class="s2">'marker-mid'</span><span class="s1">, </span><span class="s2">'marker-start'</span><span class="s1">, </span><span class="s2">'overline-position'</span><span class="s1">, </span><span class="s2">'overline-thickness'</span><span class="s1">, </span><span class="s2">'paint-order'</span><span class="s1">, </span><span class="s2">'panose-1'</span><span class="s1">, </span><span class="s2">'pointer-events'</span><span class="s1">, </span><span class="s2">'rendering-intent'</span><span class="s1">, </span><span class="s2">'shape-rendering'</span><span class="s1">, </span><span class="s2">'stop-color'</span><span class="s1">, </span><span class="s2">'stop-opacity'</span><span class="s1">, </span><span class="s2">'strikethrough-position'</span><span class="s1">, </span><span class="s2">'strikethrough-thickness'</span><span class="s1">, </span><span class="s2">'stroke-dasharray'</span><span class="s1">, </span><span class="s2">'stroke-dashoffset'</span><span class="s1">, </span><span class="s2">'stroke-linecap'</span><span class="s1">, </span><span class="s2">'stroke-linejoin'</span><span class="s1">, </span><span class="s2">'stroke-miterlimit'</span><span class="s1">, </span><span class="s2">'stroke-opacity'</span><span class="s1">, </span><span class="s2">'stroke-width'</span><span class="s1">, </span><span class="s2">'text-anchor'</span><span class="s1">, </span><span class="s2">'text-decoration'</span><span class="s1">, </span><span class="s2">'text-rendering'</span><span class="s1">, </span><span class="s2">'underline-position'</span><span class="s1">, </span><span class="s2">'underline-thickness'</span><span class="s1">, </span><span class="s2">'unicode-bidi'</span><span class="s1">, </span><span class="s2">'unicode-range'</span><span class="s1">, </span><span class="s2">'units-per-em'</span><span class="s1">, </span><span class="s2">'v-alphabetic'</span><span class="s1">, </span><span class="s2">'v-hanging'</span><span class="s1">, </span><span class="s2">'v-ideographic'</span><span class="s1">, </span><span class="s2">'v-mathematical'</span><span class="s1">, </span><span class="s2">'vector-effect'</span><span class="s1">, </span><span class="s2">'vert-adv-y'</span><span class="s1">, </span><span class="s2">'vert-origin-x'</span><span class="s1">, </span><span class="s2">'vert-origin-y'</span><span class="s1">, </span><span class="s2">'word-spacing'</span><span class="s1">, </span><span class="s2">'writing-mode'</span><span class="s1">, </span><span class="s2">'xmlns:xlink'</span><span class="s1">, </span><span class="s2">'x-height' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(attributeName) {</span>
    <span class="s3">var </span><span class="s1">name = attributeName.replace(CAMELIZE, capitalize);</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName, </span><span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// String SVG attributes with the xlink namespace.</span>

  <span class="s1">[</span><span class="s2">'xlink:actuate'</span><span class="s1">, </span><span class="s2">'xlink:arcrole'</span><span class="s1">, </span><span class="s2">'xlink:role'</span><span class="s1">, </span><span class="s2">'xlink:show'</span><span class="s1">, </span><span class="s2">'xlink:title'</span><span class="s1">, </span><span class="s2">'xlink:type' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(attributeName) {</span>
    <span class="s3">var </span><span class="s1">name = attributeName.replace(CAMELIZE, capitalize);</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName, </span><span class="s2">'http://www.w3.org/1999/xlink'</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// String SVG attributes with the xml namespace.</span>

  <span class="s1">[</span><span class="s2">'xml:base'</span><span class="s1">, </span><span class="s2">'xml:lang'</span><span class="s1">, </span><span class="s2">'xml:space' </span><span class="s0">// NOTE: if you add a camelCased prop to this list,</span>
  <span class="s0">// you'll need to set attributeName to name.toLowerCase()</span>
  <span class="s0">// instead in the assignment below.</span>
  <span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(attributeName) {</span>
    <span class="s3">var </span><span class="s1">name = attributeName.replace(CAMELIZE, capitalize);</span>
    <span class="s1">properties[name] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(name, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName, </span><span class="s2">'http://www.w3.org/XML/1998/namespace'</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These attribute exists both in HTML and SVG.</span>
  <span class="s0">// The attribute name is case-sensitive in SVG so we can't just use</span>
  <span class="s0">// the React name like we do for attributes that exist only in HTML.</span>

  <span class="s1">[</span><span class="s2">'tabIndex'</span><span class="s1">, </span><span class="s2">'crossOrigin'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(attributeName) {</span>
    <span class="s1">properties[attributeName] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(attributeName, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName.toLowerCase(), </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}); </span><span class="s0">// These attributes accept URLs. These must not allow javascript: URLS.</span>
  <span class="s0">// These will also need to accept Trusted Types object in the future.</span>

  <span class="s3">var </span><span class="s1">xlinkHref = </span><span class="s2">'xlinkHref'</span><span class="s1">;</span>
  <span class="s1">properties[xlinkHref] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(</span><span class="s2">'xlinkHref'</span><span class="s1">, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
  <span class="s2">'xlink:href'</span><span class="s1">, </span><span class="s2">'http://www.w3.org/1999/xlink'</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">[</span><span class="s2">'src'</span><span class="s1">, </span><span class="s2">'href'</span><span class="s1">, </span><span class="s2">'action'</span><span class="s1">, </span><span class="s2">'formAction'</span><span class="s1">].forEach(</span><span class="s3">function </span><span class="s1">(attributeName) {</span>
    <span class="s1">properties[attributeName] = </span><span class="s3">new </span><span class="s1">PropertyInfoRecord(attributeName, STRING, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// mustUseProperty</span>
    <span class="s1">attributeName.toLowerCase(), </span><span class="s0">// attributeName</span>
    <span class="s3">null</span><span class="s1">, </span><span class="s0">// attributeNamespace</span>
    <span class="s3">true</span><span class="s1">);</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
  <span class="s1">} </span><span class="s0">// A javascript: URL can contain leading C0 control or \u0020 SPACE,</span>
  <span class="s0">// and any newline or tab are filtered out as if they're not part of the URL.</span>
  <span class="s0">// https://url.spec.whatwg.org/#url-parsing</span>
  <span class="s0">// Tab or newline are defined as \r\n\t:</span>
  <span class="s0">// https://infra.spec.whatwg.org/#ascii-tab-or-newline</span>
  <span class="s0">// A C0 control is a code point in the range \u0000 NULL to \u001F</span>
  <span class="s0">// INFORMATION SEPARATOR ONE, inclusive:</span>
  <span class="s0">// https://infra.spec.whatwg.org/#c0-control-or-space</span>

  <span class="s0">/* eslint-disable max-len */</span>


  <span class="s3">var </span><span class="s1">isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;</span>
  <span class="s3">var </span><span class="s1">didWarn = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">sanitizeURL(url) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!didWarn &amp;&amp; isJavaScriptProtocol.test(url)) {</span>
        <span class="s1">didWarn = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'A future version of React will block javascript: URLs as a security precaution. ' </span><span class="s1">+ </span><span class="s2">'Use event handlers instead if you can. If you need to generate unsafe HTML try ' </span><span class="s1">+ </span><span class="s2">'using dangerouslySetInnerHTML instead. React was passed %s.'</span><span class="s1">, JSON.stringify(url));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Get the value for a property on a node. Only used in DEV for SSR validation. 
   * The &quot;expected&quot; argument is used as a hint of what the expected value is. 
   * Some properties have multiple equivalent values. 
   */</span>
  <span class="s3">function </span><span class="s1">getValueForProperty(node, name, expected, propertyInfo) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(propertyInfo.mustUseProperty) {</span>
        <span class="s3">var </span><span class="s1">propertyName = propertyInfo.propertyName;</span>
        <span class="s3">return </span><span class="s1">node[propertyName];</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">( propertyInfo.sanitizeURL) {</span>
          <span class="s0">// If we haven't fully disabled javascript: URLs, and if</span>
          <span class="s0">// the hydration is successful of a javascript: URL, we</span>
          <span class="s0">// still want to warn on the client.</span>
          <span class="s1">sanitizeURL(</span><span class="s2">'' </span><span class="s1">+ expected);</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">attributeName = propertyInfo.attributeName;</span>
        <span class="s3">var </span><span class="s1">stringValue = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(propertyInfo.type === OVERLOADED_BOOLEAN) {</span>
          <span class="s3">if </span><span class="s1">(node.hasAttribute(attributeName)) {</span>
            <span class="s3">var </span><span class="s1">value = node.getAttribute(attributeName);</span>

            <span class="s3">if </span><span class="s1">(value === </span><span class="s2">''</span><span class="s1">) {</span>
              <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(shouldRemoveAttribute(name, expected, propertyInfo, </span><span class="s3">false</span><span class="s1">)) {</span>
              <span class="s3">return </span><span class="s1">value;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(value === </span><span class="s2">'' </span><span class="s1">+ expected) {</span>
              <span class="s3">return </span><span class="s1">expected;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">value;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.hasAttribute(attributeName)) {</span>
          <span class="s3">if </span><span class="s1">(shouldRemoveAttribute(name, expected, propertyInfo, </span><span class="s3">false</span><span class="s1">)) {</span>
            <span class="s0">// We had an attribute but shouldn't have had one, so read it</span>
            <span class="s0">// for the error message.</span>
            <span class="s3">return </span><span class="s1">node.getAttribute(attributeName);</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(propertyInfo.type === BOOLEAN) {</span>
            <span class="s0">// If this was a boolean, it doesn't matter what the value is</span>
            <span class="s0">// the fact that we have it is the same as the expected.</span>
            <span class="s3">return </span><span class="s1">expected;</span>
          <span class="s1">} </span><span class="s0">// Even if this property uses a namespace we use getAttribute</span>
          <span class="s0">// because we assume its namespaced name is the same as our config.</span>
          <span class="s0">// To use getAttributeNS we need the local name which we don't have</span>
          <span class="s0">// in our config atm.</span>


          <span class="s1">stringValue = node.getAttribute(attributeName);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(shouldRemoveAttribute(name, expected, propertyInfo, </span><span class="s3">false</span><span class="s1">)) {</span>
          <span class="s3">return </span><span class="s1">stringValue === </span><span class="s3">null </span><span class="s1">? expected : stringValue;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stringValue === </span><span class="s2">'' </span><span class="s1">+ expected) {</span>
          <span class="s3">return </span><span class="s1">expected;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">stringValue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Get the value for a attribute on a node. Only used in DEV for SSR validation. 
   * The third argument is used as a hint of what the expected value is. Some 
   * attributes have multiple equivalent values. 
   */</span>

  <span class="s3">function </span><span class="s1">getValueForAttribute(node, name, expected) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!isAttributeNameSafe(name)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!node.hasAttribute(name)) {</span>
        <span class="s3">return </span><span class="s1">expected === undefined ? undefined : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">value = node.getAttribute(name);</span>

      <span class="s3">if </span><span class="s1">(value === </span><span class="s2">'' </span><span class="s1">+ expected) {</span>
        <span class="s3">return </span><span class="s1">expected;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Sets the value for a property on a node. 
   * 
   * @param {DOMElement} node 
   * @param {string} name 
   * @param {*} value 
   */</span>

  <span class="s3">function </span><span class="s1">setValueForProperty(node, name, value, isCustomComponentTag) {</span>
    <span class="s3">var </span><span class="s1">propertyInfo = getPropertyInfo(name);</span>

    <span class="s3">if </span><span class="s1">(shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {</span>
      <span class="s1">value = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If the prop isn't in the special list, treat it as a simple attribute.</span>


    <span class="s3">if </span><span class="s1">(isCustomComponentTag || propertyInfo === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isAttributeNameSafe(name)) {</span>
        <span class="s3">var </span><span class="s1">_attributeName = name;</span>

        <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">node.removeAttribute(_attributeName);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">node.setAttribute(_attributeName,  </span><span class="s2">'' </span><span class="s1">+ value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">mustUseProperty = propertyInfo.mustUseProperty;</span>

    <span class="s3">if </span><span class="s1">(mustUseProperty) {</span>
      <span class="s3">var </span><span class="s1">propertyName = propertyInfo.propertyName;</span>

      <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">type = propertyInfo.type;</span>
        <span class="s1">node[propertyName] = type === BOOLEAN ? </span><span class="s3">false </span><span class="s1">: </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Contrary to `setAttribute`, object properties are properly</span>
        <span class="s0">// `toString`ed by IE8/9.</span>
        <span class="s1">node[propertyName] = value;</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// The rest are treated as attributes with special cases.</span>


    <span class="s3">var </span><span class="s1">attributeName = propertyInfo.attributeName,</span>
        <span class="s1">attributeNamespace = propertyInfo.attributeNamespace;</span>

    <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">node.removeAttribute(attributeName);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_type = propertyInfo.type;</span>
      <span class="s3">var </span><span class="s1">attributeValue;</span>

      <span class="s3">if </span><span class="s1">(_type === BOOLEAN || _type === OVERLOADED_BOOLEAN &amp;&amp; value === </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s0">// If attribute type is boolean, we know for sure it won't be an execution sink</span>
        <span class="s0">// and we won't require Trusted Type here.</span>
        <span class="s1">attributeValue = </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// `setAttribute` with objects becomes only `[object]` in IE8/9,</span>
        <span class="s0">// ('' + value) makes it output the correct toString()-value.</span>
        <span class="s1">{</span>
          <span class="s1">attributeValue = </span><span class="s2">'' </span><span class="s1">+ value;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(propertyInfo.sanitizeURL) {</span>
          <span class="s1">sanitizeURL(attributeValue.toString());</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(attributeNamespace) {</span>
        <span class="s1">node.setAttributeNS(attributeNamespace, attributeName, attributeValue);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">node.setAttribute(attributeName, attributeValue);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">BEFORE_SLASH_RE = /^(.*)[\\\/]/;</span>
  <span class="s3">function </span><span class="s1">describeComponentFrame (name, source, ownerName) {</span>
    <span class="s3">var </span><span class="s1">sourceInfo = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(source) {</span>
      <span class="s3">var </span><span class="s1">path = source.fileName;</span>
      <span class="s3">var </span><span class="s1">fileName = path.replace(BEFORE_SLASH_RE, </span><span class="s2">''</span><span class="s1">);</span>

      <span class="s1">{</span>
        <span class="s0">// In DEV, include code for a common special case:</span>
        <span class="s0">// prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</span>
        <span class="s3">if </span><span class="s1">(/^index\./.test(fileName)) {</span>
          <span class="s3">var </span><span class="s1">match = path.match(BEFORE_SLASH_RE);</span>

          <span class="s3">if </span><span class="s1">(match) {</span>
            <span class="s3">var </span><span class="s1">pathBeforeSlash = match[</span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(pathBeforeSlash) {</span>
              <span class="s3">var </span><span class="s1">folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, </span><span class="s2">''</span><span class="s1">);</span>
              <span class="s1">fileName = folderName + </span><span class="s2">'/' </span><span class="s1">+ fileName;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">sourceInfo = </span><span class="s2">' (at ' </span><span class="s1">+ fileName + </span><span class="s2">':' </span><span class="s1">+ source.lineNumber + </span><span class="s2">')'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ownerName) {</span>
      <span class="s1">sourceInfo = </span><span class="s2">' (created by ' </span><span class="s1">+ ownerName + </span><span class="s2">')'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">'</span><span class="s5">\n    </span><span class="s2">in ' </span><span class="s1">+ (name || </span><span class="s2">'Unknown'</span><span class="s1">) + sourceInfo;</span>
  <span class="s1">}</span>

  <span class="s0">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span>
  <span class="s0">// nor polyfill, then a plain number is used for performance.</span>
  <span class="s3">var </span><span class="s1">hasSymbol = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.</span><span class="s3">for</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">REACT_ELEMENT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.element'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeac7;</span>
  <span class="s3">var </span><span class="s1">REACT_PORTAL_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.portal'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeaca;</span>
  <span class="s3">var </span><span class="s1">REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.fragment'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacb;</span>
  <span class="s3">var </span><span class="s1">REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.strict_mode'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacc;</span>
  <span class="s3">var </span><span class="s1">REACT_PROFILER_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.profiler'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead2;</span>
  <span class="s3">var </span><span class="s1">REACT_PROVIDER_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.provider'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacd;</span>
  <span class="s3">var </span><span class="s1">REACT_CONTEXT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.context'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeace; </span><span class="s0">// TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary</span>
  <span class="s3">var </span><span class="s1">REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.concurrent_mode'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacf;</span>
  <span class="s3">var </span><span class="s1">REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.forward_ref'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead0;</span>
  <span class="s3">var </span><span class="s1">REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead1;</span>
  <span class="s3">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense_list'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead8;</span>
  <span class="s3">var </span><span class="s1">REACT_MEMO_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.memo'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead3;</span>
  <span class="s3">var </span><span class="s1">REACT_LAZY_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.lazy'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead4;</span>
  <span class="s3">var </span><span class="s1">REACT_BLOCK_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.block'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead9;</span>
  <span class="s3">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.iterator;</span>
  <span class="s3">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s2">'@@iterator'</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
    <span class="s3">if </span><span class="s1">(maybeIterable === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">maybeIterable !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeIterator === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">maybeIterator;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">Uninitialized = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Pending = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Resolved = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Rejected = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">refineResolvedLazyComponent(lazyComponent) {</span>
    <span class="s3">return </span><span class="s1">lazyComponent._status === Resolved ? lazyComponent._result : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">initializeLazyComponentType(lazyComponent) {</span>
    <span class="s3">if </span><span class="s1">(lazyComponent._status === Uninitialized) {</span>
      <span class="s1">lazyComponent._status = Pending;</span>
      <span class="s3">var </span><span class="s1">ctor = lazyComponent._ctor;</span>
      <span class="s3">var </span><span class="s1">thenable = ctor();</span>
      <span class="s1">lazyComponent._result = thenable;</span>
      <span class="s1">thenable.then(</span><span class="s3">function </span><span class="s1">(moduleObject) {</span>
        <span class="s3">if </span><span class="s1">(lazyComponent._status === Pending) {</span>
          <span class="s3">var </span><span class="s1">defaultExport = moduleObject.</span><span class="s3">default</span><span class="s1">;</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(defaultExport === undefined) {</span>
              <span class="s1">error(</span><span class="s2">'lazy: Expected the result of a dynamic import() call. ' </span><span class="s1">+ </span><span class="s2">'Instead received: %s</span><span class="s5">\n\n</span><span class="s2">Your code should look like: </span><span class="s5">\n  </span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;const MyComponent = lazy(() =&gt; import('./MyComponent'))&quot;</span><span class="s1">, moduleObject);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">lazyComponent._status = Resolved;</span>
          <span class="s1">lazyComponent._result = defaultExport;</span>
        <span class="s1">}</span>
      <span class="s1">}, </span><span class="s3">function </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(lazyComponent._status === Pending) {</span>
          <span class="s1">lazyComponent._status = Rejected;</span>
          <span class="s1">lazyComponent._result = error;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
    <span class="s3">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">outerType.displayName || (functionName !== </span><span class="s2">'' </span><span class="s1">? wrapperName + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s2">&quot;)&quot; </span><span class="s1">: wrapperName);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getComponentName(type) {</span>
    <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Host root, text node or just invalid type.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.tag === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Received an unexpected object in getComponentName(). ' </span><span class="s1">+ </span><span class="s2">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Fragment'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Portal'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s3">return </span><span class="s2">'StrictMode'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Suspense'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s3">return </span><span class="s2">'SuspenseList'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
          <span class="s3">return </span><span class="s2">'Context.Consumer'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
          <span class="s3">return </span><span class="s2">'Context.Provider'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s3">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s2">'ForwardRef'</span><span class="s1">);</span>

        <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s3">return </span><span class="s1">getComponentName(type.type);</span>

        <span class="s3">case </span><span class="s1">REACT_BLOCK_TYPE:</span>
          <span class="s3">return </span><span class="s1">getComponentName(type.render);</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">thenable = type;</span>
            <span class="s3">var </span><span class="s1">resolvedThenable = refineResolvedLazyComponent(thenable);</span>

            <span class="s3">if </span><span class="s1">(resolvedThenable) {</span>
              <span class="s3">return </span><span class="s1">getComponentName(resolvedThenable);</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;</span>

  <span class="s3">function </span><span class="s1">describeFiber(fiber) {</span>
    <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
      <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">case </span><span class="s1">Fragment:</span>
      <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">case </span><span class="s1">ContextConsumer:</span>
        <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">var </span><span class="s1">owner = fiber._debugOwner;</span>
        <span class="s3">var </span><span class="s1">source = fiber._debugSource;</span>
        <span class="s3">var </span><span class="s1">name = getComponentName(fiber.type);</span>
        <span class="s3">var </span><span class="s1">ownerName = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(owner) {</span>
          <span class="s1">ownerName = getComponentName(owner.type);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">describeComponentFrame(name, source, ownerName);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getStackByFiberInDevAndProd(workInProgress) {</span>
    <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">node = workInProgress;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">info += describeFiber(node);</span>
      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(node);</span>

    <span class="s3">return </span><span class="s1">info;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">current = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">getCurrentFiberOwnerNameInDevOrNull() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">owner = current._debugOwner;</span>

      <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">owner !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">getComponentName(owner.type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getCurrentFiberStackInDev() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Safe because if current fiber exists, we are reconciling,</span>
      <span class="s0">// and it is guaranteed to be the work-in-progress version.</span>


      <span class="s3">return </span><span class="s1">getStackByFiberInDevAndProd(current);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resetCurrentFiber() {</span>
    <span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setCurrentFiber(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;</span>
      <span class="s1">current = fiber;</span>
      <span class="s1">isRendering = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setIsRendering(rendering) {</span>
    <span class="s1">{</span>
      <span class="s1">isRendering = rendering;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Flow does not allow string concatenation of most non-string types. To work</span>
  <span class="s0">// around this limitation, we use an opaque type that can only be obtained by</span>
  <span class="s0">// passing the value through getToStringValue first.</span>
  <span class="s3">function </span><span class="s1">toString(value) {</span>
    <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ value;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getToStringValue(value) {</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value) {</span>
      <span class="s3">case </span><span class="s2">'boolean'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'number'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'string'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'undefined'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">value;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s0">// function, symbol are assigned as empty strings</span>
        <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Copyright (c) 2013-present, Facebook, Inc. 
   * 
   * This source code is licensed under the MIT license found in the 
   * LICENSE file in the root directory of this source tree. 
   */</span>

  <span class="s3">var </span><span class="s1">ReactPropTypesSecret = </span><span class="s2">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactPropTypesSecret_1 = ReactPropTypesSecret;</span>

  <span class="s3">var </span><span class="s1">printWarning$1 = </span><span class="s3">function</span><span class="s1">() {};</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">ReactPropTypesSecret$1 = ReactPropTypesSecret_1;</span>
    <span class="s3">var </span><span class="s1">loggedTypeFailures = {};</span>
    <span class="s3">var </span><span class="s1">has = Function.call.bind(Object.prototype.hasOwnProperty);</span>

    <span class="s1">printWarning$1 = </span><span class="s3">function</span><span class="s1">(text) {</span>
      <span class="s3">var </span><span class="s1">message = </span><span class="s2">'Warning: ' </span><span class="s1">+ text;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s1">console.error(message);</span>
      <span class="s1">}</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s0">// --- Welcome to debugging React ---</span>
        <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
        <span class="s0">// to find the callsite that caused this warning to fire.</span>
        <span class="s3">throw new </span><span class="s1">Error(message);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Assert that the values match with the type specs. 
   * Error messages are memorized and will only be shown once. 
   * 
   * @param {object} typeSpecs Map of name to a ReactPropType 
   * @param {object} values Runtime values that need to be type-checked 
   * @param {string} location e.g. &quot;prop&quot;, &quot;context&quot;, &quot;child context&quot; 
   * @param {string} componentName Name of the component for error messages. 
   * @param {?Function} getStack Returns the component stack. 
   * @private 
   */</span>
  <span class="s3">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, getStack) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">typeSpecName </span><span class="s3">in </span><span class="s1">typeSpecs) {</span>
        <span class="s3">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
          <span class="s3">var </span><span class="s1">error;</span>
          <span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
          <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
          <span class="s0">// After these have been cleaned up, we'll let them throw.</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
            <span class="s0">// behavior as without this statement except with a better message.</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">err = Error(</span>
                <span class="s1">(componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': ' </span><span class="s1">+ location + </span><span class="s2">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s2">'` is invalid; ' </span><span class="s1">+</span>
                <span class="s2">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s2">'`.'</span>
              <span class="s1">);</span>
              <span class="s1">err.name = </span><span class="s2">'Invariant Violation'</span><span class="s1">;</span>
              <span class="s3">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s1">error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s3">null</span><span class="s1">, ReactPropTypesSecret$1);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
            <span class="s1">error = ex;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(error &amp;&amp; !(error </span><span class="s3">instanceof </span><span class="s1">Error)) {</span>
            <span class="s1">printWarning$1(</span>
              <span class="s1">(componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': type specification of ' </span><span class="s1">+</span>
              <span class="s1">location + </span><span class="s2">' `' </span><span class="s1">+ typeSpecName + </span><span class="s2">'` is invalid; the type checker ' </span><span class="s1">+</span>
              <span class="s2">'function must return `null` or an `Error` but returned a ' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">error + </span><span class="s2">'. ' </span><span class="s1">+</span>
              <span class="s2">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+</span>
              <span class="s2">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+</span>
              <span class="s2">'shape all require an argument).'</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(error </span><span class="s3">instanceof </span><span class="s1">Error &amp;&amp; !(error.message </span><span class="s3">in </span><span class="s1">loggedTypeFailures)) {</span>
            <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
            <span class="s0">// same error.</span>
            <span class="s1">loggedTypeFailures[error.message] = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s3">var </span><span class="s1">stack = getStack ? getStack() : </span><span class="s2">''</span><span class="s1">;</span>

            <span class="s1">printWarning$1(</span>
              <span class="s2">'Failed ' </span><span class="s1">+ location + </span><span class="s2">' type: ' </span><span class="s1">+ error.message + (stack != </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Resets warning cache when testing. 
   * 
   * @private 
   */</span>
  <span class="s1">checkPropTypes.resetWarningCache = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">{</span>
      <span class="s1">loggedTypeFailures = {};</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">checkPropTypes_1 = checkPropTypes;</span>

  <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame$2 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ReactControlledValuePropTypes = {</span>
    <span class="s1">checkPropTypes: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;</span>
    <span class="s3">var </span><span class="s1">hasReadOnlyValue = {</span>
      <span class="s1">button: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">checkbox: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">image: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">hidden: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">radio: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">reset: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">submit: </span><span class="s3">true</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">propTypes = {</span>
      <span class="s1">value: </span><span class="s3">function </span><span class="s1">(props, propName, componentName) {</span>
        <span class="s3">if </span><span class="s1">(hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == </span><span class="s3">null </span><span class="s1">|| enableDeprecatedFlareAPI ) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return new </span><span class="s1">Error(</span><span class="s2">'You provided a `value` prop to a form field without an ' </span><span class="s1">+ </span><span class="s2">'`onChange` handler. This will render a read-only field. If ' </span><span class="s1">+ </span><span class="s2">'the field should be mutable use `defaultValue`. Otherwise, ' </span><span class="s1">+ </span><span class="s2">'set either `onChange` or `readOnly`.'</span><span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">checked: </span><span class="s3">function </span><span class="s1">(props, propName, componentName) {</span>
        <span class="s3">if </span><span class="s1">(props.onChange || props.readOnly || props.disabled || props[propName] == </span><span class="s3">null </span><span class="s1">|| enableDeprecatedFlareAPI ) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return new </span><span class="s1">Error(</span><span class="s2">'You provided a `checked` prop to a form field without an ' </span><span class="s1">+ </span><span class="s2">'`onChange` handler. This will render a read-only field. If ' </span><span class="s1">+ </span><span class="s2">'the field should be mutable use `defaultChecked`. Otherwise, ' </span><span class="s1">+ </span><span class="s2">'set either `onChange` or `readOnly`.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * Provide a linked `value` attribute for controlled forms. You should not use 
     * this outside of the ReactDOM controlled form components. 
     */</span>

    <span class="s1">ReactControlledValuePropTypes.checkPropTypes = </span><span class="s3">function </span><span class="s1">(tagName, props) {</span>
      <span class="s1">checkPropTypes_1(propTypes, props, </span><span class="s2">'prop'</span><span class="s1">, tagName, ReactDebugCurrentFrame$2.getStackAddendum);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isCheckable(elem) {</span>
    <span class="s3">var </span><span class="s1">type = elem.type;</span>
    <span class="s3">var </span><span class="s1">nodeName = elem.nodeName;</span>
    <span class="s3">return </span><span class="s1">nodeName &amp;&amp; nodeName.toLowerCase() === </span><span class="s2">'input' </span><span class="s1">&amp;&amp; (type === </span><span class="s2">'checkbox' </span><span class="s1">|| type === </span><span class="s2">'radio'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getTracker(node) {</span>
    <span class="s3">return </span><span class="s1">node._valueTracker;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">detachTracker(node) {</span>
    <span class="s1">node._valueTracker = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getValueFromNode(node) {</span>
    <span class="s3">var </span><span class="s1">value = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!node) {</span>
      <span class="s3">return </span><span class="s1">value;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isCheckable(node)) {</span>
      <span class="s1">value = node.checked ? </span><span class="s2">'true' </span><span class="s1">: </span><span class="s2">'false'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">value = node.value;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">value;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">trackValueOnNode(node) {</span>
    <span class="s3">var </span><span class="s1">valueField = isCheckable(node) ? </span><span class="s2">'checked' </span><span class="s1">: </span><span class="s2">'value'</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);</span>
    <span class="s3">var </span><span class="s1">currentValue = </span><span class="s2">'' </span><span class="s1">+ node[valueField]; </span><span class="s0">// if someone has already defined a value or Safari, then bail</span>
    <span class="s0">// and don't track value will cause over reporting of changes,</span>
    <span class="s0">// but it's better then a hard failure</span>
    <span class="s0">// (needed for certain tests that spyOn input values and Safari)</span>

    <span class="s3">if </span><span class="s1">(node.hasOwnProperty(valueField) || </span><span class="s3">typeof </span><span class="s1">descriptor === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">descriptor.get !== </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">descriptor.set !== </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">get = descriptor.get,</span>
        <span class="s1">set = descriptor.set;</span>
    <span class="s1">Object.defineProperty(node, valueField, {</span>
      <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">get.call(</span><span class="s3">this</span><span class="s1">);</span>
      <span class="s1">},</span>
      <span class="s1">set: </span><span class="s3">function </span><span class="s1">(value) {</span>
        <span class="s1">currentValue = </span><span class="s2">'' </span><span class="s1">+ value;</span>
        <span class="s1">set.call(</span><span class="s3">this</span><span class="s1">, value);</span>
      <span class="s1">}</span>
    <span class="s1">}); </span><span class="s0">// We could've passed this the first time</span>
    <span class="s0">// but it triggers a bug in IE11 and Edge 14/15.</span>
    <span class="s0">// Calling defineProperty() again should be equivalent.</span>
    <span class="s0">// https://github.com/facebook/react/issues/11768</span>

    <span class="s1">Object.defineProperty(node, valueField, {</span>
      <span class="s1">enumerable: descriptor.enumerable</span>
    <span class="s1">});</span>
    <span class="s3">var </span><span class="s1">tracker = {</span>
      <span class="s1">getValue: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">currentValue;</span>
      <span class="s1">},</span>
      <span class="s1">setValue: </span><span class="s3">function </span><span class="s1">(value) {</span>
        <span class="s1">currentValue = </span><span class="s2">'' </span><span class="s1">+ value;</span>
      <span class="s1">},</span>
      <span class="s1">stopTracking: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">detachTracker(node);</span>
        <span class="s3">delete </span><span class="s1">node[valueField];</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s3">return </span><span class="s1">tracker;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">track(node) {</span>
    <span class="s3">if </span><span class="s1">(getTracker(node)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// TODO: Once it's just Fiber we can move this to node._wrapperState</span>


    <span class="s1">node._valueTracker = trackValueOnNode(node);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateValueIfChanged(node) {</span>
    <span class="s3">if </span><span class="s1">(!node) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">tracker = getTracker(node); </span><span class="s0">// if there is no tracker at this point it's unlikely</span>
    <span class="s0">// that trying again will succeed</span>

    <span class="s3">if </span><span class="s1">(!tracker) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">lastValue = tracker.getValue();</span>
    <span class="s3">var </span><span class="s1">nextValue = getValueFromNode(node);</span>

    <span class="s3">if </span><span class="s1">(nextValue !== lastValue) {</span>
      <span class="s1">tracker.setValue(nextValue);</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnValueDefaultValue = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnCheckedDefaultChecked = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnControlledToUncontrolled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnUncontrolledToControlled = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">isControlled(props) {</span>
    <span class="s3">var </span><span class="s1">usesChecked = props.type === </span><span class="s2">'checkbox' </span><span class="s1">|| props.type === </span><span class="s2">'radio'</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">usesChecked ? props.checked != </span><span class="s3">null </span><span class="s1">: props.value != </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Implements an &lt;input&gt; host component that allows setting these optional 
   * props: `checked`, `value`, `defaultChecked`, and `defaultValue`. 
   * 
   * If `checked` or `value` are not supplied (or null/undefined), user actions 
   * that affect the checked state or value will trigger updates to the element. 
   * 
   * If they are supplied (and not null/undefined), the rendered element will not 
   * trigger updates to the element. Instead, the props must change in order for 
   * the rendered element to be updated. 
   * 
   * The rendered element will be initialized as unchecked (or `defaultChecked`) 
   * with an empty value (or `defaultValue`). 
   * 
   * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html 
   */</span>


  <span class="s3">function </span><span class="s1">getHostProps(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">checked = props.checked;</span>

    <span class="s3">var </span><span class="s1">hostProps = _assign({}, props, {</span>
      <span class="s1">defaultChecked: undefined,</span>
      <span class="s1">defaultValue: undefined,</span>
      <span class="s1">value: undefined,</span>
      <span class="s1">checked: checked != </span><span class="s3">null </span><span class="s1">? checked : node._wrapperState.initialChecked</span>
    <span class="s1">});</span>

    <span class="s3">return </span><span class="s1">hostProps;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">initWrapperState(element, props) {</span>
    <span class="s1">{</span>
      <span class="s1">ReactControlledValuePropTypes.checkPropTypes(</span><span class="s2">'input'</span><span class="s1">, props);</span>

      <span class="s3">if </span><span class="s1">(props.checked !== undefined &amp;&amp; props.defaultChecked !== undefined &amp;&amp; !didWarnCheckedDefaultChecked) {</span>
        <span class="s1">error(</span><span class="s2">'%s contains an input of type %s with both checked and defaultChecked props. ' </span><span class="s1">+ </span><span class="s2">'Input elements must be either controlled or uncontrolled ' </span><span class="s1">+ </span><span class="s2">'(specify either the checked prop, or the defaultChecked prop, but not ' </span><span class="s1">+ </span><span class="s2">'both). Decide between using a controlled or uncontrolled input ' </span><span class="s1">+ </span><span class="s2">'element and remove one of these props. More info: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-controlled-components'</span><span class="s1">, getCurrentFiberOwnerNameInDevOrNull() || </span><span class="s2">'A component'</span><span class="s1">, props.type);</span>

        <span class="s1">didWarnCheckedDefaultChecked = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValueDefaultValue) {</span>
        <span class="s1">error(</span><span class="s2">'%s contains an input of type %s with both value and defaultValue props. ' </span><span class="s1">+ </span><span class="s2">'Input elements must be either controlled or uncontrolled ' </span><span class="s1">+ </span><span class="s2">'(specify either the value prop, or the defaultValue prop, but not ' </span><span class="s1">+ </span><span class="s2">'both). Decide between using a controlled or uncontrolled input ' </span><span class="s1">+ </span><span class="s2">'element and remove one of these props. More info: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-controlled-components'</span><span class="s1">, getCurrentFiberOwnerNameInDevOrNull() || </span><span class="s2">'A component'</span><span class="s1">, props.type);</span>

        <span class="s1">didWarnValueDefaultValue = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">defaultValue = props.defaultValue == </span><span class="s3">null </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: props.defaultValue;</span>
    <span class="s1">node._wrapperState = {</span>
      <span class="s1">initialChecked: props.checked != </span><span class="s3">null </span><span class="s1">? props.checked : props.defaultChecked,</span>
      <span class="s1">initialValue: getToStringValue(props.value != </span><span class="s3">null </span><span class="s1">? props.value : defaultValue),</span>
      <span class="s1">controlled: isControlled(props)</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateChecked(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">checked = props.checked;</span>

    <span class="s3">if </span><span class="s1">(checked != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">setValueForProperty(node, </span><span class="s2">'checked'</span><span class="s1">, checked, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateWrapper(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">controlled = isControlled(props);</span>

      <span class="s3">if </span><span class="s1">(!node._wrapperState.controlled &amp;&amp; controlled &amp;&amp; !didWarnUncontrolledToControlled) {</span>
        <span class="s1">error(</span><span class="s2">'A component is changing an uncontrolled input of type %s to be controlled. ' </span><span class="s1">+ </span><span class="s2">'Input elements should not switch from uncontrolled to controlled (or vice versa). ' </span><span class="s1">+ </span><span class="s2">'Decide between using a controlled or uncontrolled input ' </span><span class="s1">+ </span><span class="s2">'element for the lifetime of the component. More info: https://fb.me/react-controlled-components'</span><span class="s1">, props.type);</span>

        <span class="s1">didWarnUncontrolledToControlled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node._wrapperState.controlled &amp;&amp; !controlled &amp;&amp; !didWarnControlledToUncontrolled) {</span>
        <span class="s1">error(</span><span class="s2">'A component is changing a controlled input of type %s to be uncontrolled. ' </span><span class="s1">+ </span><span class="s2">'Input elements should not switch from controlled to uncontrolled (or vice versa). ' </span><span class="s1">+ </span><span class="s2">'Decide between using a controlled or uncontrolled input ' </span><span class="s1">+ </span><span class="s2">'element for the lifetime of the component. More info: https://fb.me/react-controlled-components'</span><span class="s1">, props.type);</span>

        <span class="s1">didWarnControlledToUncontrolled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">updateChecked(element, props);</span>
    <span class="s3">var </span><span class="s1">value = getToStringValue(props.value);</span>
    <span class="s3">var </span><span class="s1">type = props.type;</span>

    <span class="s3">if </span><span class="s1">(value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(value === </span><span class="s4">0 </span><span class="s1">&amp;&amp; node.value === </span><span class="s2">'' </span><span class="s1">|| </span><span class="s0">// We explicitly want to coerce to number here if possible.</span>
        <span class="s0">// eslint-disable-next-line</span>
        <span class="s1">node.value != value) {</span>
          <span class="s1">node.value = toString(value);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.value !== toString(value)) {</span>
        <span class="s1">node.value = toString(value);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s2">'submit' </span><span class="s1">|| type === </span><span class="s2">'reset'</span><span class="s1">) {</span>
      <span class="s0">// Submit/reset inputs need the attribute removed completely to avoid</span>
      <span class="s0">// blank-text buttons.</span>
      <span class="s1">node.removeAttribute(</span><span class="s2">'value'</span><span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// When syncing the value attribute, the value comes from a cascade of</span>
      <span class="s0">// properties:</span>
      <span class="s0">//  1. The value React property</span>
      <span class="s0">//  2. The defaultValue React property</span>
      <span class="s0">//  3. Otherwise there should be no change</span>
      <span class="s3">if </span><span class="s1">(props.hasOwnProperty(</span><span class="s2">'value'</span><span class="s1">)) {</span>
        <span class="s1">setDefaultValue(node, props.type, value);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(props.hasOwnProperty(</span><span class="s2">'defaultValue'</span><span class="s1">)) {</span>
        <span class="s1">setDefaultValue(node, props.type, getToStringValue(props.defaultValue));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// When syncing the checked attribute, it only changes when it needs</span>
      <span class="s0">// to be removed, such as transitioning from a checkbox into a text input</span>
      <span class="s3">if </span><span class="s1">(props.checked == </span><span class="s3">null </span><span class="s1">&amp;&amp; props.defaultChecked != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.defaultChecked = !!props.defaultChecked;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">postMountWrapper(element, props, isHydrating) {</span>
    <span class="s3">var </span><span class="s1">node = element; </span><span class="s0">// Do not assign value if it is already set. This prevents user text input</span>
    <span class="s0">// from being lost during SSR hydration.</span>

    <span class="s3">if </span><span class="s1">(props.hasOwnProperty(</span><span class="s2">'value'</span><span class="s1">) || props.hasOwnProperty(</span><span class="s2">'defaultValue'</span><span class="s1">)) {</span>
      <span class="s3">var </span><span class="s1">type = props.type;</span>
      <span class="s3">var </span><span class="s1">isButton = type === </span><span class="s2">'submit' </span><span class="s1">|| type === </span><span class="s2">'reset'</span><span class="s1">; </span><span class="s0">// Avoid setting value attribute on submit/reset inputs as it overrides the</span>
      <span class="s0">// default value provided by the browser. See: #12872</span>

      <span class="s3">if </span><span class="s1">(isButton &amp;&amp; (props.value === undefined || props.value === </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">initialValue = toString(node._wrapperState.initialValue); </span><span class="s0">// Do not assign value if it is already set. This prevents user text input</span>
      <span class="s0">// from being lost during SSR hydration.</span>

      <span class="s3">if </span><span class="s1">(!isHydrating) {</span>
        <span class="s1">{</span>
          <span class="s0">// When syncing the value attribute, the value property should use</span>
          <span class="s0">// the wrapperState._initialValue property. This uses:</span>
          <span class="s0">//</span>
          <span class="s0">//   1. The value React property when present</span>
          <span class="s0">//   2. The defaultValue React property when present</span>
          <span class="s0">//   3. An empty string</span>
          <span class="s3">if </span><span class="s1">(initialValue !== node.value) {</span>
            <span class="s1">node.value = initialValue;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// Otherwise, the value attribute is synchronized to the property,</span>
        <span class="s0">// so we assign defaultValue to the same thing as the value property</span>
        <span class="s0">// assignment step above.</span>
        <span class="s1">node.defaultValue = initialValue;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug</span>
    <span class="s0">// this is needed to work around a chrome bug where setting defaultChecked</span>
    <span class="s0">// will sometimes influence the value of checked (even after detachment).</span>
    <span class="s0">// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416</span>
    <span class="s0">// We need to temporarily unset name to avoid disrupting radio button groups.</span>


    <span class="s3">var </span><span class="s1">name = node.name;</span>

    <span class="s3">if </span><span class="s1">(name !== </span><span class="s2">''</span><span class="s1">) {</span>
      <span class="s1">node.name = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// When syncing the checked attribute, both the checked property and</span>
      <span class="s0">// attribute are assigned at the same time using defaultChecked. This uses:</span>
      <span class="s0">//</span>
      <span class="s0">//   1. The checked React property when present</span>
      <span class="s0">//   2. The defaultChecked React property when present</span>
      <span class="s0">//   3. Otherwise, false</span>
      <span class="s1">node.defaultChecked = !node.defaultChecked;</span>
      <span class="s1">node.defaultChecked = !!node._wrapperState.initialChecked;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(name !== </span><span class="s2">''</span><span class="s1">) {</span>
      <span class="s1">node.name = name;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">restoreControlledState(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s1">updateWrapper(node, props);</span>
    <span class="s1">updateNamedCousins(node, props);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateNamedCousins(rootNode, props) {</span>
    <span class="s3">var </span><span class="s1">name = props.name;</span>

    <span class="s3">if </span><span class="s1">(props.type === </span><span class="s2">'radio' </span><span class="s1">&amp;&amp; name != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">queryRoot = rootNode;</span>

      <span class="s3">while </span><span class="s1">(queryRoot.parentNode) {</span>
        <span class="s1">queryRoot = queryRoot.parentNode;</span>
      <span class="s1">} </span><span class="s0">// If `rootNode.form` was non-null, then we could try `form.elements`,</span>
      <span class="s0">// but that sometimes behaves strangely in IE8. We could also try using</span>
      <span class="s0">// `form.getElementsByName`, but that will only return direct children</span>
      <span class="s0">// and won't include inputs that use the HTML5 `form=` attribute. Since</span>
      <span class="s0">// the input might not even be in a form. It might not even be in the</span>
      <span class="s0">// document. Let's just use the local `querySelectorAll` to ensure we don't</span>
      <span class="s0">// miss anything.</span>


      <span class="s3">var </span><span class="s1">group = queryRoot.querySelectorAll(</span><span class="s2">'input[name=' </span><span class="s1">+ JSON.stringify(</span><span class="s2">'' </span><span class="s1">+ name) + </span><span class="s2">'][type=&quot;radio&quot;]'</span><span class="s1">);</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; group.length; i++) {</span>
        <span class="s3">var </span><span class="s1">otherNode = group[i];</span>

        <span class="s3">if </span><span class="s1">(otherNode === rootNode || otherNode.form !== rootNode.form) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// This will throw if radio buttons rendered by different copies of React</span>
        <span class="s0">// and the same name are rendered into the same form (same as #1939).</span>
        <span class="s0">// That's probably okay; we don't support it just as we don't support</span>
        <span class="s0">// mixing React radio buttons with non-React ones.</span>


        <span class="s3">var </span><span class="s1">otherProps = getFiberCurrentPropsFromNode$1(otherNode);</span>

        <span class="s3">if </span><span class="s1">(!otherProps) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// We need update the tracked value on the named cousin since the value</span>
        <span class="s0">// was changed but the input saw no event or value set</span>


        <span class="s1">updateValueIfChanged(otherNode); </span><span class="s0">// If this is a controlled radio button group, forcing the input that</span>
        <span class="s0">// was previously checked to update will cause it to be come re-checked</span>
        <span class="s0">// as appropriate.</span>

        <span class="s1">updateWrapper(otherNode, otherProps);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// In Chrome, assigning defaultValue to certain input types triggers input validation.</span>
  <span class="s0">// For number inputs, the display value loses trailing decimal points. For email inputs,</span>
  <span class="s0">// Chrome raises &quot;The specified value &lt;x&gt; is not a valid email address&quot;.</span>
  <span class="s0">//</span>
  <span class="s0">// Here we check to see if the defaultValue has actually changed, avoiding these problems</span>
  <span class="s0">// when the user is inputting text</span>
  <span class="s0">//</span>
  <span class="s0">// https://github.com/facebook/react/issues/7253</span>


  <span class="s3">function </span><span class="s1">setDefaultValue(node, type, value) {</span>
    <span class="s3">if </span><span class="s1">( </span><span class="s0">// Focused number inputs synchronize on blur. See ChangeEventPlugin.js</span>
    <span class="s1">type !== </span><span class="s2">'number' </span><span class="s1">|| node.ownerDocument.activeElement !== node) {</span>
      <span class="s3">if </span><span class="s1">(value == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.defaultValue = toString(node._wrapperState.initialValue);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.defaultValue !== toString(value)) {</span>
        <span class="s1">node.defaultValue = toString(value);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnSelectedSetOnOption = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnInvalidChild = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">flattenChildren(children) {</span>
    <span class="s3">var </span><span class="s1">content = </span><span class="s2">''</span><span class="s1">; </span><span class="s0">// Flatten children. We'll warn if they are invalid</span>
    <span class="s0">// during validateProps() which runs for hydration too.</span>
    <span class="s0">// Note that this would throw on non-element objects.</span>
    <span class="s0">// Elements are stringified (which is normally irrelevant</span>
    <span class="s0">// but matters for &lt;fbt&gt;).</span>

    <span class="s1">React.Children.forEach(children, </span><span class="s3">function </span><span class="s1">(child) {</span>
      <span class="s3">if </span><span class="s1">(child == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">content += child; </span><span class="s0">// Note: we don't warn about invalid children here.</span>
      <span class="s0">// Instead, this is done separately below so that</span>
      <span class="s0">// it happens during the hydration codepath too.</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">content;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Implements an &lt;option&gt; host component that warns when `selected` is set. 
   */</span>


  <span class="s3">function </span><span class="s1">validateProps(element, props) {</span>
    <span class="s1">{</span>
      <span class="s0">// This mirrors the codepath above, but runs for hydration too.</span>
      <span class="s0">// Warn about invalid children here so that client and hydration are consistent.</span>
      <span class="s0">// TODO: this seems like it could cause a DEV-only throw for hydration</span>
      <span class="s0">// if children contains a non-element object. We should try to avoid that.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">props.children === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; props.children !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">React.Children.forEach(props.children, </span><span class="s3">function </span><span class="s1">(child) {</span>
          <span class="s3">if </span><span class="s1">(child == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">child === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">child === </span><span class="s2">'number'</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">child.type !== </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(!didWarnInvalidChild) {</span>
            <span class="s1">didWarnInvalidChild = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s2">'Only strings and numbers are supported as &lt;option&gt; children.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s0">// TODO: Remove support for `selected` in &lt;option&gt;.</span>


      <span class="s3">if </span><span class="s1">(props.selected != </span><span class="s3">null </span><span class="s1">&amp;&amp; !didWarnSelectedSetOnOption) {</span>
        <span class="s1">error(</span><span class="s2">'Use the `defaultValue` or `value` props on &lt;select&gt; instead of ' </span><span class="s1">+ </span><span class="s2">'setting `selected` on &lt;option&gt;.'</span><span class="s1">);</span>

        <span class="s1">didWarnSelectedSetOnOption = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">postMountWrapper$1(element, props) {</span>
    <span class="s0">// value=&quot;&quot; should make a value attribute (#6219)</span>
    <span class="s3">if </span><span class="s1">(props.value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">element.setAttribute(</span><span class="s2">'value'</span><span class="s1">, toString(getToStringValue(props.value)));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getHostProps$1(element, props) {</span>
    <span class="s3">var </span><span class="s1">hostProps = _assign({</span>
      <span class="s1">children: undefined</span>
    <span class="s1">}, props);</span>

    <span class="s3">var </span><span class="s1">content = flattenChildren(props.children);</span>

    <span class="s3">if </span><span class="s1">(content) {</span>
      <span class="s1">hostProps.children = content;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">hostProps;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnValueDefaultValue$1;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnValueDefaultValue$1 = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getDeclarationErrorAddendum() {</span>
    <span class="s3">var </span><span class="s1">ownerName = getCurrentFiberOwnerNameInDevOrNull();</span>

    <span class="s3">if </span><span class="s1">(ownerName) {</span>
      <span class="s3">return </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check the render method of `' </span><span class="s1">+ ownerName + </span><span class="s2">'`.'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">valuePropNames = [</span><span class="s2">'value'</span><span class="s1">, </span><span class="s2">'defaultValue'</span><span class="s1">];</span>
  <span class="s0">/** 
   * Validation function for `value` and `defaultValue`. 
   */</span>

  <span class="s3">function </span><span class="s1">checkSelectPropTypes(props) {</span>
    <span class="s1">{</span>
      <span class="s1">ReactControlledValuePropTypes.checkPropTypes(</span><span class="s2">'select'</span><span class="s1">, props);</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; valuePropNames.length; i++) {</span>
        <span class="s3">var </span><span class="s1">propName = valuePropNames[i];</span>

        <span class="s3">if </span><span class="s1">(props[propName] == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">isArray = Array.isArray(props[propName]);</span>

        <span class="s3">if </span><span class="s1">(props.multiple &amp;&amp; !isArray) {</span>
          <span class="s1">error(</span><span class="s2">'The `%s` prop supplied to &lt;select&gt; must be an array if ' </span><span class="s1">+ </span><span class="s2">'`multiple` is true.%s'</span><span class="s1">, propName, getDeclarationErrorAddendum());</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!props.multiple &amp;&amp; isArray) {</span>
          <span class="s1">error(</span><span class="s2">'The `%s` prop supplied to &lt;select&gt; must be a scalar ' </span><span class="s1">+ </span><span class="s2">'value if `multiple` is false.%s'</span><span class="s1">, propName, getDeclarationErrorAddendum());</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateOptions(node, multiple, propValue, setDefaultSelected) {</span>
    <span class="s3">var </span><span class="s1">options = node.options;</span>

    <span class="s3">if </span><span class="s1">(multiple) {</span>
      <span class="s3">var </span><span class="s1">selectedValues = propValue;</span>
      <span class="s3">var </span><span class="s1">selectedValue = {};</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; selectedValues.length; i++) {</span>
        <span class="s0">// Prefix to avoid chaos with special keys.</span>
        <span class="s1">selectedValue[</span><span class="s2">'$' </span><span class="s1">+ selectedValues[i]] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">; _i &lt; options.length; _i++) {</span>
        <span class="s3">var </span><span class="s1">selected = selectedValue.hasOwnProperty(</span><span class="s2">'$' </span><span class="s1">+ options[_i].value);</span>

        <span class="s3">if </span><span class="s1">(options[_i].selected !== selected) {</span>
          <span class="s1">options[_i].selected = selected;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(selected &amp;&amp; setDefaultSelected) {</span>
          <span class="s1">options[_i].defaultSelected = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Do not set `select.value` as exact behavior isn't consistent across all</span>
      <span class="s0">// browsers for all cases.</span>
      <span class="s3">var </span><span class="s1">_selectedValue = toString(getToStringValue(propValue));</span>

      <span class="s3">var </span><span class="s1">defaultSelected = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i2 = </span><span class="s4">0</span><span class="s1">; _i2 &lt; options.length; _i2++) {</span>
        <span class="s3">if </span><span class="s1">(options[_i2].value === _selectedValue) {</span>
          <span class="s1">options[_i2].selected = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(setDefaultSelected) {</span>
            <span class="s1">options[_i2].defaultSelected = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(defaultSelected === </span><span class="s3">null </span><span class="s1">&amp;&amp; !options[_i2].disabled) {</span>
          <span class="s1">defaultSelected = options[_i2];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(defaultSelected !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">defaultSelected.selected = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Implements a &lt;select&gt; host component that allows optionally setting the 
   * props `value` and `defaultValue`. If `multiple` is false, the prop must be a 
   * stringable. If `multiple` is true, the prop must be an array of stringables. 
   * 
   * If `value` is not supplied (or null/undefined), user actions that change the 
   * selected option will trigger updates to the rendered options. 
   * 
   * If it is supplied (and not null/undefined), the rendered options will not 
   * update in response to user actions. Instead, the `value` prop must change in 
   * order for the rendered options to update. 
   * 
   * If `defaultValue` is provided, any options with the supplied values will be 
   * selected. 
   */</span>


  <span class="s3">function </span><span class="s1">getHostProps$2(element, props) {</span>
    <span class="s3">return </span><span class="s1">_assign({}, props, {</span>
      <span class="s1">value: undefined</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">initWrapperState$1(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>

    <span class="s1">{</span>
      <span class="s1">checkSelectPropTypes(props);</span>
    <span class="s1">}</span>

    <span class="s1">node._wrapperState = {</span>
      <span class="s1">wasMultiple: !!props.multiple</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValueDefaultValue$1) {</span>
        <span class="s1">error(</span><span class="s2">'Select elements must be either controlled or uncontrolled ' </span><span class="s1">+ </span><span class="s2">'(specify either the value prop, or the defaultValue prop, but not ' </span><span class="s1">+ </span><span class="s2">'both). Decide between using a controlled or uncontrolled select ' </span><span class="s1">+ </span><span class="s2">'element and remove one of these props. More info: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-controlled-components'</span><span class="s1">);</span>

        <span class="s1">didWarnValueDefaultValue$1 = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">postMountWrapper$2(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s1">node.multiple = !!props.multiple;</span>
    <span class="s3">var </span><span class="s1">value = props.value;</span>

    <span class="s3">if </span><span class="s1">(value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateOptions(node, !!props.multiple, value, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(props.defaultValue != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateOptions(node, !!props.multiple, props.defaultValue, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">postUpdateWrapper(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">wasMultiple = node._wrapperState.wasMultiple;</span>
    <span class="s1">node._wrapperState.wasMultiple = !!props.multiple;</span>
    <span class="s3">var </span><span class="s1">value = props.value;</span>

    <span class="s3">if </span><span class="s1">(value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateOptions(node, !!props.multiple, value, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(wasMultiple !== !!props.multiple) {</span>
      <span class="s0">// For simplicity, reapply `defaultValue` if `multiple` is toggled.</span>
      <span class="s3">if </span><span class="s1">(props.defaultValue != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">updateOptions(node, !!props.multiple, props.defaultValue, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Revert the select back to its default unselected state.</span>
        <span class="s1">updateOptions(node, !!props.multiple, props.multiple ? [] : </span><span class="s2">''</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">restoreControlledState$1(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">value = props.value;</span>

    <span class="s3">if </span><span class="s1">(value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateOptions(node, !!props.multiple, value, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnValDefaultVal = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s0">/** 
   * Implements a &lt;textarea&gt; host component that allows setting `value`, and 
   * `defaultValue`. This differs from the traditional DOM API because value is 
   * usually set as PCDATA children. 
   * 
   * If `value` is not supplied (or null/undefined), user actions that affect the 
   * value will trigger updates to the element. 
   * 
   * If `value` is supplied (and not null/undefined), the rendered element will 
   * not trigger updates to the element. Instead, the `value` prop must change in 
   * order for the rendered element to be updated. 
   * 
   * The rendered element will be initialized with an empty value, the prop 
   * `defaultValue` if specified, or the children content (deprecated). 
   */</span>
  <span class="s3">function </span><span class="s1">getHostProps$3(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>

    <span class="s3">if </span><span class="s1">(!(props.dangerouslySetInnerHTML == </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;`dangerouslySetInnerHTML` does not make sense on &lt;textarea&gt;.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Always set children to the same thing. In IE9, the selection range will</span>
    <span class="s0">// get reset if `textContent` is mutated.  We could add a check in setTextContent</span>
    <span class="s0">// to only set the value if/when the value differs from the node value (which would</span>
    <span class="s0">// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this</span>
    <span class="s0">// solution. The value can be a boolean or object so that's why it's forced</span>
    <span class="s0">// to be a string.</span>


    <span class="s3">var </span><span class="s1">hostProps = _assign({}, props, {</span>
      <span class="s1">value: undefined,</span>
      <span class="s1">defaultValue: undefined,</span>
      <span class="s1">children: toString(node._wrapperState.initialValue)</span>
    <span class="s1">});</span>

    <span class="s3">return </span><span class="s1">hostProps;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">initWrapperState$2(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>

    <span class="s1">{</span>
      <span class="s1">ReactControlledValuePropTypes.checkPropTypes(</span><span class="s2">'textarea'</span><span class="s1">, props);</span>

      <span class="s3">if </span><span class="s1">(props.value !== undefined &amp;&amp; props.defaultValue !== undefined &amp;&amp; !didWarnValDefaultVal) {</span>
        <span class="s1">error(</span><span class="s2">'%s contains a textarea with both value and defaultValue props. ' </span><span class="s1">+ </span><span class="s2">'Textarea elements must be either controlled or uncontrolled ' </span><span class="s1">+ </span><span class="s2">'(specify either the value prop, or the defaultValue prop, but not ' </span><span class="s1">+ </span><span class="s2">'both). Decide between using a controlled or uncontrolled textarea ' </span><span class="s1">+ </span><span class="s2">'and remove one of these props. More info: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-controlled-components'</span><span class="s1">, getCurrentFiberOwnerNameInDevOrNull() || </span><span class="s2">'A component'</span><span class="s1">);</span>

        <span class="s1">didWarnValDefaultVal = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">initialValue = props.value; </span><span class="s0">// Only bother fetching default value if we're going to use it</span>

    <span class="s3">if </span><span class="s1">(initialValue == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">children = props.children,</span>
          <span class="s1">defaultValue = props.defaultValue;</span>

      <span class="s3">if </span><span class="s1">(children != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">error(</span><span class="s2">'Use the `defaultValue` or `value` props instead of setting ' </span><span class="s1">+ </span><span class="s2">'children on &lt;textarea&gt;.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(!(defaultValue == </span><span class="s3">null</span><span class="s1">)) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;If you supply `defaultValue` on a &lt;textarea&gt;, do not pass children.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(Array.isArray(children)) {</span>
            <span class="s3">if </span><span class="s1">(!(children.length &lt;= </span><span class="s4">1</span><span class="s1">)) {</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;&lt;textarea&gt; can only have at most one child.&quot; </span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">children = children[</span><span class="s4">0</span><span class="s1">];</span>
          <span class="s1">}</span>

          <span class="s1">defaultValue = children;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(defaultValue == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">defaultValue = </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">initialValue = defaultValue;</span>
    <span class="s1">}</span>

    <span class="s1">node._wrapperState = {</span>
      <span class="s1">initialValue: getToStringValue(initialValue)</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateWrapper$1(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element;</span>
    <span class="s3">var </span><span class="s1">value = getToStringValue(props.value);</span>
    <span class="s3">var </span><span class="s1">defaultValue = getToStringValue(props.defaultValue);</span>

    <span class="s3">if </span><span class="s1">(value != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Cast `value` to a string to ensure the value is set correctly. While</span>
      <span class="s0">// browsers typically do this as necessary, jsdom doesn't.</span>
      <span class="s3">var </span><span class="s1">newValue = toString(value); </span><span class="s0">// To avoid side effects (such as losing text selection), only set value if changed</span>

      <span class="s3">if </span><span class="s1">(newValue !== node.value) {</span>
        <span class="s1">node.value = newValue;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(props.defaultValue == </span><span class="s3">null </span><span class="s1">&amp;&amp; node.defaultValue !== newValue) {</span>
        <span class="s1">node.defaultValue = newValue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(defaultValue != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">node.defaultValue = toString(defaultValue);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">postMountWrapper$3(element, props) {</span>
    <span class="s3">var </span><span class="s1">node = element; </span><span class="s0">// This is in postMount because we need access to the DOM node, which is not</span>
    <span class="s0">// available until after the component has mounted.</span>

    <span class="s3">var </span><span class="s1">textContent = node.textContent; </span><span class="s0">// Only set node.value if textContent is equal to the expected</span>
    <span class="s0">// initial value. In IE10/IE11 there is a bug where the placeholder attribute</span>
    <span class="s0">// will populate textContent as well.</span>
    <span class="s0">// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/</span>

    <span class="s3">if </span><span class="s1">(textContent === node._wrapperState.initialValue) {</span>
      <span class="s3">if </span><span class="s1">(textContent !== </span><span class="s2">'' </span><span class="s1">&amp;&amp; textContent !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.value = textContent;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">restoreControlledState$2(element, props) {</span>
    <span class="s0">// DOM component is still mounted; update</span>
    <span class="s1">updateWrapper$1(element, props);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">HTML_NAMESPACE = </span><span class="s2">'http://www.w3.org/1999/xhtml'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">MATH_NAMESPACE = </span><span class="s2">'http://www.w3.org/1998/Math/MathML'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SVG_NAMESPACE = </span><span class="s2">'http://www.w3.org/2000/svg'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Namespaces = {</span>
    <span class="s1">html: HTML_NAMESPACE,</span>
    <span class="s1">mathml: MATH_NAMESPACE,</span>
    <span class="s1">svg: SVG_NAMESPACE</span>
  <span class="s1">}; </span><span class="s0">// Assumes there is no parent namespace.</span>

  <span class="s3">function </span><span class="s1">getIntrinsicNamespace(type) {</span>
    <span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s2">'svg'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">SVG_NAMESPACE;</span>

      <span class="s3">case </span><span class="s2">'math'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">MATH_NAMESPACE;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">HTML_NAMESPACE;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getChildNamespace(parentNamespace, type) {</span>
    <span class="s3">if </span><span class="s1">(parentNamespace == </span><span class="s3">null </span><span class="s1">|| parentNamespace === HTML_NAMESPACE) {</span>
      <span class="s0">// No (or default) parent namespace: potential entry point.</span>
      <span class="s3">return </span><span class="s1">getIntrinsicNamespace(type);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(parentNamespace === SVG_NAMESPACE &amp;&amp; type === </span><span class="s2">'foreignObject'</span><span class="s1">) {</span>
      <span class="s0">// We're leaving SVG.</span>
      <span class="s3">return </span><span class="s1">HTML_NAMESPACE;</span>
    <span class="s1">} </span><span class="s0">// By default, pass namespace below.</span>


    <span class="s3">return </span><span class="s1">parentNamespace;</span>
  <span class="s1">}</span>

  <span class="s0">/* globals MSApp */</span>

  <span class="s0">/** 
   * Create a function which has 'unsafe' privileges (required by windows8 apps) 
   */</span>
  <span class="s3">var </span><span class="s1">createMicrosoftUnsafeLocalFunction = </span><span class="s3">function </span><span class="s1">(func) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">MSApp !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; MSApp.execUnsafeLocalFunction) {</span>
      <span class="s3">return function </span><span class="s1">(arg0, arg1, arg2, arg3) {</span>
        <span class="s1">MSApp.execUnsafeLocalFunction(</span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">return </span><span class="s1">func(arg0, arg1, arg2, arg3);</span>
        <span class="s1">});</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">func;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">reusableSVGContainer;</span>
  <span class="s0">/** 
   * Set the innerHTML property of a node 
   * 
   * @param {DOMElement} node 
   * @param {string} html 
   * @internal 
   */</span>

  <span class="s3">var </span><span class="s1">setInnerHTML = createMicrosoftUnsafeLocalFunction(</span><span class="s3">function </span><span class="s1">(node, html) {</span>
    <span class="s3">if </span><span class="s1">(node.namespaceURI === Namespaces.svg) {</span>

      <span class="s3">if </span><span class="s1">(!(</span><span class="s2">'innerHTML' </span><span class="s3">in </span><span class="s1">node)) {</span>
        <span class="s0">// IE does not have innerHTML for SVG nodes, so instead we inject the</span>
        <span class="s0">// new markup in a temp node and then move the child nodes across into</span>
        <span class="s0">// the target node</span>
        <span class="s1">reusableSVGContainer = reusableSVGContainer || document.createElement(</span><span class="s2">'div'</span><span class="s1">);</span>
        <span class="s1">reusableSVGContainer.innerHTML = </span><span class="s2">'&lt;svg&gt;' </span><span class="s1">+ html.valueOf().toString() + </span><span class="s2">'&lt;/svg&gt;'</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">svgNode = reusableSVGContainer.firstChild;</span>

        <span class="s3">while </span><span class="s1">(node.firstChild) {</span>
          <span class="s1">node.removeChild(node.firstChild);</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(svgNode.firstChild) {</span>
          <span class="s1">node.appendChild(svgNode.firstChild);</span>
        <span class="s1">}</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">node.innerHTML = html;</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * HTML nodeType values that represent the type of the node 
   */</span>
  <span class="s3">var </span><span class="s1">ELEMENT_NODE = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TEXT_NODE = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">COMMENT_NODE = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DOCUMENT_NODE = </span><span class="s4">9</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DOCUMENT_FRAGMENT_NODE = </span><span class="s4">11</span><span class="s1">;</span>

  <span class="s0">/** 
   * Set the textContent property of a node. For text updates, it's faster 
   * to set the `nodeValue` of the Text node directly instead of using 
   * `.textContent` which will remove the existing node and create a new one. 
   * 
   * @param {DOMElement} node 
   * @param {string} text 
   * @internal 
   */</span>

  <span class="s3">var </span><span class="s1">setTextContent = </span><span class="s3">function </span><span class="s1">(node, text) {</span>
    <span class="s3">if </span><span class="s1">(text) {</span>
      <span class="s3">var </span><span class="s1">firstChild = node.firstChild;</span>

      <span class="s3">if </span><span class="s1">(firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType === TEXT_NODE) {</span>
        <span class="s1">firstChild.nodeValue = text;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">node.textContent = text;</span>
  <span class="s1">};</span>

  <span class="s0">// Do not use the below two methods directly!</span>
  <span class="s0">// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.</span>
  <span class="s0">// (It is the only module that is allowed to access these methods.)</span>
  <span class="s3">function </span><span class="s1">unsafeCastStringToDOMTopLevelType(topLevelType) {</span>
    <span class="s3">return </span><span class="s1">topLevelType;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unsafeCastDOMTopLevelTypeToString(topLevelType) {</span>
    <span class="s3">return </span><span class="s1">topLevelType;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Generate a mapping of standard vendor prefixes using the defined style property and event name. 
   * 
   * @param {string} styleProp 
   * @param {string} eventName 
   * @returns {object} 
   */</span>

  <span class="s3">function </span><span class="s1">makePrefixMap(styleProp, eventName) {</span>
    <span class="s3">var </span><span class="s1">prefixes = {};</span>
    <span class="s1">prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();</span>
    <span class="s1">prefixes[</span><span class="s2">'Webkit' </span><span class="s1">+ styleProp] = </span><span class="s2">'webkit' </span><span class="s1">+ eventName;</span>
    <span class="s1">prefixes[</span><span class="s2">'Moz' </span><span class="s1">+ styleProp] = </span><span class="s2">'moz' </span><span class="s1">+ eventName;</span>
    <span class="s3">return </span><span class="s1">prefixes;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * A list of event names to a configurable list of vendor prefixes. 
   */</span>


  <span class="s3">var </span><span class="s1">vendorPrefixes = {</span>
    <span class="s1">animationend: makePrefixMap(</span><span class="s2">'Animation'</span><span class="s1">, </span><span class="s2">'AnimationEnd'</span><span class="s1">),</span>
    <span class="s1">animationiteration: makePrefixMap(</span><span class="s2">'Animation'</span><span class="s1">, </span><span class="s2">'AnimationIteration'</span><span class="s1">),</span>
    <span class="s1">animationstart: makePrefixMap(</span><span class="s2">'Animation'</span><span class="s1">, </span><span class="s2">'AnimationStart'</span><span class="s1">),</span>
    <span class="s1">transitionend: makePrefixMap(</span><span class="s2">'Transition'</span><span class="s1">, </span><span class="s2">'TransitionEnd'</span><span class="s1">)</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Event names that have already been detected and prefixed (if applicable). 
   */</span>

  <span class="s3">var </span><span class="s1">prefixedEventNames = {};</span>
  <span class="s0">/** 
   * Element to check for prefixes on. 
   */</span>

  <span class="s3">var </span><span class="s1">style = {};</span>
  <span class="s0">/** 
   * Bootstrap if a DOM exists. 
   */</span>

  <span class="s3">if </span><span class="s1">(canUseDOM) {</span>
    <span class="s1">style = document.createElement(</span><span class="s2">'div'</span><span class="s1">).style; </span><span class="s0">// On some platforms, in particular some releases of Android 4.x,</span>
    <span class="s0">// the un-prefixed &quot;animation&quot; and &quot;transition&quot; properties are defined on the</span>
    <span class="s0">// style object but the events that fire will still be prefixed, so we need</span>
    <span class="s0">// to check if the un-prefixed events are usable, and if not remove them from the map.</span>

    <span class="s3">if </span><span class="s1">(!(</span><span class="s2">'AnimationEvent' </span><span class="s3">in </span><span class="s1">window)) {</span>
      <span class="s3">delete </span><span class="s1">vendorPrefixes.animationend.animation;</span>
      <span class="s3">delete </span><span class="s1">vendorPrefixes.animationiteration.animation;</span>
      <span class="s3">delete </span><span class="s1">vendorPrefixes.animationstart.animation;</span>
    <span class="s1">} </span><span class="s0">// Same as above</span>


    <span class="s3">if </span><span class="s1">(!(</span><span class="s2">'TransitionEvent' </span><span class="s3">in </span><span class="s1">window)) {</span>
      <span class="s3">delete </span><span class="s1">vendorPrefixes.transitionend.transition;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Attempts to determine the correct vendor prefixed event name. 
   * 
   * @param {string} eventName 
   * @returns {string} 
   */</span>


  <span class="s3">function </span><span class="s1">getVendorPrefixedEventName(eventName) {</span>
    <span class="s3">if </span><span class="s1">(prefixedEventNames[eventName]) {</span>
      <span class="s3">return </span><span class="s1">prefixedEventNames[eventName];</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!vendorPrefixes[eventName]) {</span>
      <span class="s3">return </span><span class="s1">eventName;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">prefixMap = vendorPrefixes[eventName];</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">styleProp </span><span class="s3">in </span><span class="s1">prefixMap) {</span>
      <span class="s3">if </span><span class="s1">(prefixMap.hasOwnProperty(styleProp) &amp;&amp; styleProp </span><span class="s3">in </span><span class="s1">style) {</span>
        <span class="s3">return </span><span class="s1">prefixedEventNames[eventName] = prefixMap[styleProp];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">eventName;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * To identify top level events in ReactDOM, we use constants defined by this 
   * module. This is the only module that uses the unsafe* methods to express 
   * that the constants actually correspond to the browser event names. This lets 
   * us save some bundle size by avoiding a top level type -&gt; event name map. 
   * The rest of ReactDOM code should import top level types from this file. 
   */</span>

  <span class="s3">var </span><span class="s1">TOP_ABORT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'abort'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(</span><span class="s2">'animationend'</span><span class="s1">));</span>
  <span class="s3">var </span><span class="s1">TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(</span><span class="s2">'animationiteration'</span><span class="s1">));</span>
  <span class="s3">var </span><span class="s1">TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(</span><span class="s2">'animationstart'</span><span class="s1">));</span>
  <span class="s3">var </span><span class="s1">TOP_BLUR = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'blur'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'canplay'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'canplaythrough'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CANCEL = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'cancel'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CHANGE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'change'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CLICK = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'click'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CLOSE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'close'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'compositionend'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'compositionstart'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'compositionupdate'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'contextmenu'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_COPY = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'copy'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_CUT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'cut'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dblclick'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'auxclick'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'drag'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_END = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragend'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragenter'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragexit'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragleave'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragover'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DRAG_START = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'dragstart'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DROP = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'drop'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'durationchange'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_EMPTIED = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'emptied'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'encrypted'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_ENDED = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'ended'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_ERROR = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'error'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_FOCUS = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'focus'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'gotpointercapture'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_INPUT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'input'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_INVALID = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'invalid'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'keydown'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'keypress'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_KEY_UP = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'keyup'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_LOAD = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'load'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_LOAD_START = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'loadstart'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'loadeddata'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'loadedmetadata'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'lostpointercapture'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'mousedown'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'mousemove'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'mouseout'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'mouseover'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'mouseup'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_PASTE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'paste'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_PAUSE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pause'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_PLAY = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'play'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_PLAYING = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'playing'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointercancel'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointerdown'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointermove'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointerout'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointerover'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'pointerup'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_PROGRESS = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'progress'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'ratechange'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_RESET = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'reset'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SCROLL = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'scroll'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SEEKED = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'seeked'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SEEKING = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'seeking'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'selectionchange'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_STALLED = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'stalled'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SUBMIT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'submit'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_SUSPEND = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'suspend'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'textInput'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'timeupdate'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TOGGLE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'toggle'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'touchcancel'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'touchend'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'touchmove'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'touchstart'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(</span><span class="s2">'transitionend'</span><span class="s1">));</span>
  <span class="s3">var </span><span class="s1">TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'volumechange'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_WAITING = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'waiting'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">TOP_WHEEL = unsafeCastStringToDOMTopLevelType(</span><span class="s2">'wheel'</span><span class="s1">); </span><span class="s0">// List of events that need to be individually attached to media elements.</span>
  <span class="s0">// Note that events in this list will *not* be listened to at the top level</span>
  <span class="s0">// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.</span>

  <span class="s3">var </span><span class="s1">mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];</span>
  <span class="s3">function </span><span class="s1">getRawEventName(topLevelType) {</span>
    <span class="s3">return </span><span class="s1">unsafeCastDOMTopLevelTypeToString(topLevelType);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">PossiblyWeakMap = </span><span class="s3">typeof </span><span class="s1">WeakMap === </span><span class="s2">'function' </span><span class="s1">? WeakMap : Map; </span><span class="s0">// prettier-ignore</span>

  <span class="s3">var </span><span class="s1">elementListenerMap = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap();</span>
  <span class="s3">function </span><span class="s1">getListenerMapForElement(element) {</span>
    <span class="s3">var </span><span class="s1">listenerMap = elementListenerMap.get(element);</span>

    <span class="s3">if </span><span class="s1">(listenerMap === undefined) {</span>
      <span class="s1">listenerMap = </span><span class="s3">new </span><span class="s1">Map();</span>
      <span class="s1">elementListenerMap.set(element, listenerMap);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">listenerMap;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * `ReactInstanceMap` maintains a mapping from a public facing stateful 
   * instance (key) and the internal representation (value). This allows public 
   * methods to accept the user facing instance as an argument and map them back 
   * to internal methods. 
   * 
   * Note that this module is currently shared and assumed to be stateless. 
   * If this becomes an actual Map, that will break. 
   */</span>
  <span class="s3">function </span><span class="s1">get(key) {</span>
    <span class="s3">return </span><span class="s1">key._reactInternalFiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">has$1(key) {</span>
    <span class="s3">return </span><span class="s1">key._reactInternalFiber !== undefined;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">set(key, value) {</span>
    <span class="s1">key._reactInternalFiber = value;</span>
  <span class="s1">}</span>

  <span class="s0">// Don't change these two values. They're used by React Dev Tools.</span>
  <span class="s3">var </span><span class="s1">NoEffect =</span>
  <span class="s0">/*              */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">PerformedWork =</span>
  <span class="s0">/*         */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// You can change the rest (and add more).</span>

  <span class="s3">var </span><span class="s1">Placement =</span>
  <span class="s0">/*             */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Update =</span>
  <span class="s0">/*                */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">PlacementAndUpdate =</span>
  <span class="s0">/*    */</span>
  <span class="s4">6</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Deletion =</span>
  <span class="s0">/*              */</span>
  <span class="s4">8</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ContentReset =</span>
  <span class="s0">/*          */</span>
  <span class="s4">16</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Callback =</span>
  <span class="s0">/*              */</span>
  <span class="s4">32</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DidCapture =</span>
  <span class="s0">/*            */</span>
  <span class="s4">64</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Ref =</span>
  <span class="s0">/*                   */</span>
  <span class="s4">128</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Snapshot =</span>
  <span class="s0">/*              */</span>
  <span class="s4">256</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Passive =</span>
  <span class="s0">/*               */</span>
  <span class="s4">512</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Hydrating =</span>
  <span class="s0">/*             */</span>
  <span class="s4">1024</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HydratingAndUpdate =</span>
  <span class="s0">/*    */</span>
  <span class="s4">1028</span><span class="s1">; </span><span class="s0">// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span>

  <span class="s3">var </span><span class="s1">LifecycleEffectMask =</span>
  <span class="s0">/*   */</span>
  <span class="s4">932</span><span class="s1">; </span><span class="s0">// Union of all host effects</span>

  <span class="s3">var </span><span class="s1">HostEffectMask =</span>
  <span class="s0">/*        */</span>
  <span class="s4">2047</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Incomplete =</span>
  <span class="s0">/*            */</span>
  <span class="s4">2048</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ShouldCapture =</span>
  <span class="s0">/*         */</span>
  <span class="s4">4096</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;</span>
  <span class="s3">function </span><span class="s1">getNearestMountedFiber(fiber) {</span>
    <span class="s3">var </span><span class="s1">node = fiber;</span>
    <span class="s3">var </span><span class="s1">nearestMounted = fiber;</span>

    <span class="s3">if </span><span class="s1">(!fiber.alternate) {</span>
      <span class="s0">// If there is no alternate, this might be a new tree that isn't inserted</span>
      <span class="s0">// yet. If it is, then it will have a pending insertion effect on it.</span>
      <span class="s3">var </span><span class="s1">nextNode = node;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">node = nextNode;</span>

        <span class="s3">if </span><span class="s1">((node.effectTag &amp; (Placement | Hydrating)) !== NoEffect) {</span>
          <span class="s0">// This is an insertion or in-progress hydration. The nearest possible</span>
          <span class="s0">// mounted fiber is the parent but we need to continue to figure out</span>
          <span class="s0">// if that one is still mounted.</span>
          <span class="s1">nearestMounted = node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">nextNode = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(nextNode);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">while </span><span class="s1">(node.</span><span class="s3">return</span><span class="s1">) {</span>
        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(node.tag === HostRoot) {</span>
      <span class="s0">// TODO: Check if this was a nested HostRoot when used with</span>
      <span class="s0">// renderContainerIntoSubtree.</span>
      <span class="s3">return </span><span class="s1">nearestMounted;</span>
    <span class="s1">} </span><span class="s0">// If we didn't hit the root, that means that we're in an disconnected tree</span>
    <span class="s0">// that has been unmounted.</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getSuspenseInstanceFromFiber(fiber) {</span>
    <span class="s3">if </span><span class="s1">(fiber.tag === SuspenseComponent) {</span>
      <span class="s3">var </span><span class="s1">suspenseState = fiber.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(suspenseState === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">current = fiber.alternate;</span>

        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">suspenseState = current.memoizedState;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">suspenseState.dehydrated;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getContainerFromFiber(fiber) {</span>
    <span class="s3">return </span><span class="s1">fiber.tag === HostRoot ? fiber.stateNode.containerInfo : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isFiberMounted(fiber) {</span>
    <span class="s3">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isMounted(component) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">owner = ReactCurrentOwner.current;</span>

      <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; owner.tag === ClassComponent) {</span>
        <span class="s3">var </span><span class="s1">ownerFiber = owner;</span>
        <span class="s3">var </span><span class="s1">instance = ownerFiber.stateNode;</span>

        <span class="s3">if </span><span class="s1">(!instance._warnedAboutRefsInRender) {</span>
          <span class="s1">error(</span><span class="s2">'%s is accessing isMounted inside its render() function. ' </span><span class="s1">+ </span><span class="s2">'render() should be a pure function of props and state. It should ' </span><span class="s1">+ </span><span class="s2">'never access something that requires stale data from the previous ' </span><span class="s1">+ </span><span class="s2">'render, such as refs. Move this logic to componentDidMount and ' </span><span class="s1">+ </span><span class="s2">'componentDidUpdate instead.'</span><span class="s1">, getComponentName(ownerFiber.type) || </span><span class="s2">'A component'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">instance._warnedAboutRefsInRender = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = get(component);</span>

    <span class="s3">if </span><span class="s1">(!fiber) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">getNearestMountedFiber(fiber) === fiber;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">assertIsMounted(fiber) {</span>
    <span class="s3">if </span><span class="s1">(!(getNearestMountedFiber(fiber) === fiber)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unable to find node on an unmounted component.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findCurrentFiberUsingSlowPath(fiber) {</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(!alternate) {</span>
      <span class="s0">// If there is no alternate, then we only need to check if it is mounted.</span>
      <span class="s3">var </span><span class="s1">nearestMounted = getNearestMountedFiber(fiber);</span>

      <span class="s3">if </span><span class="s1">(!(nearestMounted !== </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unable to find node on an unmounted component.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(nearestMounted !== fiber) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">fiber;</span>
    <span class="s1">} </span><span class="s0">// If we have two possible branches, we'll walk backwards up to the root</span>
    <span class="s0">// to see what path the root points to. On the way we may hit one of the</span>
    <span class="s0">// special cases and we'll deal with them.</span>


    <span class="s3">var </span><span class="s1">a = fiber;</span>
    <span class="s3">var </span><span class="s1">b = alternate;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">parentA = a.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(parentA === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We're at the root.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">parentB = parentA.alternate;</span>

      <span class="s3">if </span><span class="s1">(parentB === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// There is no alternate. This is an unusual case. Currently, it only</span>
        <span class="s0">// happens when a Suspense component is hidden. An extra fragment fiber</span>
        <span class="s0">// is inserted in between the Suspense fiber and its children. Skip</span>
        <span class="s0">// over this extra fragment fiber and proceed to the next parent.</span>
        <span class="s3">var </span><span class="s1">nextParent = parentA.</span><span class="s3">return</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(nextParent !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">a = b = nextParent;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// If there's no parent, we're at the root.</span>


        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If both copies of the parent fiber point to the same child, we can</span>
      <span class="s0">// assume that the child is current. This happens when we bailout on low</span>
      <span class="s0">// priority: the bailed out fiber's child reuses the current child.</span>


      <span class="s3">if </span><span class="s1">(parentA.child === parentB.child) {</span>
        <span class="s3">var </span><span class="s1">child = parentA.child;</span>

        <span class="s3">while </span><span class="s1">(child) {</span>
          <span class="s3">if </span><span class="s1">(child === a) {</span>
            <span class="s0">// We've determined that A is the current branch.</span>
            <span class="s1">assertIsMounted(parentA);</span>
            <span class="s3">return </span><span class="s1">fiber;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(child === b) {</span>
            <span class="s0">// We've determined that B is the current branch.</span>
            <span class="s1">assertIsMounted(parentA);</span>
            <span class="s3">return </span><span class="s1">alternate;</span>
          <span class="s1">}</span>

          <span class="s1">child = child.sibling;</span>
        <span class="s1">} </span><span class="s0">// We should never have an alternate for any mounting node. So the only</span>
        <span class="s0">// way this could possibly happen is if this was unmounted, if at all.</span>


        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unable to find node on an unmounted component.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(a.</span><span class="s3">return </span><span class="s1">!== b.</span><span class="s3">return</span><span class="s1">) {</span>
        <span class="s0">// The return pointer of A and the return pointer of B point to different</span>
        <span class="s0">// fibers. We assume that return pointers never criss-cross, so A must</span>
        <span class="s0">// belong to the child set of A.return, and B must belong to the child</span>
        <span class="s0">// set of B.return.</span>
        <span class="s1">a = parentA;</span>
        <span class="s1">b = parentB;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// The return pointers point to the same fiber. We'll have to use the</span>
        <span class="s0">// default, slow path: scan the child sets of each parent alternate to see</span>
        <span class="s0">// which child belongs to which set.</span>
        <span class="s0">//</span>
        <span class="s0">// Search parent A's child set</span>
        <span class="s3">var </span><span class="s1">didFindChild = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">_child = parentA.child;</span>

        <span class="s3">while </span><span class="s1">(_child) {</span>
          <span class="s3">if </span><span class="s1">(_child === a) {</span>
            <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">a = parentA;</span>
            <span class="s1">b = parentB;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(_child === b) {</span>
            <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">b = parentA;</span>
            <span class="s1">a = parentB;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">_child = _child.sibling;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!didFindChild) {</span>
          <span class="s0">// Search parent B's child set</span>
          <span class="s1">_child = parentB.child;</span>

          <span class="s3">while </span><span class="s1">(_child) {</span>
            <span class="s3">if </span><span class="s1">(_child === a) {</span>
              <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">a = parentB;</span>
              <span class="s1">b = parentA;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(_child === b) {</span>
              <span class="s1">didFindChild = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">b = parentB;</span>
              <span class="s1">a = parentA;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">_child = _child.sibling;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(!didFindChild) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!(a.alternate === b)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// If the root is not a host container, we're in a disconnected tree. I.e.</span>
    <span class="s0">// unmounted.</span>


    <span class="s3">if </span><span class="s1">(!(a.tag === HostRoot)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unable to find node on an unmounted component.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(a.stateNode.current === a) {</span>
      <span class="s0">// We've determined that A is the current branch.</span>
      <span class="s3">return </span><span class="s1">fiber;</span>
    <span class="s1">} </span><span class="s0">// Otherwise B has to be current branch.</span>


    <span class="s3">return </span><span class="s1">alternate;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">findCurrentHostFiber(parent) {</span>
    <span class="s3">var </span><span class="s1">currentParent = findCurrentFiberUsingSlowPath(parent);</span>

    <span class="s3">if </span><span class="s1">(!currentParent) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Next we'll drill down this component to find the first HostComponent/Text.</span>


    <span class="s3">var </span><span class="s1">node = currentParent;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
        <span class="s3">return </span><span class="s1">node;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === currentParent) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(!node.sibling) {</span>
        <span class="s3">if </span><span class="s1">(!node.</span><span class="s3">return </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== currentParent) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">} </span><span class="s0">// Flow needs the return null here, but ESLint complains about it.</span>
    <span class="s0">// eslint-disable-next-line no-unreachable</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">findCurrentHostFiberWithNoPortals(parent) {</span>
    <span class="s3">var </span><span class="s1">currentParent = findCurrentFiberUsingSlowPath(parent);</span>

    <span class="s3">if </span><span class="s1">(!currentParent) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Next we'll drill down this component to find the first HostComponent/Text.</span>


    <span class="s3">var </span><span class="s1">node = currentParent;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI ) {</span>
        <span class="s3">return </span><span class="s1">node;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child &amp;&amp; node.tag !== HostPortal) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === currentParent) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(!node.sibling) {</span>
        <span class="s3">if </span><span class="s1">(!node.</span><span class="s3">return </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== currentParent) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">} </span><span class="s0">// Flow needs the return null here, but ESLint complains about it.</span>
    <span class="s0">// eslint-disable-next-line no-unreachable</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Accumulates items that must not be null or undefined into the first one. This 
   * is used to conserve memory by avoiding array allocations, and thus sacrifices 
   * API cleanness. Since `current` can be null before being passed in and not 
   * null after this function, make sure to assign it back to `current`: 
   * 
   * `a = accumulateInto(a, b);` 
   * 
   * This API should be sparingly used. Try `accumulate` for something cleaner. 
   * 
   * @return {*|array&lt;*&gt;} An accumulation of items. 
   */</span>

  <span class="s3">function </span><span class="s1">accumulateInto(current, next) {</span>
    <span class="s3">if </span><span class="s1">(!(next != </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;accumulateInto(...): Accumulated items must not be null or undefined.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">next;</span>
    <span class="s1">} </span><span class="s0">// Both are not empty. Warning: Never call x.concat(y) when you are not</span>
    <span class="s0">// certain that x is an Array (x could be a string with concat method).</span>


    <span class="s3">if </span><span class="s1">(Array.isArray(current)) {</span>
      <span class="s3">if </span><span class="s1">(Array.isArray(next)) {</span>
        <span class="s1">current.push.apply(current, next);</span>
        <span class="s3">return </span><span class="s1">current;</span>
      <span class="s1">}</span>

      <span class="s1">current.push(next);</span>
      <span class="s3">return </span><span class="s1">current;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(Array.isArray(next)) {</span>
      <span class="s0">// A bit too dangerous to mutate `next`.</span>
      <span class="s3">return </span><span class="s1">[current].concat(next);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">[current, next];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @param {array} arr an &quot;accumulation&quot; of items which is either an Array or 
   * a single item. Useful when paired with the `accumulate` module. This is a 
   * simple utility that allows us to reason about a collection of items, but 
   * handling the case when there is exactly one item (and we do not need to 
   * allocate an array). 
   * @param {function} cb Callback invoked with each element or a collection. 
   * @param {?} [scope] Scope used as `this` in a callback. 
   */</span>
  <span class="s3">function </span><span class="s1">forEachAccumulated(arr, cb, scope) {</span>
    <span class="s3">if </span><span class="s1">(Array.isArray(arr)) {</span>
      <span class="s1">arr.forEach(cb, scope);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(arr) {</span>
      <span class="s1">cb.call(scope, arr);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Internal queue of events that have accumulated their dispatches and are 
   * waiting to have their dispatches executed. 
   */</span>

  <span class="s3">var </span><span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s0">/** 
   * Dispatches an event and releases it back into the pool, unless persistent. 
   * 
   * @param {?object} event Synthetic event to be dispatched. 
   * @private 
   */</span>

  <span class="s3">var </span><span class="s1">executeDispatchesAndRelease = </span><span class="s3">function </span><span class="s1">(event) {</span>
    <span class="s3">if </span><span class="s1">(event) {</span>
      <span class="s1">executeDispatchesInOrder(event);</span>

      <span class="s3">if </span><span class="s1">(!event.isPersistent()) {</span>
        <span class="s1">event.constructor.release(event);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">executeDispatchesAndReleaseTopLevel = </span><span class="s3">function </span><span class="s1">(e) {</span>
    <span class="s3">return </span><span class="s1">executeDispatchesAndRelease(e);</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">runEventsInBatch(events) {</span>
    <span class="s3">if </span><span class="s1">(events !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">eventQueue = accumulateInto(eventQueue, events);</span>
    <span class="s1">} </span><span class="s0">// Set `eventQueue` to null before processing it so that we can tell if more</span>
    <span class="s0">// events get enqueued while processing.</span>


    <span class="s3">var </span><span class="s1">processingEventQueue = eventQueue;</span>
    <span class="s1">eventQueue = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!processingEventQueue) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);</span>

    <span class="s3">if </span><span class="s1">(!!eventQueue) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// This would be a good time to rethrow if any of the event handlers threw.</span>


    <span class="s1">rethrowCaughtError();</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Gets the target node from a native browser event by accounting for 
   * inconsistencies in browser DOM APIs. 
   * 
   * @param {object} nativeEvent Native browser event. 
   * @return {DOMEventTarget} Target node. 
   */</span>

  <span class="s3">function </span><span class="s1">getEventTarget(nativeEvent) {</span>
    <span class="s0">// Fallback to nativeEvent.srcElement for IE9</span>
    <span class="s0">// https://github.com/facebook/react/issues/12506</span>
    <span class="s3">var </span><span class="s1">target = nativeEvent.target || nativeEvent.srcElement || window; </span><span class="s0">// Normalize SVG &lt;use&gt; element events #4963</span>

    <span class="s3">if </span><span class="s1">(target.correspondingUseElement) {</span>
      <span class="s1">target = target.correspondingUseElement;</span>
    <span class="s1">} </span><span class="s0">// Safari may fire events on text nodes (Node.TEXT_NODE is 3).</span>
    <span class="s0">// @see http://www.quirksmode.org/js/events_properties.html</span>


    <span class="s3">return </span><span class="s1">target.nodeType === TEXT_NODE ? target.parentNode : target;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Checks if an event is supported in the current execution environment. 
   * 
   * NOTE: This will not work correctly for non-generic events such as `change`, 
   * `reset`, `load`, `error`, and `select`. 
   * 
   * Borrows from Modernizr. 
   * 
   * @param {string} eventNameSuffix Event name, e.g. &quot;click&quot;. 
   * @return {boolean} True if the event is supported. 
   * @internal 
   * @license Modernizr 3.0.0pre (Custom Build) | MIT 
   */</span>

  <span class="s3">function </span><span class="s1">isEventSupported(eventNameSuffix) {</span>
    <span class="s3">if </span><span class="s1">(!canUseDOM) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">eventName = </span><span class="s2">'on' </span><span class="s1">+ eventNameSuffix;</span>
    <span class="s3">var </span><span class="s1">isSupported = eventName </span><span class="s3">in </span><span class="s1">document;</span>

    <span class="s3">if </span><span class="s1">(!isSupported) {</span>
      <span class="s3">var </span><span class="s1">element = document.createElement(</span><span class="s2">'div'</span><span class="s1">);</span>
      <span class="s1">element.setAttribute(eventName, </span><span class="s2">'return;'</span><span class="s1">);</span>
      <span class="s1">isSupported = </span><span class="s3">typeof </span><span class="s1">element[eventName] === </span><span class="s2">'function'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">isSupported;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Summary of `DOMEventPluginSystem` event handling: 
   * 
   *  - Top-level delegation is used to trap most native browser events. This 
   *    may only occur in the main thread and is the responsibility of 
   *    ReactDOMEventListener, which is injected and can therefore support 
   *    pluggable event sources. This is the only work that occurs in the main 
   *    thread. 
   * 
   *  - We normalize and de-duplicate events to account for browser quirks. This 
   *    may be done in the worker thread. 
   * 
   *  - Forward these native events (with the associated top-level type used to 
   *    trap it) to `EventPluginRegistry`, which in turn will ask plugins if they want 
   *    to extract any synthetic events. 
   * 
   *  - The `EventPluginRegistry` will then process each event by annotating them with 
   *    &quot;dispatches&quot;, a sequence of listeners and IDs that care about that event. 
   * 
   *  - The `EventPluginRegistry` then dispatches the events. 
   * 
   * Overview of React and the event system: 
   * 
   * +------------+    . 
   * |    DOM     |    . 
   * +------------+    . 
   *       |           . 
   *       v           . 
   * +------------+    . 
   * | ReactEvent |    . 
   * |  Listener  |    . 
   * +------------+    .                         +-----------+ 
   *       |           .               +--------+|SimpleEvent| 
   *       |           .               |         |Plugin     | 
   * +-----|------+    .               v         +-----------+ 
   * |     |      |    .    +--------------+                    +------------+ 
   * |     +-----------.---&gt;|PluginRegistry|                    |    Event   | 
   * |            |    .    |              |     +-----------+  | Propagators| 
   * | ReactEvent |    .    |              |     |TapEvent   |  |------------| 
   * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin| 
   * |            |    .    |              |     +-----------+  |  utilities | 
   * |     +-----------.---&gt;|              |                    +------------+ 
   * |     |      |    .    +--------------+ 
   * +-----|------+    .                ^        +-----------+ 
   *       |           .                |        |Enter/Leave| 
   *       +           .                +-------+|Plugin     | 
   * +-------------+   .                         +-----------+ 
   * | application |   . 
   * |-------------|   . 
   * |             |   . 
   * |             |   . 
   * +-------------+   . 
   *                   . 
   *    React Core     .  General Purpose Event Plugin System 
   */</span>

  <span class="s3">var </span><span class="s1">CALLBACK_BOOKKEEPING_POOL_SIZE = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">callbackBookkeepingPool = [];</span>

  <span class="s3">function </span><span class="s1">releaseTopLevelCallbackBookKeeping(instance) {</span>
    <span class="s1">instance.topLevelType = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">instance.nativeEvent = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">instance.targetInst = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">instance.ancestors.length = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(callbackBookkeepingPool.length &lt; CALLBACK_BOOKKEEPING_POOL_SIZE) {</span>
      <span class="s1">callbackBookkeepingPool.push(instance);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Used to store ancestor hierarchy in top level callback</span>


  <span class="s3">function </span><span class="s1">getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags) {</span>
    <span class="s3">if </span><span class="s1">(callbackBookkeepingPool.length) {</span>
      <span class="s3">var </span><span class="s1">instance = callbackBookkeepingPool.pop();</span>
      <span class="s1">instance.topLevelType = topLevelType;</span>
      <span class="s1">instance.eventSystemFlags = eventSystemFlags;</span>
      <span class="s1">instance.nativeEvent = nativeEvent;</span>
      <span class="s1">instance.targetInst = targetInst;</span>
      <span class="s3">return </span><span class="s1">instance;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">topLevelType: topLevelType,</span>
      <span class="s1">eventSystemFlags: eventSystemFlags,</span>
      <span class="s1">nativeEvent: nativeEvent,</span>
      <span class="s1">targetInst: targetInst,</span>
      <span class="s1">ancestors: []</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Find the deepest React component completely containing the root of the 
   * passed-in instance (for use when entire React trees are nested within each 
   * other). If React trees are not nested, returns null. 
   */</span>


  <span class="s3">function </span><span class="s1">findRootContainerNode(inst) {</span>
    <span class="s3">if </span><span class="s1">(inst.tag === HostRoot) {</span>
      <span class="s3">return </span><span class="s1">inst.stateNode.containerInfo;</span>
    <span class="s1">} </span><span class="s0">// TODO: It may be a good idea to cache this to prevent unnecessary DOM</span>
    <span class="s0">// traversal, but caching is difficult to do correctly without using a</span>
    <span class="s0">// mutation observer to listen for all DOM changes.</span>


    <span class="s3">while </span><span class="s1">(inst.</span><span class="s3">return</span><span class="s1">) {</span>
      <span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(inst.tag !== HostRoot) {</span>
      <span class="s0">// This can happen if we're in a detached tree.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">inst.stateNode.containerInfo;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Allows registered plugins an opportunity to extract events from top-level 
   * native browser events. 
   * 
   * @return {*} An accumulation of synthetic events. 
   * @internal 
   */</span>


  <span class="s3">function </span><span class="s1">extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
    <span class="s3">var </span><span class="s1">events = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; plugins.length; i++) {</span>
      <span class="s0">// Not every plugin in the ordering may be loaded at runtime.</span>
      <span class="s3">var </span><span class="s1">possiblePlugin = plugins[i];</span>

      <span class="s3">if </span><span class="s1">(possiblePlugin) {</span>
        <span class="s3">var </span><span class="s1">extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span>

        <span class="s3">if </span><span class="s1">(extractedEvents) {</span>
          <span class="s1">events = accumulateInto(events, extractedEvents);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">events;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
    <span class="s3">var </span><span class="s1">events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span>
    <span class="s1">runEventsInBatch(events);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">handleTopLevel(bookKeeping) {</span>
    <span class="s3">var </span><span class="s1">targetInst = bookKeeping.targetInst; </span><span class="s0">// Loop through the hierarchy, in case there's any nested components.</span>
    <span class="s0">// It's important that we build the array of ancestors before calling any</span>
    <span class="s0">// event handlers, because event handlers can modify the DOM, leading to</span>
    <span class="s0">// inconsistencies with ReactMount's node cache. See #1105.</span>

    <span class="s3">var </span><span class="s1">ancestor = targetInst;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!ancestor) {</span>
        <span class="s3">var </span><span class="s1">ancestors = bookKeeping.ancestors;</span>
        <span class="s1">ancestors.push(ancestor);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">root = findRootContainerNode(ancestor);</span>

      <span class="s3">if </span><span class="s1">(!root) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">tag = ancestor.tag;</span>

      <span class="s3">if </span><span class="s1">(tag === HostComponent || tag === HostText) {</span>
        <span class="s1">bookKeeping.ancestors.push(ancestor);</span>
      <span class="s1">}</span>

      <span class="s1">ancestor = getClosestInstanceFromNode(root);</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(ancestor);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; bookKeeping.ancestors.length; i++) {</span>
      <span class="s1">targetInst = bookKeeping.ancestors[i];</span>
      <span class="s3">var </span><span class="s1">eventTarget = getEventTarget(bookKeeping.nativeEvent);</span>
      <span class="s3">var </span><span class="s1">topLevelType = bookKeeping.topLevelType;</span>
      <span class="s3">var </span><span class="s1">nativeEvent = bookKeeping.nativeEvent;</span>
      <span class="s3">var </span><span class="s1">eventSystemFlags = bookKeeping.eventSystemFlags; </span><span class="s0">// If this is the first ancestor, we mark it on the system flags</span>

      <span class="s3">if </span><span class="s1">(i === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">eventSystemFlags |= IS_FIRST_ANCESTOR;</span>
      <span class="s1">}</span>

      <span class="s1">runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {</span>
    <span class="s3">var </span><span class="s1">bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// Event queue being processed in the same cycle allows</span>
      <span class="s0">// `preventDefault`.</span>
      <span class="s1">batchedEventUpdates(handleTopLevel, bookKeeping);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">releaseTopLevelCallbackBookKeeping(bookKeeping);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * We listen for bubbled touch events on the document object. 
   * 
   * Firefox v8.01 (and possibly others) exhibited strange behavior when 
   * mounting `onmousemove` events at some node that was not the document 
   * element. The symptoms were that if your mouse is not moving over something 
   * contained within that mount point (for example on the background) the 
   * top-level listeners for `onmousemove` won't be called. However, if you 
   * register the `mousemove` on the document object, then it will of course 
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting 
   * top-level listeners to the document object only, at least for these 
   * movement types of events and possibly all events. 
   * 
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html 
   * 
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but 
   * they bubble to document. 
   * 
   * @param {string} registrationName Name of listener (e.g. `onClick`). 
   * @param {object} mountAt Container where to mount the listener 
   */</span>

  <span class="s3">function </span><span class="s1">legacyListenToEvent(registrationName, mountAt) {</span>
    <span class="s3">var </span><span class="s1">listenerMap = getListenerMapForElement(mountAt);</span>
    <span class="s3">var </span><span class="s1">dependencies = registrationNameDependencies[registrationName];</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dependencies.length; i++) {</span>
      <span class="s3">var </span><span class="s1">dependency = dependencies[i];</span>
      <span class="s1">legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">legacyListenToTopLevelEvent(topLevelType, mountAt, listenerMap) {</span>
    <span class="s3">if </span><span class="s1">(!listenerMap.has(topLevelType)) {</span>
      <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
        <span class="s3">case </span><span class="s1">TOP_SCROLL:</span>
          <span class="s1">trapCapturedEvent(TOP_SCROLL, mountAt);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_FOCUS:</span>
        <span class="s3">case </span><span class="s1">TOP_BLUR:</span>
          <span class="s1">trapCapturedEvent(TOP_FOCUS, mountAt);</span>
          <span class="s1">trapCapturedEvent(TOP_BLUR, mountAt); </span><span class="s0">// We set the flag for a single dependency later in this function,</span>
          <span class="s0">// but this ensures we mark both as attached rather than just one.</span>

          <span class="s1">listenerMap.set(TOP_BLUR, </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">listenerMap.set(TOP_FOCUS, </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_CANCEL:</span>
        <span class="s3">case </span><span class="s1">TOP_CLOSE:</span>
          <span class="s3">if </span><span class="s1">(isEventSupported(getRawEventName(topLevelType))) {</span>
            <span class="s1">trapCapturedEvent(topLevelType, mountAt);</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_INVALID:</span>
        <span class="s3">case </span><span class="s1">TOP_SUBMIT:</span>
        <span class="s3">case </span><span class="s1">TOP_RESET:</span>
          <span class="s0">// We listen to them on the target DOM elements.</span>
          <span class="s0">// Some of them bubble so we don't want them to fire twice.</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s0">// By default, listen on the top level to all non-media events.</span>
          <span class="s0">// Media events don't bubble so adding the listener wouldn't do anything.</span>
          <span class="s3">var </span><span class="s1">isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -</span><span class="s4">1</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(!isMediaEvent) {</span>
            <span class="s1">trapBubbledEvent(topLevelType, mountAt);</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">listenerMap.set(topLevelType, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isListeningToAllDependencies(registrationName, mountAt) {</span>
    <span class="s3">var </span><span class="s1">listenerMap = getListenerMapForElement(mountAt);</span>
    <span class="s3">var </span><span class="s1">dependencies = registrationNameDependencies[registrationName];</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; dependencies.length; i++) {</span>
      <span class="s3">var </span><span class="s1">dependency = dependencies[i];</span>

      <span class="s3">if </span><span class="s1">(!listenerMap.has(dependency)) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">attemptUserBlockingHydration;</span>
  <span class="s3">function </span><span class="s1">setAttemptUserBlockingHydration(fn) {</span>
    <span class="s1">attemptUserBlockingHydration = fn;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">attemptContinuousHydration;</span>
  <span class="s3">function </span><span class="s1">setAttemptContinuousHydration(fn) {</span>
    <span class="s1">attemptContinuousHydration = fn;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">attemptHydrationAtCurrentPriority;</span>
  <span class="s3">function </span><span class="s1">setAttemptHydrationAtCurrentPriority(fn) {</span>
    <span class="s1">attemptHydrationAtCurrentPriority = fn;</span>
  <span class="s1">} </span><span class="s0">// TODO: Upgrade this definition once we're on a newer version of Flow that</span>
  <span class="s3">var </span><span class="s1">hasScheduledReplayAttempt = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// The queue of discrete events to be replayed.</span>

  <span class="s3">var </span><span class="s1">queuedDiscreteEvents = []; </span><span class="s0">// Indicates if any continuous event targets are non-null for early bailout.</span>
  <span class="s0">// if the last target was dehydrated.</span>

  <span class="s3">var </span><span class="s1">queuedFocus = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">queuedDrag = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">queuedMouse = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// For pointer events there can be one latest event per pointerId.</span>

  <span class="s3">var </span><span class="s1">queuedPointers = </span><span class="s3">new </span><span class="s1">Map();</span>
  <span class="s3">var </span><span class="s1">queuedPointerCaptures = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// We could consider replaying selectionchange and touchmoves too.</span>

  <span class="s3">var </span><span class="s1">queuedExplicitHydrationTargets = [];</span>
  <span class="s3">function </span><span class="s1">hasQueuedDiscreteEvents() {</span>
    <span class="s3">return </span><span class="s1">queuedDiscreteEvents.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">discreteReplayableEvents = [TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT];</span>
  <span class="s3">var </span><span class="s1">continuousReplayableEvents = [TOP_FOCUS, TOP_BLUR, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE];</span>
  <span class="s3">function </span><span class="s1">isReplayableDiscreteEvent(eventType) {</span>
    <span class="s3">return </span><span class="s1">discreteReplayableEvents.indexOf(eventType) &gt; -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">trapReplayableEventForDocument(topLevelType, document, listenerMap) {</span>
    <span class="s1">legacyListenToTopLevelEvent(topLevelType, document, listenerMap);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">eagerlyTrapReplayableEvents(container, document) {</span>
    <span class="s3">var </span><span class="s1">listenerMapForDoc = getListenerMapForElement(document); </span><span class="s0">// Discrete</span>

    <span class="s1">discreteReplayableEvents.forEach(</span><span class="s3">function </span><span class="s1">(topLevelType) {</span>
      <span class="s1">trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);</span>
    <span class="s1">}); </span><span class="s0">// Continuous</span>

    <span class="s1">continuousReplayableEvents.forEach(</span><span class="s3">function </span><span class="s1">(topLevelType) {</span>
      <span class="s1">trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">blockedOn: blockedOn,</span>
      <span class="s1">topLevelType: topLevelType,</span>
      <span class="s1">eventSystemFlags: eventSystemFlags | IS_REPLAYED,</span>
      <span class="s1">nativeEvent: nativeEvent,</span>
      <span class="s1">container: container</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s3">var </span><span class="s1">queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);</span>
    <span class="s1">queuedDiscreteEvents.push(queuedEvent);</span>
  <span class="s1">} </span><span class="s0">// Resets the replaying for this type of continuous event to no event.</span>

  <span class="s3">function </span><span class="s1">clearIfContinuousEvent(topLevelType, nativeEvent) {</span>
    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_FOCUS:</span>
      <span class="s3">case </span><span class="s1">TOP_BLUR:</span>
        <span class="s1">queuedFocus = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_DRAG_ENTER:</span>
      <span class="s3">case </span><span class="s1">TOP_DRAG_LEAVE:</span>
        <span class="s1">queuedDrag = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_MOUSE_OVER:</span>
      <span class="s3">case </span><span class="s1">TOP_MOUSE_OUT:</span>
        <span class="s1">queuedMouse = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_POINTER_OVER:</span>
      <span class="s3">case </span><span class="s1">TOP_POINTER_OUT:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">pointerId = nativeEvent.pointerId;</span>
          <span class="s1">queuedPointers.</span><span class="s3">delete</span><span class="s1">(pointerId);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">TOP_GOT_POINTER_CAPTURE:</span>
      <span class="s3">case </span><span class="s1">TOP_LOST_POINTER_CAPTURE:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_pointerId = nativeEvent.pointerId;</span>
          <span class="s1">queuedPointerCaptures.</span><span class="s3">delete</span><span class="s1">(_pointerId);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s3">if </span><span class="s1">(existingQueuedEvent === </span><span class="s3">null </span><span class="s1">|| existingQueuedEvent.nativeEvent !== nativeEvent) {</span>
      <span class="s3">var </span><span class="s1">queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);</span>

      <span class="s3">if </span><span class="s1">(blockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_fiber2 = getInstanceFromNode$1(blockedOn);</span>

        <span class="s3">if </span><span class="s1">(_fiber2 !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Attempt to increase the priority of this target.</span>
          <span class="s1">attemptContinuousHydration(_fiber2);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">queuedEvent;</span>
    <span class="s1">} </span><span class="s0">// If we have already queued this exact event, then it's because</span>
    <span class="s0">// the different event systems have different DOM event listeners.</span>
    <span class="s0">// We can accumulate the flags and store a single event to be</span>
    <span class="s0">// replayed.</span>


    <span class="s1">existingQueuedEvent.eventSystemFlags |= eventSystemFlags;</span>
    <span class="s3">return </span><span class="s1">existingQueuedEvent;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s0">// These set relatedTarget to null because the replayed event will be treated as if we</span>
    <span class="s0">// moved from outside the window (no target) onto the target once it hydrates.</span>
    <span class="s0">// Instead of mutating we could clone the event.</span>
    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_FOCUS:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">focusEvent = nativeEvent;</span>
          <span class="s1">queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, topLevelType, eventSystemFlags, container, focusEvent);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">TOP_DRAG_ENTER:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">dragEvent = nativeEvent;</span>
          <span class="s1">queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, topLevelType, eventSystemFlags, container, dragEvent);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">TOP_MOUSE_OVER:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">mouseEvent = nativeEvent;</span>
          <span class="s1">queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, topLevelType, eventSystemFlags, container, mouseEvent);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">TOP_POINTER_OVER:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">pointerEvent = nativeEvent;</span>
          <span class="s3">var </span><span class="s1">pointerId = pointerEvent.pointerId;</span>
          <span class="s1">queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || </span><span class="s3">null</span><span class="s1">, blockedOn, topLevelType, eventSystemFlags, container, pointerEvent));</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">TOP_GOT_POINTER_CAPTURE:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_pointerEvent = nativeEvent;</span>
          <span class="s3">var </span><span class="s1">_pointerId2 = _pointerEvent.pointerId;</span>
          <span class="s1">queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || </span><span class="s3">null</span><span class="s1">, blockedOn, topLevelType, eventSystemFlags, container, _pointerEvent));</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Check if this target is unblocked. Returns true if it's unblocked.</span>

  <span class="s3">function </span><span class="s1">attemptExplicitHydrationTarget(queuedTarget) {</span>
    <span class="s0">// TODO: This function shares a lot of logic with attemptToDispatchEvent.</span>
    <span class="s0">// Try to unify them. It's a bit tricky since it would require two return</span>
    <span class="s0">// values.</span>
    <span class="s3">var </span><span class="s1">targetInst = getClosestInstanceFromNode(queuedTarget.target);</span>

    <span class="s3">if </span><span class="s1">(targetInst !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">nearestMounted = getNearestMountedFiber(targetInst);</span>

      <span class="s3">if </span><span class="s1">(nearestMounted !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">tag = nearestMounted.tag;</span>

        <span class="s3">if </span><span class="s1">(tag === SuspenseComponent) {</span>
          <span class="s3">var </span><span class="s1">instance = getSuspenseInstanceFromFiber(nearestMounted);</span>

          <span class="s3">if </span><span class="s1">(instance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We're blocked on hydrating this boundary.</span>
            <span class="s0">// Increase its priority.</span>
            <span class="s1">queuedTarget.blockedOn = instance;</span>
            <span class="s1">unstable_runWithPriority(queuedTarget.priority, </span><span class="s3">function </span><span class="s1">() {</span>
              <span class="s1">attemptHydrationAtCurrentPriority(nearestMounted);</span>
            <span class="s1">});</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tag === HostRoot) {</span>
          <span class="s3">var </span><span class="s1">root = nearestMounted.stateNode;</span>

          <span class="s3">if </span><span class="s1">(root.hydrate) {</span>
            <span class="s1">queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); </span><span class="s0">// We don't currently have a way to increase the priority of</span>
            <span class="s0">// a root other than sync.</span>

            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">queuedTarget.blockedOn = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">attemptReplayContinuousQueuedEvent(queuedEvent) {</span>
    <span class="s3">if </span><span class="s1">(queuedEvent.blockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextBlockedOn = attemptToDispatchEvent(queuedEvent.topLevelType, queuedEvent.eventSystemFlags, queuedEvent.container, queuedEvent.nativeEvent);</span>

    <span class="s3">if </span><span class="s1">(nextBlockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We're still blocked. Try again later.</span>
      <span class="s3">var </span><span class="s1">_fiber3 = getInstanceFromNode$1(nextBlockedOn);</span>

      <span class="s3">if </span><span class="s1">(_fiber3 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">attemptContinuousHydration(_fiber3);</span>
      <span class="s1">}</span>

      <span class="s1">queuedEvent.blockedOn = nextBlockedOn;</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {</span>
    <span class="s3">if </span><span class="s1">(attemptReplayContinuousQueuedEvent(queuedEvent)) {</span>
      <span class="s1">map.</span><span class="s3">delete</span><span class="s1">(key);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">replayUnblockedEvents() {</span>
    <span class="s1">hasScheduledReplayAttempt = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// First replay discrete events.</span>

    <span class="s3">while </span><span class="s1">(queuedDiscreteEvents.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">nextDiscreteEvent = queuedDiscreteEvents[</span><span class="s4">0</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(nextDiscreteEvent.blockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We're still blocked.</span>
        <span class="s0">// Increase the priority of this boundary to unblock</span>
        <span class="s0">// the next discrete event.</span>
        <span class="s3">var </span><span class="s1">_fiber4 = getInstanceFromNode$1(nextDiscreteEvent.blockedOn);</span>

        <span class="s3">if </span><span class="s1">(_fiber4 !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">attemptUserBlockingHydration(_fiber4);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.topLevelType, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.container, nextDiscreteEvent.nativeEvent);</span>

      <span class="s3">if </span><span class="s1">(nextBlockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We're still blocked. Try again later.</span>
        <span class="s1">nextDiscreteEvent.blockedOn = nextBlockedOn;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// We've successfully replayed the first event. Let's try the next one.</span>
        <span class="s1">queuedDiscreteEvents.shift();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Next replay any continuous events.</span>


    <span class="s3">if </span><span class="s1">(queuedFocus !== </span><span class="s3">null </span><span class="s1">&amp;&amp; attemptReplayContinuousQueuedEvent(queuedFocus)) {</span>
      <span class="s1">queuedFocus = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queuedDrag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; attemptReplayContinuousQueuedEvent(queuedDrag)) {</span>
      <span class="s1">queuedDrag = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queuedMouse !== </span><span class="s3">null </span><span class="s1">&amp;&amp; attemptReplayContinuousQueuedEvent(queuedMouse)) {</span>
      <span class="s1">queuedMouse = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);</span>
    <span class="s1">queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">scheduleCallbackIfUnblocked(queuedEvent, unblocked) {</span>
    <span class="s3">if </span><span class="s1">(queuedEvent.blockedOn === unblocked) {</span>
      <span class="s1">queuedEvent.blockedOn = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!hasScheduledReplayAttempt) {</span>
        <span class="s1">hasScheduledReplayAttempt = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Schedule a callback to attempt replaying as many events as are</span>
        <span class="s0">// now unblocked. This first might not actually be unblocked yet.</span>
        <span class="s0">// We could check it early to avoid scheduling an unnecessary callback.</span>

        <span class="s1">unstable_scheduleCallback(unstable_NormalPriority, replayUnblockedEvents);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">retryIfBlockedOn(unblocked) {</span>
    <span class="s0">// Mark anything that was blocked on this as no longer blocked</span>
    <span class="s0">// and eligible for a replay.</span>
    <span class="s3">if </span><span class="s1">(queuedDiscreteEvents.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">scheduleCallbackIfUnblocked(queuedDiscreteEvents[</span><span class="s4">0</span><span class="s1">], unblocked); </span><span class="s0">// This is a exponential search for each boundary that commits. I think it's</span>
      <span class="s0">// worth it because we expect very few discrete events to queue up and once</span>
      <span class="s0">// we are actually fully unblocked it will be fast to replay them.</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">1</span><span class="s1">; i &lt; queuedDiscreteEvents.length; i++) {</span>
        <span class="s3">var </span><span class="s1">queuedEvent = queuedDiscreteEvents[i];</span>

        <span class="s3">if </span><span class="s1">(queuedEvent.blockedOn === unblocked) {</span>
          <span class="s1">queuedEvent.blockedOn = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queuedFocus !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleCallbackIfUnblocked(queuedFocus, unblocked);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queuedDrag !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleCallbackIfUnblocked(queuedDrag, unblocked);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queuedMouse !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">scheduleCallbackIfUnblocked(queuedMouse, unblocked);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">unblock = </span><span class="s3">function </span><span class="s1">(queuedEvent) {</span>
      <span class="s3">return </span><span class="s1">scheduleCallbackIfUnblocked(queuedEvent, unblocked);</span>
    <span class="s1">};</span>

    <span class="s1">queuedPointers.forEach(unblock);</span>
    <span class="s1">queuedPointerCaptures.forEach(unblock);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">; _i &lt; queuedExplicitHydrationTargets.length; _i++) {</span>
      <span class="s3">var </span><span class="s1">queuedTarget = queuedExplicitHydrationTargets[_i];</span>

      <span class="s3">if </span><span class="s1">(queuedTarget.blockedOn === unblocked) {</span>
        <span class="s1">queuedTarget.blockedOn = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">while </span><span class="s1">(queuedExplicitHydrationTargets.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">nextExplicitTarget = queuedExplicitHydrationTargets[</span><span class="s4">0</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(nextExplicitTarget.blockedOn !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// We're still blocked.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">attemptExplicitHydrationTarget(nextExplicitTarget);</span>

        <span class="s3">if </span><span class="s1">(nextExplicitTarget.blockedOn === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// We're unblocked.</span>
          <span class="s1">queuedExplicitHydrationTargets.shift();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">addEventBubbleListener(element, eventType, listener) {</span>
    <span class="s1">element.addEventListener(eventType, listener, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">addEventCaptureListener(element, eventType, listener) {</span>
    <span class="s1">element.addEventListener(eventType, listener, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// do it in two places, which duplicates logic</span>
  <span class="s0">// and increases the bundle size, we do it all</span>
  <span class="s0">// here once. If we remove or refactor the</span>
  <span class="s0">// SimpleEventPlugin, we should also remove or</span>
  <span class="s0">// update the below line.</span>

  <span class="s3">var </span><span class="s1">simpleEventPluginEventTypes = {};</span>
  <span class="s3">var </span><span class="s1">topLevelEventsToDispatchConfig = </span><span class="s3">new </span><span class="s1">Map();</span>
  <span class="s3">var </span><span class="s1">eventPriorities = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// We store most of the events in this module in pairs of two strings so we can re-use</span>
  <span class="s0">// the code required to apply the same logic for event prioritization and that of the</span>
  <span class="s0">// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code</span>
  <span class="s0">// duplication (for which there would be quite a bit). For the events that are not needed</span>
  <span class="s0">// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an</span>
  <span class="s0">// array of top level events.</span>
  <span class="s0">// Lastly, we ignore prettier so we can keep the formatting sane.</span>
  <span class="s0">// prettier-ignore</span>

  <span class="s3">var </span><span class="s1">discreteEventPairsForSimpleEventPlugin = [TOP_BLUR, </span><span class="s2">'blur'</span><span class="s1">, TOP_CANCEL, </span><span class="s2">'cancel'</span><span class="s1">, TOP_CLICK, </span><span class="s2">'click'</span><span class="s1">, TOP_CLOSE, </span><span class="s2">'close'</span><span class="s1">, TOP_CONTEXT_MENU, </span><span class="s2">'contextMenu'</span><span class="s1">, TOP_COPY, </span><span class="s2">'copy'</span><span class="s1">, TOP_CUT, </span><span class="s2">'cut'</span><span class="s1">, TOP_AUX_CLICK, </span><span class="s2">'auxClick'</span><span class="s1">, TOP_DOUBLE_CLICK, </span><span class="s2">'doubleClick'</span><span class="s1">, TOP_DRAG_END, </span><span class="s2">'dragEnd'</span><span class="s1">, TOP_DRAG_START, </span><span class="s2">'dragStart'</span><span class="s1">, TOP_DROP, </span><span class="s2">'drop'</span><span class="s1">, TOP_FOCUS, </span><span class="s2">'focus'</span><span class="s1">, TOP_INPUT, </span><span class="s2">'input'</span><span class="s1">, TOP_INVALID, </span><span class="s2">'invalid'</span><span class="s1">, TOP_KEY_DOWN, </span><span class="s2">'keyDown'</span><span class="s1">, TOP_KEY_PRESS, </span><span class="s2">'keyPress'</span><span class="s1">, TOP_KEY_UP, </span><span class="s2">'keyUp'</span><span class="s1">, TOP_MOUSE_DOWN, </span><span class="s2">'mouseDown'</span><span class="s1">, TOP_MOUSE_UP, </span><span class="s2">'mouseUp'</span><span class="s1">, TOP_PASTE, </span><span class="s2">'paste'</span><span class="s1">, TOP_PAUSE, </span><span class="s2">'pause'</span><span class="s1">, TOP_PLAY, </span><span class="s2">'play'</span><span class="s1">, TOP_POINTER_CANCEL, </span><span class="s2">'pointerCancel'</span><span class="s1">, TOP_POINTER_DOWN, </span><span class="s2">'pointerDown'</span><span class="s1">, TOP_POINTER_UP, </span><span class="s2">'pointerUp'</span><span class="s1">, TOP_RATE_CHANGE, </span><span class="s2">'rateChange'</span><span class="s1">, TOP_RESET, </span><span class="s2">'reset'</span><span class="s1">, TOP_SEEKED, </span><span class="s2">'seeked'</span><span class="s1">, TOP_SUBMIT, </span><span class="s2">'submit'</span><span class="s1">, TOP_TOUCH_CANCEL, </span><span class="s2">'touchCancel'</span><span class="s1">, TOP_TOUCH_END, </span><span class="s2">'touchEnd'</span><span class="s1">, TOP_TOUCH_START, </span><span class="s2">'touchStart'</span><span class="s1">, TOP_VOLUME_CHANGE, </span><span class="s2">'volumeChange'</span><span class="s1">];</span>
  <span class="s3">var </span><span class="s1">otherDiscreteEvents = [TOP_CHANGE, TOP_SELECTION_CHANGE, TOP_TEXT_INPUT, TOP_COMPOSITION_START, TOP_COMPOSITION_END, TOP_COMPOSITION_UPDATE]; </span><span class="s0">// prettier-ignore</span>

  <span class="s3">var </span><span class="s1">userBlockingPairsForSimpleEventPlugin = [TOP_DRAG, </span><span class="s2">'drag'</span><span class="s1">, TOP_DRAG_ENTER, </span><span class="s2">'dragEnter'</span><span class="s1">, TOP_DRAG_EXIT, </span><span class="s2">'dragExit'</span><span class="s1">, TOP_DRAG_LEAVE, </span><span class="s2">'dragLeave'</span><span class="s1">, TOP_DRAG_OVER, </span><span class="s2">'dragOver'</span><span class="s1">, TOP_MOUSE_MOVE, </span><span class="s2">'mouseMove'</span><span class="s1">, TOP_MOUSE_OUT, </span><span class="s2">'mouseOut'</span><span class="s1">, TOP_MOUSE_OVER, </span><span class="s2">'mouseOver'</span><span class="s1">, TOP_POINTER_MOVE, </span><span class="s2">'pointerMove'</span><span class="s1">, TOP_POINTER_OUT, </span><span class="s2">'pointerOut'</span><span class="s1">, TOP_POINTER_OVER, </span><span class="s2">'pointerOver'</span><span class="s1">, TOP_SCROLL, </span><span class="s2">'scroll'</span><span class="s1">, TOP_TOGGLE, </span><span class="s2">'toggle'</span><span class="s1">, TOP_TOUCH_MOVE, </span><span class="s2">'touchMove'</span><span class="s1">, TOP_WHEEL, </span><span class="s2">'wheel'</span><span class="s1">]; </span><span class="s0">// prettier-ignore</span>

  <span class="s3">var </span><span class="s1">continuousPairsForSimpleEventPlugin = [TOP_ABORT, </span><span class="s2">'abort'</span><span class="s1">, TOP_ANIMATION_END, </span><span class="s2">'animationEnd'</span><span class="s1">, TOP_ANIMATION_ITERATION, </span><span class="s2">'animationIteration'</span><span class="s1">, TOP_ANIMATION_START, </span><span class="s2">'animationStart'</span><span class="s1">, TOP_CAN_PLAY, </span><span class="s2">'canPlay'</span><span class="s1">, TOP_CAN_PLAY_THROUGH, </span><span class="s2">'canPlayThrough'</span><span class="s1">, TOP_DURATION_CHANGE, </span><span class="s2">'durationChange'</span><span class="s1">, TOP_EMPTIED, </span><span class="s2">'emptied'</span><span class="s1">, TOP_ENCRYPTED, </span><span class="s2">'encrypted'</span><span class="s1">, TOP_ENDED, </span><span class="s2">'ended'</span><span class="s1">, TOP_ERROR, </span><span class="s2">'error'</span><span class="s1">, TOP_GOT_POINTER_CAPTURE, </span><span class="s2">'gotPointerCapture'</span><span class="s1">, TOP_LOAD, </span><span class="s2">'load'</span><span class="s1">, TOP_LOADED_DATA, </span><span class="s2">'loadedData'</span><span class="s1">, TOP_LOADED_METADATA, </span><span class="s2">'loadedMetadata'</span><span class="s1">, TOP_LOAD_START, </span><span class="s2">'loadStart'</span><span class="s1">, TOP_LOST_POINTER_CAPTURE, </span><span class="s2">'lostPointerCapture'</span><span class="s1">, TOP_PLAYING, </span><span class="s2">'playing'</span><span class="s1">, TOP_PROGRESS, </span><span class="s2">'progress'</span><span class="s1">, TOP_SEEKING, </span><span class="s2">'seeking'</span><span class="s1">, TOP_STALLED, </span><span class="s2">'stalled'</span><span class="s1">, TOP_SUSPEND, </span><span class="s2">'suspend'</span><span class="s1">, TOP_TIME_UPDATE, </span><span class="s2">'timeUpdate'</span><span class="s1">, TOP_TRANSITION_END, </span><span class="s2">'transitionEnd'</span><span class="s1">, TOP_WAITING, </span><span class="s2">'waiting'</span><span class="s1">];</span>
  <span class="s0">/** 
   * Turns 
   * ['abort', ...] 
   * into 
   * eventTypes = { 
   *   'abort': { 
   *     phasedRegistrationNames: { 
   *       bubbled: 'onAbort', 
   *       captured: 'onAbortCapture', 
   *     }, 
   *     dependencies: [TOP_ABORT], 
   *   }, 
   *   ... 
   * }; 
   * topLevelEventsToDispatchConfig = new Map([ 
   *   [TOP_ABORT, { sameConfig }], 
   * ]); 
   */</span>

  <span class="s3">function </span><span class="s1">processSimpleEventPluginPairsByPriority(eventTypes, priority) {</span>
    <span class="s0">// As the event types are in pairs of two, we need to iterate</span>
    <span class="s0">// through in twos. The events are in pairs of two to save code</span>
    <span class="s0">// and improve init perf of processing this array, as it will</span>
    <span class="s0">// result in far fewer object allocations and property accesses</span>
    <span class="s0">// if we only use three arrays to process all the categories of</span>
    <span class="s0">// instead of tuples.</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; eventTypes.length; i += </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">topEvent = eventTypes[i];</span>
      <span class="s3">var </span><span class="s1">event = eventTypes[i + </span><span class="s4">1</span><span class="s1">];</span>
      <span class="s3">var </span><span class="s1">capitalizedEvent = event[</span><span class="s4">0</span><span class="s1">].toUpperCase() + event.slice(</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">onEvent = </span><span class="s2">'on' </span><span class="s1">+ capitalizedEvent;</span>
      <span class="s3">var </span><span class="s1">config = {</span>
        <span class="s1">phasedRegistrationNames: {</span>
          <span class="s1">bubbled: onEvent,</span>
          <span class="s1">captured: onEvent + </span><span class="s2">'Capture'</span>
        <span class="s1">},</span>
        <span class="s1">dependencies: [topEvent],</span>
        <span class="s1">eventPriority: priority</span>
      <span class="s1">};</span>
      <span class="s1">eventPriorities.set(topEvent, priority);</span>
      <span class="s1">topLevelEventsToDispatchConfig.set(topEvent, config);</span>
      <span class="s1">simpleEventPluginEventTypes[event] = config;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">processTopEventPairsByPriority(eventTypes, priority) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; eventTypes.length; i++) {</span>
      <span class="s1">eventPriorities.set(eventTypes[i], priority);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// SimpleEventPlugin</span>


  <span class="s1">processSimpleEventPluginPairsByPriority(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);</span>
  <span class="s1">processSimpleEventPluginPairsByPriority(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);</span>
  <span class="s1">processSimpleEventPluginPairsByPriority(continuousPairsForSimpleEventPlugin, ContinuousEvent); </span><span class="s0">// Not used by SimpleEventPlugin</span>

  <span class="s1">processTopEventPairsByPriority(otherDiscreteEvents, DiscreteEvent);</span>
  <span class="s3">function </span><span class="s1">getEventPriorityForPluginSystem(topLevelType) {</span>
    <span class="s3">var </span><span class="s1">priority = eventPriorities.get(topLevelType); </span><span class="s0">// Default to a ContinuousEvent. Note: we might</span>
    <span class="s0">// want to warn if we can't detect the priority</span>
    <span class="s0">// for the event.</span>

    <span class="s3">return </span><span class="s1">priority === undefined ? ContinuousEvent : priority;</span>
  <span class="s1">}</span>

  <span class="s0">// Intentionally not named imports because Rollup would use dynamic dispatch for</span>
  <span class="s3">var </span><span class="s1">UserBlockingPriority = unstable_UserBlockingPriority,</span>
      <span class="s1">runWithPriority = unstable_runWithPriority; </span><span class="s0">// TODO: can we stop exporting these?</span>

  <span class="s3">var </span><span class="s1">_enabled = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">setEnabled(enabled) {</span>
    <span class="s1">_enabled = !!enabled;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isEnabled() {</span>
    <span class="s3">return </span><span class="s1">_enabled;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">trapBubbledEvent(topLevelType, element) {</span>
    <span class="s1">trapEventForPluginEventSystem(element, topLevelType, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">trapCapturedEvent(topLevelType, element) {</span>
    <span class="s1">trapEventForPluginEventSystem(element, topLevelType, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">trapEventForPluginEventSystem(container, topLevelType, capture) {</span>
    <span class="s3">var </span><span class="s1">listener;</span>

    <span class="s3">switch </span><span class="s1">(getEventPriorityForPluginSystem(topLevelType)) {</span>
      <span class="s3">case </span><span class="s1">DiscreteEvent:</span>
        <span class="s1">listener = dispatchDiscreteEvent.bind(</span><span class="s3">null</span><span class="s1">, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">UserBlockingEvent:</span>
        <span class="s1">listener = dispatchUserBlockingUpdate.bind(</span><span class="s3">null</span><span class="s1">, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ContinuousEvent:</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">listener = dispatchEvent.bind(</span><span class="s3">null</span><span class="s1">, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">rawEventName = getRawEventName(topLevelType);</span>

    <span class="s3">if </span><span class="s1">(capture) {</span>
      <span class="s1">addEventCaptureListener(container, rawEventName, listener);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">addEventBubbleListener(container, rawEventName, listener);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">dispatchDiscreteEvent(topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s1">flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);</span>
    <span class="s1">discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, container, nativeEvent);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s1">runWithPriority(UserBlockingPriority, dispatchEvent.bind(</span><span class="s3">null</span><span class="s1">, topLevelType, eventSystemFlags, container, nativeEvent));</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">dispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s3">if </span><span class="s1">(!_enabled) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hasQueuedDiscreteEvents() &amp;&amp; isReplayableDiscreteEvent(topLevelType)) {</span>
      <span class="s0">// If we already have a queue of discrete events, and this is another discrete</span>
      <span class="s0">// event, then we can't dispatch it regardless of its target, since they</span>
      <span class="s0">// need to dispatch in order.</span>
      <span class="s1">queueDiscreteEvent(</span><span class="s3">null</span><span class="s1">, </span><span class="s0">// Flags that we're not actually blocked on anything as far as we know.</span>
      <span class="s1">topLevelType, eventSystemFlags, container, nativeEvent);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent);</span>

    <span class="s3">if </span><span class="s1">(blockedOn === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We successfully dispatched this event.</span>
      <span class="s1">clearIfContinuousEvent(topLevelType, nativeEvent);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isReplayableDiscreteEvent(topLevelType)) {</span>
      <span class="s0">// This this to be replayed later once the target is available.</span>
      <span class="s1">queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// We need to clear only if we didn't queue because</span>
    <span class="s0">// queueing is accummulative.</span>


    <span class="s1">clearIfContinuousEvent(topLevelType, nativeEvent); </span><span class="s0">// This is not replayable so we'll invoke it but without a target,</span>
    <span class="s0">// in case the event system needs to trace it.</span>

    <span class="s1">{</span>
      <span class="s1">dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.</span>

  <span class="s3">function </span><span class="s1">attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {</span>
    <span class="s0">// TODO: Warn if _enabled is false.</span>
    <span class="s3">var </span><span class="s1">nativeEventTarget = getEventTarget(nativeEvent);</span>
    <span class="s3">var </span><span class="s1">targetInst = getClosestInstanceFromNode(nativeEventTarget);</span>

    <span class="s3">if </span><span class="s1">(targetInst !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">nearestMounted = getNearestMountedFiber(targetInst);</span>

      <span class="s3">if </span><span class="s1">(nearestMounted === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This tree has been unmounted already. Dispatch without a target.</span>
        <span class="s1">targetInst = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">tag = nearestMounted.tag;</span>

        <span class="s3">if </span><span class="s1">(tag === SuspenseComponent) {</span>
          <span class="s3">var </span><span class="s1">instance = getSuspenseInstanceFromFiber(nearestMounted);</span>

          <span class="s3">if </span><span class="s1">(instance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Queue the event to be replayed later. Abort dispatching since we</span>
            <span class="s0">// don't want this event dispatched twice through the event system.</span>
            <span class="s0">// TODO: If this is the first discrete event in the queue. Schedule an increased</span>
            <span class="s0">// priority for this boundary.</span>
            <span class="s3">return </span><span class="s1">instance;</span>
          <span class="s1">} </span><span class="s0">// This shouldn't happen, something went wrong but to avoid blocking</span>
          <span class="s0">// the whole system, dispatch the event without a target.</span>
          <span class="s0">// TODO: Warn.</span>


          <span class="s1">targetInst = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tag === HostRoot) {</span>
          <span class="s3">var </span><span class="s1">root = nearestMounted.stateNode;</span>

          <span class="s3">if </span><span class="s1">(root.hydrate) {</span>
            <span class="s0">// If this happens during a replay something went wrong and it might block</span>
            <span class="s0">// the whole system.</span>
            <span class="s3">return </span><span class="s1">getContainerFromFiber(nearestMounted);</span>
          <span class="s1">}</span>

          <span class="s1">targetInst = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nearestMounted !== targetInst) {</span>
          <span class="s0">// If we get an event (ex: img onload) before committing that</span>
          <span class="s0">// component's mount, ignore it for now (that is, treat it as if it was an</span>
          <span class="s0">// event on a non-React tree). We might also consider queueing events and</span>
          <span class="s0">// dispatching them after the mount.</span>
          <span class="s1">targetInst = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);</span>
    <span class="s1">} </span><span class="s0">// We're not blocked on anything.</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// List derived from Gecko source code:</span>
  <span class="s0">// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js</span>
  <span class="s3">var </span><span class="s1">shorthandToLonghand = {</span>
    <span class="s1">animation: [</span><span class="s2">'animationDelay'</span><span class="s1">, </span><span class="s2">'animationDirection'</span><span class="s1">, </span><span class="s2">'animationDuration'</span><span class="s1">, </span><span class="s2">'animationFillMode'</span><span class="s1">, </span><span class="s2">'animationIterationCount'</span><span class="s1">, </span><span class="s2">'animationName'</span><span class="s1">, </span><span class="s2">'animationPlayState'</span><span class="s1">, </span><span class="s2">'animationTimingFunction'</span><span class="s1">],</span>
    <span class="s1">background: [</span><span class="s2">'backgroundAttachment'</span><span class="s1">, </span><span class="s2">'backgroundClip'</span><span class="s1">, </span><span class="s2">'backgroundColor'</span><span class="s1">, </span><span class="s2">'backgroundImage'</span><span class="s1">, </span><span class="s2">'backgroundOrigin'</span><span class="s1">, </span><span class="s2">'backgroundPositionX'</span><span class="s1">, </span><span class="s2">'backgroundPositionY'</span><span class="s1">, </span><span class="s2">'backgroundRepeat'</span><span class="s1">, </span><span class="s2">'backgroundSize'</span><span class="s1">],</span>
    <span class="s1">backgroundPosition: [</span><span class="s2">'backgroundPositionX'</span><span class="s1">, </span><span class="s2">'backgroundPositionY'</span><span class="s1">],</span>
    <span class="s1">border: [</span><span class="s2">'borderBottomColor'</span><span class="s1">, </span><span class="s2">'borderBottomStyle'</span><span class="s1">, </span><span class="s2">'borderBottomWidth'</span><span class="s1">, </span><span class="s2">'borderImageOutset'</span><span class="s1">, </span><span class="s2">'borderImageRepeat'</span><span class="s1">, </span><span class="s2">'borderImageSlice'</span><span class="s1">, </span><span class="s2">'borderImageSource'</span><span class="s1">, </span><span class="s2">'borderImageWidth'</span><span class="s1">, </span><span class="s2">'borderLeftColor'</span><span class="s1">, </span><span class="s2">'borderLeftStyle'</span><span class="s1">, </span><span class="s2">'borderLeftWidth'</span><span class="s1">, </span><span class="s2">'borderRightColor'</span><span class="s1">, </span><span class="s2">'borderRightStyle'</span><span class="s1">, </span><span class="s2">'borderRightWidth'</span><span class="s1">, </span><span class="s2">'borderTopColor'</span><span class="s1">, </span><span class="s2">'borderTopStyle'</span><span class="s1">, </span><span class="s2">'borderTopWidth'</span><span class="s1">],</span>
    <span class="s1">borderBlockEnd: [</span><span class="s2">'borderBlockEndColor'</span><span class="s1">, </span><span class="s2">'borderBlockEndStyle'</span><span class="s1">, </span><span class="s2">'borderBlockEndWidth'</span><span class="s1">],</span>
    <span class="s1">borderBlockStart: [</span><span class="s2">'borderBlockStartColor'</span><span class="s1">, </span><span class="s2">'borderBlockStartStyle'</span><span class="s1">, </span><span class="s2">'borderBlockStartWidth'</span><span class="s1">],</span>
    <span class="s1">borderBottom: [</span><span class="s2">'borderBottomColor'</span><span class="s1">, </span><span class="s2">'borderBottomStyle'</span><span class="s1">, </span><span class="s2">'borderBottomWidth'</span><span class="s1">],</span>
    <span class="s1">borderColor: [</span><span class="s2">'borderBottomColor'</span><span class="s1">, </span><span class="s2">'borderLeftColor'</span><span class="s1">, </span><span class="s2">'borderRightColor'</span><span class="s1">, </span><span class="s2">'borderTopColor'</span><span class="s1">],</span>
    <span class="s1">borderImage: [</span><span class="s2">'borderImageOutset'</span><span class="s1">, </span><span class="s2">'borderImageRepeat'</span><span class="s1">, </span><span class="s2">'borderImageSlice'</span><span class="s1">, </span><span class="s2">'borderImageSource'</span><span class="s1">, </span><span class="s2">'borderImageWidth'</span><span class="s1">],</span>
    <span class="s1">borderInlineEnd: [</span><span class="s2">'borderInlineEndColor'</span><span class="s1">, </span><span class="s2">'borderInlineEndStyle'</span><span class="s1">, </span><span class="s2">'borderInlineEndWidth'</span><span class="s1">],</span>
    <span class="s1">borderInlineStart: [</span><span class="s2">'borderInlineStartColor'</span><span class="s1">, </span><span class="s2">'borderInlineStartStyle'</span><span class="s1">, </span><span class="s2">'borderInlineStartWidth'</span><span class="s1">],</span>
    <span class="s1">borderLeft: [</span><span class="s2">'borderLeftColor'</span><span class="s1">, </span><span class="s2">'borderLeftStyle'</span><span class="s1">, </span><span class="s2">'borderLeftWidth'</span><span class="s1">],</span>
    <span class="s1">borderRadius: [</span><span class="s2">'borderBottomLeftRadius'</span><span class="s1">, </span><span class="s2">'borderBottomRightRadius'</span><span class="s1">, </span><span class="s2">'borderTopLeftRadius'</span><span class="s1">, </span><span class="s2">'borderTopRightRadius'</span><span class="s1">],</span>
    <span class="s1">borderRight: [</span><span class="s2">'borderRightColor'</span><span class="s1">, </span><span class="s2">'borderRightStyle'</span><span class="s1">, </span><span class="s2">'borderRightWidth'</span><span class="s1">],</span>
    <span class="s1">borderStyle: [</span><span class="s2">'borderBottomStyle'</span><span class="s1">, </span><span class="s2">'borderLeftStyle'</span><span class="s1">, </span><span class="s2">'borderRightStyle'</span><span class="s1">, </span><span class="s2">'borderTopStyle'</span><span class="s1">],</span>
    <span class="s1">borderTop: [</span><span class="s2">'borderTopColor'</span><span class="s1">, </span><span class="s2">'borderTopStyle'</span><span class="s1">, </span><span class="s2">'borderTopWidth'</span><span class="s1">],</span>
    <span class="s1">borderWidth: [</span><span class="s2">'borderBottomWidth'</span><span class="s1">, </span><span class="s2">'borderLeftWidth'</span><span class="s1">, </span><span class="s2">'borderRightWidth'</span><span class="s1">, </span><span class="s2">'borderTopWidth'</span><span class="s1">],</span>
    <span class="s1">columnRule: [</span><span class="s2">'columnRuleColor'</span><span class="s1">, </span><span class="s2">'columnRuleStyle'</span><span class="s1">, </span><span class="s2">'columnRuleWidth'</span><span class="s1">],</span>
    <span class="s1">columns: [</span><span class="s2">'columnCount'</span><span class="s1">, </span><span class="s2">'columnWidth'</span><span class="s1">],</span>
    <span class="s1">flex: [</span><span class="s2">'flexBasis'</span><span class="s1">, </span><span class="s2">'flexGrow'</span><span class="s1">, </span><span class="s2">'flexShrink'</span><span class="s1">],</span>
    <span class="s1">flexFlow: [</span><span class="s2">'flexDirection'</span><span class="s1">, </span><span class="s2">'flexWrap'</span><span class="s1">],</span>
    <span class="s1">font: [</span><span class="s2">'fontFamily'</span><span class="s1">, </span><span class="s2">'fontFeatureSettings'</span><span class="s1">, </span><span class="s2">'fontKerning'</span><span class="s1">, </span><span class="s2">'fontLanguageOverride'</span><span class="s1">, </span><span class="s2">'fontSize'</span><span class="s1">, </span><span class="s2">'fontSizeAdjust'</span><span class="s1">, </span><span class="s2">'fontStretch'</span><span class="s1">, </span><span class="s2">'fontStyle'</span><span class="s1">, </span><span class="s2">'fontVariant'</span><span class="s1">, </span><span class="s2">'fontVariantAlternates'</span><span class="s1">, </span><span class="s2">'fontVariantCaps'</span><span class="s1">, </span><span class="s2">'fontVariantEastAsian'</span><span class="s1">, </span><span class="s2">'fontVariantLigatures'</span><span class="s1">, </span><span class="s2">'fontVariantNumeric'</span><span class="s1">, </span><span class="s2">'fontVariantPosition'</span><span class="s1">, </span><span class="s2">'fontWeight'</span><span class="s1">, </span><span class="s2">'lineHeight'</span><span class="s1">],</span>
    <span class="s1">fontVariant: [</span><span class="s2">'fontVariantAlternates'</span><span class="s1">, </span><span class="s2">'fontVariantCaps'</span><span class="s1">, </span><span class="s2">'fontVariantEastAsian'</span><span class="s1">, </span><span class="s2">'fontVariantLigatures'</span><span class="s1">, </span><span class="s2">'fontVariantNumeric'</span><span class="s1">, </span><span class="s2">'fontVariantPosition'</span><span class="s1">],</span>
    <span class="s1">gap: [</span><span class="s2">'columnGap'</span><span class="s1">, </span><span class="s2">'rowGap'</span><span class="s1">],</span>
    <span class="s1">grid: [</span><span class="s2">'gridAutoColumns'</span><span class="s1">, </span><span class="s2">'gridAutoFlow'</span><span class="s1">, </span><span class="s2">'gridAutoRows'</span><span class="s1">, </span><span class="s2">'gridTemplateAreas'</span><span class="s1">, </span><span class="s2">'gridTemplateColumns'</span><span class="s1">, </span><span class="s2">'gridTemplateRows'</span><span class="s1">],</span>
    <span class="s1">gridArea: [</span><span class="s2">'gridColumnEnd'</span><span class="s1">, </span><span class="s2">'gridColumnStart'</span><span class="s1">, </span><span class="s2">'gridRowEnd'</span><span class="s1">, </span><span class="s2">'gridRowStart'</span><span class="s1">],</span>
    <span class="s1">gridColumn: [</span><span class="s2">'gridColumnEnd'</span><span class="s1">, </span><span class="s2">'gridColumnStart'</span><span class="s1">],</span>
    <span class="s1">gridColumnGap: [</span><span class="s2">'columnGap'</span><span class="s1">],</span>
    <span class="s1">gridGap: [</span><span class="s2">'columnGap'</span><span class="s1">, </span><span class="s2">'rowGap'</span><span class="s1">],</span>
    <span class="s1">gridRow: [</span><span class="s2">'gridRowEnd'</span><span class="s1">, </span><span class="s2">'gridRowStart'</span><span class="s1">],</span>
    <span class="s1">gridRowGap: [</span><span class="s2">'rowGap'</span><span class="s1">],</span>
    <span class="s1">gridTemplate: [</span><span class="s2">'gridTemplateAreas'</span><span class="s1">, </span><span class="s2">'gridTemplateColumns'</span><span class="s1">, </span><span class="s2">'gridTemplateRows'</span><span class="s1">],</span>
    <span class="s1">listStyle: [</span><span class="s2">'listStyleImage'</span><span class="s1">, </span><span class="s2">'listStylePosition'</span><span class="s1">, </span><span class="s2">'listStyleType'</span><span class="s1">],</span>
    <span class="s1">margin: [</span><span class="s2">'marginBottom'</span><span class="s1">, </span><span class="s2">'marginLeft'</span><span class="s1">, </span><span class="s2">'marginRight'</span><span class="s1">, </span><span class="s2">'marginTop'</span><span class="s1">],</span>
    <span class="s1">marker: [</span><span class="s2">'markerEnd'</span><span class="s1">, </span><span class="s2">'markerMid'</span><span class="s1">, </span><span class="s2">'markerStart'</span><span class="s1">],</span>
    <span class="s1">mask: [</span><span class="s2">'maskClip'</span><span class="s1">, </span><span class="s2">'maskComposite'</span><span class="s1">, </span><span class="s2">'maskImage'</span><span class="s1">, </span><span class="s2">'maskMode'</span><span class="s1">, </span><span class="s2">'maskOrigin'</span><span class="s1">, </span><span class="s2">'maskPositionX'</span><span class="s1">, </span><span class="s2">'maskPositionY'</span><span class="s1">, </span><span class="s2">'maskRepeat'</span><span class="s1">, </span><span class="s2">'maskSize'</span><span class="s1">],</span>
    <span class="s1">maskPosition: [</span><span class="s2">'maskPositionX'</span><span class="s1">, </span><span class="s2">'maskPositionY'</span><span class="s1">],</span>
    <span class="s1">outline: [</span><span class="s2">'outlineColor'</span><span class="s1">, </span><span class="s2">'outlineStyle'</span><span class="s1">, </span><span class="s2">'outlineWidth'</span><span class="s1">],</span>
    <span class="s1">overflow: [</span><span class="s2">'overflowX'</span><span class="s1">, </span><span class="s2">'overflowY'</span><span class="s1">],</span>
    <span class="s1">padding: [</span><span class="s2">'paddingBottom'</span><span class="s1">, </span><span class="s2">'paddingLeft'</span><span class="s1">, </span><span class="s2">'paddingRight'</span><span class="s1">, </span><span class="s2">'paddingTop'</span><span class="s1">],</span>
    <span class="s1">placeContent: [</span><span class="s2">'alignContent'</span><span class="s1">, </span><span class="s2">'justifyContent'</span><span class="s1">],</span>
    <span class="s1">placeItems: [</span><span class="s2">'alignItems'</span><span class="s1">, </span><span class="s2">'justifyItems'</span><span class="s1">],</span>
    <span class="s1">placeSelf: [</span><span class="s2">'alignSelf'</span><span class="s1">, </span><span class="s2">'justifySelf'</span><span class="s1">],</span>
    <span class="s1">textDecoration: [</span><span class="s2">'textDecorationColor'</span><span class="s1">, </span><span class="s2">'textDecorationLine'</span><span class="s1">, </span><span class="s2">'textDecorationStyle'</span><span class="s1">],</span>
    <span class="s1">textEmphasis: [</span><span class="s2">'textEmphasisColor'</span><span class="s1">, </span><span class="s2">'textEmphasisStyle'</span><span class="s1">],</span>
    <span class="s1">transition: [</span><span class="s2">'transitionDelay'</span><span class="s1">, </span><span class="s2">'transitionDuration'</span><span class="s1">, </span><span class="s2">'transitionProperty'</span><span class="s1">, </span><span class="s2">'transitionTimingFunction'</span><span class="s1">],</span>
    <span class="s1">wordWrap: [</span><span class="s2">'overflowWrap'</span><span class="s1">]</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * CSS properties which accept numbers but are not in units of &quot;px&quot;. 
   */</span>
  <span class="s3">var </span><span class="s1">isUnitlessNumber = {</span>
    <span class="s1">animationIterationCount: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">borderImageOutset: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">borderImageSlice: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">borderImageWidth: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">boxFlex: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">boxFlexGroup: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">boxOrdinalGroup: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">columnCount: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">columns: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flex: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flexGrow: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flexPositive: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flexShrink: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flexNegative: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">flexOrder: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridArea: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridRow: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridRowEnd: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridRowSpan: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridRowStart: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridColumn: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridColumnEnd: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridColumnSpan: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">gridColumnStart: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">fontWeight: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">lineClamp: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">lineHeight: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">opacity: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">order: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">orphans: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">tabSize: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">widows: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">zIndex: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">zoom: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s0">// SVG-related properties</span>
    <span class="s1">fillOpacity: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">floodOpacity: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">stopOpacity: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">strokeDasharray: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">strokeDashoffset: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">strokeMiterlimit: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">strokeOpacity: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">strokeWidth: </span><span class="s3">true</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * @param {string} prefix vendor-specific prefix, eg: Webkit 
   * @param {string} key style name, eg: transitionDuration 
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg: 
   * WebkitTransitionDuration 
   */</span>

  <span class="s3">function </span><span class="s1">prefixKey(prefix, key) {</span>
    <span class="s3">return </span><span class="s1">prefix + key.charAt(</span><span class="s4">0</span><span class="s1">).toUpperCase() + key.substring(</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Support style names that may come passed in prefixed by adding permutations 
   * of vendor prefixes. 
   */</span>


  <span class="s3">var </span><span class="s1">prefixes = [</span><span class="s2">'Webkit'</span><span class="s1">, </span><span class="s2">'ms'</span><span class="s1">, </span><span class="s2">'Moz'</span><span class="s1">, </span><span class="s2">'O'</span><span class="s1">]; </span><span class="s0">// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an</span>
  <span class="s0">// infinite loop, because it iterates over the newly added props too.</span>

  <span class="s1">Object.keys(isUnitlessNumber).forEach(</span><span class="s3">function </span><span class="s1">(prop) {</span>
    <span class="s1">prefixes.forEach(</span><span class="s3">function </span><span class="s1">(prefix) {</span>
      <span class="s1">isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];</span>
    <span class="s1">});</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * Convert a value into the proper css writable value. The style name `name` 
   * should be logical (no hyphens), as specified 
   * in `CSSProperty.isUnitlessNumber`. 
   * 
   * @param {string} name CSS property name such as `topMargin`. 
   * @param {*} value CSS property value such as `10px`. 
   * @return {string} Normalized style value with dimensions applied. 
   */</span>

  <span class="s3">function </span><span class="s1">dangerousStyleValue(name, value, isCustomProperty) {</span>
    <span class="s0">// Note that we've removed escapeTextForBrowser() calls here since the</span>
    <span class="s0">// whole string will be escaped when the attribute is injected into</span>
    <span class="s0">// the markup. If you provide unsafe user data here they can inject</span>
    <span class="s0">// arbitrary CSS which may be problematic (I couldn't repro this):</span>
    <span class="s0">// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</span>
    <span class="s0">// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/</span>
    <span class="s0">// This is not an XSS hole but instead a potential CSS injection issue</span>
    <span class="s0">// which has lead to a greater discussion about how we're going to</span>
    <span class="s0">// trust URLs moving forward. See #2115901</span>
    <span class="s3">var </span><span class="s1">isEmpty = value == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'boolean' </span><span class="s1">|| value === </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isEmpty) {</span>
      <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!isCustomProperty &amp;&amp; </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; value !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !(isUnitlessNumber.hasOwnProperty(name) &amp;&amp; isUnitlessNumber[name])) {</span>
      <span class="s3">return </span><span class="s1">value + </span><span class="s2">'px'</span><span class="s1">; </span><span class="s0">// Presumes implicit 'px' suffix for unitless numbers</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">(</span><span class="s2">'' </span><span class="s1">+ value).trim();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">uppercasePattern = /([A-Z])/g;</span>
  <span class="s3">var </span><span class="s1">msPattern = /^ms-/;</span>
  <span class="s0">/** 
   * Hyphenates a camelcased CSS property name, for example: 
   * 
   *   &gt; hyphenateStyleName('backgroundColor') 
   *   &lt; &quot;background-color&quot; 
   *   &gt; hyphenateStyleName('MozTransition') 
   *   &lt; &quot;-moz-transition&quot; 
   *   &gt; hyphenateStyleName('msTransition') 
   *   &lt; &quot;-ms-transition&quot; 
   * 
   * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix 
   * is converted to `-ms-`. 
   */</span>

  <span class="s3">function </span><span class="s1">hyphenateStyleName(name) {</span>
    <span class="s3">return </span><span class="s1">name.replace(uppercasePattern, </span><span class="s2">'-$1'</span><span class="s1">).toLowerCase().replace(msPattern, </span><span class="s2">'-ms-'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">warnValidStyle = </span><span class="s3">function </span><span class="s1">() {};</span>

  <span class="s1">{</span>
    <span class="s0">// 'msTransform' is correct, but the other prefixes should be capitalized</span>
    <span class="s3">var </span><span class="s1">badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;</span>
    <span class="s3">var </span><span class="s1">msPattern$1 = /^-ms-/;</span>
    <span class="s3">var </span><span class="s1">hyphenPattern = /-(.)/g; </span><span class="s0">// style values shouldn't contain a semicolon</span>

    <span class="s3">var </span><span class="s1">badStyleValueWithSemicolonPattern = /;\s*$/;</span>
    <span class="s3">var </span><span class="s1">warnedStyleNames = {};</span>
    <span class="s3">var </span><span class="s1">warnedStyleValues = {};</span>
    <span class="s3">var </span><span class="s1">warnedForNaNValue = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">warnedForInfinityValue = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">var </span><span class="s1">camelize = </span><span class="s3">function </span><span class="s1">(string) {</span>
      <span class="s3">return </span><span class="s1">string.replace(hyphenPattern, </span><span class="s3">function </span><span class="s1">(_, character) {</span>
        <span class="s3">return </span><span class="s1">character.toUpperCase();</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnHyphenatedStyleName = </span><span class="s3">function </span><span class="s1">(name) {</span>
      <span class="s3">if </span><span class="s1">(warnedStyleNames.hasOwnProperty(name) &amp;&amp; warnedStyleNames[name]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">warnedStyleNames[name] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Unsupported style property %s. Did you mean %s?'</span><span class="s1">, name, </span><span class="s0">// As Andi Smith suggests</span>
      <span class="s0">// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix</span>
      <span class="s0">// is converted to lowercase `ms`.</span>
      <span class="s1">camelize(name.replace(msPattern$1, </span><span class="s2">'ms-'</span><span class="s1">)));</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnBadVendoredStyleName = </span><span class="s3">function </span><span class="s1">(name) {</span>
      <span class="s3">if </span><span class="s1">(warnedStyleNames.hasOwnProperty(name) &amp;&amp; warnedStyleNames[name]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">warnedStyleNames[name] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Unsupported vendor-prefixed style property %s. Did you mean %s?'</span><span class="s1">, name, name.charAt(</span><span class="s4">0</span><span class="s1">).toUpperCase() + name.slice(</span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnStyleValueWithSemicolon = </span><span class="s3">function </span><span class="s1">(name, value) {</span>
      <span class="s3">if </span><span class="s1">(warnedStyleValues.hasOwnProperty(value) &amp;&amp; warnedStyleValues[value]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">warnedStyleValues[value] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">&quot;Style property values shouldn't contain a semicolon. &quot; </span><span class="s1">+ </span><span class="s2">'Try &quot;%s: %s&quot; instead.'</span><span class="s1">, name, value.replace(badStyleValueWithSemicolonPattern, </span><span class="s2">''</span><span class="s1">));</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnStyleValueIsNaN = </span><span class="s3">function </span><span class="s1">(name, value) {</span>
      <span class="s3">if </span><span class="s1">(warnedForNaNValue) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">warnedForNaNValue = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'`NaN` is an invalid value for the `%s` css style property.'</span><span class="s1">, name);</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnStyleValueIsInfinity = </span><span class="s3">function </span><span class="s1">(name, value) {</span>
      <span class="s3">if </span><span class="s1">(warnedForInfinityValue) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">warnedForInfinityValue = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'`Infinity` is an invalid value for the `%s` css style property.'</span><span class="s1">, name);</span>
    <span class="s1">};</span>

    <span class="s1">warnValidStyle = </span><span class="s3">function </span><span class="s1">(name, value) {</span>
      <span class="s3">if </span><span class="s1">(name.indexOf(</span><span class="s2">'-'</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">warnHyphenatedStyleName(name);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(badVendoredStyleNamePattern.test(name)) {</span>
        <span class="s1">warnBadVendoredStyleName(name);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(badStyleValueWithSemicolonPattern.test(value)) {</span>
        <span class="s1">warnStyleValueWithSemicolon(name, value);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(isNaN(value)) {</span>
          <span class="s1">warnStyleValueIsNaN(name, value);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!isFinite(value)) {</span>
          <span class="s1">warnStyleValueIsInfinity(name, value);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">warnValidStyle$1 = warnValidStyle;</span>

  <span class="s0">/** 
   * Operations for dealing with CSS properties. 
   */</span>

  <span class="s0">/** 
   * This creates a string that is expected to be equivalent to the style 
   * attribute generated by server-side rendering. It by-passes warnings and 
   * security checks so it's not safe to use this value for anything other than 
   * comparison. It is only used in DEV for SSR validation. 
   */</span>

  <span class="s3">function </span><span class="s1">createDangerousStringForStyles(styles) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">serialized = </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">delimiter = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">styleName </span><span class="s3">in </span><span class="s1">styles) {</span>
        <span class="s3">if </span><span class="s1">(!styles.hasOwnProperty(styleName)) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">styleValue = styles[styleName];</span>

        <span class="s3">if </span><span class="s1">(styleValue != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">isCustomProperty = styleName.indexOf(</span><span class="s2">'--'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + </span><span class="s2">':'</span><span class="s1">;</span>
          <span class="s1">serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);</span>
          <span class="s1">delimiter = </span><span class="s2">';'</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">serialized || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Sets the value for multiple styles on a node.  If a value is specified as 
   * '' (empty string), the corresponding style property will be unset. 
   * 
   * @param {DOMElement} node 
   * @param {object} styles 
   */</span>

  <span class="s3">function </span><span class="s1">setValueForStyles(node, styles) {</span>
    <span class="s3">var </span><span class="s1">style = node.style;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">styleName </span><span class="s3">in </span><span class="s1">styles) {</span>
      <span class="s3">if </span><span class="s1">(!styles.hasOwnProperty(styleName)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">isCustomProperty = styleName.indexOf(</span><span class="s2">'--'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!isCustomProperty) {</span>
          <span class="s1">warnValidStyle$1(styleName, styles[styleName]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);</span>

      <span class="s3">if </span><span class="s1">(styleName === </span><span class="s2">'float'</span><span class="s1">) {</span>
        <span class="s1">styleName = </span><span class="s2">'cssFloat'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isCustomProperty) {</span>
        <span class="s1">style.setProperty(styleName, styleValue);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">style[styleName] = styleValue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isValueEmpty(value) {</span>
    <span class="s3">return </span><span class="s1">value == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'boolean' </span><span class="s1">|| value === </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given {color: 'red', overflow: 'hidden'} returns { 
   *   color: 'color', 
   *   overflowX: 'overflow', 
   *   overflowY: 'overflow', 
   * }. This can be read as &quot;the overflowY property was set by the overflow 
   * shorthand&quot;. That is, the values are the property that each was derived from. 
   */</span>


  <span class="s3">function </span><span class="s1">expandShorthandMap(styles) {</span>
    <span class="s3">var </span><span class="s1">expanded = {};</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">styles) {</span>
      <span class="s3">var </span><span class="s1">longhands = shorthandToLonghand[key] || [key];</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; longhands.length; i++) {</span>
        <span class="s1">expanded[longhands[i]] = key;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">expanded;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * When mixing shorthand and longhand property names, we warn during updates if 
   * we expect an incorrect result to occur. In particular, we warn for: 
   * 
   * Updating a shorthand property (longhand gets overwritten): 
   *   {font: 'foo', fontVariant: 'bar'} -&gt; {font: 'baz', fontVariant: 'bar'} 
   *   becomes .style.font = 'baz' 
   * Removing a shorthand property (longhand gets lost too): 
   *   {font: 'foo', fontVariant: 'bar'} -&gt; {fontVariant: 'bar'} 
   *   becomes .style.font = '' 
   * Removing a longhand property (should revert to shorthand; doesn't): 
   *   {font: 'foo', fontVariant: 'bar'} -&gt; {font: 'foo'} 
   *   becomes .style.fontVariant = '' 
   */</span>


  <span class="s3">function </span><span class="s1">validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {</span>
    <span class="s1">{</span>

      <span class="s3">if </span><span class="s1">(!nextStyles) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">expandedUpdates = expandShorthandMap(styleUpdates);</span>
      <span class="s3">var </span><span class="s1">expandedStyles = expandShorthandMap(nextStyles);</span>
      <span class="s3">var </span><span class="s1">warnedAbout = {};</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">expandedUpdates) {</span>
        <span class="s3">var </span><span class="s1">originalKey = expandedUpdates[key];</span>
        <span class="s3">var </span><span class="s1">correctOriginalKey = expandedStyles[key];</span>

        <span class="s3">if </span><span class="s1">(correctOriginalKey &amp;&amp; originalKey !== correctOriginalKey) {</span>
          <span class="s3">var </span><span class="s1">warningKey = originalKey + </span><span class="s2">',' </span><span class="s1">+ correctOriginalKey;</span>

          <span class="s3">if </span><span class="s1">(warnedAbout[warningKey]) {</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">warnedAbout[warningKey] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'%s a style property during rerender (%s) when a ' </span><span class="s1">+ </span><span class="s2">'conflicting property is set (%s) can lead to styling bugs. To ' </span><span class="s1">+ </span><span class="s2">&quot;avoid this, don't mix shorthand and non-shorthand properties &quot; </span><span class="s1">+ </span><span class="s2">'for the same value; instead, replace the shorthand with ' </span><span class="s1">+ </span><span class="s2">'separate values.'</span><span class="s1">, isValueEmpty(styleUpdates[originalKey]) ? </span><span class="s2">'Removing' </span><span class="s1">: </span><span class="s2">'Updating'</span><span class="s1">, originalKey, correctOriginalKey);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// For HTML, certain tags should omit their close tag. We keep a whitelist for</span>
  <span class="s0">// those special-case tags.</span>
  <span class="s3">var </span><span class="s1">omittedCloseTags = {</span>
    <span class="s1">area: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">base: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">br: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">col: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">embed: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">hr: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">img: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">input: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">keygen: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">link: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">meta: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">param: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">source: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">track: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">wbr: </span><span class="s3">true </span><span class="s0">// NOTE: menuitem's close tag should be omitted, but that causes problems.</span>

  <span class="s1">};</span>

  <span class="s0">// `omittedCloseTags` except that `menuitem` should still have its closing tag.</span>

  <span class="s3">var </span><span class="s1">voidElementTags = _assign({</span>
    <span class="s1">menuitem: </span><span class="s3">true</span>
  <span class="s1">}, omittedCloseTags);</span>

  <span class="s3">var </span><span class="s1">HTML = </span><span class="s2">'__html'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame$3 = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">ReactDebugCurrentFrame$3 = ReactSharedInternals.ReactDebugCurrentFrame;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">assertValidProps(tag, props) {</span>
    <span class="s3">if </span><span class="s1">(!props) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Note the use of `==` which checks for null or undefined.</span>


    <span class="s3">if </span><span class="s1">(voidElementTags[tag]) {</span>
      <span class="s3">if </span><span class="s1">(!(props.children == </span><span class="s3">null </span><span class="s1">&amp;&amp; props.dangerouslySetInnerHTML == </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( tag + </span><span class="s2">&quot; is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.&quot; </span><span class="s1">+ ( ReactDebugCurrentFrame$3.getStackAddendum() ) );</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(props.dangerouslySetInnerHTML != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!(props.children == </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Can only set one of `children` or `props.dangerouslySetInnerHTML`.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">props.dangerouslySetInnerHTML === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; HTML </span><span class="s3">in </span><span class="s1">props.dangerouslySetInnerHTML)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!props.suppressContentEditableWarning &amp;&amp; props.contentEditable &amp;&amp; props.children != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'A component is `contentEditable` and contains `children` managed by ' </span><span class="s1">+ </span><span class="s2">'React. It is now your responsibility to guarantee that none of ' </span><span class="s1">+ </span><span class="s2">'those nodes are unexpectedly modified or duplicated. This is ' </span><span class="s1">+ </span><span class="s2">'probably not intentional.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!(props.style == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">props.style === </span><span class="s2">'object'</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.&quot; </span><span class="s1">+ ( ReactDebugCurrentFrame$3.getStackAddendum() ) );</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isCustomComponent(tagName, props) {</span>
    <span class="s3">if </span><span class="s1">(tagName.indexOf(</span><span class="s2">'-'</span><span class="s1">) === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">return typeof </span><span class="s1">props.is === </span><span class="s2">'string'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(tagName) {</span>
      <span class="s0">// These are reserved SVG and MathML elements.</span>
      <span class="s0">// We don't mind this whitelist too much because we expect it to never grow.</span>
      <span class="s0">// The alternative is to track the namespace in a few places which is convoluted.</span>
      <span class="s0">// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts</span>
      <span class="s3">case </span><span class="s2">'annotation-xml'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'color-profile'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'font-face'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'font-face-src'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'font-face-uri'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'font-face-format'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'font-face-name'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'missing-glyph'</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// When adding attributes to the HTML or SVG whitelist, be sure to</span>
  <span class="s0">// also add them to this module to ensure casing and incorrect name</span>
  <span class="s0">// warnings.</span>
  <span class="s3">var </span><span class="s1">possibleStandardNames = {</span>
    <span class="s0">// HTML</span>
    <span class="s1">accept: </span><span class="s2">'accept'</span><span class="s1">,</span>
    <span class="s1">acceptcharset: </span><span class="s2">'acceptCharset'</span><span class="s1">,</span>
    <span class="s2">'accept-charset'</span><span class="s1">: </span><span class="s2">'acceptCharset'</span><span class="s1">,</span>
    <span class="s1">accesskey: </span><span class="s2">'accessKey'</span><span class="s1">,</span>
    <span class="s1">action: </span><span class="s2">'action'</span><span class="s1">,</span>
    <span class="s1">allowfullscreen: </span><span class="s2">'allowFullScreen'</span><span class="s1">,</span>
    <span class="s1">alt: </span><span class="s2">'alt'</span><span class="s1">,</span>
    <span class="s1">as: </span><span class="s2">'as'</span><span class="s1">,</span>
    <span class="s1">async: </span><span class="s2">'async'</span><span class="s1">,</span>
    <span class="s1">autocapitalize: </span><span class="s2">'autoCapitalize'</span><span class="s1">,</span>
    <span class="s1">autocomplete: </span><span class="s2">'autoComplete'</span><span class="s1">,</span>
    <span class="s1">autocorrect: </span><span class="s2">'autoCorrect'</span><span class="s1">,</span>
    <span class="s1">autofocus: </span><span class="s2">'autoFocus'</span><span class="s1">,</span>
    <span class="s1">autoplay: </span><span class="s2">'autoPlay'</span><span class="s1">,</span>
    <span class="s1">autosave: </span><span class="s2">'autoSave'</span><span class="s1">,</span>
    <span class="s1">capture: </span><span class="s2">'capture'</span><span class="s1">,</span>
    <span class="s1">cellpadding: </span><span class="s2">'cellPadding'</span><span class="s1">,</span>
    <span class="s1">cellspacing: </span><span class="s2">'cellSpacing'</span><span class="s1">,</span>
    <span class="s1">challenge: </span><span class="s2">'challenge'</span><span class="s1">,</span>
    <span class="s1">charset: </span><span class="s2">'charSet'</span><span class="s1">,</span>
    <span class="s1">checked: </span><span class="s2">'checked'</span><span class="s1">,</span>
    <span class="s1">children: </span><span class="s2">'children'</span><span class="s1">,</span>
    <span class="s1">cite: </span><span class="s2">'cite'</span><span class="s1">,</span>
    <span class="s1">class: </span><span class="s2">'className'</span><span class="s1">,</span>
    <span class="s1">classid: </span><span class="s2">'classID'</span><span class="s1">,</span>
    <span class="s1">classname: </span><span class="s2">'className'</span><span class="s1">,</span>
    <span class="s1">cols: </span><span class="s2">'cols'</span><span class="s1">,</span>
    <span class="s1">colspan: </span><span class="s2">'colSpan'</span><span class="s1">,</span>
    <span class="s1">content: </span><span class="s2">'content'</span><span class="s1">,</span>
    <span class="s1">contenteditable: </span><span class="s2">'contentEditable'</span><span class="s1">,</span>
    <span class="s1">contextmenu: </span><span class="s2">'contextMenu'</span><span class="s1">,</span>
    <span class="s1">controls: </span><span class="s2">'controls'</span><span class="s1">,</span>
    <span class="s1">controlslist: </span><span class="s2">'controlsList'</span><span class="s1">,</span>
    <span class="s1">coords: </span><span class="s2">'coords'</span><span class="s1">,</span>
    <span class="s1">crossorigin: </span><span class="s2">'crossOrigin'</span><span class="s1">,</span>
    <span class="s1">dangerouslysetinnerhtml: </span><span class="s2">'dangerouslySetInnerHTML'</span><span class="s1">,</span>
    <span class="s1">data: </span><span class="s2">'data'</span><span class="s1">,</span>
    <span class="s1">datetime: </span><span class="s2">'dateTime'</span><span class="s1">,</span>
    <span class="s3">default</span><span class="s1">: </span><span class="s2">'default'</span><span class="s1">,</span>
    <span class="s1">defaultchecked: </span><span class="s2">'defaultChecked'</span><span class="s1">,</span>
    <span class="s1">defaultvalue: </span><span class="s2">'defaultValue'</span><span class="s1">,</span>
    <span class="s1">defer: </span><span class="s2">'defer'</span><span class="s1">,</span>
    <span class="s1">dir: </span><span class="s2">'dir'</span><span class="s1">,</span>
    <span class="s1">disabled: </span><span class="s2">'disabled'</span><span class="s1">,</span>
    <span class="s1">disablepictureinpicture: </span><span class="s2">'disablePictureInPicture'</span><span class="s1">,</span>
    <span class="s1">download: </span><span class="s2">'download'</span><span class="s1">,</span>
    <span class="s1">draggable: </span><span class="s2">'draggable'</span><span class="s1">,</span>
    <span class="s1">enctype: </span><span class="s2">'encType'</span><span class="s1">,</span>
    <span class="s3">for</span><span class="s1">: </span><span class="s2">'htmlFor'</span><span class="s1">,</span>
    <span class="s1">form: </span><span class="s2">'form'</span><span class="s1">,</span>
    <span class="s1">formmethod: </span><span class="s2">'formMethod'</span><span class="s1">,</span>
    <span class="s1">formaction: </span><span class="s2">'formAction'</span><span class="s1">,</span>
    <span class="s1">formenctype: </span><span class="s2">'formEncType'</span><span class="s1">,</span>
    <span class="s1">formnovalidate: </span><span class="s2">'formNoValidate'</span><span class="s1">,</span>
    <span class="s1">formtarget: </span><span class="s2">'formTarget'</span><span class="s1">,</span>
    <span class="s1">frameborder: </span><span class="s2">'frameBorder'</span><span class="s1">,</span>
    <span class="s1">headers: </span><span class="s2">'headers'</span><span class="s1">,</span>
    <span class="s1">height: </span><span class="s2">'height'</span><span class="s1">,</span>
    <span class="s1">hidden: </span><span class="s2">'hidden'</span><span class="s1">,</span>
    <span class="s1">high: </span><span class="s2">'high'</span><span class="s1">,</span>
    <span class="s1">href: </span><span class="s2">'href'</span><span class="s1">,</span>
    <span class="s1">hreflang: </span><span class="s2">'hrefLang'</span><span class="s1">,</span>
    <span class="s1">htmlfor: </span><span class="s2">'htmlFor'</span><span class="s1">,</span>
    <span class="s1">httpequiv: </span><span class="s2">'httpEquiv'</span><span class="s1">,</span>
    <span class="s2">'http-equiv'</span><span class="s1">: </span><span class="s2">'httpEquiv'</span><span class="s1">,</span>
    <span class="s1">icon: </span><span class="s2">'icon'</span><span class="s1">,</span>
    <span class="s1">id: </span><span class="s2">'id'</span><span class="s1">,</span>
    <span class="s1">innerhtml: </span><span class="s2">'innerHTML'</span><span class="s1">,</span>
    <span class="s1">inputmode: </span><span class="s2">'inputMode'</span><span class="s1">,</span>
    <span class="s1">integrity: </span><span class="s2">'integrity'</span><span class="s1">,</span>
    <span class="s1">is: </span><span class="s2">'is'</span><span class="s1">,</span>
    <span class="s1">itemid: </span><span class="s2">'itemID'</span><span class="s1">,</span>
    <span class="s1">itemprop: </span><span class="s2">'itemProp'</span><span class="s1">,</span>
    <span class="s1">itemref: </span><span class="s2">'itemRef'</span><span class="s1">,</span>
    <span class="s1">itemscope: </span><span class="s2">'itemScope'</span><span class="s1">,</span>
    <span class="s1">itemtype: </span><span class="s2">'itemType'</span><span class="s1">,</span>
    <span class="s1">keyparams: </span><span class="s2">'keyParams'</span><span class="s1">,</span>
    <span class="s1">keytype: </span><span class="s2">'keyType'</span><span class="s1">,</span>
    <span class="s1">kind: </span><span class="s2">'kind'</span><span class="s1">,</span>
    <span class="s1">label: </span><span class="s2">'label'</span><span class="s1">,</span>
    <span class="s1">lang: </span><span class="s2">'lang'</span><span class="s1">,</span>
    <span class="s1">list: </span><span class="s2">'list'</span><span class="s1">,</span>
    <span class="s1">loop: </span><span class="s2">'loop'</span><span class="s1">,</span>
    <span class="s1">low: </span><span class="s2">'low'</span><span class="s1">,</span>
    <span class="s1">manifest: </span><span class="s2">'manifest'</span><span class="s1">,</span>
    <span class="s1">marginwidth: </span><span class="s2">'marginWidth'</span><span class="s1">,</span>
    <span class="s1">marginheight: </span><span class="s2">'marginHeight'</span><span class="s1">,</span>
    <span class="s1">max: </span><span class="s2">'max'</span><span class="s1">,</span>
    <span class="s1">maxlength: </span><span class="s2">'maxLength'</span><span class="s1">,</span>
    <span class="s1">media: </span><span class="s2">'media'</span><span class="s1">,</span>
    <span class="s1">mediagroup: </span><span class="s2">'mediaGroup'</span><span class="s1">,</span>
    <span class="s1">method: </span><span class="s2">'method'</span><span class="s1">,</span>
    <span class="s1">min: </span><span class="s2">'min'</span><span class="s1">,</span>
    <span class="s1">minlength: </span><span class="s2">'minLength'</span><span class="s1">,</span>
    <span class="s1">multiple: </span><span class="s2">'multiple'</span><span class="s1">,</span>
    <span class="s1">muted: </span><span class="s2">'muted'</span><span class="s1">,</span>
    <span class="s1">name: </span><span class="s2">'name'</span><span class="s1">,</span>
    <span class="s1">nomodule: </span><span class="s2">'noModule'</span><span class="s1">,</span>
    <span class="s1">nonce: </span><span class="s2">'nonce'</span><span class="s1">,</span>
    <span class="s1">novalidate: </span><span class="s2">'noValidate'</span><span class="s1">,</span>
    <span class="s1">open: </span><span class="s2">'open'</span><span class="s1">,</span>
    <span class="s1">optimum: </span><span class="s2">'optimum'</span><span class="s1">,</span>
    <span class="s1">pattern: </span><span class="s2">'pattern'</span><span class="s1">,</span>
    <span class="s1">placeholder: </span><span class="s2">'placeholder'</span><span class="s1">,</span>
    <span class="s1">playsinline: </span><span class="s2">'playsInline'</span><span class="s1">,</span>
    <span class="s1">poster: </span><span class="s2">'poster'</span><span class="s1">,</span>
    <span class="s1">preload: </span><span class="s2">'preload'</span><span class="s1">,</span>
    <span class="s1">profile: </span><span class="s2">'profile'</span><span class="s1">,</span>
    <span class="s1">radiogroup: </span><span class="s2">'radioGroup'</span><span class="s1">,</span>
    <span class="s1">readonly: </span><span class="s2">'readOnly'</span><span class="s1">,</span>
    <span class="s1">referrerpolicy: </span><span class="s2">'referrerPolicy'</span><span class="s1">,</span>
    <span class="s1">rel: </span><span class="s2">'rel'</span><span class="s1">,</span>
    <span class="s1">required: </span><span class="s2">'required'</span><span class="s1">,</span>
    <span class="s1">reversed: </span><span class="s2">'reversed'</span><span class="s1">,</span>
    <span class="s1">role: </span><span class="s2">'role'</span><span class="s1">,</span>
    <span class="s1">rows: </span><span class="s2">'rows'</span><span class="s1">,</span>
    <span class="s1">rowspan: </span><span class="s2">'rowSpan'</span><span class="s1">,</span>
    <span class="s1">sandbox: </span><span class="s2">'sandbox'</span><span class="s1">,</span>
    <span class="s1">scope: </span><span class="s2">'scope'</span><span class="s1">,</span>
    <span class="s1">scoped: </span><span class="s2">'scoped'</span><span class="s1">,</span>
    <span class="s1">scrolling: </span><span class="s2">'scrolling'</span><span class="s1">,</span>
    <span class="s1">seamless: </span><span class="s2">'seamless'</span><span class="s1">,</span>
    <span class="s1">selected: </span><span class="s2">'selected'</span><span class="s1">,</span>
    <span class="s1">shape: </span><span class="s2">'shape'</span><span class="s1">,</span>
    <span class="s1">size: </span><span class="s2">'size'</span><span class="s1">,</span>
    <span class="s1">sizes: </span><span class="s2">'sizes'</span><span class="s1">,</span>
    <span class="s1">span: </span><span class="s2">'span'</span><span class="s1">,</span>
    <span class="s1">spellcheck: </span><span class="s2">'spellCheck'</span><span class="s1">,</span>
    <span class="s1">src: </span><span class="s2">'src'</span><span class="s1">,</span>
    <span class="s1">srcdoc: </span><span class="s2">'srcDoc'</span><span class="s1">,</span>
    <span class="s1">srclang: </span><span class="s2">'srcLang'</span><span class="s1">,</span>
    <span class="s1">srcset: </span><span class="s2">'srcSet'</span><span class="s1">,</span>
    <span class="s1">start: </span><span class="s2">'start'</span><span class="s1">,</span>
    <span class="s1">step: </span><span class="s2">'step'</span><span class="s1">,</span>
    <span class="s1">style: </span><span class="s2">'style'</span><span class="s1">,</span>
    <span class="s1">summary: </span><span class="s2">'summary'</span><span class="s1">,</span>
    <span class="s1">tabindex: </span><span class="s2">'tabIndex'</span><span class="s1">,</span>
    <span class="s1">target: </span><span class="s2">'target'</span><span class="s1">,</span>
    <span class="s1">title: </span><span class="s2">'title'</span><span class="s1">,</span>
    <span class="s1">type: </span><span class="s2">'type'</span><span class="s1">,</span>
    <span class="s1">usemap: </span><span class="s2">'useMap'</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">'value'</span><span class="s1">,</span>
    <span class="s1">width: </span><span class="s2">'width'</span><span class="s1">,</span>
    <span class="s1">wmode: </span><span class="s2">'wmode'</span><span class="s1">,</span>
    <span class="s1">wrap: </span><span class="s2">'wrap'</span><span class="s1">,</span>
    <span class="s0">// SVG</span>
    <span class="s1">about: </span><span class="s2">'about'</span><span class="s1">,</span>
    <span class="s1">accentheight: </span><span class="s2">'accentHeight'</span><span class="s1">,</span>
    <span class="s2">'accent-height'</span><span class="s1">: </span><span class="s2">'accentHeight'</span><span class="s1">,</span>
    <span class="s1">accumulate: </span><span class="s2">'accumulate'</span><span class="s1">,</span>
    <span class="s1">additive: </span><span class="s2">'additive'</span><span class="s1">,</span>
    <span class="s1">alignmentbaseline: </span><span class="s2">'alignmentBaseline'</span><span class="s1">,</span>
    <span class="s2">'alignment-baseline'</span><span class="s1">: </span><span class="s2">'alignmentBaseline'</span><span class="s1">,</span>
    <span class="s1">allowreorder: </span><span class="s2">'allowReorder'</span><span class="s1">,</span>
    <span class="s1">alphabetic: </span><span class="s2">'alphabetic'</span><span class="s1">,</span>
    <span class="s1">amplitude: </span><span class="s2">'amplitude'</span><span class="s1">,</span>
    <span class="s1">arabicform: </span><span class="s2">'arabicForm'</span><span class="s1">,</span>
    <span class="s2">'arabic-form'</span><span class="s1">: </span><span class="s2">'arabicForm'</span><span class="s1">,</span>
    <span class="s1">ascent: </span><span class="s2">'ascent'</span><span class="s1">,</span>
    <span class="s1">attributename: </span><span class="s2">'attributeName'</span><span class="s1">,</span>
    <span class="s1">attributetype: </span><span class="s2">'attributeType'</span><span class="s1">,</span>
    <span class="s1">autoreverse: </span><span class="s2">'autoReverse'</span><span class="s1">,</span>
    <span class="s1">azimuth: </span><span class="s2">'azimuth'</span><span class="s1">,</span>
    <span class="s1">basefrequency: </span><span class="s2">'baseFrequency'</span><span class="s1">,</span>
    <span class="s1">baselineshift: </span><span class="s2">'baselineShift'</span><span class="s1">,</span>
    <span class="s2">'baseline-shift'</span><span class="s1">: </span><span class="s2">'baselineShift'</span><span class="s1">,</span>
    <span class="s1">baseprofile: </span><span class="s2">'baseProfile'</span><span class="s1">,</span>
    <span class="s1">bbox: </span><span class="s2">'bbox'</span><span class="s1">,</span>
    <span class="s1">begin: </span><span class="s2">'begin'</span><span class="s1">,</span>
    <span class="s1">bias: </span><span class="s2">'bias'</span><span class="s1">,</span>
    <span class="s1">by: </span><span class="s2">'by'</span><span class="s1">,</span>
    <span class="s1">calcmode: </span><span class="s2">'calcMode'</span><span class="s1">,</span>
    <span class="s1">capheight: </span><span class="s2">'capHeight'</span><span class="s1">,</span>
    <span class="s2">'cap-height'</span><span class="s1">: </span><span class="s2">'capHeight'</span><span class="s1">,</span>
    <span class="s1">clip: </span><span class="s2">'clip'</span><span class="s1">,</span>
    <span class="s1">clippath: </span><span class="s2">'clipPath'</span><span class="s1">,</span>
    <span class="s2">'clip-path'</span><span class="s1">: </span><span class="s2">'clipPath'</span><span class="s1">,</span>
    <span class="s1">clippathunits: </span><span class="s2">'clipPathUnits'</span><span class="s1">,</span>
    <span class="s1">cliprule: </span><span class="s2">'clipRule'</span><span class="s1">,</span>
    <span class="s2">'clip-rule'</span><span class="s1">: </span><span class="s2">'clipRule'</span><span class="s1">,</span>
    <span class="s1">color: </span><span class="s2">'color'</span><span class="s1">,</span>
    <span class="s1">colorinterpolation: </span><span class="s2">'colorInterpolation'</span><span class="s1">,</span>
    <span class="s2">'color-interpolation'</span><span class="s1">: </span><span class="s2">'colorInterpolation'</span><span class="s1">,</span>
    <span class="s1">colorinterpolationfilters: </span><span class="s2">'colorInterpolationFilters'</span><span class="s1">,</span>
    <span class="s2">'color-interpolation-filters'</span><span class="s1">: </span><span class="s2">'colorInterpolationFilters'</span><span class="s1">,</span>
    <span class="s1">colorprofile: </span><span class="s2">'colorProfile'</span><span class="s1">,</span>
    <span class="s2">'color-profile'</span><span class="s1">: </span><span class="s2">'colorProfile'</span><span class="s1">,</span>
    <span class="s1">colorrendering: </span><span class="s2">'colorRendering'</span><span class="s1">,</span>
    <span class="s2">'color-rendering'</span><span class="s1">: </span><span class="s2">'colorRendering'</span><span class="s1">,</span>
    <span class="s1">contentscripttype: </span><span class="s2">'contentScriptType'</span><span class="s1">,</span>
    <span class="s1">contentstyletype: </span><span class="s2">'contentStyleType'</span><span class="s1">,</span>
    <span class="s1">cursor: </span><span class="s2">'cursor'</span><span class="s1">,</span>
    <span class="s1">cx: </span><span class="s2">'cx'</span><span class="s1">,</span>
    <span class="s1">cy: </span><span class="s2">'cy'</span><span class="s1">,</span>
    <span class="s1">d: </span><span class="s2">'d'</span><span class="s1">,</span>
    <span class="s1">datatype: </span><span class="s2">'datatype'</span><span class="s1">,</span>
    <span class="s1">decelerate: </span><span class="s2">'decelerate'</span><span class="s1">,</span>
    <span class="s1">descent: </span><span class="s2">'descent'</span><span class="s1">,</span>
    <span class="s1">diffuseconstant: </span><span class="s2">'diffuseConstant'</span><span class="s1">,</span>
    <span class="s1">direction: </span><span class="s2">'direction'</span><span class="s1">,</span>
    <span class="s1">display: </span><span class="s2">'display'</span><span class="s1">,</span>
    <span class="s1">divisor: </span><span class="s2">'divisor'</span><span class="s1">,</span>
    <span class="s1">dominantbaseline: </span><span class="s2">'dominantBaseline'</span><span class="s1">,</span>
    <span class="s2">'dominant-baseline'</span><span class="s1">: </span><span class="s2">'dominantBaseline'</span><span class="s1">,</span>
    <span class="s1">dur: </span><span class="s2">'dur'</span><span class="s1">,</span>
    <span class="s1">dx: </span><span class="s2">'dx'</span><span class="s1">,</span>
    <span class="s1">dy: </span><span class="s2">'dy'</span><span class="s1">,</span>
    <span class="s1">edgemode: </span><span class="s2">'edgeMode'</span><span class="s1">,</span>
    <span class="s1">elevation: </span><span class="s2">'elevation'</span><span class="s1">,</span>
    <span class="s1">enablebackground: </span><span class="s2">'enableBackground'</span><span class="s1">,</span>
    <span class="s2">'enable-background'</span><span class="s1">: </span><span class="s2">'enableBackground'</span><span class="s1">,</span>
    <span class="s1">end: </span><span class="s2">'end'</span><span class="s1">,</span>
    <span class="s1">exponent: </span><span class="s2">'exponent'</span><span class="s1">,</span>
    <span class="s1">externalresourcesrequired: </span><span class="s2">'externalResourcesRequired'</span><span class="s1">,</span>
    <span class="s1">fill: </span><span class="s2">'fill'</span><span class="s1">,</span>
    <span class="s1">fillopacity: </span><span class="s2">'fillOpacity'</span><span class="s1">,</span>
    <span class="s2">'fill-opacity'</span><span class="s1">: </span><span class="s2">'fillOpacity'</span><span class="s1">,</span>
    <span class="s1">fillrule: </span><span class="s2">'fillRule'</span><span class="s1">,</span>
    <span class="s2">'fill-rule'</span><span class="s1">: </span><span class="s2">'fillRule'</span><span class="s1">,</span>
    <span class="s1">filter: </span><span class="s2">'filter'</span><span class="s1">,</span>
    <span class="s1">filterres: </span><span class="s2">'filterRes'</span><span class="s1">,</span>
    <span class="s1">filterunits: </span><span class="s2">'filterUnits'</span><span class="s1">,</span>
    <span class="s1">floodopacity: </span><span class="s2">'floodOpacity'</span><span class="s1">,</span>
    <span class="s2">'flood-opacity'</span><span class="s1">: </span><span class="s2">'floodOpacity'</span><span class="s1">,</span>
    <span class="s1">floodcolor: </span><span class="s2">'floodColor'</span><span class="s1">,</span>
    <span class="s2">'flood-color'</span><span class="s1">: </span><span class="s2">'floodColor'</span><span class="s1">,</span>
    <span class="s1">focusable: </span><span class="s2">'focusable'</span><span class="s1">,</span>
    <span class="s1">fontfamily: </span><span class="s2">'fontFamily'</span><span class="s1">,</span>
    <span class="s2">'font-family'</span><span class="s1">: </span><span class="s2">'fontFamily'</span><span class="s1">,</span>
    <span class="s1">fontsize: </span><span class="s2">'fontSize'</span><span class="s1">,</span>
    <span class="s2">'font-size'</span><span class="s1">: </span><span class="s2">'fontSize'</span><span class="s1">,</span>
    <span class="s1">fontsizeadjust: </span><span class="s2">'fontSizeAdjust'</span><span class="s1">,</span>
    <span class="s2">'font-size-adjust'</span><span class="s1">: </span><span class="s2">'fontSizeAdjust'</span><span class="s1">,</span>
    <span class="s1">fontstretch: </span><span class="s2">'fontStretch'</span><span class="s1">,</span>
    <span class="s2">'font-stretch'</span><span class="s1">: </span><span class="s2">'fontStretch'</span><span class="s1">,</span>
    <span class="s1">fontstyle: </span><span class="s2">'fontStyle'</span><span class="s1">,</span>
    <span class="s2">'font-style'</span><span class="s1">: </span><span class="s2">'fontStyle'</span><span class="s1">,</span>
    <span class="s1">fontvariant: </span><span class="s2">'fontVariant'</span><span class="s1">,</span>
    <span class="s2">'font-variant'</span><span class="s1">: </span><span class="s2">'fontVariant'</span><span class="s1">,</span>
    <span class="s1">fontweight: </span><span class="s2">'fontWeight'</span><span class="s1">,</span>
    <span class="s2">'font-weight'</span><span class="s1">: </span><span class="s2">'fontWeight'</span><span class="s1">,</span>
    <span class="s1">format: </span><span class="s2">'format'</span><span class="s1">,</span>
    <span class="s1">from: </span><span class="s2">'from'</span><span class="s1">,</span>
    <span class="s1">fx: </span><span class="s2">'fx'</span><span class="s1">,</span>
    <span class="s1">fy: </span><span class="s2">'fy'</span><span class="s1">,</span>
    <span class="s1">g1: </span><span class="s2">'g1'</span><span class="s1">,</span>
    <span class="s1">g2: </span><span class="s2">'g2'</span><span class="s1">,</span>
    <span class="s1">glyphname: </span><span class="s2">'glyphName'</span><span class="s1">,</span>
    <span class="s2">'glyph-name'</span><span class="s1">: </span><span class="s2">'glyphName'</span><span class="s1">,</span>
    <span class="s1">glyphorientationhorizontal: </span><span class="s2">'glyphOrientationHorizontal'</span><span class="s1">,</span>
    <span class="s2">'glyph-orientation-horizontal'</span><span class="s1">: </span><span class="s2">'glyphOrientationHorizontal'</span><span class="s1">,</span>
    <span class="s1">glyphorientationvertical: </span><span class="s2">'glyphOrientationVertical'</span><span class="s1">,</span>
    <span class="s2">'glyph-orientation-vertical'</span><span class="s1">: </span><span class="s2">'glyphOrientationVertical'</span><span class="s1">,</span>
    <span class="s1">glyphref: </span><span class="s2">'glyphRef'</span><span class="s1">,</span>
    <span class="s1">gradienttransform: </span><span class="s2">'gradientTransform'</span><span class="s1">,</span>
    <span class="s1">gradientunits: </span><span class="s2">'gradientUnits'</span><span class="s1">,</span>
    <span class="s1">hanging: </span><span class="s2">'hanging'</span><span class="s1">,</span>
    <span class="s1">horizadvx: </span><span class="s2">'horizAdvX'</span><span class="s1">,</span>
    <span class="s2">'horiz-adv-x'</span><span class="s1">: </span><span class="s2">'horizAdvX'</span><span class="s1">,</span>
    <span class="s1">horizoriginx: </span><span class="s2">'horizOriginX'</span><span class="s1">,</span>
    <span class="s2">'horiz-origin-x'</span><span class="s1">: </span><span class="s2">'horizOriginX'</span><span class="s1">,</span>
    <span class="s1">ideographic: </span><span class="s2">'ideographic'</span><span class="s1">,</span>
    <span class="s1">imagerendering: </span><span class="s2">'imageRendering'</span><span class="s1">,</span>
    <span class="s2">'image-rendering'</span><span class="s1">: </span><span class="s2">'imageRendering'</span><span class="s1">,</span>
    <span class="s1">in2: </span><span class="s2">'in2'</span><span class="s1">,</span>
    <span class="s3">in</span><span class="s1">: </span><span class="s2">'in'</span><span class="s1">,</span>
    <span class="s1">inlist: </span><span class="s2">'inlist'</span><span class="s1">,</span>
    <span class="s1">intercept: </span><span class="s2">'intercept'</span><span class="s1">,</span>
    <span class="s1">k1: </span><span class="s2">'k1'</span><span class="s1">,</span>
    <span class="s1">k2: </span><span class="s2">'k2'</span><span class="s1">,</span>
    <span class="s1">k3: </span><span class="s2">'k3'</span><span class="s1">,</span>
    <span class="s1">k4: </span><span class="s2">'k4'</span><span class="s1">,</span>
    <span class="s1">k: </span><span class="s2">'k'</span><span class="s1">,</span>
    <span class="s1">kernelmatrix: </span><span class="s2">'kernelMatrix'</span><span class="s1">,</span>
    <span class="s1">kernelunitlength: </span><span class="s2">'kernelUnitLength'</span><span class="s1">,</span>
    <span class="s1">kerning: </span><span class="s2">'kerning'</span><span class="s1">,</span>
    <span class="s1">keypoints: </span><span class="s2">'keyPoints'</span><span class="s1">,</span>
    <span class="s1">keysplines: </span><span class="s2">'keySplines'</span><span class="s1">,</span>
    <span class="s1">keytimes: </span><span class="s2">'keyTimes'</span><span class="s1">,</span>
    <span class="s1">lengthadjust: </span><span class="s2">'lengthAdjust'</span><span class="s1">,</span>
    <span class="s1">letterspacing: </span><span class="s2">'letterSpacing'</span><span class="s1">,</span>
    <span class="s2">'letter-spacing'</span><span class="s1">: </span><span class="s2">'letterSpacing'</span><span class="s1">,</span>
    <span class="s1">lightingcolor: </span><span class="s2">'lightingColor'</span><span class="s1">,</span>
    <span class="s2">'lighting-color'</span><span class="s1">: </span><span class="s2">'lightingColor'</span><span class="s1">,</span>
    <span class="s1">limitingconeangle: </span><span class="s2">'limitingConeAngle'</span><span class="s1">,</span>
    <span class="s1">local: </span><span class="s2">'local'</span><span class="s1">,</span>
    <span class="s1">markerend: </span><span class="s2">'markerEnd'</span><span class="s1">,</span>
    <span class="s2">'marker-end'</span><span class="s1">: </span><span class="s2">'markerEnd'</span><span class="s1">,</span>
    <span class="s1">markerheight: </span><span class="s2">'markerHeight'</span><span class="s1">,</span>
    <span class="s1">markermid: </span><span class="s2">'markerMid'</span><span class="s1">,</span>
    <span class="s2">'marker-mid'</span><span class="s1">: </span><span class="s2">'markerMid'</span><span class="s1">,</span>
    <span class="s1">markerstart: </span><span class="s2">'markerStart'</span><span class="s1">,</span>
    <span class="s2">'marker-start'</span><span class="s1">: </span><span class="s2">'markerStart'</span><span class="s1">,</span>
    <span class="s1">markerunits: </span><span class="s2">'markerUnits'</span><span class="s1">,</span>
    <span class="s1">markerwidth: </span><span class="s2">'markerWidth'</span><span class="s1">,</span>
    <span class="s1">mask: </span><span class="s2">'mask'</span><span class="s1">,</span>
    <span class="s1">maskcontentunits: </span><span class="s2">'maskContentUnits'</span><span class="s1">,</span>
    <span class="s1">maskunits: </span><span class="s2">'maskUnits'</span><span class="s1">,</span>
    <span class="s1">mathematical: </span><span class="s2">'mathematical'</span><span class="s1">,</span>
    <span class="s1">mode: </span><span class="s2">'mode'</span><span class="s1">,</span>
    <span class="s1">numoctaves: </span><span class="s2">'numOctaves'</span><span class="s1">,</span>
    <span class="s1">offset: </span><span class="s2">'offset'</span><span class="s1">,</span>
    <span class="s1">opacity: </span><span class="s2">'opacity'</span><span class="s1">,</span>
    <span class="s1">operator: </span><span class="s2">'operator'</span><span class="s1">,</span>
    <span class="s1">order: </span><span class="s2">'order'</span><span class="s1">,</span>
    <span class="s1">orient: </span><span class="s2">'orient'</span><span class="s1">,</span>
    <span class="s1">orientation: </span><span class="s2">'orientation'</span><span class="s1">,</span>
    <span class="s1">origin: </span><span class="s2">'origin'</span><span class="s1">,</span>
    <span class="s1">overflow: </span><span class="s2">'overflow'</span><span class="s1">,</span>
    <span class="s1">overlineposition: </span><span class="s2">'overlinePosition'</span><span class="s1">,</span>
    <span class="s2">'overline-position'</span><span class="s1">: </span><span class="s2">'overlinePosition'</span><span class="s1">,</span>
    <span class="s1">overlinethickness: </span><span class="s2">'overlineThickness'</span><span class="s1">,</span>
    <span class="s2">'overline-thickness'</span><span class="s1">: </span><span class="s2">'overlineThickness'</span><span class="s1">,</span>
    <span class="s1">paintorder: </span><span class="s2">'paintOrder'</span><span class="s1">,</span>
    <span class="s2">'paint-order'</span><span class="s1">: </span><span class="s2">'paintOrder'</span><span class="s1">,</span>
    <span class="s1">panose1: </span><span class="s2">'panose1'</span><span class="s1">,</span>
    <span class="s2">'panose-1'</span><span class="s1">: </span><span class="s2">'panose1'</span><span class="s1">,</span>
    <span class="s1">pathlength: </span><span class="s2">'pathLength'</span><span class="s1">,</span>
    <span class="s1">patterncontentunits: </span><span class="s2">'patternContentUnits'</span><span class="s1">,</span>
    <span class="s1">patterntransform: </span><span class="s2">'patternTransform'</span><span class="s1">,</span>
    <span class="s1">patternunits: </span><span class="s2">'patternUnits'</span><span class="s1">,</span>
    <span class="s1">pointerevents: </span><span class="s2">'pointerEvents'</span><span class="s1">,</span>
    <span class="s2">'pointer-events'</span><span class="s1">: </span><span class="s2">'pointerEvents'</span><span class="s1">,</span>
    <span class="s1">points: </span><span class="s2">'points'</span><span class="s1">,</span>
    <span class="s1">pointsatx: </span><span class="s2">'pointsAtX'</span><span class="s1">,</span>
    <span class="s1">pointsaty: </span><span class="s2">'pointsAtY'</span><span class="s1">,</span>
    <span class="s1">pointsatz: </span><span class="s2">'pointsAtZ'</span><span class="s1">,</span>
    <span class="s1">prefix: </span><span class="s2">'prefix'</span><span class="s1">,</span>
    <span class="s1">preservealpha: </span><span class="s2">'preserveAlpha'</span><span class="s1">,</span>
    <span class="s1">preserveaspectratio: </span><span class="s2">'preserveAspectRatio'</span><span class="s1">,</span>
    <span class="s1">primitiveunits: </span><span class="s2">'primitiveUnits'</span><span class="s1">,</span>
    <span class="s1">property: </span><span class="s2">'property'</span><span class="s1">,</span>
    <span class="s1">r: </span><span class="s2">'r'</span><span class="s1">,</span>
    <span class="s1">radius: </span><span class="s2">'radius'</span><span class="s1">,</span>
    <span class="s1">refx: </span><span class="s2">'refX'</span><span class="s1">,</span>
    <span class="s1">refy: </span><span class="s2">'refY'</span><span class="s1">,</span>
    <span class="s1">renderingintent: </span><span class="s2">'renderingIntent'</span><span class="s1">,</span>
    <span class="s2">'rendering-intent'</span><span class="s1">: </span><span class="s2">'renderingIntent'</span><span class="s1">,</span>
    <span class="s1">repeatcount: </span><span class="s2">'repeatCount'</span><span class="s1">,</span>
    <span class="s1">repeatdur: </span><span class="s2">'repeatDur'</span><span class="s1">,</span>
    <span class="s1">requiredextensions: </span><span class="s2">'requiredExtensions'</span><span class="s1">,</span>
    <span class="s1">requiredfeatures: </span><span class="s2">'requiredFeatures'</span><span class="s1">,</span>
    <span class="s1">resource: </span><span class="s2">'resource'</span><span class="s1">,</span>
    <span class="s1">restart: </span><span class="s2">'restart'</span><span class="s1">,</span>
    <span class="s1">result: </span><span class="s2">'result'</span><span class="s1">,</span>
    <span class="s1">results: </span><span class="s2">'results'</span><span class="s1">,</span>
    <span class="s1">rotate: </span><span class="s2">'rotate'</span><span class="s1">,</span>
    <span class="s1">rx: </span><span class="s2">'rx'</span><span class="s1">,</span>
    <span class="s1">ry: </span><span class="s2">'ry'</span><span class="s1">,</span>
    <span class="s1">scale: </span><span class="s2">'scale'</span><span class="s1">,</span>
    <span class="s1">security: </span><span class="s2">'security'</span><span class="s1">,</span>
    <span class="s1">seed: </span><span class="s2">'seed'</span><span class="s1">,</span>
    <span class="s1">shaperendering: </span><span class="s2">'shapeRendering'</span><span class="s1">,</span>
    <span class="s2">'shape-rendering'</span><span class="s1">: </span><span class="s2">'shapeRendering'</span><span class="s1">,</span>
    <span class="s1">slope: </span><span class="s2">'slope'</span><span class="s1">,</span>
    <span class="s1">spacing: </span><span class="s2">'spacing'</span><span class="s1">,</span>
    <span class="s1">specularconstant: </span><span class="s2">'specularConstant'</span><span class="s1">,</span>
    <span class="s1">specularexponent: </span><span class="s2">'specularExponent'</span><span class="s1">,</span>
    <span class="s1">speed: </span><span class="s2">'speed'</span><span class="s1">,</span>
    <span class="s1">spreadmethod: </span><span class="s2">'spreadMethod'</span><span class="s1">,</span>
    <span class="s1">startoffset: </span><span class="s2">'startOffset'</span><span class="s1">,</span>
    <span class="s1">stddeviation: </span><span class="s2">'stdDeviation'</span><span class="s1">,</span>
    <span class="s1">stemh: </span><span class="s2">'stemh'</span><span class="s1">,</span>
    <span class="s1">stemv: </span><span class="s2">'stemv'</span><span class="s1">,</span>
    <span class="s1">stitchtiles: </span><span class="s2">'stitchTiles'</span><span class="s1">,</span>
    <span class="s1">stopcolor: </span><span class="s2">'stopColor'</span><span class="s1">,</span>
    <span class="s2">'stop-color'</span><span class="s1">: </span><span class="s2">'stopColor'</span><span class="s1">,</span>
    <span class="s1">stopopacity: </span><span class="s2">'stopOpacity'</span><span class="s1">,</span>
    <span class="s2">'stop-opacity'</span><span class="s1">: </span><span class="s2">'stopOpacity'</span><span class="s1">,</span>
    <span class="s1">strikethroughposition: </span><span class="s2">'strikethroughPosition'</span><span class="s1">,</span>
    <span class="s2">'strikethrough-position'</span><span class="s1">: </span><span class="s2">'strikethroughPosition'</span><span class="s1">,</span>
    <span class="s1">strikethroughthickness: </span><span class="s2">'strikethroughThickness'</span><span class="s1">,</span>
    <span class="s2">'strikethrough-thickness'</span><span class="s1">: </span><span class="s2">'strikethroughThickness'</span><span class="s1">,</span>
    <span class="s1">string: </span><span class="s2">'string'</span><span class="s1">,</span>
    <span class="s1">stroke: </span><span class="s2">'stroke'</span><span class="s1">,</span>
    <span class="s1">strokedasharray: </span><span class="s2">'strokeDasharray'</span><span class="s1">,</span>
    <span class="s2">'stroke-dasharray'</span><span class="s1">: </span><span class="s2">'strokeDasharray'</span><span class="s1">,</span>
    <span class="s1">strokedashoffset: </span><span class="s2">'strokeDashoffset'</span><span class="s1">,</span>
    <span class="s2">'stroke-dashoffset'</span><span class="s1">: </span><span class="s2">'strokeDashoffset'</span><span class="s1">,</span>
    <span class="s1">strokelinecap: </span><span class="s2">'strokeLinecap'</span><span class="s1">,</span>
    <span class="s2">'stroke-linecap'</span><span class="s1">: </span><span class="s2">'strokeLinecap'</span><span class="s1">,</span>
    <span class="s1">strokelinejoin: </span><span class="s2">'strokeLinejoin'</span><span class="s1">,</span>
    <span class="s2">'stroke-linejoin'</span><span class="s1">: </span><span class="s2">'strokeLinejoin'</span><span class="s1">,</span>
    <span class="s1">strokemiterlimit: </span><span class="s2">'strokeMiterlimit'</span><span class="s1">,</span>
    <span class="s2">'stroke-miterlimit'</span><span class="s1">: </span><span class="s2">'strokeMiterlimit'</span><span class="s1">,</span>
    <span class="s1">strokewidth: </span><span class="s2">'strokeWidth'</span><span class="s1">,</span>
    <span class="s2">'stroke-width'</span><span class="s1">: </span><span class="s2">'strokeWidth'</span><span class="s1">,</span>
    <span class="s1">strokeopacity: </span><span class="s2">'strokeOpacity'</span><span class="s1">,</span>
    <span class="s2">'stroke-opacity'</span><span class="s1">: </span><span class="s2">'strokeOpacity'</span><span class="s1">,</span>
    <span class="s1">suppresscontenteditablewarning: </span><span class="s2">'suppressContentEditableWarning'</span><span class="s1">,</span>
    <span class="s1">suppresshydrationwarning: </span><span class="s2">'suppressHydrationWarning'</span><span class="s1">,</span>
    <span class="s1">surfacescale: </span><span class="s2">'surfaceScale'</span><span class="s1">,</span>
    <span class="s1">systemlanguage: </span><span class="s2">'systemLanguage'</span><span class="s1">,</span>
    <span class="s1">tablevalues: </span><span class="s2">'tableValues'</span><span class="s1">,</span>
    <span class="s1">targetx: </span><span class="s2">'targetX'</span><span class="s1">,</span>
    <span class="s1">targety: </span><span class="s2">'targetY'</span><span class="s1">,</span>
    <span class="s1">textanchor: </span><span class="s2">'textAnchor'</span><span class="s1">,</span>
    <span class="s2">'text-anchor'</span><span class="s1">: </span><span class="s2">'textAnchor'</span><span class="s1">,</span>
    <span class="s1">textdecoration: </span><span class="s2">'textDecoration'</span><span class="s1">,</span>
    <span class="s2">'text-decoration'</span><span class="s1">: </span><span class="s2">'textDecoration'</span><span class="s1">,</span>
    <span class="s1">textlength: </span><span class="s2">'textLength'</span><span class="s1">,</span>
    <span class="s1">textrendering: </span><span class="s2">'textRendering'</span><span class="s1">,</span>
    <span class="s2">'text-rendering'</span><span class="s1">: </span><span class="s2">'textRendering'</span><span class="s1">,</span>
    <span class="s1">to: </span><span class="s2">'to'</span><span class="s1">,</span>
    <span class="s1">transform: </span><span class="s2">'transform'</span><span class="s1">,</span>
    <span class="s3">typeof</span><span class="s1">: </span><span class="s2">'typeof'</span><span class="s1">,</span>
    <span class="s1">u1: </span><span class="s2">'u1'</span><span class="s1">,</span>
    <span class="s1">u2: </span><span class="s2">'u2'</span><span class="s1">,</span>
    <span class="s1">underlineposition: </span><span class="s2">'underlinePosition'</span><span class="s1">,</span>
    <span class="s2">'underline-position'</span><span class="s1">: </span><span class="s2">'underlinePosition'</span><span class="s1">,</span>
    <span class="s1">underlinethickness: </span><span class="s2">'underlineThickness'</span><span class="s1">,</span>
    <span class="s2">'underline-thickness'</span><span class="s1">: </span><span class="s2">'underlineThickness'</span><span class="s1">,</span>
    <span class="s1">unicode: </span><span class="s2">'unicode'</span><span class="s1">,</span>
    <span class="s1">unicodebidi: </span><span class="s2">'unicodeBidi'</span><span class="s1">,</span>
    <span class="s2">'unicode-bidi'</span><span class="s1">: </span><span class="s2">'unicodeBidi'</span><span class="s1">,</span>
    <span class="s1">unicoderange: </span><span class="s2">'unicodeRange'</span><span class="s1">,</span>
    <span class="s2">'unicode-range'</span><span class="s1">: </span><span class="s2">'unicodeRange'</span><span class="s1">,</span>
    <span class="s1">unitsperem: </span><span class="s2">'unitsPerEm'</span><span class="s1">,</span>
    <span class="s2">'units-per-em'</span><span class="s1">: </span><span class="s2">'unitsPerEm'</span><span class="s1">,</span>
    <span class="s1">unselectable: </span><span class="s2">'unselectable'</span><span class="s1">,</span>
    <span class="s1">valphabetic: </span><span class="s2">'vAlphabetic'</span><span class="s1">,</span>
    <span class="s2">'v-alphabetic'</span><span class="s1">: </span><span class="s2">'vAlphabetic'</span><span class="s1">,</span>
    <span class="s1">values: </span><span class="s2">'values'</span><span class="s1">,</span>
    <span class="s1">vectoreffect: </span><span class="s2">'vectorEffect'</span><span class="s1">,</span>
    <span class="s2">'vector-effect'</span><span class="s1">: </span><span class="s2">'vectorEffect'</span><span class="s1">,</span>
    <span class="s1">version: </span><span class="s2">'version'</span><span class="s1">,</span>
    <span class="s1">vertadvy: </span><span class="s2">'vertAdvY'</span><span class="s1">,</span>
    <span class="s2">'vert-adv-y'</span><span class="s1">: </span><span class="s2">'vertAdvY'</span><span class="s1">,</span>
    <span class="s1">vertoriginx: </span><span class="s2">'vertOriginX'</span><span class="s1">,</span>
    <span class="s2">'vert-origin-x'</span><span class="s1">: </span><span class="s2">'vertOriginX'</span><span class="s1">,</span>
    <span class="s1">vertoriginy: </span><span class="s2">'vertOriginY'</span><span class="s1">,</span>
    <span class="s2">'vert-origin-y'</span><span class="s1">: </span><span class="s2">'vertOriginY'</span><span class="s1">,</span>
    <span class="s1">vhanging: </span><span class="s2">'vHanging'</span><span class="s1">,</span>
    <span class="s2">'v-hanging'</span><span class="s1">: </span><span class="s2">'vHanging'</span><span class="s1">,</span>
    <span class="s1">videographic: </span><span class="s2">'vIdeographic'</span><span class="s1">,</span>
    <span class="s2">'v-ideographic'</span><span class="s1">: </span><span class="s2">'vIdeographic'</span><span class="s1">,</span>
    <span class="s1">viewbox: </span><span class="s2">'viewBox'</span><span class="s1">,</span>
    <span class="s1">viewtarget: </span><span class="s2">'viewTarget'</span><span class="s1">,</span>
    <span class="s1">visibility: </span><span class="s2">'visibility'</span><span class="s1">,</span>
    <span class="s1">vmathematical: </span><span class="s2">'vMathematical'</span><span class="s1">,</span>
    <span class="s2">'v-mathematical'</span><span class="s1">: </span><span class="s2">'vMathematical'</span><span class="s1">,</span>
    <span class="s1">vocab: </span><span class="s2">'vocab'</span><span class="s1">,</span>
    <span class="s1">widths: </span><span class="s2">'widths'</span><span class="s1">,</span>
    <span class="s1">wordspacing: </span><span class="s2">'wordSpacing'</span><span class="s1">,</span>
    <span class="s2">'word-spacing'</span><span class="s1">: </span><span class="s2">'wordSpacing'</span><span class="s1">,</span>
    <span class="s1">writingmode: </span><span class="s2">'writingMode'</span><span class="s1">,</span>
    <span class="s2">'writing-mode'</span><span class="s1">: </span><span class="s2">'writingMode'</span><span class="s1">,</span>
    <span class="s1">x1: </span><span class="s2">'x1'</span><span class="s1">,</span>
    <span class="s1">x2: </span><span class="s2">'x2'</span><span class="s1">,</span>
    <span class="s1">x: </span><span class="s2">'x'</span><span class="s1">,</span>
    <span class="s1">xchannelselector: </span><span class="s2">'xChannelSelector'</span><span class="s1">,</span>
    <span class="s1">xheight: </span><span class="s2">'xHeight'</span><span class="s1">,</span>
    <span class="s2">'x-height'</span><span class="s1">: </span><span class="s2">'xHeight'</span><span class="s1">,</span>
    <span class="s1">xlinkactuate: </span><span class="s2">'xlinkActuate'</span><span class="s1">,</span>
    <span class="s2">'xlink:actuate'</span><span class="s1">: </span><span class="s2">'xlinkActuate'</span><span class="s1">,</span>
    <span class="s1">xlinkarcrole: </span><span class="s2">'xlinkArcrole'</span><span class="s1">,</span>
    <span class="s2">'xlink:arcrole'</span><span class="s1">: </span><span class="s2">'xlinkArcrole'</span><span class="s1">,</span>
    <span class="s1">xlinkhref: </span><span class="s2">'xlinkHref'</span><span class="s1">,</span>
    <span class="s2">'xlink:href'</span><span class="s1">: </span><span class="s2">'xlinkHref'</span><span class="s1">,</span>
    <span class="s1">xlinkrole: </span><span class="s2">'xlinkRole'</span><span class="s1">,</span>
    <span class="s2">'xlink:role'</span><span class="s1">: </span><span class="s2">'xlinkRole'</span><span class="s1">,</span>
    <span class="s1">xlinkshow: </span><span class="s2">'xlinkShow'</span><span class="s1">,</span>
    <span class="s2">'xlink:show'</span><span class="s1">: </span><span class="s2">'xlinkShow'</span><span class="s1">,</span>
    <span class="s1">xlinktitle: </span><span class="s2">'xlinkTitle'</span><span class="s1">,</span>
    <span class="s2">'xlink:title'</span><span class="s1">: </span><span class="s2">'xlinkTitle'</span><span class="s1">,</span>
    <span class="s1">xlinktype: </span><span class="s2">'xlinkType'</span><span class="s1">,</span>
    <span class="s2">'xlink:type'</span><span class="s1">: </span><span class="s2">'xlinkType'</span><span class="s1">,</span>
    <span class="s1">xmlbase: </span><span class="s2">'xmlBase'</span><span class="s1">,</span>
    <span class="s2">'xml:base'</span><span class="s1">: </span><span class="s2">'xmlBase'</span><span class="s1">,</span>
    <span class="s1">xmllang: </span><span class="s2">'xmlLang'</span><span class="s1">,</span>
    <span class="s2">'xml:lang'</span><span class="s1">: </span><span class="s2">'xmlLang'</span><span class="s1">,</span>
    <span class="s1">xmlns: </span><span class="s2">'xmlns'</span><span class="s1">,</span>
    <span class="s2">'xml:space'</span><span class="s1">: </span><span class="s2">'xmlSpace'</span><span class="s1">,</span>
    <span class="s1">xmlnsxlink: </span><span class="s2">'xmlnsXlink'</span><span class="s1">,</span>
    <span class="s2">'xmlns:xlink'</span><span class="s1">: </span><span class="s2">'xmlnsXlink'</span><span class="s1">,</span>
    <span class="s1">xmlspace: </span><span class="s2">'xmlSpace'</span><span class="s1">,</span>
    <span class="s1">y1: </span><span class="s2">'y1'</span><span class="s1">,</span>
    <span class="s1">y2: </span><span class="s2">'y2'</span><span class="s1">,</span>
    <span class="s1">y: </span><span class="s2">'y'</span><span class="s1">,</span>
    <span class="s1">ychannelselector: </span><span class="s2">'yChannelSelector'</span><span class="s1">,</span>
    <span class="s1">z: </span><span class="s2">'z'</span><span class="s1">,</span>
    <span class="s1">zoomandpan: </span><span class="s2">'zoomAndPan'</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">ariaProperties = {</span>
    <span class="s2">'aria-current'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// state</span>
    <span class="s2">'aria-details'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-disabled'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// state</span>
    <span class="s2">'aria-hidden'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// state</span>
    <span class="s2">'aria-invalid'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// state</span>
    <span class="s2">'aria-keyshortcuts'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-label'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-roledescription'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// Widget Attributes</span>
    <span class="s2">'aria-autocomplete'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-checked'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-expanded'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-haspopup'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-level'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-modal'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-multiline'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-multiselectable'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-orientation'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-placeholder'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-pressed'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-readonly'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-required'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-selected'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-sort'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-valuemax'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-valuemin'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-valuenow'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-valuetext'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// Live Region Attributes</span>
    <span class="s2">'aria-atomic'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-busy'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-live'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-relevant'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// Drag-and-Drop Attributes</span>
    <span class="s2">'aria-dropeffect'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-grabbed'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s0">// Relationship Attributes</span>
    <span class="s2">'aria-activedescendant'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-colcount'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-colindex'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-colspan'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-controls'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-describedby'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-errormessage'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-flowto'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-labelledby'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-owns'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-posinset'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-rowcount'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-rowindex'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-rowspan'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s2">'aria-setsize'</span><span class="s1">: </span><span class="s4">0</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">warnedProperties = {};</span>
  <span class="s3">var </span><span class="s1">rARIA = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^(aria)-[' </span><span class="s1">+ ATTRIBUTE_NAME_CHAR + </span><span class="s2">']*$'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">rARIACamel = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^(aria)[A-Z][' </span><span class="s1">+ ATTRIBUTE_NAME_CHAR + </span><span class="s2">']*$'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">hasOwnProperty$1 = Object.prototype.hasOwnProperty;</span>

  <span class="s3">function </span><span class="s1">validateProperty(tagName, name) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(hasOwnProperty$1.call(warnedProperties, name) &amp;&amp; warnedProperties[name]) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(rARIACamel.test(name)) {</span>
        <span class="s3">var </span><span class="s1">ariaName = </span><span class="s2">'aria-' </span><span class="s1">+ name.slice(</span><span class="s4">4</span><span class="s1">).toLowerCase();</span>
        <span class="s3">var </span><span class="s1">correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// If this is an aria-* attribute, but is not listed in the known DOM</span>
        <span class="s0">// DOM properties, then it is an invalid aria-* attribute.</span>

        <span class="s3">if </span><span class="s1">(correctName == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.'</span><span class="s1">, name);</span>

          <span class="s1">warnedProperties[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


        <span class="s3">if </span><span class="s1">(name !== correctName) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid ARIA attribute `%s`. Did you mean `%s`?'</span><span class="s1">, name, correctName);</span>

          <span class="s1">warnedProperties[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(rARIA.test(name)) {</span>
        <span class="s3">var </span><span class="s1">lowerCasedName = name.toLowerCase();</span>
        <span class="s3">var </span><span class="s1">standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// If this is an aria-* attribute, but is not listed in the known DOM</span>
        <span class="s0">// DOM properties, then it is an invalid aria-* attribute.</span>

        <span class="s3">if </span><span class="s1">(standardName == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">warnedProperties[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


        <span class="s3">if </span><span class="s1">(name !== standardName) {</span>
          <span class="s1">error(</span><span class="s2">'Unknown ARIA attribute `%s`. Did you mean `%s`?'</span><span class="s1">, name, standardName);</span>

          <span class="s1">warnedProperties[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnInvalidARIAProps(type, props) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">invalidProps = [];</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">props) {</span>
        <span class="s3">var </span><span class="s1">isValid = validateProperty(type, key);</span>

        <span class="s3">if </span><span class="s1">(!isValid) {</span>
          <span class="s1">invalidProps.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">unknownPropString = invalidProps.map(</span><span class="s3">function </span><span class="s1">(prop) {</span>
        <span class="s3">return </span><span class="s2">'`' </span><span class="s1">+ prop + </span><span class="s2">'`'</span><span class="s1">;</span>
      <span class="s1">}).join(</span><span class="s2">', '</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(invalidProps.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Invalid aria prop %s on &lt;%s&gt; tag. ' </span><span class="s1">+ </span><span class="s2">'For details, see https://fb.me/invalid-aria-prop'</span><span class="s1">, unknownPropString, type);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(invalidProps.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Invalid aria props %s on &lt;%s&gt; tag. ' </span><span class="s1">+ </span><span class="s2">'For details, see https://fb.me/invalid-aria-prop'</span><span class="s1">, unknownPropString, type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateProperties(type, props) {</span>
    <span class="s3">if </span><span class="s1">(isCustomComponent(type, props)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">warnInvalidARIAProps(type, props);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnValueNull = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">validateProperties$1(type, props) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(type !== </span><span class="s2">'input' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">'textarea' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">'select'</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(props != </span><span class="s3">null </span><span class="s1">&amp;&amp; props.value === </span><span class="s3">null </span><span class="s1">&amp;&amp; !didWarnValueNull) {</span>
        <span class="s1">didWarnValueNull = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'select' </span><span class="s1">&amp;&amp; props.multiple) {</span>
          <span class="s1">error(</span><span class="s2">'`value` prop on `%s` should not be null. ' </span><span class="s1">+ </span><span class="s2">'Consider using an empty array when `multiple` is set to `true` ' </span><span class="s1">+ </span><span class="s2">'to clear the component or `undefined` for uncontrolled components.'</span><span class="s1">, type);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s2">'`value` prop on `%s` should not be null. ' </span><span class="s1">+ </span><span class="s2">'Consider using an empty string to clear the component or `undefined` ' </span><span class="s1">+ </span><span class="s2">'for uncontrolled components.'</span><span class="s1">, type);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">validateProperty$1 = </span><span class="s3">function </span><span class="s1">() {};</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">warnedProperties$1 = {};</span>
    <span class="s3">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>
    <span class="s3">var </span><span class="s1">EVENT_NAME_REGEX = /^on./;</span>
    <span class="s3">var </span><span class="s1">INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;</span>
    <span class="s3">var </span><span class="s1">rARIA$1 = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^(aria)-[' </span><span class="s1">+ ATTRIBUTE_NAME_CHAR + </span><span class="s2">']*$'</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">rARIACamel$1 = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^(aria)[A-Z][' </span><span class="s1">+ ATTRIBUTE_NAME_CHAR + </span><span class="s2">']*$'</span><span class="s1">);</span>

    <span class="s1">validateProperty$1 = </span><span class="s3">function </span><span class="s1">(tagName, name, value, canUseEventSystem) {</span>
      <span class="s3">if </span><span class="s1">(_hasOwnProperty.call(warnedProperties$1, name) &amp;&amp; warnedProperties$1[name]) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">lowerCasedName = name.toLowerCase();</span>

      <span class="s3">if </span><span class="s1">(lowerCasedName === </span><span class="s2">'onfocusin' </span><span class="s1">|| lowerCasedName === </span><span class="s2">'onfocusout'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' </span><span class="s1">+ </span><span class="s2">'All React events are normalized to bubble, so onFocusIn and onFocusOut ' </span><span class="s1">+ </span><span class="s2">'are not needed/supported by React.'</span><span class="s1">);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// We can't rely on the event system being injected on the server.</span>


      <span class="s3">if </span><span class="s1">(canUseEventSystem) {</span>
        <span class="s3">if </span><span class="s1">(registrationNameModules.hasOwnProperty(name)) {</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(registrationName != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid event handler property `%s`. Did you mean `%s`?'</span><span class="s1">, name, registrationName);</span>

          <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(EVENT_NAME_REGEX.test(name)) {</span>
          <span class="s1">error(</span><span class="s2">'Unknown event handler property `%s`. It will be ignored.'</span><span class="s1">, name);</span>

          <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(EVENT_NAME_REGEX.test(name)) {</span>
        <span class="s0">// If no event plugins have been injected, we are in a server environment.</span>
        <span class="s0">// So we can't tell if the event name is correct for sure, but we can filter</span>
        <span class="s0">// out known bad ones like `onclick`. We can't suggest a specific replacement though.</span>
        <span class="s3">if </span><span class="s1">(INVALID_EVENT_NAME_REGEX.test(name)) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid event handler property `%s`. ' </span><span class="s1">+ </span><span class="s2">'React events use the camelCase naming convention, for example `onClick`.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Let the ARIA attribute hook validate ARIA attributes</span>


      <span class="s3">if </span><span class="s1">(rARIA$1.test(name) || rARIACamel$1.test(name)) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(lowerCasedName === </span><span class="s2">'innerhtml'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Directly setting property `innerHTML` is not permitted. ' </span><span class="s1">+ </span><span class="s2">'For more information, lookup documentation on `dangerouslySetInnerHTML`.'</span><span class="s1">);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(lowerCasedName === </span><span class="s2">'aria'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'The `aria` attribute is reserved for future use in React. ' </span><span class="s1">+ </span><span class="s2">'Pass individual `aria-` attributes instead.'</span><span class="s1">);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(lowerCasedName === </span><span class="s2">'is' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; value !== undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">value !== </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Received a `%s` for a string attribute `is`. If this is expected, cast ' </span><span class="s1">+ </span><span class="s2">'the value to a string.'</span><span class="s1">, </span><span class="s3">typeof </span><span class="s1">value);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; isNaN(value)) {</span>
        <span class="s1">error(</span><span class="s2">'Received NaN for the `%s` attribute. If this is expected, cast ' </span><span class="s1">+ </span><span class="s2">'the value to a string.'</span><span class="s1">, name);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">propertyInfo = getPropertyInfo(name);</span>
      <span class="s3">var </span><span class="s1">isReserved = propertyInfo !== </span><span class="s3">null </span><span class="s1">&amp;&amp; propertyInfo.type === RESERVED; </span><span class="s0">// Known attributes should match the casing specified in the property config.</span>

      <span class="s3">if </span><span class="s1">(possibleStandardNames.hasOwnProperty(lowerCasedName)) {</span>
        <span class="s3">var </span><span class="s1">standardName = possibleStandardNames[lowerCasedName];</span>

        <span class="s3">if </span><span class="s1">(standardName !== name) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid DOM property `%s`. Did you mean `%s`?'</span><span class="s1">, name, standardName);</span>

          <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!isReserved &amp;&amp; name !== lowerCasedName) {</span>
        <span class="s0">// Unknown attributes should have lowercase casing since that's how they</span>
        <span class="s0">// will be cased anyway with server rendering.</span>
        <span class="s1">error(</span><span class="s2">'React does not recognize the `%s` prop on a DOM element. If you ' </span><span class="s1">+ </span><span class="s2">'intentionally want it to appear in the DOM as a custom ' </span><span class="s1">+ </span><span class="s2">'attribute, spell it as lowercase `%s` instead. ' </span><span class="s1">+ </span><span class="s2">'If you accidentally passed it from a parent component, remove ' </span><span class="s1">+ </span><span class="s2">'it from the DOM element.'</span><span class="s1">, name, lowerCasedName);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'boolean' </span><span class="s1">&amp;&amp; shouldRemoveAttributeWithWarning(name, value, propertyInfo, </span><span class="s3">false</span><span class="s1">)) {</span>
        <span class="s3">if </span><span class="s1">(value) {</span>
          <span class="s1">error(</span><span class="s2">'Received `%s` for a non-boolean attribute `%s`.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'If you want to write it to the DOM, pass a string instead: ' </span><span class="s1">+ </span><span class="s2">'%s=&quot;%s&quot; or %s={value.toString()}.'</span><span class="s1">, value, name, name, value, name);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s2">'Received `%s` for a non-boolean attribute `%s`.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'If you want to write it to the DOM, pass a string instead: ' </span><span class="s1">+ </span><span class="s2">'%s=&quot;%s&quot; or %s={value.toString()}.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'If you used to conditionally omit it with %s={condition &amp;&amp; value}, ' </span><span class="s1">+ </span><span class="s2">'pass %s={condition ? value : undefined} instead.'</span><span class="s1">, value, name, name, value, name, name, name);</span>
        <span class="s1">}</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Now that we've validated casing, do not validate</span>
      <span class="s0">// data types for reserved props</span>


      <span class="s3">if </span><span class="s1">(isReserved) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Warn when a known attribute is a bad type</span>


      <span class="s3">if </span><span class="s1">(shouldRemoveAttributeWithWarning(name, value, propertyInfo, </span><span class="s3">false</span><span class="s1">)) {</span>
        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Warn when passing the strings 'false' or 'true' into a boolean prop</span>


      <span class="s3">if </span><span class="s1">((value === </span><span class="s2">'false' </span><span class="s1">|| value === </span><span class="s2">'true'</span><span class="s1">) &amp;&amp; propertyInfo !== </span><span class="s3">null </span><span class="s1">&amp;&amp; propertyInfo.type === BOOLEAN) {</span>
        <span class="s1">error(</span><span class="s2">'Received the string `%s` for the boolean attribute `%s`. ' </span><span class="s1">+ </span><span class="s2">'%s ' </span><span class="s1">+ </span><span class="s2">'Did you mean %s={%s}?'</span><span class="s1">, value, name, value === </span><span class="s2">'false' </span><span class="s1">? </span><span class="s2">'The browser will interpret it as a truthy value.' </span><span class="s1">: </span><span class="s2">'Although this works, it will not work as expected if you pass the string &quot;false&quot;.'</span><span class="s1">, name, value);</span>

        <span class="s1">warnedProperties$1[name] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">warnUnknownProperties = </span><span class="s3">function </span><span class="s1">(type, props, canUseEventSystem) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">unknownProps = [];</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">props) {</span>
        <span class="s3">var </span><span class="s1">isValid = validateProperty$1(type, key, props[key], canUseEventSystem);</span>

        <span class="s3">if </span><span class="s1">(!isValid) {</span>
          <span class="s1">unknownProps.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">unknownPropString = unknownProps.map(</span><span class="s3">function </span><span class="s1">(prop) {</span>
        <span class="s3">return </span><span class="s2">'`' </span><span class="s1">+ prop + </span><span class="s2">'`'</span><span class="s1">;</span>
      <span class="s1">}).join(</span><span class="s2">', '</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(unknownProps.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Invalid value for prop %s on &lt;%s&gt; tag. Either remove it from the element, ' </span><span class="s1">+ </span><span class="s2">'or pass a string or number value to keep it in the DOM. ' </span><span class="s1">+ </span><span class="s2">'For details, see https://fb.me/react-attribute-behavior'</span><span class="s1">, unknownPropString, type);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(unknownProps.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Invalid values for props %s on &lt;%s&gt; tag. Either remove them from the element, ' </span><span class="s1">+ </span><span class="s2">'or pass a string or number value to keep them in the DOM. ' </span><span class="s1">+ </span><span class="s2">'For details, see https://fb.me/react-attribute-behavior'</span><span class="s1">, unknownPropString, type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">validateProperties$2(type, props, canUseEventSystem) {</span>
    <span class="s3">if </span><span class="s1">(isCustomComponent(type, props)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">warnUnknownProperties(type, props, canUseEventSystem);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnInvalidHydration = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DANGEROUSLY_SET_INNER_HTML = </span><span class="s2">'dangerouslySetInnerHTML'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUPPRESS_CONTENT_EDITABLE_WARNING = </span><span class="s2">'suppressContentEditableWarning'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUPPRESS_HYDRATION_WARNING = </span><span class="s2">'suppressHydrationWarning'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">AUTOFOCUS = </span><span class="s2">'autoFocus'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">CHILDREN = </span><span class="s2">'children'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">STYLE = </span><span class="s2">'style'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HTML$1 = </span><span class="s2">'__html'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HTML_NAMESPACE$1 = Namespaces.html;</span>
  <span class="s3">var </span><span class="s1">warnedUnknownTags;</span>
  <span class="s3">var </span><span class="s1">suppressHydrationWarning;</span>
  <span class="s3">var </span><span class="s1">validatePropertiesInDevelopment;</span>
  <span class="s3">var </span><span class="s1">warnForTextDifference;</span>
  <span class="s3">var </span><span class="s1">warnForPropDifference;</span>
  <span class="s3">var </span><span class="s1">warnForExtraAttributes;</span>
  <span class="s3">var </span><span class="s1">warnForInvalidEventListener;</span>
  <span class="s3">var </span><span class="s1">canDiffStyleForHydrationWarning;</span>
  <span class="s3">var </span><span class="s1">normalizeMarkupForTextOrAttribute;</span>
  <span class="s3">var </span><span class="s1">normalizeHTML;</span>

  <span class="s1">{</span>
    <span class="s1">warnedUnknownTags = {</span>
      <span class="s0">// Chrome is the only major browser not shipping &lt;time&gt;. But as of July</span>
      <span class="s0">// 2017 it intends to ship it due to widespread usage. We intentionally</span>
      <span class="s0">// *don't* warn for &lt;time&gt; even if it's unrecognized by Chrome because</span>
      <span class="s0">// it soon will be, and many apps have been using it anyway.</span>
      <span class="s1">time: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s0">// There are working polyfills for &lt;dialog&gt;. Let people use it.</span>
      <span class="s1">dialog: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s0">// Electron ships a custom &lt;webview&gt; tag to display external web content in</span>
      <span class="s0">// an isolated frame and process.</span>
      <span class="s0">// This tag is not present in non Electron environments such as JSDom which</span>
      <span class="s0">// is often used for testing purposes.</span>
      <span class="s0">// @see https://electronjs.org/docs/api/webview-tag</span>
      <span class="s1">webview: </span><span class="s3">true</span>
    <span class="s1">};</span>

    <span class="s1">validatePropertiesInDevelopment = </span><span class="s3">function </span><span class="s1">(type, props) {</span>
      <span class="s1">validateProperties(type, props);</span>
      <span class="s1">validateProperties$1(type, props);</span>
      <span class="s1">validateProperties$2(type, props,</span>
      <span class="s0">/* canUseEventSystem */</span>
      <span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}; </span><span class="s0">// IE 11 parses &amp; normalizes the style attribute as opposed to other</span>
    <span class="s0">// browsers. It adds spaces and sorts the properties in some</span>
    <span class="s0">// non-alphabetical order. Handling that would require sorting CSS</span>
    <span class="s0">// properties in the client &amp; server versions or applying</span>
    <span class="s0">// `expectedStyle` to a temporary DOM node to read its `style` attribute</span>
    <span class="s0">// normalized. Since it only affects IE, we're skipping style warnings</span>
    <span class="s0">// in that browser completely in favor of doing all that work.</span>
    <span class="s0">// See https://github.com/facebook/react/issues/11807</span>


    <span class="s1">canDiffStyleForHydrationWarning = canUseDOM &amp;&amp; !document.documentMode; </span><span class="s0">// HTML parsing normalizes CR and CRLF to LF.</span>
    <span class="s0">// It also can turn \u0000 into \uFFFD inside attributes.</span>
    <span class="s0">// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream</span>
    <span class="s0">// If we have a mismatch, it might be caused by that.</span>
    <span class="s0">// We will still patch up in this case but not fire the warning.</span>

    <span class="s3">var </span><span class="s1">NORMALIZE_NEWLINES_REGEX = /\r\n?/g;</span>
    <span class="s3">var </span><span class="s1">NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;</span>

    <span class="s1">normalizeMarkupForTextOrAttribute = </span><span class="s3">function </span><span class="s1">(markup) {</span>
      <span class="s3">var </span><span class="s1">markupString = </span><span class="s3">typeof </span><span class="s1">markup === </span><span class="s2">'string' </span><span class="s1">? markup : </span><span class="s2">'' </span><span class="s1">+ markup;</span>
      <span class="s3">return </span><span class="s1">markupString.replace(NORMALIZE_NEWLINES_REGEX, </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, </span><span class="s2">''</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s1">warnForTextDifference = </span><span class="s3">function </span><span class="s1">(serverText, clientText) {</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);</span>
      <span class="s3">var </span><span class="s1">normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);</span>

      <span class="s3">if </span><span class="s1">(normalizedServerText === normalizedClientText) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Text content did not match. Server: &quot;%s&quot; Client: &quot;%s&quot;'</span><span class="s1">, normalizedServerText, normalizedClientText);</span>
    <span class="s1">};</span>

    <span class="s1">warnForPropDifference = </span><span class="s3">function </span><span class="s1">(propName, serverValue, clientValue) {</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);</span>
      <span class="s3">var </span><span class="s1">normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);</span>

      <span class="s3">if </span><span class="s1">(normalizedServerValue === normalizedClientValue) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Prop `%s` did not match. Server: %s Client: %s'</span><span class="s1">, propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));</span>
    <span class="s1">};</span>

    <span class="s1">warnForExtraAttributes = </span><span class="s3">function </span><span class="s1">(attributeNames) {</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">names = [];</span>
      <span class="s1">attributeNames.forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
        <span class="s1">names.push(name);</span>
      <span class="s1">});</span>

      <span class="s1">error(</span><span class="s2">'Extra attributes from the server: %s'</span><span class="s1">, names);</span>
    <span class="s1">};</span>

    <span class="s1">warnForInvalidEventListener = </span><span class="s3">function </span><span class="s1">(registrationName, listener) {</span>
      <span class="s3">if </span><span class="s1">(listener === </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Expected `%s` listener to be a function, instead got `false`.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'If you used to conditionally omit it with %s={condition &amp;&amp; value}, ' </span><span class="s1">+ </span><span class="s2">'pass %s={condition ? value : undefined} instead.'</span><span class="s1">, registrationName, registrationName, registrationName);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'Expected `%s` listener to be a function, instead got a value of `%s` type.'</span><span class="s1">, registrationName, </span><span class="s3">typeof </span><span class="s1">listener);</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// Parse the HTML and read it back to normalize the HTML string so that it</span>
    <span class="s0">// can be used for comparison.</span>


    <span class="s1">normalizeHTML = </span><span class="s3">function </span><span class="s1">(parent, html) {</span>
      <span class="s0">// We could have created a separate document here to avoid</span>
      <span class="s0">// re-initializing custom elements if they exist. But this breaks</span>
      <span class="s0">// how &lt;noscript&gt; is being handled. So we use the same document.</span>
      <span class="s0">// See the discussion in https://github.com/facebook/react/pull/11157.</span>
      <span class="s3">var </span><span class="s1">testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);</span>
      <span class="s1">testElement.innerHTML = html;</span>
      <span class="s3">return </span><span class="s1">testElement.innerHTML;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">ensureListeningTo(rootContainerElement, registrationName) {</span>
    <span class="s3">var </span><span class="s1">isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;</span>
    <span class="s3">var </span><span class="s1">doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;</span>
    <span class="s1">legacyListenToEvent(registrationName, doc);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getOwnerDocumentFromRootContainer(rootContainerElement) {</span>
    <span class="s3">return </span><span class="s1">rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">noop() {}</span>

  <span class="s3">function </span><span class="s1">trapClickOnNonInteractiveElement(node) {</span>
    <span class="s0">// Mobile Safari does not fire properly bubble click events on</span>
    <span class="s0">// non-interactive elements, which means delegated click listeners do not</span>
    <span class="s0">// fire. The workaround for this bug involves attaching an empty click</span>
    <span class="s0">// listener on the target node.</span>
    <span class="s0">// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html</span>
    <span class="s0">// Just set it using the onclick property so that we don't have to manage any</span>
    <span class="s0">// bookkeeping for it. Not sure if we need to clear it when the listener is</span>
    <span class="s0">// removed.</span>
    <span class="s0">// TODO: Only do this for the relevant Safaris maybe?</span>
    <span class="s1">node.onclick = noop;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propKey </span><span class="s3">in </span><span class="s1">nextProps) {</span>
      <span class="s3">if </span><span class="s1">(!nextProps.hasOwnProperty(propKey)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">nextProp = nextProps[propKey];</span>

      <span class="s3">if </span><span class="s1">(propKey === STYLE) {</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(nextProp) {</span>
            <span class="s0">// Freeze the next style object so that we can assume it won't be</span>
            <span class="s0">// mutated. We have already warned for this in the past.</span>
            <span class="s1">Object.freeze(nextProp);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span>


        <span class="s1">setValueForStyles(domElement, nextProp);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === DANGEROUSLY_SET_INNER_HTML) {</span>
        <span class="s3">var </span><span class="s1">nextHtml = nextProp ? nextProp[HTML$1] : undefined;</span>

        <span class="s3">if </span><span class="s1">(nextHtml != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">setInnerHTML(domElement, nextHtml);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === CHILDREN) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'string'</span><span class="s1">) {</span>
          <span class="s0">// Avoid setting initial textContent when the text is empty. In IE11 setting</span>
          <span class="s0">// textContent on a &lt;textarea&gt; will cause the placeholder to not</span>
          <span class="s0">// show within the &lt;textarea&gt; until it has been focused and blurred again.</span>
          <span class="s0">// https://github.com/facebook/react/issues/6731#issuecomment-254874553</span>
          <span class="s3">var </span><span class="s1">canSetTextContent = tag !== </span><span class="s2">'textarea' </span><span class="s1">|| nextProp !== </span><span class="s2">''</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(canSetTextContent) {</span>
            <span class="s1">setTextContent(domElement, nextProp);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'number'</span><span class="s1">) {</span>
          <span class="s1">setTextContent(domElement, </span><span class="s2">'' </span><span class="s1">+ nextProp);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">( propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; </span><span class="s3">else if </span><span class="s1">(propKey === AUTOFOCUS) ; </span><span class="s3">else if </span><span class="s1">(registrationNameModules.hasOwnProperty(propKey)) {</span>
        <span class="s3">if </span><span class="s1">(nextProp != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">( </span><span class="s3">typeof </span><span class="s1">nextProp !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">warnForInvalidEventListener(propKey, nextProp);</span>
          <span class="s1">}</span>

          <span class="s1">ensureListeningTo(rootContainerElement, propKey);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nextProp != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {</span>
    <span class="s0">// TODO: Handle wasCustomComponentTag</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; updatePayload.length; i += </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">propKey = updatePayload[i];</span>
      <span class="s3">var </span><span class="s1">propValue = updatePayload[i + </span><span class="s4">1</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(propKey === STYLE) {</span>
        <span class="s1">setValueForStyles(domElement, propValue);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === DANGEROUSLY_SET_INNER_HTML) {</span>
        <span class="s1">setInnerHTML(domElement, propValue);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === CHILDREN) {</span>
        <span class="s1">setTextContent(domElement, propValue);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createElement(type, props, rootContainerElement, parentNamespace) {</span>
    <span class="s3">var </span><span class="s1">isCustomComponentTag; </span><span class="s0">// We create tags in the namespace of their parent container, except HTML</span>
    <span class="s0">// tags get no namespace.</span>

    <span class="s3">var </span><span class="s1">ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);</span>
    <span class="s3">var </span><span class="s1">domElement;</span>
    <span class="s3">var </span><span class="s1">namespaceURI = parentNamespace;</span>

    <span class="s3">if </span><span class="s1">(namespaceURI === HTML_NAMESPACE$1) {</span>
      <span class="s1">namespaceURI = getIntrinsicNamespace(type);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(namespaceURI === HTML_NAMESPACE$1) {</span>
      <span class="s1">{</span>
        <span class="s1">isCustomComponentTag = isCustomComponent(type, props); </span><span class="s0">// Should this check be gated by parent namespace? Not sure we want to</span>
        <span class="s0">// allow &lt;SVG&gt; or &lt;mATH&gt;.</span>

        <span class="s3">if </span><span class="s1">(!isCustomComponentTag &amp;&amp; type !== type.toLowerCase()) {</span>
          <span class="s1">error(</span><span class="s2">'&lt;%s /&gt; is using incorrect casing. ' </span><span class="s1">+ </span><span class="s2">'Use PascalCase for React components, ' </span><span class="s1">+ </span><span class="s2">'or lowercase for HTML elements.'</span><span class="s1">, type);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'script'</span><span class="s1">) {</span>
        <span class="s0">// Create the script via .innerHTML so its &quot;parser-inserted&quot; flag is</span>
        <span class="s0">// set to true and it does not execute</span>
        <span class="s3">var </span><span class="s1">div = ownerDocument.createElement(</span><span class="s2">'div'</span><span class="s1">);</span>

        <span class="s1">div.innerHTML = </span><span class="s2">'&lt;script&gt;&lt;' </span><span class="s1">+ </span><span class="s2">'/script&gt;'</span><span class="s1">; </span><span class="s0">// eslint-disable-line</span>
        <span class="s0">// This is guaranteed to yield a script element.</span>

        <span class="s3">var </span><span class="s1">firstChild = div.firstChild;</span>
        <span class="s1">domElement = div.removeChild(firstChild);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">props.is === </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s0">// $FlowIssue `createElement` should be updated for Web Components</span>
        <span class="s1">domElement = ownerDocument.createElement(type, {</span>
          <span class="s1">is: props.is</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.</span>
        <span class="s0">// See discussion in https://github.com/facebook/react/pull/6896</span>
        <span class="s0">// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</span>
        <span class="s1">domElement = ownerDocument.createElement(type); </span><span class="s0">// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`</span>
        <span class="s0">// attributes on `select`s needs to be added before `option`s are inserted.</span>
        <span class="s0">// This prevents:</span>
        <span class="s0">// - a bug where the `select` does not scroll to the correct option because singular</span>
        <span class="s0">//  `select` elements automatically pick the first item #13222</span>
        <span class="s0">// - a bug where the `select` set the first item as selected despite the `size` attribute #14239</span>
        <span class="s0">// See https://github.com/facebook/react/issues/13222</span>
        <span class="s0">// and https://github.com/facebook/react/issues/14239</span>

        <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'select'</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">node = domElement;</span>

          <span class="s3">if </span><span class="s1">(props.multiple) {</span>
            <span class="s1">node.multiple = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(props.size) {</span>
            <span class="s0">// Setting a size greater than 1 causes a select to behave like `multiple=true`, where</span>
            <span class="s0">// it is possible that no option is selected.</span>
            <span class="s0">//</span>
            <span class="s0">// This is only necessary when a select in &quot;single selection mode&quot;.</span>
            <span class="s1">node.size = props.size;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">domElement = ownerDocument.createElementNS(namespaceURI, type);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(namespaceURI === HTML_NAMESPACE$1) {</span>
        <span class="s3">if </span><span class="s1">(!isCustomComponentTag &amp;&amp; Object.prototype.toString.call(domElement) === </span><span class="s2">'[object HTMLUnknownElement]' </span><span class="s1">&amp;&amp; !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {</span>
          <span class="s1">warnedUnknownTags[type] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'The tag &lt;%s&gt; is unrecognized in this browser. ' </span><span class="s1">+ </span><span class="s2">'If you meant to render a React component, start its name with ' </span><span class="s1">+ </span><span class="s2">'an uppercase letter.'</span><span class="s1">, type);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">domElement;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createTextNode(text, rootContainerElement) {</span>
    <span class="s3">return </span><span class="s1">getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setInitialProperties(domElement, tag, rawProps, rootContainerElement) {</span>
    <span class="s3">var </span><span class="s1">isCustomComponentTag = isCustomComponent(tag, rawProps);</span>

    <span class="s1">{</span>
      <span class="s1">validatePropertiesInDevelopment(tag, rawProps);</span>
    <span class="s1">} </span><span class="s0">// TODO: Make sure that we check isMounted before firing any of these events.</span>


    <span class="s3">var </span><span class="s1">props;</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'iframe'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'embed'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_LOAD, domElement);</span>
        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'video'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'audio'</span><span class="s1">:</span>
        <span class="s0">// Create listener for each media event</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; mediaEventTypes.length; i++) {</span>
          <span class="s1">trapBubbledEvent(mediaEventTypes[i], domElement);</span>
        <span class="s1">}</span>

        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'source'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_ERROR, domElement);</span>
        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'img'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'image'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'link'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_ERROR, domElement);</span>
        <span class="s1">trapBubbledEvent(TOP_LOAD, domElement);</span>
        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'form'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_RESET, domElement);</span>
        <span class="s1">trapBubbledEvent(TOP_SUBMIT, domElement);</span>
        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'details'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_TOGGLE, domElement);</span>
        <span class="s1">props = rawProps;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s1">initWrapperState(domElement, rawProps);</span>
        <span class="s1">props = getHostProps(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
        <span class="s1">validateProps(domElement, rawProps);</span>
        <span class="s1">props = getHostProps$1(domElement, rawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s1">initWrapperState$1(domElement, rawProps);</span>
        <span class="s1">props = getHostProps$2(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s1">initWrapperState$2(domElement, rawProps);</span>
        <span class="s1">props = getHostProps$3(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">props = rawProps;</span>
    <span class="s1">}</span>

    <span class="s1">assertValidProps(tag, props);</span>
    <span class="s1">setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s0">// TODO: Make sure we check if this is still unmounted or do any clean</span>
        <span class="s0">// up necessary since we never stop tracking anymore.</span>
        <span class="s1">track(domElement);</span>
        <span class="s1">postMountWrapper(domElement, rawProps, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s0">// TODO: Make sure we check if this is still unmounted or do any clean</span>
        <span class="s0">// up necessary since we never stop tracking anymore.</span>
        <span class="s1">track(domElement);</span>
        <span class="s1">postMountWrapper$3(domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
        <span class="s1">postMountWrapper$1(domElement, rawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s1">postMountWrapper$2(domElement, rawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">props.onClick === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// TODO: This cast may not be sound for SVG, MathML or custom elements.</span>
          <span class="s1">trapClickOnNonInteractiveElement(domElement);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Calculate the diff between the two objects.</span>

  <span class="s3">function </span><span class="s1">diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {</span>
    <span class="s1">{</span>
      <span class="s1">validatePropertiesInDevelopment(tag, nextRawProps);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">updatePayload = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">lastProps;</span>
    <span class="s3">var </span><span class="s1">nextProps;</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s1">lastProps = getHostProps(domElement, lastRawProps);</span>
        <span class="s1">nextProps = getHostProps(domElement, nextRawProps);</span>
        <span class="s1">updatePayload = [];</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
        <span class="s1">lastProps = getHostProps$1(domElement, lastRawProps);</span>
        <span class="s1">nextProps = getHostProps$1(domElement, nextRawProps);</span>
        <span class="s1">updatePayload = [];</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s1">lastProps = getHostProps$2(domElement, lastRawProps);</span>
        <span class="s1">nextProps = getHostProps$2(domElement, nextRawProps);</span>
        <span class="s1">updatePayload = [];</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s1">lastProps = getHostProps$3(domElement, lastRawProps);</span>
        <span class="s1">nextProps = getHostProps$3(domElement, nextRawProps);</span>
        <span class="s1">updatePayload = [];</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">lastProps = lastRawProps;</span>
        <span class="s1">nextProps = nextRawProps;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">lastProps.onClick !== </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">nextProps.onClick === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// TODO: This cast may not be sound for SVG, MathML or custom elements.</span>
          <span class="s1">trapClickOnNonInteractiveElement(domElement);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">assertValidProps(tag, nextProps);</span>
    <span class="s3">var </span><span class="s1">propKey;</span>
    <span class="s3">var </span><span class="s1">styleName;</span>
    <span class="s3">var </span><span class="s1">styleUpdates = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(propKey </span><span class="s3">in </span><span class="s1">lastProps) {</span>
      <span class="s3">if </span><span class="s1">(nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(propKey === STYLE) {</span>
        <span class="s3">var </span><span class="s1">lastStyle = lastProps[propKey];</span>

        <span class="s3">for </span><span class="s1">(styleName </span><span class="s3">in </span><span class="s1">lastStyle) {</span>
          <span class="s3">if </span><span class="s1">(lastStyle.hasOwnProperty(styleName)) {</span>
            <span class="s3">if </span><span class="s1">(!styleUpdates) {</span>
              <span class="s1">styleUpdates = {};</span>
            <span class="s1">}</span>

            <span class="s1">styleUpdates[styleName] = </span><span class="s2">''</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; </span><span class="s3">else if </span><span class="s1">( propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; </span><span class="s3">else if </span><span class="s1">(propKey === AUTOFOCUS) ; </span><span class="s3">else if </span><span class="s1">(registrationNameModules.hasOwnProperty(propKey)) {</span>
        <span class="s0">// This is a special case. If any listener updates we need to ensure</span>
        <span class="s0">// that the &quot;current&quot; fiber pointer gets updated so we need a commit</span>
        <span class="s0">// to update this element.</span>
        <span class="s3">if </span><span class="s1">(!updatePayload) {</span>
          <span class="s1">updatePayload = [];</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// For all other deleted properties we add it to the queue. We use</span>
        <span class="s0">// the whitelist in the commit phase instead.</span>
        <span class="s1">(updatePayload = updatePayload || []).push(propKey, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(propKey </span><span class="s3">in </span><span class="s1">nextProps) {</span>
      <span class="s3">var </span><span class="s1">nextProp = nextProps[propKey];</span>
      <span class="s3">var </span><span class="s1">lastProp = lastProps != </span><span class="s3">null </span><span class="s1">? lastProps[propKey] : undefined;</span>

      <span class="s3">if </span><span class="s1">(!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == </span><span class="s3">null </span><span class="s1">&amp;&amp; lastProp == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(propKey === STYLE) {</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(nextProp) {</span>
            <span class="s0">// Freeze the next style object so that we can assume it won't be</span>
            <span class="s0">// mutated. We have already warned for this in the past.</span>
            <span class="s1">Object.freeze(nextProp);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(lastProp) {</span>
          <span class="s0">// Unset styles on `lastProp` but not on `nextProp`.</span>
          <span class="s3">for </span><span class="s1">(styleName </span><span class="s3">in </span><span class="s1">lastProp) {</span>
            <span class="s3">if </span><span class="s1">(lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {</span>
              <span class="s3">if </span><span class="s1">(!styleUpdates) {</span>
                <span class="s1">styleUpdates = {};</span>
              <span class="s1">}</span>

              <span class="s1">styleUpdates[styleName] = </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Update styles that changed since `lastProp`.</span>


          <span class="s3">for </span><span class="s1">(styleName </span><span class="s3">in </span><span class="s1">nextProp) {</span>
            <span class="s3">if </span><span class="s1">(nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {</span>
              <span class="s3">if </span><span class="s1">(!styleUpdates) {</span>
                <span class="s1">styleUpdates = {};</span>
              <span class="s1">}</span>

              <span class="s1">styleUpdates[styleName] = nextProp[styleName];</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span>
          <span class="s3">if </span><span class="s1">(!styleUpdates) {</span>
            <span class="s3">if </span><span class="s1">(!updatePayload) {</span>
              <span class="s1">updatePayload = [];</span>
            <span class="s1">}</span>

            <span class="s1">updatePayload.push(propKey, styleUpdates);</span>
          <span class="s1">}</span>

          <span class="s1">styleUpdates = nextProp;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === DANGEROUSLY_SET_INNER_HTML) {</span>
        <span class="s3">var </span><span class="s1">nextHtml = nextProp ? nextProp[HTML$1] : undefined;</span>
        <span class="s3">var </span><span class="s1">lastHtml = lastProp ? lastProp[HTML$1] : undefined;</span>

        <span class="s3">if </span><span class="s1">(nextHtml != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(lastHtml !== nextHtml) {</span>
            <span class="s1">(updatePayload = updatePayload || []).push(propKey, nextHtml);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === CHILDREN) {</span>
        <span class="s3">if </span><span class="s1">(lastProp !== nextProp &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'number'</span><span class="s1">)) {</span>
          <span class="s1">(updatePayload = updatePayload || []).push(propKey, </span><span class="s2">'' </span><span class="s1">+ nextProp);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">( propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; </span><span class="s3">else if </span><span class="s1">(registrationNameModules.hasOwnProperty(propKey)) {</span>
        <span class="s3">if </span><span class="s1">(nextProp != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// We eagerly listen to this even though we haven't committed yet.</span>
          <span class="s3">if </span><span class="s1">( </span><span class="s3">typeof </span><span class="s1">nextProp !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">warnForInvalidEventListener(propKey, nextProp);</span>
          <span class="s1">}</span>

          <span class="s1">ensureListeningTo(rootContainerElement, propKey);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!updatePayload &amp;&amp; lastProp !== nextProp) {</span>
          <span class="s0">// This is a special case. If any listener updates we need to ensure</span>
          <span class="s0">// that the &quot;current&quot; props pointer gets updated so we need a commit</span>
          <span class="s0">// to update this element.</span>
          <span class="s1">updatePayload = [];</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// For any other property we always add it to the queue and then we</span>
        <span class="s0">// filter it out using the whitelist during the commit.</span>
        <span class="s1">(updatePayload = updatePayload || []).push(propKey, nextProp);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(styleUpdates) {</span>
      <span class="s1">{</span>
        <span class="s1">validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);</span>
      <span class="s1">}</span>

      <span class="s1">(updatePayload = updatePayload || []).push(STYLE, styleUpdates);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">} </span><span class="s0">// Apply the diff.</span>

  <span class="s3">function </span><span class="s1">updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {</span>
    <span class="s0">// Update checked *before* name.</span>
    <span class="s0">// In the middle of an update, it is possible to have multiple checked.</span>
    <span class="s0">// When a checked radio tries to change name, browser makes another radio's checked false.</span>
    <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'input' </span><span class="s1">&amp;&amp; nextRawProps.type === </span><span class="s2">'radio' </span><span class="s1">&amp;&amp; nextRawProps.name != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateChecked(domElement, nextRawProps);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">wasCustomComponentTag = isCustomComponent(tag, lastRawProps);</span>
    <span class="s3">var </span><span class="s1">isCustomComponentTag = isCustomComponent(tag, nextRawProps); </span><span class="s0">// Apply the diff.</span>

    <span class="s1">updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); </span><span class="s0">// TODO: Ensure that an update gets scheduled if any of the special props</span>
    <span class="s0">// changed.</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s0">// Update the wrapper around inputs *after* updating props. This has to</span>
        <span class="s0">// happen after `updateDOMProperties`. Otherwise HTML5 input validations</span>
        <span class="s0">// raise warnings and prevent the new value from being assigned.</span>
        <span class="s1">updateWrapper(domElement, nextRawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s1">updateWrapper$1(domElement, nextRawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s0">// &lt;select&gt; value update needs to occur after &lt;option&gt; children</span>
        <span class="s0">// reconciliation</span>
        <span class="s1">postUpdateWrapper(domElement, nextRawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getPossibleStandardName(propName) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">lowerCasedName = propName.toLowerCase();</span>

      <span class="s3">if </span><span class="s1">(!possibleStandardNames.hasOwnProperty(lowerCasedName)) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">possibleStandardNames[lowerCasedName] || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {</span>
    <span class="s3">var </span><span class="s1">isCustomComponentTag;</span>
    <span class="s3">var </span><span class="s1">extraAttributeNames;</span>

    <span class="s1">{</span>
      <span class="s1">suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">isCustomComponentTag = isCustomComponent(tag, rawProps);</span>
      <span class="s1">validatePropertiesInDevelopment(tag, rawProps);</span>
    <span class="s1">} </span><span class="s0">// TODO: Make sure that we check isMounted before firing any of these events.</span>


    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'iframe'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'embed'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_LOAD, domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'video'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'audio'</span><span class="s1">:</span>
        <span class="s0">// Create listener for each media event</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; mediaEventTypes.length; i++) {</span>
          <span class="s1">trapBubbledEvent(mediaEventTypes[i], domElement);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'source'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_ERROR, domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'img'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'image'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'link'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_ERROR, domElement);</span>
        <span class="s1">trapBubbledEvent(TOP_LOAD, domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'form'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_RESET, domElement);</span>
        <span class="s1">trapBubbledEvent(TOP_SUBMIT, domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'details'</span><span class="s1">:</span>
        <span class="s1">trapBubbledEvent(TOP_TOGGLE, domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s1">initWrapperState(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
        <span class="s1">validateProps(domElement, rawProps);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s1">initWrapperState$1(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s1">initWrapperState$2(domElement, rawProps);</span>
        <span class="s1">trapBubbledEvent(TOP_INVALID, domElement); </span><span class="s0">// For controlled components we always need to ensure we're listening</span>
        <span class="s0">// to onChange. Even if there is no listener.</span>

        <span class="s1">ensureListeningTo(rootContainerElement, </span><span class="s2">'onChange'</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">assertValidProps(tag, rawProps);</span>

    <span class="s1">{</span>
      <span class="s1">extraAttributeNames = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s3">var </span><span class="s1">attributes = domElement.attributes;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">; _i &lt; attributes.length; _i++) {</span>
        <span class="s3">var </span><span class="s1">name = attributes[_i].name.toLowerCase();</span>

        <span class="s3">switch </span><span class="s1">(name) {</span>
          <span class="s0">// Built-in SSR attribute is whitelisted</span>
          <span class="s3">case </span><span class="s2">'data-reactroot'</span><span class="s1">:</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s0">// Controlled attributes are not validated</span>
          <span class="s0">// TODO: Only ignore them on controlled tags.</span>

          <span class="s3">case </span><span class="s2">'value'</span><span class="s1">:</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s2">'checked'</span><span class="s1">:</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s2">'selected'</span><span class="s1">:</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">default</span><span class="s1">:</span>
            <span class="s0">// Intentionally use the original name.</span>
            <span class="s0">// See discussion in https://github.com/facebook/react/pull/10676.</span>
            <span class="s1">extraAttributeNames.add(attributes[_i].name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">updatePayload = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propKey </span><span class="s3">in </span><span class="s1">rawProps) {</span>
      <span class="s3">if </span><span class="s1">(!rawProps.hasOwnProperty(propKey)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">nextProp = rawProps[propKey];</span>

      <span class="s3">if </span><span class="s1">(propKey === CHILDREN) {</span>
        <span class="s0">// For text content children we compare against textContent. This</span>
        <span class="s0">// might match additional HTML that is hidden when we read it using</span>
        <span class="s0">// textContent. E.g. &quot;foo&quot; will match &quot;f&lt;span&gt;oo&lt;/span&gt;&quot; but that still</span>
        <span class="s0">// satisfies our requirement. Our requirement is not to produce perfect</span>
        <span class="s0">// HTML and attributes. Ideally we should preserve structure but it's</span>
        <span class="s0">// ok not to if the visible content is still enough to indicate what</span>
        <span class="s0">// even listeners these nodes might be wired up to.</span>
        <span class="s0">// TODO: Warn if there is more than a single textNode as a child.</span>
        <span class="s0">// TODO: Should we use domElement.firstChild.nodeValue to compare?</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'string'</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(domElement.textContent !== nextProp) {</span>
            <span class="s3">if </span><span class="s1">( !suppressHydrationWarning) {</span>
              <span class="s1">warnForTextDifference(domElement.textContent, nextProp);</span>
            <span class="s1">}</span>

            <span class="s1">updatePayload = [CHILDREN, nextProp];</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextProp === </span><span class="s2">'number'</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(domElement.textContent !== </span><span class="s2">'' </span><span class="s1">+ nextProp) {</span>
            <span class="s3">if </span><span class="s1">( !suppressHydrationWarning) {</span>
              <span class="s1">warnForTextDifference(domElement.textContent, nextProp);</span>
            <span class="s1">}</span>

            <span class="s1">updatePayload = [CHILDREN, </span><span class="s2">'' </span><span class="s1">+ nextProp];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(registrationNameModules.hasOwnProperty(propKey)) {</span>
        <span class="s3">if </span><span class="s1">(nextProp != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">( </span><span class="s3">typeof </span><span class="s1">nextProp !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">warnForInvalidEventListener(propKey, nextProp);</span>
          <span class="s1">}</span>

          <span class="s1">ensureListeningTo(rootContainerElement, propKey);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">( </span><span class="s0">// Convince Flow we've calculated it (it's DEV-only in this method.)</span>
      <span class="s3">typeof </span><span class="s1">isCustomComponentTag === </span><span class="s2">'boolean'</span><span class="s1">) {</span>
        <span class="s0">// Validate that the properties correspond to their expected values.</span>
        <span class="s3">var </span><span class="s1">serverValue = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">propertyInfo = getPropertyInfo(propKey);</span>

        <span class="s3">if </span><span class="s1">(suppressHydrationWarning) ; </span><span class="s3">else if </span><span class="s1">( propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || </span><span class="s0">// Controlled attributes are not validated</span>
        <span class="s0">// TODO: Only ignore them on controlled tags.</span>
        <span class="s1">propKey === </span><span class="s2">'value' </span><span class="s1">|| propKey === </span><span class="s2">'checked' </span><span class="s1">|| propKey === </span><span class="s2">'selected'</span><span class="s1">) ; </span><span class="s3">else if </span><span class="s1">(propKey === DANGEROUSLY_SET_INNER_HTML) {</span>
          <span class="s3">var </span><span class="s1">serverHTML = domElement.innerHTML;</span>
          <span class="s3">var </span><span class="s1">nextHtml = nextProp ? nextProp[HTML$1] : undefined;</span>
          <span class="s3">var </span><span class="s1">expectedHTML = normalizeHTML(domElement, nextHtml != </span><span class="s3">null </span><span class="s1">? nextHtml : </span><span class="s2">''</span><span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(expectedHTML !== serverHTML) {</span>
            <span class="s1">warnForPropDifference(propKey, serverHTML, expectedHTML);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(propKey === STYLE) {</span>
          <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
          <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(propKey);</span>

          <span class="s3">if </span><span class="s1">(canDiffStyleForHydrationWarning) {</span>
            <span class="s3">var </span><span class="s1">expectedStyle = createDangerousStringForStyles(nextProp);</span>
            <span class="s1">serverValue = domElement.getAttribute(</span><span class="s2">'style'</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(expectedStyle !== serverValue) {</span>
              <span class="s1">warnForPropDifference(propKey, serverValue, expectedStyle);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isCustomComponentTag) {</span>
          <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
          <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(propKey.toLowerCase());</span>
          <span class="s1">serverValue = getValueForAttribute(domElement, propKey, nextProp);</span>

          <span class="s3">if </span><span class="s1">(nextProp !== serverValue) {</span>
            <span class="s1">warnForPropDifference(propKey, serverValue, nextProp);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) &amp;&amp; !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {</span>
          <span class="s3">var </span><span class="s1">isMismatchDueToBadCasing = </span><span class="s3">false</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(propertyInfo !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
            <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(propertyInfo.attributeName);</span>
            <span class="s1">serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">ownNamespace = parentNamespace;</span>

            <span class="s3">if </span><span class="s1">(ownNamespace === HTML_NAMESPACE$1) {</span>
              <span class="s1">ownNamespace = getIntrinsicNamespace(tag);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(ownNamespace === HTML_NAMESPACE$1) {</span>
              <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
              <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(propKey.toLowerCase());</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">standardName = getPossibleStandardName(propKey);</span>

              <span class="s3">if </span><span class="s1">(standardName !== </span><span class="s3">null </span><span class="s1">&amp;&amp; standardName !== propKey) {</span>
                <span class="s0">// If an SVG prop is supplied with bad casing, it will</span>
                <span class="s0">// be successfully parsed from HTML, but will produce a mismatch</span>
                <span class="s0">// (and would be incorrectly rendered on the client).</span>
                <span class="s0">// However, we already warn about bad casing elsewhere.</span>
                <span class="s0">// So we'll skip the misleading extra mismatch warning in this case.</span>
                <span class="s1">isMismatchDueToBadCasing = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>

                <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(standardName);</span>
              <span class="s1">} </span><span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>


              <span class="s1">extraAttributeNames.</span><span class="s3">delete</span><span class="s1">(propKey);</span>
            <span class="s1">}</span>

            <span class="s1">serverValue = getValueForAttribute(domElement, propKey, nextProp);</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(nextProp !== serverValue &amp;&amp; !isMismatchDueToBadCasing) {</span>
            <span class="s1">warnForPropDifference(propKey, serverValue, nextProp);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
      <span class="s3">if </span><span class="s1">(extraAttributeNames.size &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !suppressHydrationWarning) {</span>
        <span class="s0">// $FlowFixMe - Should be inferred as not undefined.</span>
        <span class="s1">warnForExtraAttributes(extraAttributeNames);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s0">// TODO: Make sure we check if this is still unmounted or do any clean</span>
        <span class="s0">// up necessary since we never stop tracking anymore.</span>
        <span class="s1">track(domElement);</span>
        <span class="s1">postMountWrapper(domElement, rawProps, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s0">// TODO: Make sure we check if this is still unmounted or do any clean</span>
        <span class="s0">// up necessary since we never stop tracking anymore.</span>
        <span class="s1">track(domElement);</span>
        <span class="s1">postMountWrapper$3(domElement);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
        <span class="s0">// For input and textarea we current always set the value property at</span>
        <span class="s0">// post mount to force it to diverge from attributes. However, for</span>
        <span class="s0">// option and select we don't quite do the same thing and select</span>
        <span class="s0">// is not resilient to the DOM state changing so we don't do that here.</span>
        <span class="s0">// TODO: Consider not doing this for input and textarea.</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">rawProps.onClick === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// TODO: This cast may not be sound for SVG, MathML or custom elements.</span>
          <span class="s1">trapClickOnNonInteractiveElement(domElement);</span>
        <span class="s1">}</span>

        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updatePayload;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">diffHydratedText(textNode, text) {</span>
    <span class="s3">var </span><span class="s1">isDifferent = textNode.nodeValue !== text;</span>
    <span class="s3">return </span><span class="s1">isDifferent;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnForUnmatchedText(textNode, text) {</span>
    <span class="s1">{</span>
      <span class="s1">warnForTextDifference(textNode.nodeValue, text);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnForDeletedHydratableElement(parentNode, child) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Did not expect server HTML to contain a &lt;%s&gt; in &lt;%s&gt;.'</span><span class="s1">, child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnForDeletedHydratableText(parentNode, child) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Did not expect server HTML to contain the text node &quot;%s&quot; in &lt;%s&gt;.'</span><span class="s1">, child.nodeValue, parentNode.nodeName.toLowerCase());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnForInsertedHydratedElement(parentNode, tag, props) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Expected server HTML to contain a matching &lt;%s&gt; in &lt;%s&gt;.'</span><span class="s1">, tag, parentNode.nodeName.toLowerCase());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnForInsertedHydratedText(parentNode, text) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(text === </span><span class="s2">''</span><span class="s1">) {</span>
        <span class="s0">// We expect to insert empty text nodes since they're not represented in</span>
        <span class="s0">// the HTML.</span>
        <span class="s0">// TODO: Remove this special case if we can just avoid inserting empty</span>
        <span class="s0">// text nodes.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(didWarnInvalidHydration) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarnInvalidHydration = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Expected server HTML to contain a matching text node for &quot;%s&quot; in &lt;%s&gt;.'</span><span class="s1">, text, parentNode.nodeName.toLowerCase());</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">restoreControlledState$3(domElement, tag, props) {</span>
    <span class="s3">switch </span><span class="s1">(tag) {</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
        <span class="s1">restoreControlledState(domElement, props);</span>
        <span class="s3">return</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s1">restoreControlledState$2(domElement, props);</span>
        <span class="s3">return</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
        <span class="s1">restoreControlledState$1(domElement, props);</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getActiveElement(doc) {</span>
    <span class="s1">doc = doc || (</span><span class="s3">typeof </span><span class="s1">document !== </span><span class="s2">'undefined' </span><span class="s1">? document : undefined);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">doc === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">doc.activeElement || doc.body;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s3">return </span><span class="s1">doc.body;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Given any node return the first leaf node without children. 
   * 
   * @param {DOMElement|DOMTextNode} node 
   * @return {DOMElement|DOMTextNode} 
   */</span>

  <span class="s3">function </span><span class="s1">getLeafNode(node) {</span>
    <span class="s3">while </span><span class="s1">(node &amp;&amp; node.firstChild) {</span>
      <span class="s1">node = node.firstChild;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Get the next sibling within a container. This will walk up the 
   * DOM if a node's siblings have been exhausted. 
   * 
   * @param {DOMElement|DOMTextNode} node 
   * @return {?DOMElement|DOMTextNode} 
   */</span>


  <span class="s3">function </span><span class="s1">getSiblingNode(node) {</span>
    <span class="s3">while </span><span class="s1">(node) {</span>
      <span class="s3">if </span><span class="s1">(node.nextSibling) {</span>
        <span class="s3">return </span><span class="s1">node.nextSibling;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.parentNode;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Get object describing the nodes which contain characters at offset. 
   * 
   * @param {DOMElement|DOMTextNode} root 
   * @param {number} offset 
   * @return {?object} 
   */</span>


  <span class="s3">function </span><span class="s1">getNodeForCharacterOffset(root, offset) {</span>
    <span class="s3">var </span><span class="s1">node = getLeafNode(root);</span>
    <span class="s3">var </span><span class="s1">nodeStart = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">nodeEnd = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(node) {</span>
      <span class="s3">if </span><span class="s1">(node.nodeType === TEXT_NODE) {</span>
        <span class="s1">nodeEnd = nodeStart + node.textContent.length;</span>

        <span class="s3">if </span><span class="s1">(nodeStart &lt;= offset &amp;&amp; nodeEnd &gt;= offset) {</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">node: node,</span>
            <span class="s1">offset: offset - nodeStart</span>
          <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">nodeStart = nodeEnd;</span>
      <span class="s1">}</span>

      <span class="s1">node = getLeafNode(getSiblingNode(node));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @param {DOMElement} outerNode 
   * @return {?object} 
   */</span>

  <span class="s3">function </span><span class="s1">getOffsets(outerNode) {</span>
    <span class="s3">var </span><span class="s1">ownerDocument = outerNode.ownerDocument;</span>
    <span class="s3">var </span><span class="s1">win = ownerDocument &amp;&amp; ownerDocument.defaultView || window;</span>
    <span class="s3">var </span><span class="s1">selection = win.getSelection &amp;&amp; win.getSelection();</span>

    <span class="s3">if </span><span class="s1">(!selection || selection.rangeCount === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">anchorNode = selection.anchorNode,</span>
        <span class="s1">anchorOffset = selection.anchorOffset,</span>
        <span class="s1">focusNode = selection.focusNode,</span>
        <span class="s1">focusOffset = selection.focusOffset; </span><span class="s0">// In Firefox, anchorNode and focusNode can be &quot;anonymous divs&quot;, e.g. the</span>
    <span class="s0">// up/down buttons on an &lt;input type=&quot;number&quot;&gt;. Anonymous divs do not seem to</span>
    <span class="s0">// expose properties, triggering a &quot;Permission denied error&quot; if any of its</span>
    <span class="s0">// properties are accessed. The only seemingly possible way to avoid erroring</span>
    <span class="s0">// is to access a property that typically works for non-anonymous divs and</span>
    <span class="s0">// catch any error that may otherwise arise. See</span>
    <span class="s0">// https://bugzilla.mozilla.org/show_bug.cgi?id=208427</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">/* eslint-disable no-unused-expressions */</span>
      <span class="s1">anchorNode.nodeType;</span>
      <span class="s1">focusNode.nodeType;</span>
      <span class="s0">/* eslint-enable no-unused-expressions */</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Returns {start, end} where `start` is the character/codepoint index of 
   * (anchorNode, anchorOffset) within the textContent of `outerNode`, and 
   * `end` is the index of (focusNode, focusOffset). 
   * 
   * Returns null if you pass in garbage input but we should probably just crash. 
   * 
   * Exported only for testing. 
   */</span>

  <span class="s3">function </span><span class="s1">getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {</span>
    <span class="s3">var </span><span class="s1">length = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">start = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">end = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">indexWithinAnchor = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">indexWithinFocus = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">node = outerNode;</span>
    <span class="s3">var </span><span class="s1">parentNode = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">outer: </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">next = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node === anchorNode &amp;&amp; (anchorOffset === </span><span class="s4">0 </span><span class="s1">|| node.nodeType === TEXT_NODE)) {</span>
          <span class="s1">start = length + anchorOffset;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node === focusNode &amp;&amp; (focusOffset === </span><span class="s4">0 </span><span class="s1">|| node.nodeType === TEXT_NODE)) {</span>
          <span class="s1">end = length + focusOffset;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node.nodeType === TEXT_NODE) {</span>
          <span class="s1">length += node.nodeValue.length;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">((next = node.firstChild) === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Moving from `node` to its first child `next`.</span>


        <span class="s1">parentNode = node;</span>
        <span class="s1">node = next;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node === outerNode) {</span>
          <span class="s0">// If `outerNode` has children, this is always the second time visiting</span>
          <span class="s0">// it. If it has no children, this is still the first loop, and the only</span>
          <span class="s0">// valid selection is anchorNode and focusNode both equal to this node</span>
          <span class="s0">// and both offsets 0, in which case we will have handled above.</span>
          <span class="s3">break </span><span class="s1">outer;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(parentNode === anchorNode &amp;&amp; ++indexWithinAnchor === anchorOffset) {</span>
          <span class="s1">start = length;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(parentNode === focusNode &amp;&amp; ++indexWithinFocus === focusOffset) {</span>
          <span class="s1">end = length;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">((next = node.nextSibling) !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = parentNode;</span>
        <span class="s1">parentNode = node.parentNode;</span>
      <span class="s1">} </span><span class="s0">// Moving from `node` to its next sibling `next`.</span>


      <span class="s1">node = next;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(start === -</span><span class="s4">1 </span><span class="s1">|| end === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s0">// This should never happen. (Would happen if the anchor/focus nodes aren't</span>
      <span class="s0">// actually inside the passed-in node.)</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">start: start,</span>
      <span class="s1">end: end</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * In modern non-IE browsers, we can support both forward and backward 
   * selections. 
   * 
   * Note: IE10+ supports the Selection object, but it does not support 
   * the `extend` method, which means that even in modern IE, it's not possible 
   * to programmatically create a backward selection. Thus, for all IE 
   * versions, we use the old IE API to create our selections. 
   * 
   * @param {DOMElement|DOMTextNode} node 
   * @param {object} offsets 
   */</span>

  <span class="s3">function </span><span class="s1">setOffsets(node, offsets) {</span>
    <span class="s3">var </span><span class="s1">doc = node.ownerDocument || document;</span>
    <span class="s3">var </span><span class="s1">win = doc &amp;&amp; doc.defaultView || window; </span><span class="s0">// Edge fails with &quot;Object expected&quot; in some scenarios.</span>
    <span class="s0">// (For instance: TinyMCE editor used in a list component that supports pasting to add more,</span>
    <span class="s0">// fails when pasting 100+ items)</span>

    <span class="s3">if </span><span class="s1">(!win.getSelection) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">selection = win.getSelection();</span>
    <span class="s3">var </span><span class="s1">length = node.textContent.length;</span>
    <span class="s3">var </span><span class="s1">start = Math.min(offsets.start, length);</span>
    <span class="s3">var </span><span class="s1">end = offsets.end === undefined ? start : Math.min(offsets.end, length); </span><span class="s0">// IE 11 uses modern selection, but doesn't support the extend method.</span>
    <span class="s0">// Flip backward selections, so we can set with a single range.</span>

    <span class="s3">if </span><span class="s1">(!selection.extend &amp;&amp; start &gt; end) {</span>
      <span class="s3">var </span><span class="s1">temp = end;</span>
      <span class="s1">end = start;</span>
      <span class="s1">start = temp;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">startMarker = getNodeForCharacterOffset(node, start);</span>
    <span class="s3">var </span><span class="s1">endMarker = getNodeForCharacterOffset(node, end);</span>

    <span class="s3">if </span><span class="s1">(startMarker &amp;&amp; endMarker) {</span>
      <span class="s3">if </span><span class="s1">(selection.rangeCount === </span><span class="s4">1 </span><span class="s1">&amp;&amp; selection.anchorNode === startMarker.node &amp;&amp; selection.anchorOffset === startMarker.offset &amp;&amp; selection.focusNode === endMarker.node &amp;&amp; selection.focusOffset === endMarker.offset) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">range = doc.createRange();</span>
      <span class="s1">range.setStart(startMarker.node, startMarker.offset);</span>
      <span class="s1">selection.removeAllRanges();</span>

      <span class="s3">if </span><span class="s1">(start &gt; end) {</span>
        <span class="s1">selection.addRange(range);</span>
        <span class="s1">selection.extend(endMarker.node, endMarker.offset);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">range.setEnd(endMarker.node, endMarker.offset);</span>
        <span class="s1">selection.addRange(range);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isTextNode(node) {</span>
    <span class="s3">return </span><span class="s1">node &amp;&amp; node.nodeType === TEXT_NODE;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">containsNode(outerNode, innerNode) {</span>
    <span class="s3">if </span><span class="s1">(!outerNode || !innerNode) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(outerNode === innerNode) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isTextNode(outerNode)) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isTextNode(innerNode)) {</span>
      <span class="s3">return </span><span class="s1">containsNode(outerNode, innerNode.parentNode);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">'contains' </span><span class="s3">in </span><span class="s1">outerNode) {</span>
      <span class="s3">return </span><span class="s1">outerNode.contains(innerNode);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(outerNode.compareDocumentPosition) {</span>
      <span class="s3">return </span><span class="s1">!!(outerNode.compareDocumentPosition(innerNode) &amp; </span><span class="s4">16</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isInDocument(node) {</span>
    <span class="s3">return </span><span class="s1">node &amp;&amp; node.ownerDocument &amp;&amp; containsNode(node.ownerDocument.documentElement, node);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isSameOriginFrame(iframe) {</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// Accessing the contentDocument of a HTMLIframeElement can cause the browser</span>
      <span class="s0">// to throw, e.g. if it has a cross-origin src attribute.</span>
      <span class="s0">// Safari will show an error in the console when the access results in &quot;Blocked a frame with origin&quot;. e.g:</span>
      <span class="s0">// iframe.contentDocument.defaultView;</span>
      <span class="s0">// A safety way is to access one of the cross origin properties: Window or Location</span>
      <span class="s0">// Which might result in &quot;SecurityError&quot; DOM Exception and it is compatible to Safari.</span>
      <span class="s0">// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl</span>
      <span class="s3">return typeof </span><span class="s1">iframe.contentWindow.location.href === </span><span class="s2">'string'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getActiveElementDeep() {</span>
    <span class="s3">var </span><span class="s1">win = window;</span>
    <span class="s3">var </span><span class="s1">element = getActiveElement();</span>

    <span class="s3">while </span><span class="s1">(element </span><span class="s3">instanceof </span><span class="s1">win.HTMLIFrameElement) {</span>
      <span class="s3">if </span><span class="s1">(isSameOriginFrame(element)) {</span>
        <span class="s1">win = element.contentWindow;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">element;</span>
      <span class="s1">}</span>

      <span class="s1">element = getActiveElement(win.document);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">element;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @ReactInputSelection: React input selection module. Based on Selection.js, 
   * but modified to be suitable for react and has a couple of bug fixes (doesn't 
   * assume buttons have range selections allowed). 
   * Input selection module for React. 
   */</span>

  <span class="s0">/** 
   * @hasSelectionCapabilities: we get the element types that support selection 
   * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart` 
   * and `selectionEnd` rows. 
   */</span>


  <span class="s3">function </span><span class="s1">hasSelectionCapabilities(elem) {</span>
    <span class="s3">var </span><span class="s1">nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();</span>
    <span class="s3">return </span><span class="s1">nodeName &amp;&amp; (nodeName === </span><span class="s2">'input' </span><span class="s1">&amp;&amp; (elem.type === </span><span class="s2">'text' </span><span class="s1">|| elem.type === </span><span class="s2">'search' </span><span class="s1">|| elem.type === </span><span class="s2">'tel' </span><span class="s1">|| elem.type === </span><span class="s2">'url' </span><span class="s1">|| elem.type === </span><span class="s2">'password'</span><span class="s1">) || nodeName === </span><span class="s2">'textarea' </span><span class="s1">|| elem.contentEditable === </span><span class="s2">'true'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getSelectionInformation() {</span>
    <span class="s3">var </span><span class="s1">focusedElem = getActiveElementDeep();</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s0">// Used by Flare</span>
      <span class="s1">activeElementDetached: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">focusedElem: focusedElem,</span>
      <span class="s1">selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @restoreSelection: If any selection information was potentially lost, 
   * restore it. This is useful when performing operations that could remove dom 
   * nodes and place them back in, resulting in focus being lost. 
   */</span>

  <span class="s3">function </span><span class="s1">restoreSelection(priorSelectionInformation) {</span>
    <span class="s3">var </span><span class="s1">curFocusedElem = getActiveElementDeep();</span>
    <span class="s3">var </span><span class="s1">priorFocusedElem = priorSelectionInformation.focusedElem;</span>
    <span class="s3">var </span><span class="s1">priorSelectionRange = priorSelectionInformation.selectionRange;</span>

    <span class="s3">if </span><span class="s1">(curFocusedElem !== priorFocusedElem &amp;&amp; isInDocument(priorFocusedElem)) {</span>
      <span class="s3">if </span><span class="s1">(priorSelectionRange !== </span><span class="s3">null </span><span class="s1">&amp;&amp; hasSelectionCapabilities(priorFocusedElem)) {</span>
        <span class="s1">setSelection(priorFocusedElem, priorSelectionRange);</span>
      <span class="s1">} </span><span class="s0">// Focusing a node can change the scroll position, which is undesirable</span>


      <span class="s3">var </span><span class="s1">ancestors = [];</span>
      <span class="s3">var </span><span class="s1">ancestor = priorFocusedElem;</span>

      <span class="s3">while </span><span class="s1">(ancestor = ancestor.parentNode) {</span>
        <span class="s3">if </span><span class="s1">(ancestor.nodeType === ELEMENT_NODE) {</span>
          <span class="s1">ancestors.push({</span>
            <span class="s1">element: ancestor,</span>
            <span class="s1">left: ancestor.scrollLeft,</span>
            <span class="s1">top: ancestor.scrollTop</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">priorFocusedElem.focus === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">priorFocusedElem.focus();</span>
      <span class="s1">}</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; ancestors.length; i++) {</span>
        <span class="s3">var </span><span class="s1">info = ancestors[i];</span>
        <span class="s1">info.element.scrollLeft = info.left;</span>
        <span class="s1">info.element.scrollTop = info.top;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @getSelection: Gets the selection bounds of a focused textarea, input or 
   * contentEditable node. 
   * -@input: Look up selection bounds of this input 
   * -@return {start: selectionStart, end: selectionEnd} 
   */</span>

  <span class="s3">function </span><span class="s1">getSelection(input) {</span>
    <span class="s3">var </span><span class="s1">selection;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">'selectionStart' </span><span class="s3">in </span><span class="s1">input) {</span>
      <span class="s0">// Modern browser with input or textarea.</span>
      <span class="s1">selection = {</span>
        <span class="s1">start: input.selectionStart,</span>
        <span class="s1">end: input.selectionEnd</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Content editable or old IE textarea.</span>
      <span class="s1">selection = getOffsets(input);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">selection || {</span>
      <span class="s1">start: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">end: </span><span class="s4">0</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @setSelection: Sets the selection bounds of a textarea or input and focuses 
   * the input. 
   * -@input     Set selection bounds of this input or textarea 
   * -@offsets   Object of same form that is returned from get* 
   */</span>

  <span class="s3">function </span><span class="s1">setSelection(input, offsets) {</span>
    <span class="s3">var </span><span class="s1">start = offsets.start,</span>
        <span class="s1">end = offsets.end;</span>

    <span class="s3">if </span><span class="s1">(end === undefined) {</span>
      <span class="s1">end = start;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">'selectionStart' </span><span class="s3">in </span><span class="s1">input) {</span>
      <span class="s1">input.selectionStart = start;</span>
      <span class="s1">input.selectionEnd = Math.min(end, input.value.length);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">setOffsets(input, offsets);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">validateDOMNesting = </span><span class="s3">function </span><span class="s1">() {};</span>

  <span class="s3">var </span><span class="s1">updatedAncestorInfo = </span><span class="s3">function </span><span class="s1">() {};</span>

  <span class="s1">{</span>
    <span class="s0">// This validation code was written based on the HTML5 parsing spec:</span>
    <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</span>
    <span class="s0">//</span>
    <span class="s0">// Note: this does not catch all invalid nesting, nor does it try to (as it's</span>
    <span class="s0">// not clear what practical benefit doing so provides); instead, we warn only</span>
    <span class="s0">// for cases where the parser will give a parse tree differing from what React</span>
    <span class="s0">// intended. For example, &lt;b&gt;&lt;div&gt;&lt;/div&gt;&lt;/b&gt; is invalid but we don't warn</span>
    <span class="s0">// because it still parses correctly; we do warn for other cases like nested</span>
    <span class="s0">// &lt;p&gt; tags where the beginning of the second element implicitly closes the</span>
    <span class="s0">// first, causing a confusing mess.</span>
    <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#special</span>
    <span class="s3">var </span><span class="s1">specialTags = [</span><span class="s2">'address'</span><span class="s1">, </span><span class="s2">'applet'</span><span class="s1">, </span><span class="s2">'area'</span><span class="s1">, </span><span class="s2">'article'</span><span class="s1">, </span><span class="s2">'aside'</span><span class="s1">, </span><span class="s2">'base'</span><span class="s1">, </span><span class="s2">'basefont'</span><span class="s1">, </span><span class="s2">'bgsound'</span><span class="s1">, </span><span class="s2">'blockquote'</span><span class="s1">, </span><span class="s2">'body'</span><span class="s1">, </span><span class="s2">'br'</span><span class="s1">, </span><span class="s2">'button'</span><span class="s1">, </span><span class="s2">'caption'</span><span class="s1">, </span><span class="s2">'center'</span><span class="s1">, </span><span class="s2">'col'</span><span class="s1">, </span><span class="s2">'colgroup'</span><span class="s1">, </span><span class="s2">'dd'</span><span class="s1">, </span><span class="s2">'details'</span><span class="s1">, </span><span class="s2">'dir'</span><span class="s1">, </span><span class="s2">'div'</span><span class="s1">, </span><span class="s2">'dl'</span><span class="s1">, </span><span class="s2">'dt'</span><span class="s1">, </span><span class="s2">'embed'</span><span class="s1">, </span><span class="s2">'fieldset'</span><span class="s1">, </span><span class="s2">'figcaption'</span><span class="s1">, </span><span class="s2">'figure'</span><span class="s1">, </span><span class="s2">'footer'</span><span class="s1">, </span><span class="s2">'form'</span><span class="s1">, </span><span class="s2">'frame'</span><span class="s1">, </span><span class="s2">'frameset'</span><span class="s1">, </span><span class="s2">'h1'</span><span class="s1">, </span><span class="s2">'h2'</span><span class="s1">, </span><span class="s2">'h3'</span><span class="s1">, </span><span class="s2">'h4'</span><span class="s1">, </span><span class="s2">'h5'</span><span class="s1">, </span><span class="s2">'h6'</span><span class="s1">, </span><span class="s2">'head'</span><span class="s1">, </span><span class="s2">'header'</span><span class="s1">, </span><span class="s2">'hgroup'</span><span class="s1">, </span><span class="s2">'hr'</span><span class="s1">, </span><span class="s2">'html'</span><span class="s1">, </span><span class="s2">'iframe'</span><span class="s1">, </span><span class="s2">'img'</span><span class="s1">, </span><span class="s2">'input'</span><span class="s1">, </span><span class="s2">'isindex'</span><span class="s1">, </span><span class="s2">'li'</span><span class="s1">, </span><span class="s2">'link'</span><span class="s1">, </span><span class="s2">'listing'</span><span class="s1">, </span><span class="s2">'main'</span><span class="s1">, </span><span class="s2">'marquee'</span><span class="s1">, </span><span class="s2">'menu'</span><span class="s1">, </span><span class="s2">'menuitem'</span><span class="s1">, </span><span class="s2">'meta'</span><span class="s1">, </span><span class="s2">'nav'</span><span class="s1">, </span><span class="s2">'noembed'</span><span class="s1">, </span><span class="s2">'noframes'</span><span class="s1">, </span><span class="s2">'noscript'</span><span class="s1">, </span><span class="s2">'object'</span><span class="s1">, </span><span class="s2">'ol'</span><span class="s1">, </span><span class="s2">'p'</span><span class="s1">, </span><span class="s2">'param'</span><span class="s1">, </span><span class="s2">'plaintext'</span><span class="s1">, </span><span class="s2">'pre'</span><span class="s1">, </span><span class="s2">'script'</span><span class="s1">, </span><span class="s2">'section'</span><span class="s1">, </span><span class="s2">'select'</span><span class="s1">, </span><span class="s2">'source'</span><span class="s1">, </span><span class="s2">'style'</span><span class="s1">, </span><span class="s2">'summary'</span><span class="s1">, </span><span class="s2">'table'</span><span class="s1">, </span><span class="s2">'tbody'</span><span class="s1">, </span><span class="s2">'td'</span><span class="s1">, </span><span class="s2">'template'</span><span class="s1">, </span><span class="s2">'textarea'</span><span class="s1">, </span><span class="s2">'tfoot'</span><span class="s1">, </span><span class="s2">'th'</span><span class="s1">, </span><span class="s2">'thead'</span><span class="s1">, </span><span class="s2">'title'</span><span class="s1">, </span><span class="s2">'tr'</span><span class="s1">, </span><span class="s2">'track'</span><span class="s1">, </span><span class="s2">'ul'</span><span class="s1">, </span><span class="s2">'wbr'</span><span class="s1">, </span><span class="s2">'xmp'</span><span class="s1">]; </span><span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</span>

    <span class="s3">var </span><span class="s1">inScopeTags = [</span><span class="s2">'applet'</span><span class="s1">, </span><span class="s2">'caption'</span><span class="s1">, </span><span class="s2">'html'</span><span class="s1">, </span><span class="s2">'table'</span><span class="s1">, </span><span class="s2">'td'</span><span class="s1">, </span><span class="s2">'th'</span><span class="s1">, </span><span class="s2">'marquee'</span><span class="s1">, </span><span class="s2">'object'</span><span class="s1">, </span><span class="s2">'template'</span><span class="s1">, </span><span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point</span>
    <span class="s0">// TODO: Distinguish by namespace here -- for &lt;title&gt;, including it here</span>
    <span class="s0">// errs on the side of fewer warnings</span>
    <span class="s2">'foreignObject'</span><span class="s1">, </span><span class="s2">'desc'</span><span class="s1">, </span><span class="s2">'title'</span><span class="s1">]; </span><span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope</span>

    <span class="s3">var </span><span class="s1">buttonScopeTags = inScopeTags.concat([</span><span class="s2">'button'</span><span class="s1">]); </span><span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags</span>

    <span class="s3">var </span><span class="s1">impliedEndTags = [</span><span class="s2">'dd'</span><span class="s1">, </span><span class="s2">'dt'</span><span class="s1">, </span><span class="s2">'li'</span><span class="s1">, </span><span class="s2">'option'</span><span class="s1">, </span><span class="s2">'optgroup'</span><span class="s1">, </span><span class="s2">'p'</span><span class="s1">, </span><span class="s2">'rp'</span><span class="s1">, </span><span class="s2">'rt'</span><span class="s1">];</span>
    <span class="s3">var </span><span class="s1">emptyAncestorInfo = {</span>
      <span class="s1">current: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">formTag: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">aTagInScope: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">buttonTagInScope: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">nobrTagInScope: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">pTagInButtonScope: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">listItemTagAutoclosing: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">dlItemTagAutoclosing: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s1">updatedAncestorInfo = </span><span class="s3">function </span><span class="s1">(oldInfo, tag) {</span>
      <span class="s3">var </span><span class="s1">ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);</span>

      <span class="s3">var </span><span class="s1">info = {</span>
        <span class="s1">tag: tag</span>
      <span class="s1">};</span>

      <span class="s3">if </span><span class="s1">(inScopeTags.indexOf(tag) !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.aTagInScope = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">ancestorInfo.buttonTagInScope = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">ancestorInfo.nobrTagInScope = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(buttonScopeTags.indexOf(tag) !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.pTagInButtonScope = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// See rules for 'li', 'dd', 'dt' start tags in</span>
      <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</span>


      <span class="s3">if </span><span class="s1">(specialTags.indexOf(tag) !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; tag !== </span><span class="s2">'address' </span><span class="s1">&amp;&amp; tag !== </span><span class="s2">'div' </span><span class="s1">&amp;&amp; tag !== </span><span class="s2">'p'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.listItemTagAutoclosing = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">ancestorInfo.dlItemTagAutoclosing = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ancestorInfo.current = info;</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'form'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.formTag = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'a'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.aTagInScope = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'button'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.buttonTagInScope = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'nobr'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.nobrTagInScope = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'p'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.pTagInButtonScope = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'li'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.listItemTagAutoclosing = info;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(tag === </span><span class="s2">'dd' </span><span class="s1">|| tag === </span><span class="s2">'dt'</span><span class="s1">) {</span>
        <span class="s1">ancestorInfo.dlItemTagAutoclosing = info;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">ancestorInfo;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * Returns whether 
     */</span>


    <span class="s3">var </span><span class="s1">isTagValidWithParent = </span><span class="s3">function </span><span class="s1">(tag, parentTag) {</span>
      <span class="s0">// First, let's check if we're in an unusual parsing mode...</span>
      <span class="s3">switch </span><span class="s1">(parentTag) {</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect</span>
        <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'option' </span><span class="s1">|| tag === </span><span class="s2">'optgroup' </span><span class="s1">|| tag === </span><span class="s2">'#text'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'optgroup'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'option' </span><span class="s1">|| tag === </span><span class="s2">'#text'</span><span class="s1">;</span>
        <span class="s0">// Strictly speaking, seeing an &lt;option&gt; doesn't mean we're in a &lt;select&gt;</span>
        <span class="s0">// but</span>

        <span class="s3">case </span><span class="s2">'option'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'#text'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption</span>
        <span class="s0">// No special behavior since these rules fall back to &quot;in body&quot; mode for</span>
        <span class="s0">// all except special table nodes which cause bad parsing behavior anyway.</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr</span>

        <span class="s3">case </span><span class="s2">'tr'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'th' </span><span class="s1">|| tag === </span><span class="s2">'td' </span><span class="s1">|| tag === </span><span class="s2">'style' </span><span class="s1">|| tag === </span><span class="s2">'script' </span><span class="s1">|| tag === </span><span class="s2">'template'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody</span>

        <span class="s3">case </span><span class="s2">'tbody'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'thead'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'tfoot'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'tr' </span><span class="s1">|| tag === </span><span class="s2">'style' </span><span class="s1">|| tag === </span><span class="s2">'script' </span><span class="s1">|| tag === </span><span class="s2">'template'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup</span>

        <span class="s3">case </span><span class="s2">'colgroup'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'col' </span><span class="s1">|| tag === </span><span class="s2">'template'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable</span>

        <span class="s3">case </span><span class="s2">'table'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'caption' </span><span class="s1">|| tag === </span><span class="s2">'colgroup' </span><span class="s1">|| tag === </span><span class="s2">'tbody' </span><span class="s1">|| tag === </span><span class="s2">'tfoot' </span><span class="s1">|| tag === </span><span class="s2">'thead' </span><span class="s1">|| tag === </span><span class="s2">'style' </span><span class="s1">|| tag === </span><span class="s2">'script' </span><span class="s1">|| tag === </span><span class="s2">'template'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead</span>

        <span class="s3">case </span><span class="s2">'head'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'base' </span><span class="s1">|| tag === </span><span class="s2">'basefont' </span><span class="s1">|| tag === </span><span class="s2">'bgsound' </span><span class="s1">|| tag === </span><span class="s2">'link' </span><span class="s1">|| tag === </span><span class="s2">'meta' </span><span class="s1">|| tag === </span><span class="s2">'title' </span><span class="s1">|| tag === </span><span class="s2">'noscript' </span><span class="s1">|| tag === </span><span class="s2">'noframes' </span><span class="s1">|| tag === </span><span class="s2">'style' </span><span class="s1">|| tag === </span><span class="s2">'script' </span><span class="s1">|| tag === </span><span class="s2">'template'</span><span class="s1">;</span>
        <span class="s0">// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element</span>

        <span class="s3">case </span><span class="s2">'html'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'head' </span><span class="s1">|| tag === </span><span class="s2">'body' </span><span class="s1">|| tag === </span><span class="s2">'frameset'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'frameset'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'frame'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'#document'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'html'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Probably in the &quot;in body&quot; parsing mode, so we outlaw only tag combos</span>
      <span class="s0">// where the parsing rules cause implicit opens or closes to be added.</span>
      <span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</span>


      <span class="s3">switch </span><span class="s1">(tag) {</span>
        <span class="s3">case </span><span class="s2">'h1'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h2'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h3'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h4'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h5'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h6'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">parentTag !== </span><span class="s2">'h1' </span><span class="s1">&amp;&amp; parentTag !== </span><span class="s2">'h2' </span><span class="s1">&amp;&amp; parentTag !== </span><span class="s2">'h3' </span><span class="s1">&amp;&amp; parentTag !== </span><span class="s2">'h4' </span><span class="s1">&amp;&amp; parentTag !== </span><span class="s2">'h5' </span><span class="s1">&amp;&amp; parentTag !== </span><span class="s2">'h6'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'rp'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'rt'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">impliedEndTags.indexOf(parentTag) === -</span><span class="s4">1</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'body'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'caption'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'col'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'colgroup'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'frameset'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'frame'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'head'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'html'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'tbody'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'td'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'tfoot'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'th'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'thead'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'tr'</span><span class="s1">:</span>
          <span class="s0">// These tags are only valid with a few parents that have special child</span>
          <span class="s0">// parsing rules -- if we're down here, then none of those matched and</span>
          <span class="s0">// so we allow it only if we don't know what the parent is, as all other</span>
          <span class="s0">// cases are invalid.</span>
          <span class="s3">return </span><span class="s1">parentTag == </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * Returns whether 
     */</span>


    <span class="s3">var </span><span class="s1">findInvalidAncestorForTag = </span><span class="s3">function </span><span class="s1">(tag, ancestorInfo) {</span>
      <span class="s3">switch </span><span class="s1">(tag) {</span>
        <span class="s3">case </span><span class="s2">'address'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'article'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'aside'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'blockquote'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'center'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'details'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'dialog'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'dir'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'div'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'dl'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'fieldset'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'figcaption'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'figure'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'footer'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'header'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'hgroup'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'main'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'menu'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'nav'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'ol'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'p'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'section'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'summary'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'ul'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'pre'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'listing'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'table'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'hr'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'xmp'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h1'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h2'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h3'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h4'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h5'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'h6'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.pTagInButtonScope;</span>

        <span class="s3">case </span><span class="s2">'form'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;</span>

        <span class="s3">case </span><span class="s2">'li'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.listItemTagAutoclosing;</span>

        <span class="s3">case </span><span class="s2">'dd'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'dt'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.dlItemTagAutoclosing;</span>

        <span class="s3">case </span><span class="s2">'button'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.buttonTagInScope;</span>

        <span class="s3">case </span><span class="s2">'a'</span><span class="s1">:</span>
          <span class="s0">// Spec says something about storing a list of markers, but it sounds</span>
          <span class="s0">// equivalent to this check.</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.aTagInScope;</span>

        <span class="s3">case </span><span class="s2">'nobr'</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">ancestorInfo.nobrTagInScope;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">didWarn$1 = {};</span>

    <span class="s1">validateDOMNesting = </span><span class="s3">function </span><span class="s1">(childTag, childText, ancestorInfo) {</span>
      <span class="s1">ancestorInfo = ancestorInfo || emptyAncestorInfo;</span>
      <span class="s3">var </span><span class="s1">parentInfo = ancestorInfo.current;</span>
      <span class="s3">var </span><span class="s1">parentTag = parentInfo &amp;&amp; parentInfo.tag;</span>

      <span class="s3">if </span><span class="s1">(childText != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(childTag != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'validateDOMNesting: when childText is passed, childTag should be null'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">childTag = </span><span class="s2">'#text'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">invalidParent = isTagValidWithParent(childTag, parentTag) ? </span><span class="s3">null </span><span class="s1">: parentInfo;</span>
      <span class="s3">var </span><span class="s1">invalidAncestor = invalidParent ? </span><span class="s3">null </span><span class="s1">: findInvalidAncestorForTag(childTag, ancestorInfo);</span>
      <span class="s3">var </span><span class="s1">invalidParentOrAncestor = invalidParent || invalidAncestor;</span>

      <span class="s3">if </span><span class="s1">(!invalidParentOrAncestor) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">ancestorTag = invalidParentOrAncestor.tag;</span>
      <span class="s3">var </span><span class="s1">addendum = getCurrentFiberStackInDev();</span>
      <span class="s3">var </span><span class="s1">warnKey = !!invalidParent + </span><span class="s2">'|' </span><span class="s1">+ childTag + </span><span class="s2">'|' </span><span class="s1">+ ancestorTag + </span><span class="s2">'|' </span><span class="s1">+ addendum;</span>

      <span class="s3">if </span><span class="s1">(didWarn$1[warnKey]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">didWarn$1[warnKey] = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">tagDisplayName = childTag;</span>
      <span class="s3">var </span><span class="s1">whitespaceInfo = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(childTag === </span><span class="s2">'#text'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(/\S/.test(childText)) {</span>
          <span class="s1">tagDisplayName = </span><span class="s2">'Text nodes'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">tagDisplayName = </span><span class="s2">'Whitespace text nodes'</span><span class="s1">;</span>
          <span class="s1">whitespaceInfo = </span><span class="s2">&quot; Make sure you don't have any extra whitespace between tags on &quot; </span><span class="s1">+ </span><span class="s2">'each line of your source code.'</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">tagDisplayName = </span><span class="s2">'&lt;' </span><span class="s1">+ childTag + </span><span class="s2">'&gt;'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(invalidParent) {</span>
        <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(ancestorTag === </span><span class="s2">'table' </span><span class="s1">&amp;&amp; childTag === </span><span class="s2">'tr'</span><span class="s1">) {</span>
          <span class="s1">info += </span><span class="s2">' Add a &lt;tbody&gt;, &lt;thead&gt; or &lt;tfoot&gt; to your code to match the DOM tree generated by ' </span><span class="s1">+ </span><span class="s2">'the browser.'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">error(</span><span class="s2">'validateDOMNesting(...): %s cannot appear as a child of &lt;%s&gt;.%s%s'</span><span class="s1">, tagDisplayName, ancestorTag, whitespaceInfo, info);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'validateDOMNesting(...): %s cannot appear as a descendant of ' </span><span class="s1">+ </span><span class="s2">'&lt;%s&gt;.'</span><span class="s1">, tagDisplayName, ancestorTag);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">SUPPRESS_HYDRATION_WARNING$1;</span>

  <span class="s1">{</span>
    <span class="s1">SUPPRESS_HYDRATION_WARNING$1 = </span><span class="s2">'suppressHydrationWarning'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">SUSPENSE_START_DATA = </span><span class="s2">'$'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUSPENSE_END_DATA = </span><span class="s2">'/$'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUSPENSE_PENDING_START_DATA = </span><span class="s2">'$?'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUSPENSE_FALLBACK_START_DATA = </span><span class="s2">'$!'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">STYLE$1 = </span><span class="s2">'style'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">eventsEnabled = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">selectionInformation = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">shouldAutoFocusHostComponent(type, props) {</span>
    <span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s2">'button'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'input'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'select'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'textarea'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">!!props.autoFocus;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getRootHostContext(rootContainerInstance) {</span>
    <span class="s3">var </span><span class="s1">type;</span>
    <span class="s3">var </span><span class="s1">namespace;</span>
    <span class="s3">var </span><span class="s1">nodeType = rootContainerInstance.nodeType;</span>

    <span class="s3">switch </span><span class="s1">(nodeType) {</span>
      <span class="s3">case </span><span class="s1">DOCUMENT_NODE:</span>
      <span class="s3">case </span><span class="s1">DOCUMENT_FRAGMENT_NODE:</span>
        <span class="s1">{</span>
          <span class="s1">type = nodeType === DOCUMENT_NODE ? </span><span class="s2">'#document' </span><span class="s1">: </span><span class="s2">'#fragment'</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">root = rootContainerInstance.documentElement;</span>
          <span class="s1">namespace = root ? root.namespaceURI : getChildNamespace(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">''</span><span class="s1">);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;</span>
          <span class="s3">var </span><span class="s1">ownNamespace = container.namespaceURI || </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">type = container.tagName;</span>
          <span class="s1">namespace = getChildNamespace(ownNamespace, type);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">validatedTag = type.toLowerCase();</span>
      <span class="s3">var </span><span class="s1">ancestorInfo = updatedAncestorInfo(</span><span class="s3">null</span><span class="s1">, validatedTag);</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">namespace: namespace,</span>
        <span class="s1">ancestorInfo: ancestorInfo</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getChildHostContext(parentHostContext, type, rootContainerInstance) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">parentHostContextDev = parentHostContext;</span>
      <span class="s3">var </span><span class="s1">namespace = getChildNamespace(parentHostContextDev.namespace, type);</span>
      <span class="s3">var </span><span class="s1">ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">namespace: namespace,</span>
        <span class="s1">ancestorInfo: ancestorInfo</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getPublicInstance(instance) {</span>
    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">prepareForCommit(containerInfo) {</span>
    <span class="s1">eventsEnabled = isEnabled();</span>
    <span class="s1">selectionInformation = getSelectionInformation();</span>
    <span class="s1">setEnabled(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resetAfterCommit(containerInfo) {</span>
    <span class="s1">restoreSelection(selectionInformation);</span>
    <span class="s1">setEnabled(eventsEnabled);</span>
    <span class="s1">eventsEnabled = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">selectionInformation = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {</span>
    <span class="s3">var </span><span class="s1">parentNamespace;</span>

    <span class="s1">{</span>
      <span class="s0">// TODO: take namespace into account when validating.</span>
      <span class="s3">var </span><span class="s1">hostContextDev = hostContext;</span>
      <span class="s1">validateDOMNesting(type, </span><span class="s3">null</span><span class="s1">, hostContextDev.ancestorInfo);</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">props.children === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">props.children === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">string = </span><span class="s2">'' </span><span class="s1">+ props.children;</span>
        <span class="s3">var </span><span class="s1">ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);</span>
        <span class="s1">validateDOMNesting(</span><span class="s3">null</span><span class="s1">, string, ownAncestorInfo);</span>
      <span class="s1">}</span>

      <span class="s1">parentNamespace = hostContextDev.namespace;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">domElement = createElement(type, props, rootContainerInstance, parentNamespace);</span>
    <span class="s1">precacheFiberNode(internalInstanceHandle, domElement);</span>
    <span class="s1">updateFiberProps(domElement, props);</span>
    <span class="s3">return </span><span class="s1">domElement;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">appendInitialChild(parentInstance, child) {</span>
    <span class="s1">parentInstance.appendChild(child);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {</span>
    <span class="s1">setInitialProperties(domElement, type, props, rootContainerInstance);</span>
    <span class="s3">return </span><span class="s1">shouldAutoFocusHostComponent(type, props);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hostContextDev = hostContext;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newProps.children !== </span><span class="s3">typeof </span><span class="s1">oldProps.children &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">newProps.children === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">newProps.children === </span><span class="s2">'number'</span><span class="s1">)) {</span>
        <span class="s3">var </span><span class="s1">string = </span><span class="s2">'' </span><span class="s1">+ newProps.children;</span>
        <span class="s3">var </span><span class="s1">ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);</span>
        <span class="s1">validateDOMNesting(</span><span class="s3">null</span><span class="s1">, string, ownAncestorInfo);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">shouldSetTextContent(type, props) {</span>
    <span class="s3">return </span><span class="s1">type === </span><span class="s2">'textarea' </span><span class="s1">|| type === </span><span class="s2">'option' </span><span class="s1">|| type === </span><span class="s2">'noscript' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">props.children === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">props.children === </span><span class="s2">'number' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">props.dangerouslySetInnerHTML === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; props.dangerouslySetInnerHTML !== </span><span class="s3">null </span><span class="s1">&amp;&amp; props.dangerouslySetInnerHTML.__html != </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">shouldDeprioritizeSubtree(type, props) {</span>
    <span class="s3">return </span><span class="s1">!!props.hidden;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hostContextDev = hostContext;</span>
      <span class="s1">validateDOMNesting(</span><span class="s3">null</span><span class="s1">, text, hostContextDev.ancestorInfo);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">textNode = createTextNode(text, rootContainerInstance);</span>
    <span class="s1">precacheFiberNode(internalInstanceHandle, textNode);</span>
    <span class="s3">return </span><span class="s1">textNode;</span>
  <span class="s1">}</span>
  <span class="s0">// if a component just imports ReactDOM (e.g. for findDOMNode).</span>
  <span class="s0">// Some environments might not have setTimeout or clearTimeout.</span>

  <span class="s3">var </span><span class="s1">scheduleTimeout = </span><span class="s3">typeof </span><span class="s1">setTimeout === </span><span class="s2">'function' </span><span class="s1">? setTimeout : undefined;</span>
  <span class="s3">var </span><span class="s1">cancelTimeout = </span><span class="s3">typeof </span><span class="s1">clearTimeout === </span><span class="s2">'function' </span><span class="s1">? clearTimeout : undefined;</span>
  <span class="s3">var </span><span class="s1">noTimeout = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// -------------------</span>
  <span class="s3">function </span><span class="s1">commitMount(domElement, type, newProps, internalInstanceHandle) {</span>
    <span class="s0">// Despite the naming that might imply otherwise, this method only</span>
    <span class="s0">// fires if there is an `Update` effect scheduled during mounting.</span>
    <span class="s0">// This happens if `finalizeInitialChildren` returns `true` (which it</span>
    <span class="s0">// does to implement the `autoFocus` attribute on the client). But</span>
    <span class="s0">// there are also other cases when this might happen (such as patching</span>
    <span class="s0">// up text content during hydration mismatch). So we'll check this again.</span>
    <span class="s3">if </span><span class="s1">(shouldAutoFocusHostComponent(type, newProps)) {</span>
      <span class="s1">domElement.focus();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {</span>
    <span class="s0">// Update the props handle so that we know which props are the ones with</span>
    <span class="s0">// with current event handlers.</span>
    <span class="s1">updateFiberProps(domElement, newProps); </span><span class="s0">// Apply the diff to the DOM node.</span>

    <span class="s1">updateProperties(domElement, updatePayload, type, oldProps, newProps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resetTextContent(domElement) {</span>
    <span class="s1">setTextContent(domElement, </span><span class="s2">''</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">commitTextUpdate(textInstance, oldText, newText) {</span>
    <span class="s1">textInstance.nodeValue = newText;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">appendChild(parentInstance, child) {</span>
    <span class="s1">parentInstance.appendChild(child);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">appendChildToContainer(container, child) {</span>
    <span class="s3">var </span><span class="s1">parentNode;</span>

    <span class="s3">if </span><span class="s1">(container.nodeType === COMMENT_NODE) {</span>
      <span class="s1">parentNode = container.parentNode;</span>
      <span class="s1">parentNode.insertBefore(child, container);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">parentNode = container;</span>
      <span class="s1">parentNode.appendChild(child);</span>
    <span class="s1">} </span><span class="s0">// This container might be used for a portal.</span>
    <span class="s0">// If something inside a portal is clicked, that click should bubble</span>
    <span class="s0">// through the React tree. However, on Mobile Safari the click would</span>
    <span class="s0">// never bubble through the *DOM* tree unless an ancestor with onclick</span>
    <span class="s0">// event exists. So we wouldn't see it and dispatch it.</span>
    <span class="s0">// This is why we ensure that non React root containers have inline onclick</span>
    <span class="s0">// defined.</span>
    <span class="s0">// https://github.com/facebook/react/issues/11918</span>


    <span class="s3">var </span><span class="s1">reactRootContainer = container._reactRootContainer;</span>

    <span class="s3">if </span><span class="s1">((reactRootContainer === </span><span class="s3">null </span><span class="s1">|| reactRootContainer === undefined) &amp;&amp; parentNode.onclick === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// TODO: This cast may not be sound for SVG, MathML or custom elements.</span>
      <span class="s1">trapClickOnNonInteractiveElement(parentNode);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">insertBefore(parentInstance, child, beforeChild) {</span>
    <span class="s1">parentInstance.insertBefore(child, beforeChild);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">insertInContainerBefore(container, child, beforeChild) {</span>
    <span class="s3">if </span><span class="s1">(container.nodeType === COMMENT_NODE) {</span>
      <span class="s1">container.parentNode.insertBefore(child, beforeChild);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">container.insertBefore(child, beforeChild);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">removeChild(parentInstance, child) {</span>
    <span class="s1">parentInstance.removeChild(child);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">removeChildFromContainer(container, child) {</span>
    <span class="s3">if </span><span class="s1">(container.nodeType === COMMENT_NODE) {</span>
      <span class="s1">container.parentNode.removeChild(child);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">container.removeChild(child);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">hideInstance(instance) {</span>
    <span class="s0">// pass host context to this method?</span>


    <span class="s1">instance = instance;</span>
    <span class="s3">var </span><span class="s1">style = instance.style;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">style.setProperty === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">style.setProperty(</span><span class="s2">'display'</span><span class="s1">, </span><span class="s2">'none'</span><span class="s1">, </span><span class="s2">'important'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">style.display = </span><span class="s2">'none'</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">hideTextInstance(textInstance) {</span>
    <span class="s1">textInstance.nodeValue = </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unhideInstance(instance, props) {</span>
    <span class="s1">instance = instance;</span>
    <span class="s3">var </span><span class="s1">styleProp = props[STYLE$1];</span>
    <span class="s3">var </span><span class="s1">display = styleProp !== undefined &amp;&amp; styleProp !== </span><span class="s3">null </span><span class="s1">&amp;&amp; styleProp.hasOwnProperty(</span><span class="s2">'display'</span><span class="s1">) ? styleProp.display : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">instance.style.display = dangerousStyleValue(</span><span class="s2">'display'</span><span class="s1">, display);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unhideTextInstance(textInstance, text) {</span>
    <span class="s1">textInstance.nodeValue = text;</span>
  <span class="s1">} </span><span class="s0">// -------------------</span>
  <span class="s3">function </span><span class="s1">canHydrateInstance(instance, type, props) {</span>
    <span class="s3">if </span><span class="s1">(instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// This has now been refined to an element node.</span>


    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">canHydrateTextInstance(instance, text) {</span>
    <span class="s3">if </span><span class="s1">(text === </span><span class="s2">'' </span><span class="s1">|| instance.nodeType !== TEXT_NODE) {</span>
      <span class="s0">// Empty strings are not parsed by HTML so there won't be a correct match here.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// This has now been refined to a text node.</span>


    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isSuspenseInstancePending(instance) {</span>
    <span class="s3">return </span><span class="s1">instance.data === SUSPENSE_PENDING_START_DATA;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isSuspenseInstanceFallback(instance) {</span>
    <span class="s3">return </span><span class="s1">instance.data === SUSPENSE_FALLBACK_START_DATA;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getNextHydratable(node) {</span>
    <span class="s0">// Skip non-hydratable nodes.</span>
    <span class="s3">for </span><span class="s1">(; node != </span><span class="s3">null</span><span class="s1">; node = node.nextSibling) {</span>
      <span class="s3">var </span><span class="s1">nodeType = node.nodeType;</span>

      <span class="s3">if </span><span class="s1">(nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getNextHydratableSibling(instance) {</span>
    <span class="s3">return </span><span class="s1">getNextHydratable(instance.nextSibling);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getFirstHydratableChild(parentInstance) {</span>
    <span class="s3">return </span><span class="s1">getNextHydratable(parentInstance.firstChild);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {</span>
    <span class="s1">precacheFiberNode(internalInstanceHandle, instance); </span><span class="s0">// TODO: Possibly defer this until the commit phase where all the events</span>
    <span class="s0">// get attached.</span>

    <span class="s1">updateFiberProps(instance, props);</span>
    <span class="s3">var </span><span class="s1">parentNamespace;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hostContextDev = hostContext;</span>
      <span class="s1">parentNamespace = hostContextDev.namespace;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">hydrateTextInstance(textInstance, text, internalInstanceHandle) {</span>
    <span class="s1">precacheFiberNode(internalInstanceHandle, textInstance);</span>
    <span class="s3">return </span><span class="s1">diffHydratedText(textInstance, text);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {</span>
    <span class="s3">var </span><span class="s1">node = suspenseInstance.nextSibling; </span><span class="s0">// Skip past all nodes within this suspense boundary.</span>
    <span class="s0">// There might be nested nodes so we need to keep track of how</span>
    <span class="s0">// deep we are and only break out when we're back on top.</span>

    <span class="s3">var </span><span class="s1">depth = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(node) {</span>
      <span class="s3">if </span><span class="s1">(node.nodeType === COMMENT_NODE) {</span>
        <span class="s3">var </span><span class="s1">data = node.data;</span>

        <span class="s3">if </span><span class="s1">(data === SUSPENSE_END_DATA) {</span>
          <span class="s3">if </span><span class="s1">(depth === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">getNextHydratableSibling(node);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">depth--;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {</span>
          <span class="s1">depth++;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node = node.nextSibling;</span>
    <span class="s1">} </span><span class="s0">// TODO: Warn, we didn't find the end comment boundary.</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Returns the SuspenseInstance if this node is a direct child of a</span>
  <span class="s0">// SuspenseInstance. I.e. if its previous sibling is a Comment with</span>
  <span class="s0">// SUSPENSE_x_START_DATA. Otherwise, null.</span>

  <span class="s3">function </span><span class="s1">getParentSuspenseInstance(targetInstance) {</span>
    <span class="s3">var </span><span class="s1">node = targetInstance.previousSibling; </span><span class="s0">// Skip past all nodes within this suspense boundary.</span>
    <span class="s0">// There might be nested nodes so we need to keep track of how</span>
    <span class="s0">// deep we are and only break out when we're back on top.</span>

    <span class="s3">var </span><span class="s1">depth = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(node) {</span>
      <span class="s3">if </span><span class="s1">(node.nodeType === COMMENT_NODE) {</span>
        <span class="s3">var </span><span class="s1">data = node.data;</span>

        <span class="s3">if </span><span class="s1">(data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {</span>
          <span class="s3">if </span><span class="s1">(depth === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">node;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">depth--;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(data === SUSPENSE_END_DATA) {</span>
          <span class="s1">depth++;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node = node.previousSibling;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">commitHydratedContainer(container) {</span>
    <span class="s0">// Retry if any event replaying was blocked on this.</span>
    <span class="s1">retryIfBlockedOn(container);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">commitHydratedSuspenseInstance(suspenseInstance) {</span>
    <span class="s0">// Retry if any event replaying was blocked on this.</span>
    <span class="s1">retryIfBlockedOn(suspenseInstance);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {</span>
    <span class="s1">{</span>
      <span class="s1">warnForUnmatchedText(textInstance, text);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {</span>
    <span class="s3">if </span><span class="s1">( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s1">warnForUnmatchedText(textInstance, text);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotHydrateContainerInstance(parentContainer, instance) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(instance.nodeType === ELEMENT_NODE) {</span>
        <span class="s1">warnForDeletedHydratableElement(parentContainer, instance);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(instance.nodeType === COMMENT_NODE) ; </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">warnForDeletedHydratableText(parentContainer, instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {</span>
    <span class="s3">if </span><span class="s1">( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(instance.nodeType === ELEMENT_NODE) {</span>
        <span class="s1">warnForDeletedHydratableElement(parentInstance, instance);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(instance.nodeType === COMMENT_NODE) ; </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">warnForDeletedHydratableText(parentInstance, instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotFindHydratableContainerInstance(parentContainer, type, props) {</span>
    <span class="s1">{</span>
      <span class="s1">warnForInsertedHydratedElement(parentContainer, type);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotFindHydratableContainerTextInstance(parentContainer, text) {</span>
    <span class="s1">{</span>
      <span class="s1">warnForInsertedHydratedText(parentContainer, text);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {</span>
    <span class="s3">if </span><span class="s1">( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s1">warnForInsertedHydratedElement(parentInstance, type);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {</span>
    <span class="s3">if </span><span class="s1">( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s1">warnForInsertedHydratedText(parentInstance, text);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {</span>
    <span class="s3">if </span><span class="s1">( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== </span><span class="s3">true</span><span class="s1">) ;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">randomKey = Math.random().toString(</span><span class="s4">36</span><span class="s1">).slice(</span><span class="s4">2</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">internalInstanceKey = </span><span class="s2">'__reactInternalInstance$' </span><span class="s1">+ randomKey;</span>
  <span class="s3">var </span><span class="s1">internalEventHandlersKey = </span><span class="s2">'__reactEventHandlers$' </span><span class="s1">+ randomKey;</span>
  <span class="s3">var </span><span class="s1">internalContainerInstanceKey = </span><span class="s2">'__reactContainere$' </span><span class="s1">+ randomKey;</span>
  <span class="s3">function </span><span class="s1">precacheFiberNode(hostInst, node) {</span>
    <span class="s1">node[internalInstanceKey] = hostInst;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markContainerAsRoot(hostRoot, node) {</span>
    <span class="s1">node[internalContainerInstanceKey] = hostRoot;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unmarkContainerAsRoot(node) {</span>
    <span class="s1">node[internalContainerInstanceKey] = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isContainerMarkedAsRoot(node) {</span>
    <span class="s3">return </span><span class="s1">!!node[internalContainerInstanceKey];</span>
  <span class="s1">} </span><span class="s0">// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.</span>
  <span class="s0">// If the target node is part of a hydrated or not yet rendered subtree, then</span>
  <span class="s0">// this may also return a SuspenseComponent or HostRoot to indicate that.</span>
  <span class="s0">// Conceptually the HostRoot fiber is a child of the Container node. So if you</span>
  <span class="s0">// pass the Container node as the targetNode, you will not actually get the</span>
  <span class="s0">// HostRoot back. To get to the HostRoot, you need to pass a child of it.</span>
  <span class="s0">// The same thing applies to Suspense boundaries.</span>

  <span class="s3">function </span><span class="s1">getClosestInstanceFromNode(targetNode) {</span>
    <span class="s3">var </span><span class="s1">targetInst = targetNode[internalInstanceKey];</span>

    <span class="s3">if </span><span class="s1">(targetInst) {</span>
      <span class="s0">// Don't return HostRoot or SuspenseComponent here.</span>
      <span class="s3">return </span><span class="s1">targetInst;</span>
    <span class="s1">} </span><span class="s0">// If the direct event target isn't a React owned DOM node, we need to look</span>
    <span class="s0">// to see if one of its parents is a React owned DOM node.</span>


    <span class="s3">var </span><span class="s1">parentNode = targetNode.parentNode;</span>

    <span class="s3">while </span><span class="s1">(parentNode) {</span>
      <span class="s0">// We'll check if this is a container root that could include</span>
      <span class="s0">// React nodes in the future. We need to check this first because</span>
      <span class="s0">// if we're a child of a dehydrated container, we need to first</span>
      <span class="s0">// find that inner container before moving on to finding the parent</span>
      <span class="s0">// instance. Note that we don't check this field on  the targetNode</span>
      <span class="s0">// itself because the fibers are conceptually between the container</span>
      <span class="s0">// node and the first child. It isn't surrounding the container node.</span>
      <span class="s0">// If it's not a container, we check if it's an instance.</span>
      <span class="s1">targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];</span>

      <span class="s3">if </span><span class="s1">(targetInst) {</span>
        <span class="s0">// Since this wasn't the direct target of the event, we might have</span>
        <span class="s0">// stepped past dehydrated DOM nodes to get here. However they could</span>
        <span class="s0">// also have been non-React nodes. We need to answer which one.</span>
        <span class="s0">// If we the instance doesn't have any children, then there can't be</span>
        <span class="s0">// a nested suspense boundary within it. So we can use this as a fast</span>
        <span class="s0">// bailout. Most of the time, when people add non-React children to</span>
        <span class="s0">// the tree, it is using a ref to a child-less DOM node.</span>
        <span class="s0">// Normally we'd only need to check one of the fibers because if it</span>
        <span class="s0">// has ever gone from having children to deleting them or vice versa</span>
        <span class="s0">// it would have deleted the dehydrated boundary nested inside already.</span>
        <span class="s0">// However, since the HostRoot starts out with an alternate it might</span>
        <span class="s0">// have one on the alternate so we need to check in case this was a</span>
        <span class="s0">// root.</span>
        <span class="s3">var </span><span class="s1">alternate = targetInst.alternate;</span>

        <span class="s3">if </span><span class="s1">(targetInst.child !== </span><span class="s3">null </span><span class="s1">|| alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Next we need to figure out if the node that skipped past is</span>
          <span class="s0">// nested within a dehydrated boundary and if so, which one.</span>
          <span class="s3">var </span><span class="s1">suspenseInstance = getParentSuspenseInstance(targetNode);</span>

          <span class="s3">while </span><span class="s1">(suspenseInstance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We found a suspense instance. That means that we haven't</span>
            <span class="s0">// hydrated it yet. Even though we leave the comments in the</span>
            <span class="s0">// DOM after hydrating, and there are boundaries in the DOM</span>
            <span class="s0">// that could already be hydrated, we wouldn't have found them</span>
            <span class="s0">// through this pass since if the target is hydrated it would</span>
            <span class="s0">// have had an internalInstanceKey on it.</span>
            <span class="s0">// Let's get the fiber associated with the SuspenseComponent</span>
            <span class="s0">// as the deepest instance.</span>
            <span class="s3">var </span><span class="s1">targetSuspenseInst = suspenseInstance[internalInstanceKey];</span>

            <span class="s3">if </span><span class="s1">(targetSuspenseInst) {</span>
              <span class="s3">return </span><span class="s1">targetSuspenseInst;</span>
            <span class="s1">} </span><span class="s0">// If we don't find a Fiber on the comment, it might be because</span>
            <span class="s0">// we haven't gotten to hydrate it yet. There might still be a</span>
            <span class="s0">// parent boundary that hasn't above this one so we need to find</span>
            <span class="s0">// the outer most that is known.</span>


            <span class="s1">suspenseInstance = getParentSuspenseInstance(suspenseInstance); </span><span class="s0">// If we don't find one, then that should mean that the parent</span>
            <span class="s0">// host component also hasn't hydrated yet. We can return it</span>
            <span class="s0">// below since it will bail out on the isMounted check later.</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">targetInst;</span>
      <span class="s1">}</span>

      <span class="s1">targetNode = parentNode;</span>
      <span class="s1">parentNode = targetNode.parentNode;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent 
   * instance, or null if the node was not rendered by this React. 
   */</span>

  <span class="s3">function </span><span class="s1">getInstanceFromNode$1(node) {</span>
    <span class="s3">var </span><span class="s1">inst = node[internalInstanceKey] || node[internalContainerInstanceKey];</span>

    <span class="s3">if </span><span class="s1">(inst) {</span>
      <span class="s3">if </span><span class="s1">(inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {</span>
        <span class="s3">return </span><span class="s1">inst;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding 
   * DOM node. 
   */</span>

  <span class="s3">function </span><span class="s1">getNodeFromInstance$1(inst) {</span>
    <span class="s3">if </span><span class="s1">(inst.tag === HostComponent || inst.tag === HostText) {</span>
      <span class="s0">// In Fiber this, is just the state node right now. We assume it will be</span>
      <span class="s0">// a host component or host text.</span>
      <span class="s3">return </span><span class="s1">inst.stateNode;</span>
    <span class="s1">} </span><span class="s0">// Without this first invariant, passing a non-DOM-component triggers the next</span>
    <span class="s0">// invariant for a missing parent, which is super confusing.</span>


    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;getNodeFromInstance: Invalid argument.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getFiberCurrentPropsFromNode$1(node) {</span>
    <span class="s3">return </span><span class="s1">node[internalEventHandlersKey] || </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateFiberProps(node, props) {</span>
    <span class="s1">node[internalEventHandlersKey] = props;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getParent(inst) {</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s1">inst = inst.</span><span class="s3">return</span><span class="s1">; </span><span class="s0">// TODO: If this is a HostRoot we might want to bail out.</span>
      <span class="s0">// That is depending on if we want nested subtrees (layers) to bubble</span>
      <span class="s0">// events to their parent. We could also go through parentNode on the</span>
      <span class="s0">// host node but that wouldn't work for React Native and doesn't let us</span>
      <span class="s0">// do the portal feature.</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(inst &amp;&amp; inst.tag !== HostComponent);</span>

    <span class="s3">if </span><span class="s1">(inst) {</span>
      <span class="s3">return </span><span class="s1">inst;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Return the lowest common ancestor of A and B, or null if they are in 
   * different trees. 
   */</span>


  <span class="s3">function </span><span class="s1">getLowestCommonAncestor(instA, instB) {</span>
    <span class="s3">var </span><span class="s1">depthA = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">tempA = instA; tempA; tempA = getParent(tempA)) {</span>
      <span class="s1">depthA++;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">depthB = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">tempB = instB; tempB; tempB = getParent(tempB)) {</span>
      <span class="s1">depthB++;</span>
    <span class="s1">} </span><span class="s0">// If A is deeper, crawl up.</span>


    <span class="s3">while </span><span class="s1">(depthA - depthB &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">instA = getParent(instA);</span>
      <span class="s1">depthA--;</span>
    <span class="s1">} </span><span class="s0">// If B is deeper, crawl up.</span>


    <span class="s3">while </span><span class="s1">(depthB - depthA &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">instB = getParent(instB);</span>
      <span class="s1">depthB--;</span>
    <span class="s1">} </span><span class="s0">// Walk in lockstep until we find a match.</span>


    <span class="s3">var </span><span class="s1">depth = depthA;</span>

    <span class="s3">while </span><span class="s1">(depth--) {</span>
      <span class="s3">if </span><span class="s1">(instA === instB || instA === instB.alternate) {</span>
        <span class="s3">return </span><span class="s1">instA;</span>
      <span class="s1">}</span>

      <span class="s1">instA = getParent(instA);</span>
      <span class="s1">instB = getParent(instB);</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Simulates the traversal of a two-phase, capture/bubble event dispatch. 
   */</span>

  <span class="s3">function </span><span class="s1">traverseTwoPhase(inst, fn, arg) {</span>
    <span class="s3">var </span><span class="s1">path = [];</span>

    <span class="s3">while </span><span class="s1">(inst) {</span>
      <span class="s1">path.push(inst);</span>
      <span class="s1">inst = getParent(inst);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">i;</span>

    <span class="s3">for </span><span class="s1">(i = path.length; i-- &gt; </span><span class="s4">0</span><span class="s1">;) {</span>
      <span class="s1">fn(path[i], </span><span class="s2">'captured'</span><span class="s1">, arg);</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; path.length; i++) {</span>
      <span class="s1">fn(path[i], </span><span class="s2">'bubbled'</span><span class="s1">, arg);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that 
   * should would receive a `mouseEnter` or `mouseLeave` event. 
   * 
   * Does not invoke the callback on the nearest common ancestor because nothing 
   * &quot;entered&quot; or &quot;left&quot; that element. 
   */</span>

  <span class="s3">function </span><span class="s1">traverseEnterLeave(from, to, fn, argFrom, argTo) {</span>
    <span class="s3">var </span><span class="s1">common = from &amp;&amp; to ? getLowestCommonAncestor(from, to) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">pathFrom = [];</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!from) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(from === common) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">alternate = from.alternate;</span>

      <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate === common) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">pathFrom.push(from);</span>
      <span class="s1">from = getParent(from);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">pathTo = [];</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!to) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(to === common) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">_alternate = to.alternate;</span>

      <span class="s3">if </span><span class="s1">(_alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; _alternate === common) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">pathTo.push(to);</span>
      <span class="s1">to = getParent(to);</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; pathFrom.length; i++) {</span>
      <span class="s1">fn(pathFrom[i], </span><span class="s2">'bubbled'</span><span class="s1">, argFrom);</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = pathTo.length; _i-- &gt; </span><span class="s4">0</span><span class="s1">;) {</span>
      <span class="s1">fn(pathTo[_i], </span><span class="s2">'captured'</span><span class="s1">, argTo);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isInteractive(tag) {</span>
    <span class="s3">return </span><span class="s1">tag === </span><span class="s2">'button' </span><span class="s1">|| tag === </span><span class="s2">'input' </span><span class="s1">|| tag === </span><span class="s2">'select' </span><span class="s1">|| tag === </span><span class="s2">'textarea'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">shouldPreventMouseEvent(name, type, props) {</span>
    <span class="s3">switch </span><span class="s1">(name) {</span>
      <span class="s3">case </span><span class="s2">'onClick'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onClickCapture'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onDoubleClick'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onDoubleClickCapture'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseDown'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseDownCapture'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseMove'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseMoveCapture'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseUp'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseUpCapture'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'onMouseEnter'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">!!(props.disabled &amp;&amp; isInteractive(type));</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @param {object} inst The instance, which is the source of events. 
   * @param {string} registrationName Name of listener (e.g. `onClick`). 
   * @return {?function} The stored callback. 
   */</span>


  <span class="s3">function </span><span class="s1">getListener(inst, registrationName) {</span>
    <span class="s3">var </span><span class="s1">listener; </span><span class="s0">// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not</span>
    <span class="s0">// live here; needs to be moved to a better place soon</span>

    <span class="s3">var </span><span class="s1">stateNode = inst.stateNode;</span>

    <span class="s3">if </span><span class="s1">(!stateNode) {</span>
      <span class="s0">// Work in progress (ex: onload events in incremental mode).</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">props = getFiberCurrentPropsFromNode(stateNode);</span>

    <span class="s3">if </span><span class="s1">(!props) {</span>
      <span class="s0">// Work in progress.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">listener = props[registrationName];</span>

    <span class="s3">if </span><span class="s1">(shouldPreventMouseEvent(registrationName, inst.type, props)) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!(!listener || </span><span class="s3">typeof </span><span class="s1">listener === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected `&quot; </span><span class="s1">+ registrationName + </span><span class="s2">&quot;` listener to be a function, instead got a value of `&quot; </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">listener + </span><span class="s2">&quot;` type.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">listener;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Some event types have a notion of different registration names for different 
   * &quot;phases&quot; of propagation. This finds listeners by a given phase. 
   */</span>
  <span class="s3">function </span><span class="s1">listenerAtPhase(inst, event, propagationPhase) {</span>
    <span class="s3">var </span><span class="s1">registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];</span>
    <span class="s3">return </span><span class="s1">getListener(inst, registrationName);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * A small set of propagation patterns, each of which will accept a small amount 
   * of information, and generate a set of &quot;dispatch ready event objects&quot; - which 
   * are sets of events that have already been annotated with a set of dispatched 
   * listener functions/ids. The API is designed this way to discourage these 
   * propagation strategies from actually executing the dispatches, since we 
   * always want to collect the entire set of dispatches before executing even a 
   * single one. 
   */</span>

  <span class="s0">/** 
   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function 
   * here, allows us to not have to bind or create functions for each event. 
   * Mutating the event's members allows us to not have to create a wrapping 
   * &quot;dispatch&quot; object that pairs the event with the listener. 
   */</span>


  <span class="s3">function </span><span class="s1">accumulateDirectionalDispatches(inst, phase, event) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!inst) {</span>
        <span class="s1">error(</span><span class="s2">'Dispatching inst must not be null'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">listener = listenerAtPhase(inst, event, phase);</span>

    <span class="s3">if </span><span class="s1">(listener) {</span>
      <span class="s1">event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);</span>
      <span class="s1">event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Collect dispatches (must be entirely collected before dispatching - see unit 
   * tests). Lazily allocate the array to conserve memory.  We must loop through 
   * each event and perform the traversal for each one. We cannot perform a 
   * single traversal for the entire collection of events because each event may 
   * have a different target. 
   */</span>


  <span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatchesSingle(event) {</span>
    <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) {</span>
      <span class="s1">traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Accumulates without regard to direction, does not look for phased 
   * registration names. Same as `accumulateDirectDispatchesSingle` but without 
   * requiring that the `dispatchMarker` be the same as the dispatched ID. 
   */</span>


  <span class="s3">function </span><span class="s1">accumulateDispatches(inst, ignoredDirection, event) {</span>
    <span class="s3">if </span><span class="s1">(inst &amp;&amp; event &amp;&amp; event.dispatchConfig.registrationName) {</span>
      <span class="s3">var </span><span class="s1">registrationName = event.dispatchConfig.registrationName;</span>
      <span class="s3">var </span><span class="s1">listener = getListener(inst, registrationName);</span>

      <span class="s3">if </span><span class="s1">(listener) {</span>
        <span class="s1">event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);</span>
        <span class="s1">event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Accumulates dispatches on an `SyntheticEvent`, but only for the 
   * `dispatchMarker`. 
   * @param {SyntheticEvent} event 
   */</span>


  <span class="s3">function </span><span class="s1">accumulateDirectDispatchesSingle(event) {</span>
    <span class="s3">if </span><span class="s1">(event &amp;&amp; event.dispatchConfig.registrationName) {</span>
      <span class="s1">accumulateDispatches(event._targetInst, </span><span class="s3">null</span><span class="s1">, event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">accumulateTwoPhaseDispatches(events) {</span>
    <span class="s1">forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">accumulateEnterLeaveDispatches(leave, enter, from, to) {</span>
    <span class="s1">traverseEnterLeave(from, to, accumulateDispatches, leave, enter);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">accumulateDirectDispatches(events) {</span>
    <span class="s1">forEachAccumulated(events, accumulateDirectDispatchesSingle);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * These variables store information about text content of a target node, 
   * allowing comparison of content before and after a given event. 
   * 
   * Identify the node where selection currently begins, then observe 
   * both its text content and its current position in the DOM. Since the 
   * browser may natively replace the target node during composition, we can 
   * use its position to find its replacement. 
   * 
   * 
   */</span>
  <span class="s3">var </span><span class="s1">root = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">startText = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">fallbackText = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">initialize(nativeEventTarget) {</span>
    <span class="s1">root = nativeEventTarget;</span>
    <span class="s1">startText = getText();</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">reset() {</span>
    <span class="s1">root = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">startText = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">fallbackText = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getData() {</span>
    <span class="s3">if </span><span class="s1">(fallbackText) {</span>
      <span class="s3">return </span><span class="s1">fallbackText;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">start;</span>
    <span class="s3">var </span><span class="s1">startValue = startText;</span>
    <span class="s3">var </span><span class="s1">startLength = startValue.length;</span>
    <span class="s3">var </span><span class="s1">end;</span>
    <span class="s3">var </span><span class="s1">endValue = getText();</span>
    <span class="s3">var </span><span class="s1">endLength = endValue.length;</span>

    <span class="s3">for </span><span class="s1">(start = </span><span class="s4">0</span><span class="s1">; start &lt; startLength; start++) {</span>
      <span class="s3">if </span><span class="s1">(startValue[start] !== endValue[start]) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">minEnd = startLength - start;</span>

    <span class="s3">for </span><span class="s1">(end = </span><span class="s4">1</span><span class="s1">; end &lt;= minEnd; end++) {</span>
      <span class="s3">if </span><span class="s1">(startValue[startLength - end] !== endValue[endLength - end]) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">sliceTail = end &gt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">- end : undefined;</span>
    <span class="s1">fallbackText = endValue.slice(start, sliceTail);</span>
    <span class="s3">return </span><span class="s1">fallbackText;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getText() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">'value' </span><span class="s3">in </span><span class="s1">root) {</span>
      <span class="s3">return </span><span class="s1">root.value;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">root.textContent;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">EVENT_POOL_SIZE = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">EventInterface = {</span>
    <span class="s1">type: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">target: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s0">// currentTarget is set when dispatching; no use in copying it here</span>
    <span class="s1">currentTarget: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">eventPhase: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">bubbles: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">cancelable: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">timeStamp: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">return </span><span class="s1">event.timeStamp || Date.now();</span>
    <span class="s1">},</span>
    <span class="s1">defaultPrevented: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">isTrusted: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">functionThatReturnsTrue() {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">functionThatReturnsFalse() {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Synthetic events are dispatched by event plugins, typically in response to a 
   * top-level event delegation handler. 
   * 
   * These systems should generally use pooling to reduce the frequency of garbage 
   * collection. The system should check `isPersistent` to determine whether the 
   * event should be released into the pool after being dispatched. Users that 
   * need a persisted event should invoke `persist`. 
   * 
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by 
   * normalizing browser quirks. Subclasses do not necessarily have to implement a 
   * DOM interface; custom application-specific events can also subclass this. 
   * 
   * @param {object} dispatchConfig Configuration used to dispatch this event. 
   * @param {*} targetInst Marker identifying the event target. 
   * @param {object} nativeEvent Native browser event. 
   * @param {DOMEventTarget} nativeEventTarget Target node. 
   */</span>


  <span class="s3">function </span><span class="s1">SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {</span>
    <span class="s1">{</span>
      <span class="s0">// these have a getter/setter for warnings</span>
      <span class="s3">delete this</span><span class="s1">.nativeEvent;</span>
      <span class="s3">delete this</span><span class="s1">.preventDefault;</span>
      <span class="s3">delete this</span><span class="s1">.stopPropagation;</span>
      <span class="s3">delete this</span><span class="s1">.isDefaultPrevented;</span>
      <span class="s3">delete this</span><span class="s1">.isPropagationStopped;</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.dispatchConfig = dispatchConfig;</span>
    <span class="s3">this</span><span class="s1">._targetInst = targetInst;</span>
    <span class="s3">this</span><span class="s1">.nativeEvent = nativeEvent;</span>
    <span class="s3">var </span><span class="s1">Interface = </span><span class="s3">this</span><span class="s1">.constructor.Interface;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">Interface) {</span>
      <span class="s3">if </span><span class="s1">(!Interface.hasOwnProperty(propName)) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">delete this</span><span class="s1">[propName]; </span><span class="s0">// this has a getter/setter for warnings</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">normalize = Interface[propName];</span>

      <span class="s3">if </span><span class="s1">(normalize) {</span>
        <span class="s3">this</span><span class="s1">[propName] = normalize(nativeEvent);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(propName === </span><span class="s2">'target'</span><span class="s1">) {</span>
          <span class="s3">this</span><span class="s1">.target = nativeEventTarget;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">this</span><span class="s1">[propName] = nativeEvent[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">defaultPrevented = nativeEvent.defaultPrevented != </span><span class="s3">null </span><span class="s1">? nativeEvent.defaultPrevented : nativeEvent.returnValue === </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(defaultPrevented) {</span>
      <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsTrue;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsFalse;</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsFalse;</span>
    <span class="s3">return this</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">_assign(SyntheticEvent.prototype, {</span>
    <span class="s1">preventDefault: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">this</span><span class="s1">.defaultPrevented = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>

      <span class="s3">if </span><span class="s1">(!event) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(event.preventDefault) {</span>
        <span class="s1">event.preventDefault();</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">event.returnValue !== </span><span class="s2">'unknown'</span><span class="s1">) {</span>
        <span class="s1">event.returnValue = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsTrue;</span>
    <span class="s1">},</span>
    <span class="s1">stopPropagation: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">event = </span><span class="s3">this</span><span class="s1">.nativeEvent;</span>

      <span class="s3">if </span><span class="s1">(!event) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(event.stopPropagation) {</span>
        <span class="s1">event.stopPropagation();</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">event.cancelBubble !== </span><span class="s2">'unknown'</span><span class="s1">) {</span>
        <span class="s0">// The ChangeEventPlugin registers a &quot;propertychange&quot; event for</span>
        <span class="s0">// IE. This event does not support bubbling or cancelling, and</span>
        <span class="s0">// any references to cancelBubble throw &quot;Member not found&quot;.  A</span>
        <span class="s0">// typeof check of &quot;unknown&quot; circumvents this issue (and is also</span>
        <span class="s0">// IE specific).</span>
        <span class="s1">event.cancelBubble = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsTrue;</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * We release all dispatched `SyntheticEvent`s after each event loop, adding 
     * them back into the pool. This allows a way to hold onto a reference that 
     * won't be added back into the pool. 
     */</span>
    <span class="s1">persist: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">this</span><span class="s1">.isPersistent = functionThatReturnsTrue;</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Checks if this event should be released back into the pool. 
     * 
     * @return {boolean} True if this should not be released, false otherwise. 
     */</span>
    <span class="s1">isPersistent: functionThatReturnsFalse,</span>

    <span class="s0">/** 
     * `PooledClass` looks for `destructor` on each instance it releases. 
     */</span>
    <span class="s1">destructor: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">Interface = </span><span class="s3">this</span><span class="s1">.constructor.Interface;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">Interface) {</span>
        <span class="s1">{</span>
          <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">this</span><span class="s1">.dispatchConfig = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._targetInst = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.nativeEvent = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.isDefaultPrevented = functionThatReturnsFalse;</span>
      <span class="s3">this</span><span class="s1">.isPropagationStopped = functionThatReturnsFalse;</span>
      <span class="s3">this</span><span class="s1">._dispatchListeners = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._dispatchInstances = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'nativeEvent'</span><span class="s1">, getPooledWarningPropertyDefinition(</span><span class="s2">'nativeEvent'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">));</span>
        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'isDefaultPrevented'</span><span class="s1">, getPooledWarningPropertyDefinition(</span><span class="s2">'isDefaultPrevented'</span><span class="s1">, functionThatReturnsFalse));</span>
        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'isPropagationStopped'</span><span class="s1">, getPooledWarningPropertyDefinition(</span><span class="s2">'isPropagationStopped'</span><span class="s1">, functionThatReturnsFalse));</span>
        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'preventDefault'</span><span class="s1">, getPooledWarningPropertyDefinition(</span><span class="s2">'preventDefault'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">() {}));</span>
        <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'stopPropagation'</span><span class="s1">, getPooledWarningPropertyDefinition(</span><span class="s2">'stopPropagation'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">() {}));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">SyntheticEvent.Interface = EventInterface;</span>
  <span class="s0">/** 
   * Helper to reduce boilerplate when creating subclasses. 
   */</span>

  <span class="s1">SyntheticEvent.extend = </span><span class="s3">function </span><span class="s1">(Interface) {</span>
    <span class="s3">var </span><span class="s1">Super = </span><span class="s3">this</span><span class="s1">;</span>

    <span class="s3">var </span><span class="s1">E = </span><span class="s3">function </span><span class="s1">() {};</span>

    <span class="s1">E.prototype = Super.prototype;</span>
    <span class="s3">var </span><span class="s1">prototype = </span><span class="s3">new </span><span class="s1">E();</span>

    <span class="s3">function </span><span class="s1">Class() {</span>
      <span class="s3">return </span><span class="s1">Super.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
    <span class="s1">}</span>

    <span class="s1">_assign(prototype, Class.prototype);</span>

    <span class="s1">Class.prototype = prototype;</span>
    <span class="s1">Class.prototype.constructor = Class;</span>
    <span class="s1">Class.Interface = _assign({}, Super.Interface, Interface);</span>
    <span class="s1">Class.extend = Super.extend;</span>
    <span class="s1">addEventPoolingTo(Class);</span>
    <span class="s3">return </span><span class="s1">Class;</span>
  <span class="s1">};</span>

  <span class="s1">addEventPoolingTo(SyntheticEvent);</span>
  <span class="s0">/** 
   * Helper to nullify syntheticEvent instance properties when destructing 
   * 
   * @param {String} propName 
   * @param {?object} getVal 
   * @return {object} defineProperty object 
   */</span>

  <span class="s3">function </span><span class="s1">getPooledWarningPropertyDefinition(propName, getVal) {</span>
    <span class="s3">var </span><span class="s1">isFunction = </span><span class="s3">typeof </span><span class="s1">getVal === </span><span class="s2">'function'</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">set: set,</span>
      <span class="s1">get: get</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">set(val) {</span>
      <span class="s3">var </span><span class="s1">action = isFunction ? </span><span class="s2">'setting the method' </span><span class="s1">: </span><span class="s2">'setting the property'</span><span class="s1">;</span>
      <span class="s1">warn(action, </span><span class="s2">'This is effectively a no-op'</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">val;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">get() {</span>
      <span class="s3">var </span><span class="s1">action = isFunction ? </span><span class="s2">'accessing the method' </span><span class="s1">: </span><span class="s2">'accessing the property'</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">result = isFunction ? </span><span class="s2">'This is a no-op function' </span><span class="s1">: </span><span class="s2">'This is set to null'</span><span class="s1">;</span>
      <span class="s1">warn(action, result);</span>
      <span class="s3">return </span><span class="s1">getVal;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">warn(action, result) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">&quot;This synthetic event is reused for performance reasons. If you're seeing this, &quot; </span><span class="s1">+ </span><span class="s2">&quot;you're %s `%s` on a released/nullified synthetic event. %s. &quot; </span><span class="s1">+ </span><span class="s2">'If you must keep the original synthetic event around, use event.persist(). ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-event-pooling for more information.'</span><span class="s1">, action, propName, result);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {</span>
    <span class="s3">var </span><span class="s1">EventConstructor = </span><span class="s3">this</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(EventConstructor.eventPool.length) {</span>
      <span class="s3">var </span><span class="s1">instance = EventConstructor.eventPool.pop();</span>
      <span class="s1">EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);</span>
      <span class="s3">return </span><span class="s1">instance;</span>
    <span class="s1">}</span>

    <span class="s3">return new </span><span class="s1">EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">releasePooledEvent(event) {</span>
    <span class="s3">var </span><span class="s1">EventConstructor = </span><span class="s3">this</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!(event </span><span class="s3">instanceof </span><span class="s1">EventConstructor)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Trying to release an event instance into a pool of a different type.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">event.destructor();</span>

    <span class="s3">if </span><span class="s1">(EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) {</span>
      <span class="s1">EventConstructor.eventPool.push(event);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">addEventPoolingTo(EventConstructor) {</span>
    <span class="s1">EventConstructor.eventPool = [];</span>
    <span class="s1">EventConstructor.getPooled = getPooledEvent;</span>
    <span class="s1">EventConstructor.release = releasePooledEvent;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticCompositionEvent = SyntheticEvent.extend({</span>
    <span class="s1">data: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105 
   *      /#events-inputevents 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticInputEvent = SyntheticEvent.extend({</span>
    <span class="s1">data: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">END_KEYCODES = [</span><span class="s4">9</span><span class="s1">, </span><span class="s4">13</span><span class="s1">, </span><span class="s4">27</span><span class="s1">, </span><span class="s4">32</span><span class="s1">]; </span><span class="s0">// Tab, Return, Esc, Space</span>

  <span class="s3">var </span><span class="s1">START_KEYCODE = </span><span class="s4">229</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">canUseCompositionEvent = canUseDOM &amp;&amp; </span><span class="s2">'CompositionEvent' </span><span class="s3">in </span><span class="s1">window;</span>
  <span class="s3">var </span><span class="s1">documentMode = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(canUseDOM &amp;&amp; </span><span class="s2">'documentMode' </span><span class="s3">in </span><span class="s1">document) {</span>
    <span class="s1">documentMode = document.documentMode;</span>
  <span class="s1">} </span><span class="s0">// Webkit offers a very useful `textInput` event that can be used to</span>
  <span class="s0">// directly represent `beforeInput`. The IE `textinput` event is not as</span>
  <span class="s0">// useful, so we don't use it.</span>


  <span class="s3">var </span><span class="s1">canUseTextInputEvent = canUseDOM &amp;&amp; </span><span class="s2">'TextEvent' </span><span class="s3">in </span><span class="s1">window &amp;&amp; !documentMode; </span><span class="s0">// In IE9+, we have access to composition events, but the data supplied</span>
  <span class="s0">// by the native compositionend event may be incorrect. Japanese ideographic</span>
  <span class="s0">// spaces, for instance (\u3000) are not recorded correctly.</span>

  <span class="s3">var </span><span class="s1">useFallbackCompositionData = canUseDOM &amp;&amp; (!canUseCompositionEvent || documentMode &amp;&amp; documentMode &gt; </span><span class="s4">8 </span><span class="s1">&amp;&amp; documentMode &lt;= </span><span class="s4">11</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">SPACEBAR_CODE = </span><span class="s4">32</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE); </span><span class="s0">// Events and their corresponding property names.</span>

  <span class="s3">var </span><span class="s1">eventTypes = {</span>
    <span class="s1">beforeInput: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onBeforeInput'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onBeforeInputCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]</span>
    <span class="s1">},</span>
    <span class="s1">compositionEnd: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onCompositionEnd'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onCompositionEndCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]</span>
    <span class="s1">},</span>
    <span class="s1">compositionStart: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onCompositionStart'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onCompositionStartCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]</span>
    <span class="s1">},</span>
    <span class="s1">compositionUpdate: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onCompositionUpdate'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onCompositionUpdateCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]</span>
    <span class="s1">}</span>
  <span class="s1">}; </span><span class="s0">// Track whether we've ever handled a keypress on the space key.</span>

  <span class="s3">var </span><span class="s1">hasSpaceKeypress = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s0">/** 
   * Return whether a native keypress event is assumed to be a command. 
   * This is required because Firefox fires `keypress` events for key commands 
   * (cut, copy, select-all, etc.) even though no character is inserted. 
   */</span>

  <span class="s3">function </span><span class="s1">isKeypressCommand(nativeEvent) {</span>
    <span class="s3">return </span><span class="s1">(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &amp;&amp; </span><span class="s0">// ctrlKey &amp;&amp; altKey is equivalent to AltGr, and is not a command.</span>
    <span class="s1">!(nativeEvent.ctrlKey &amp;&amp; nativeEvent.altKey);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Translate native top level events into event types. 
   * 
   * @param {string} topLevelType 
   * @return {object} 
   */</span>


  <span class="s3">function </span><span class="s1">getCompositionEventType(topLevelType) {</span>
    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_COMPOSITION_START:</span>
        <span class="s3">return </span><span class="s1">eventTypes.compositionStart;</span>

      <span class="s3">case </span><span class="s1">TOP_COMPOSITION_END:</span>
        <span class="s3">return </span><span class="s1">eventTypes.compositionEnd;</span>

      <span class="s3">case </span><span class="s1">TOP_COMPOSITION_UPDATE:</span>
        <span class="s3">return </span><span class="s1">eventTypes.compositionUpdate;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Does our fallback best-guess model think this event signifies that 
   * composition has begun? 
   * 
   * @param {string} topLevelType 
   * @param {object} nativeEvent 
   * @return {boolean} 
   */</span>


  <span class="s3">function </span><span class="s1">isFallbackCompositionStart(topLevelType, nativeEvent) {</span>
    <span class="s3">return </span><span class="s1">topLevelType === TOP_KEY_DOWN &amp;&amp; nativeEvent.keyCode === START_KEYCODE;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Does our fallback mode think that this event is the end of composition? 
   * 
   * @param {string} topLevelType 
   * @param {object} nativeEvent 
   * @return {boolean} 
   */</span>


  <span class="s3">function </span><span class="s1">isFallbackCompositionEnd(topLevelType, nativeEvent) {</span>
    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_KEY_UP:</span>
        <span class="s0">// Command keys insert or clear IME input.</span>
        <span class="s3">return </span><span class="s1">END_KEYCODES.indexOf(nativeEvent.keyCode) !== -</span><span class="s4">1</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_KEY_DOWN:</span>
        <span class="s0">// Expect IME keyCode on each keydown. If we get any other</span>
        <span class="s0">// code we must have exited earlier.</span>
        <span class="s3">return </span><span class="s1">nativeEvent.keyCode !== START_KEYCODE;</span>

      <span class="s3">case </span><span class="s1">TOP_KEY_PRESS:</span>
      <span class="s3">case </span><span class="s1">TOP_MOUSE_DOWN:</span>
      <span class="s3">case </span><span class="s1">TOP_BLUR:</span>
        <span class="s0">// Events are not possible without cancelling IME.</span>
        <span class="s3">return true</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Google Input Tools provides composition data via a CustomEvent, 
   * with the `data` property populated in the `detail` object. If this 
   * is available on the event object, use it. If not, this is a plain 
   * composition event and we have nothing special to extract. 
   * 
   * @param {object} nativeEvent 
   * @return {?string} 
   */</span>


  <span class="s3">function </span><span class="s1">getDataFromCustomEvent(nativeEvent) {</span>
    <span class="s3">var </span><span class="s1">detail = nativeEvent.detail;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">detail === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">'data' </span><span class="s3">in </span><span class="s1">detail) {</span>
      <span class="s3">return </span><span class="s1">detail.data;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Check if a composition event was triggered by Korean IME. 
   * Our fallback mode does not work well with IE's Korean IME, 
   * so just use native composition events when Korean IME is used. 
   * Although CompositionEvent.locale property is deprecated, 
   * it is available in IE, where our fallback mode is enabled. 
   * 
   * @param {object} nativeEvent 
   * @return {boolean} 
   */</span>


  <span class="s3">function </span><span class="s1">isUsingKoreanIME(nativeEvent) {</span>
    <span class="s3">return </span><span class="s1">nativeEvent.locale === </span><span class="s2">'ko'</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Track the current IME composition status, if any.</span>


  <span class="s3">var </span><span class="s1">isComposing = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s0">/** 
   * @return {?object} A SyntheticCompositionEvent. 
   */</span>

  <span class="s3">function </span><span class="s1">extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {</span>
    <span class="s3">var </span><span class="s1">eventType;</span>
    <span class="s3">var </span><span class="s1">fallbackData;</span>

    <span class="s3">if </span><span class="s1">(canUseCompositionEvent) {</span>
      <span class="s1">eventType = getCompositionEventType(topLevelType);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!isComposing) {</span>
      <span class="s3">if </span><span class="s1">(isFallbackCompositionStart(topLevelType, nativeEvent)) {</span>
        <span class="s1">eventType = eventTypes.compositionStart;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isFallbackCompositionEnd(topLevelType, nativeEvent)) {</span>
      <span class="s1">eventType = eventTypes.compositionEnd;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!eventType) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(useFallbackCompositionData &amp;&amp; !isUsingKoreanIME(nativeEvent)) {</span>
      <span class="s0">// The current composition is stored statically and must not be</span>
      <span class="s0">// overwritten while composition continues.</span>
      <span class="s3">if </span><span class="s1">(!isComposing &amp;&amp; eventType === eventTypes.compositionStart) {</span>
        <span class="s1">isComposing = initialize(nativeEventTarget);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(eventType === eventTypes.compositionEnd) {</span>
        <span class="s3">if </span><span class="s1">(isComposing) {</span>
          <span class="s1">fallbackData = getData();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);</span>

    <span class="s3">if </span><span class="s1">(fallbackData) {</span>
      <span class="s0">// Inject data generated from fallback path into the synthetic event.</span>
      <span class="s0">// This matches the property of native CompositionEventInterface.</span>
      <span class="s1">event.data = fallbackData;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">customData = getDataFromCustomEvent(nativeEvent);</span>

      <span class="s3">if </span><span class="s1">(customData !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">event.data = customData;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">accumulateTwoPhaseDispatches(event);</span>
    <span class="s3">return </span><span class="s1">event;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @param {TopLevelType} topLevelType Number from `TopLevelType`. 
   * @param {object} nativeEvent Native browser event. 
   * @return {?string} The string corresponding to this `beforeInput` event. 
   */</span>


  <span class="s3">function </span><span class="s1">getNativeBeforeInputChars(topLevelType, nativeEvent) {</span>
    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_COMPOSITION_END:</span>
        <span class="s3">return </span><span class="s1">getDataFromCustomEvent(nativeEvent);</span>

      <span class="s3">case </span><span class="s1">TOP_KEY_PRESS:</span>
        <span class="s0">/** 
         * If native `textInput` events are available, our goal is to make 
         * use of them. However, there is a special case: the spacebar key. 
         * In Webkit, preventing default on a spacebar `textInput` event 
         * cancels character insertion, but it *also* causes the browser 
         * to fall back to its default spacebar behavior of scrolling the 
         * page. 
         * 
         * Tracking at: 
         * https://code.google.com/p/chromium/issues/detail?id=355103 
         * 
         * To avoid this issue, use the keypress event as if no `textInput` 
         * event is available. 
         */</span>
        <span class="s3">var </span><span class="s1">which = nativeEvent.which;</span>

        <span class="s3">if </span><span class="s1">(which !== SPACEBAR_CODE) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">hasSpaceKeypress = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">SPACEBAR_CHAR;</span>

      <span class="s3">case </span><span class="s1">TOP_TEXT_INPUT:</span>
        <span class="s0">// Record the characters to be added to the DOM.</span>
        <span class="s3">var </span><span class="s1">chars = nativeEvent.data; </span><span class="s0">// If it's a spacebar character, assume that we have already handled</span>
        <span class="s0">// it at the keypress level and bail immediately. Android Chrome</span>
        <span class="s0">// doesn't give us keycodes, so we need to ignore it.</span>

        <span class="s3">if </span><span class="s1">(chars === SPACEBAR_CHAR &amp;&amp; hasSpaceKeypress) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">chars;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s0">// For other native event types, do nothing.</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * For browsers that do not provide the `textInput` event, extract the 
   * appropriate string to use for SyntheticInputEvent. 
   * 
   * @param {number} topLevelType Number from `TopLevelEventTypes`. 
   * @param {object} nativeEvent Native browser event. 
   * @return {?string} The fallback string for this `beforeInput` event. 
   */</span>


  <span class="s3">function </span><span class="s1">getFallbackBeforeInputChars(topLevelType, nativeEvent) {</span>
    <span class="s0">// If we are currently composing (IME) and using a fallback to do so,</span>
    <span class="s0">// try to extract the composed characters from the fallback object.</span>
    <span class="s0">// If composition event is available, we extract a string only at</span>
    <span class="s0">// compositionevent, otherwise extract it at fallback events.</span>
    <span class="s3">if </span><span class="s1">(isComposing) {</span>
      <span class="s3">if </span><span class="s1">(topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent &amp;&amp; isFallbackCompositionEnd(topLevelType, nativeEvent)) {</span>
        <span class="s3">var </span><span class="s1">chars = getData();</span>
        <span class="s1">reset();</span>
        <span class="s1">isComposing = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">chars;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
      <span class="s3">case </span><span class="s1">TOP_PASTE:</span>
        <span class="s0">// If a paste event occurs after a keypress, throw out the input</span>
        <span class="s0">// chars. Paste events should not lead to BeforeInput events.</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_KEY_PRESS:</span>
        <span class="s0">/** 
         * As of v27, Firefox may fire keypress events even when no character 
         * will be inserted. A few possibilities: 
         * 
         * - `which` is `0`. Arrow keys, Esc key, etc. 
         * 
         * - `which` is the pressed key code, but no char is available. 
         *   Ex: 'AltGr + d` in Polish. There is no modified character for 
         *   this key combination and no character is inserted into the 
         *   document, but FF fires the keypress for char code `100` anyway. 
         *   No `input` event will occur. 
         * 
         * - `which` is the pressed key code, but a command combination is 
         *   being used. Ex: `Cmd+C`. No character is inserted, and no 
         *   `input` event will occur. 
         */</span>
        <span class="s3">if </span><span class="s1">(!isKeypressCommand(nativeEvent)) {</span>
          <span class="s0">// IE fires the `keypress` event when a user types an emoji via</span>
          <span class="s0">// Touch keyboard of Windows.  In such a case, the `char` property</span>
          <span class="s0">// holds an emoji character like `\uD83D\uDE0A`.  Because its length</span>
          <span class="s0">// is 2, the property `which` does not represent an emoji correctly.</span>
          <span class="s0">// In such a case, we directly return the `char` property instead of</span>
          <span class="s0">// using `which`.</span>
          <span class="s3">if </span><span class="s1">(nativeEvent.char &amp;&amp; nativeEvent.char.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">nativeEvent.char;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nativeEvent.which) {</span>
            <span class="s3">return </span><span class="s1">String.fromCharCode(nativeEvent.which);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">TOP_COMPOSITION_END:</span>
        <span class="s3">return </span><span class="s1">useFallbackCompositionData &amp;&amp; !isUsingKoreanIME(nativeEvent) ? </span><span class="s3">null </span><span class="s1">: nativeEvent.data;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Extract a SyntheticInputEvent for `beforeInput`, based on either native 
   * `textInput` or fallback behavior. 
   * 
   * @return {?object} A SyntheticInputEvent. 
   */</span>


  <span class="s3">function </span><span class="s1">extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {</span>
    <span class="s3">var </span><span class="s1">chars;</span>

    <span class="s3">if </span><span class="s1">(canUseTextInputEvent) {</span>
      <span class="s1">chars = getNativeBeforeInputChars(topLevelType, nativeEvent);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);</span>
    <span class="s1">} </span><span class="s0">// If no characters are being inserted, no BeforeInput event should</span>
    <span class="s0">// be fired.</span>


    <span class="s3">if </span><span class="s1">(!chars) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);</span>
    <span class="s1">event.data = chars;</span>
    <span class="s1">accumulateTwoPhaseDispatches(event);</span>
    <span class="s3">return </span><span class="s1">event;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Create an `onBeforeInput` event to match 
   * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents. 
   * 
   * This event plugin is based on the native `textInput` event 
   * available in Chrome, Safari, Opera, and IE. This event fires after 
   * `onKeyPress` and `onCompositionEnd`, but before `onInput`. 
   * 
   * `beforeInput` is spec'd but not implemented in any browsers, and 
   * the `input` event does not provide any useful information about what has 
   * actually been added, contrary to the spec. Thus, `textInput` is the best 
   * available event to identify the characters that have actually been inserted 
   * into the target node. 
   * 
   * This plugin is also responsible for emitting `composition` events, thus 
   * allowing us to share composition fallback code for both `beforeInput` and 
   * `composition` event types. 
   */</span>


  <span class="s3">var </span><span class="s1">BeforeInputEventPlugin = {</span>
    <span class="s1">eventTypes: eventTypes,</span>
    <span class="s1">extractEvents: </span><span class="s3">function </span><span class="s1">(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
      <span class="s3">var </span><span class="s1">composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span>
      <span class="s3">var </span><span class="s1">beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span>

      <span class="s3">if </span><span class="s1">(composition === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">beforeInput;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(beforeInput === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">composition;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">[composition, beforeInput];</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary 
   */</span>
  <span class="s3">var </span><span class="s1">supportedInputTypes = {</span>
    <span class="s1">color: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">date: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">datetime: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s2">'datetime-local'</span><span class="s1">: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">email: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">month: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">number: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">password: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">range: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">search: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">tel: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">text: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">time: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">url: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">week: </span><span class="s3">true</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">isTextInputElement(elem) {</span>
    <span class="s3">var </span><span class="s1">nodeName = elem &amp;&amp; elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();</span>

    <span class="s3">if </span><span class="s1">(nodeName === </span><span class="s2">'input'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">!!supportedInputTypes[elem.type];</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nodeName === </span><span class="s2">'textarea'</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">eventTypes$1 = {</span>
    <span class="s1">change: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onChange'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onChangeCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">createAndAccumulateChangeEvent(inst, nativeEvent, target) {</span>
    <span class="s3">var </span><span class="s1">event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);</span>
    <span class="s1">event.type = </span><span class="s2">'change'</span><span class="s1">; </span><span class="s0">// Flag this event loop as needing state restore.</span>

    <span class="s1">enqueueStateRestore(target);</span>
    <span class="s1">accumulateTwoPhaseDispatches(event);</span>
    <span class="s3">return </span><span class="s1">event;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * For IE shims 
   */</span>


  <span class="s3">var </span><span class="s1">activeElement = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">activeElementInst = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s0">/** 
   * SECTION: handle `change` event 
   */</span>

  <span class="s3">function </span><span class="s1">shouldUseChangeEvent(elem) {</span>
    <span class="s3">var </span><span class="s1">nodeName = elem.nodeName &amp;&amp; elem.nodeName.toLowerCase();</span>
    <span class="s3">return </span><span class="s1">nodeName === </span><span class="s2">'select' </span><span class="s1">|| nodeName === </span><span class="s2">'input' </span><span class="s1">&amp;&amp; elem.type === </span><span class="s2">'file'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">manualDispatchChangeEvent(nativeEvent) {</span>
    <span class="s3">var </span><span class="s1">event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent)); </span><span class="s0">// If change and propertychange bubbled, we'd just bind to it like all the</span>
    <span class="s0">// other events and have it go through ReactBrowserEventEmitter. Since it</span>
    <span class="s0">// doesn't, we manually listen for the events and so we have to enqueue and</span>
    <span class="s0">// process the abstract event manually.</span>
    <span class="s0">//</span>
    <span class="s0">// Batching is necessary here in order to ensure that all event handlers run</span>
    <span class="s0">// before the next rerender (including event handlers attached to ancestor</span>
    <span class="s0">// elements instead of directly on the input). Without this, controlled</span>
    <span class="s0">// components don't work properly in conjunction with event bubbling because</span>
    <span class="s0">// the component is rerendered and the value reverted before all the event</span>
    <span class="s0">// handlers can run. See https://github.com/facebook/react/issues/708.</span>

    <span class="s1">batchedUpdates(runEventInBatch, event);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">runEventInBatch(event) {</span>
    <span class="s1">runEventsInBatch(event);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getInstIfValueChanged(targetInst) {</span>
    <span class="s3">var </span><span class="s1">targetNode = getNodeFromInstance$1(targetInst);</span>

    <span class="s3">if </span><span class="s1">(updateValueIfChanged(targetNode)) {</span>
      <span class="s3">return </span><span class="s1">targetInst;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getTargetInstForChangeEvent(topLevelType, targetInst) {</span>
    <span class="s3">if </span><span class="s1">(topLevelType === TOP_CHANGE) {</span>
      <span class="s3">return </span><span class="s1">targetInst;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * SECTION: handle `input` event 
   */</span>


  <span class="s3">var </span><span class="s1">isInputEventSupported = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(canUseDOM) {</span>
    <span class="s0">// IE9 claims to support the input event but fails to trigger it when</span>
    <span class="s0">// deleting text, so we ignore its input events.</span>
    <span class="s1">isInputEventSupported = isEventSupported(</span><span class="s2">'input'</span><span class="s1">) &amp;&amp; (!document.documentMode || document.documentMode &gt; </span><span class="s4">9</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * (For IE &lt;=9) Starts tracking propertychange events on the passed-in element 
   * and override the value property so that we can distinguish user events from 
   * value changes in JS. 
   */</span>


  <span class="s3">function </span><span class="s1">startWatchingForValueChange(target, targetInst) {</span>
    <span class="s1">activeElement = target;</span>
    <span class="s1">activeElementInst = targetInst;</span>
    <span class="s1">activeElement.attachEvent(</span><span class="s2">'onpropertychange'</span><span class="s1">, handlePropertyChange);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * (For IE &lt;=9) Removes the event listeners from the currently-tracked element, 
   * if any exists. 
   */</span>


  <span class="s3">function </span><span class="s1">stopWatchingForValueChange() {</span>
    <span class="s3">if </span><span class="s1">(!activeElement) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">activeElement.detachEvent(</span><span class="s2">'onpropertychange'</span><span class="s1">, handlePropertyChange);</span>
    <span class="s1">activeElement = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">activeElementInst = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * (For IE &lt;=9) Handles a propertychange event, sending a `change` event if 
   * the value of the active element has changed. 
   */</span>


  <span class="s3">function </span><span class="s1">handlePropertyChange(nativeEvent) {</span>
    <span class="s3">if </span><span class="s1">(nativeEvent.propertyName !== </span><span class="s2">'value'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(getInstIfValueChanged(activeElementInst)) {</span>
      <span class="s1">manualDispatchChangeEvent(nativeEvent);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {</span>
    <span class="s3">if </span><span class="s1">(topLevelType === TOP_FOCUS) {</span>
      <span class="s0">// In IE9, propertychange fires for most input events but is buggy and</span>
      <span class="s0">// doesn't fire when text is deleted, but conveniently, selectionchange</span>
      <span class="s0">// appears to fire in all of the remaining cases so we catch those and</span>
      <span class="s0">// forward the event if the value has changed</span>
      <span class="s0">// In either case, we don't want to call the event handler if the value</span>
      <span class="s0">// is changed from JS so we redefine a setter for `.value` that updates</span>
      <span class="s0">// our activeElementValue variable, allowing us to ignore those changes</span>
      <span class="s0">//</span>
      <span class="s0">// stopWatching() should be a noop here but we call it just in case we</span>
      <span class="s0">// missed a blur event somehow.</span>
      <span class="s1">stopWatchingForValueChange();</span>
      <span class="s1">startWatchingForValueChange(target, targetInst);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(topLevelType === TOP_BLUR) {</span>
      <span class="s1">stopWatchingForValueChange();</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// For IE8 and IE9.</span>


  <span class="s3">function </span><span class="s1">getTargetInstForInputEventPolyfill(topLevelType, targetInst) {</span>
    <span class="s3">if </span><span class="s1">(topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {</span>
      <span class="s0">// On the selectionchange event, the target is just document which isn't</span>
      <span class="s0">// helpful for us so just check activeElement instead.</span>
      <span class="s0">//</span>
      <span class="s0">// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire</span>
      <span class="s0">// propertychange on the first input event after setting `value` from a</span>
      <span class="s0">// script and fires only keydown, keypress, keyup. Catching keyup usually</span>
      <span class="s0">// gets it and catching keydown lets us fire an event for the first</span>
      <span class="s0">// keystroke if user does a key repeat (it'll be a little delayed: right</span>
      <span class="s0">// before the second keystroke). Other input methods (e.g., paste) seem to</span>
      <span class="s0">// fire selectionchange normally.</span>
      <span class="s3">return </span><span class="s1">getInstIfValueChanged(activeElementInst);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * SECTION: handle `click` event 
   */</span>


  <span class="s3">function </span><span class="s1">shouldUseClickEvent(elem) {</span>
    <span class="s0">// Use the `click` event to detect changes to checkbox and radio inputs.</span>
    <span class="s0">// This approach works across all browsers, whereas `change` does not fire</span>
    <span class="s0">// until `blur` in IE8.</span>
    <span class="s3">var </span><span class="s1">nodeName = elem.nodeName;</span>
    <span class="s3">return </span><span class="s1">nodeName &amp;&amp; nodeName.toLowerCase() === </span><span class="s2">'input' </span><span class="s1">&amp;&amp; (elem.type === </span><span class="s2">'checkbox' </span><span class="s1">|| elem.type === </span><span class="s2">'radio'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getTargetInstForClickEvent(topLevelType, targetInst) {</span>
    <span class="s3">if </span><span class="s1">(topLevelType === TOP_CLICK) {</span>
      <span class="s3">return </span><span class="s1">getInstIfValueChanged(targetInst);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {</span>
    <span class="s3">if </span><span class="s1">(topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {</span>
      <span class="s3">return </span><span class="s1">getInstIfValueChanged(targetInst);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">handleControlledInputBlur(node) {</span>
    <span class="s3">var </span><span class="s1">state = node._wrapperState;</span>

    <span class="s3">if </span><span class="s1">(!state || !state.controlled || node.type !== </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// If controlled, assign the value attribute to the current value on blur</span>
      <span class="s1">setDefaultValue(node, </span><span class="s2">'number'</span><span class="s1">, node.value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * This plugin creates an `onChange` event that normalizes change events 
   * across form elements. This event fires at a time when it's possible to 
   * change the element's value without seeing a flicker. 
   * 
   * Supported elements are: 
   * - input (see `isTextInputElement`) 
   * - textarea 
   * - select 
   */</span>


  <span class="s3">var </span><span class="s1">ChangeEventPlugin = {</span>
    <span class="s1">eventTypes: eventTypes$1,</span>
    <span class="s1">_isInputEventSupported: isInputEventSupported,</span>
    <span class="s1">extractEvents: </span><span class="s3">function </span><span class="s1">(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
      <span class="s3">var </span><span class="s1">targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;</span>
      <span class="s3">var </span><span class="s1">getTargetInstFunc, handleEventFunc;</span>

      <span class="s3">if </span><span class="s1">(shouldUseChangeEvent(targetNode)) {</span>
        <span class="s1">getTargetInstFunc = getTargetInstForChangeEvent;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isTextInputElement(targetNode)) {</span>
        <span class="s3">if </span><span class="s1">(isInputEventSupported) {</span>
          <span class="s1">getTargetInstFunc = getTargetInstForInputOrChangeEvent;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">getTargetInstFunc = getTargetInstForInputEventPolyfill;</span>
          <span class="s1">handleEventFunc = handleEventsForInputEventPolyfill;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(shouldUseClickEvent(targetNode)) {</span>
        <span class="s1">getTargetInstFunc = getTargetInstForClickEvent;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(getTargetInstFunc) {</span>
        <span class="s3">var </span><span class="s1">inst = getTargetInstFunc(topLevelType, targetInst);</span>

        <span class="s3">if </span><span class="s1">(inst) {</span>
          <span class="s3">var </span><span class="s1">event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);</span>
          <span class="s3">return </span><span class="s1">event;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(handleEventFunc) {</span>
        <span class="s1">handleEventFunc(topLevelType, targetNode, targetInst);</span>
      <span class="s1">} </span><span class="s0">// When blurring, set the value attribute for number inputs</span>


      <span class="s3">if </span><span class="s1">(topLevelType === TOP_BLUR) {</span>
        <span class="s1">handleControlledInputBlur(targetNode);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">SyntheticUIEvent = SyntheticEvent.extend({</span>
    <span class="s1">view: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">detail: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * Translation from modifier key to the associated property in the event. 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers 
   */</span>
  <span class="s3">var </span><span class="s1">modifierKeyToProp = {</span>
    <span class="s1">Alt: </span><span class="s2">'altKey'</span><span class="s1">,</span>
    <span class="s1">Control: </span><span class="s2">'ctrlKey'</span><span class="s1">,</span>
    <span class="s1">Meta: </span><span class="s2">'metaKey'</span><span class="s1">,</span>
    <span class="s1">Shift: </span><span class="s2">'shiftKey'</span>
  <span class="s1">}; </span><span class="s0">// Older browsers (Safari &lt;= 10, iOS Safari &lt;= 10.2) do not support</span>
  <span class="s0">// getModifierState. If getModifierState is not supported, we map it to a set of</span>
  <span class="s0">// modifier keys exposed by the event. In this case, Lock-keys are not supported.</span>

  <span class="s3">function </span><span class="s1">modifierStateGetter(keyArg) {</span>
    <span class="s3">var </span><span class="s1">syntheticEvent = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">nativeEvent = syntheticEvent.nativeEvent;</span>

    <span class="s3">if </span><span class="s1">(nativeEvent.getModifierState) {</span>
      <span class="s3">return </span><span class="s1">nativeEvent.getModifierState(keyArg);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">keyProp = modifierKeyToProp[keyArg];</span>
    <span class="s3">return </span><span class="s1">keyProp ? !!nativeEvent[keyProp] : </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getEventModifierState(nativeEvent) {</span>
    <span class="s3">return </span><span class="s1">modifierStateGetter;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">previousScreenX = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">previousScreenY = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Use flags to signal movementX/Y has already been set</span>

  <span class="s3">var </span><span class="s1">isMovementXSet = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isMovementYSet = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s0">/** 
   * @interface MouseEvent 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticMouseEvent = SyntheticUIEvent.extend({</span>
    <span class="s1">screenX: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">screenY: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">clientX: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">clientY: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pageX: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pageY: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">ctrlKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">shiftKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">altKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">metaKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">getModifierState: getEventModifierState,</span>
    <span class="s1">button: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">buttons: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">relatedTarget: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">return </span><span class="s1">event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);</span>
    <span class="s1">},</span>
    <span class="s1">movementX: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'movementX' </span><span class="s3">in </span><span class="s1">event) {</span>
        <span class="s3">return </span><span class="s1">event.movementX;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">screenX = previousScreenX;</span>
      <span class="s1">previousScreenX = event.screenX;</span>

      <span class="s3">if </span><span class="s1">(!isMovementXSet) {</span>
        <span class="s1">isMovementXSet = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">event.type === </span><span class="s2">'mousemove' </span><span class="s1">? event.screenX - screenX : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">movementY: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'movementY' </span><span class="s3">in </span><span class="s1">event) {</span>
        <span class="s3">return </span><span class="s1">event.movementY;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">screenY = previousScreenY;</span>
      <span class="s1">previousScreenY = event.screenY;</span>

      <span class="s3">if </span><span class="s1">(!isMovementYSet) {</span>
        <span class="s1">isMovementYSet = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">event.type === </span><span class="s2">'mousemove' </span><span class="s1">? event.screenY - screenY : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface PointerEvent 
   * @see http://www.w3.org/TR/pointerevents/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticPointerEvent = SyntheticMouseEvent.extend({</span>
    <span class="s1">pointerId: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">width: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">height: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pressure: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">tangentialPressure: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">tiltX: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">tiltY: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">twist: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pointerType: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">isPrimary: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">eventTypes$2 = {</span>
    <span class="s1">mouseEnter: {</span>
      <span class="s1">registrationName: </span><span class="s2">'onMouseEnter'</span><span class="s1">,</span>
      <span class="s1">dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]</span>
    <span class="s1">},</span>
    <span class="s1">mouseLeave: {</span>
      <span class="s1">registrationName: </span><span class="s2">'onMouseLeave'</span><span class="s1">,</span>
      <span class="s1">dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]</span>
    <span class="s1">},</span>
    <span class="s1">pointerEnter: {</span>
      <span class="s1">registrationName: </span><span class="s2">'onPointerEnter'</span><span class="s1">,</span>
      <span class="s1">dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]</span>
    <span class="s1">},</span>
    <span class="s1">pointerLeave: {</span>
      <span class="s1">registrationName: </span><span class="s2">'onPointerLeave'</span><span class="s1">,</span>
      <span class="s1">dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">EnterLeaveEventPlugin = {</span>
    <span class="s1">eventTypes: eventTypes$2,</span>

    <span class="s0">/** 
     * For almost every interaction we care about, there will be both a top-level 
     * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that 
     * we do not extract duplicate events. However, moving the mouse into the 
     * browser from outside will not fire a `mouseout` event. In this case, we use 
     * the `mouseover` top-level event. 
     */</span>
    <span class="s1">extractEvents: </span><span class="s3">function </span><span class="s1">(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
      <span class="s3">var </span><span class="s1">isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;</span>
      <span class="s3">var </span><span class="s1">isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;</span>

      <span class="s3">if </span><span class="s1">(isOverEvent &amp;&amp; (eventSystemFlags &amp; IS_REPLAYED) === </span><span class="s4">0 </span><span class="s1">&amp;&amp; (nativeEvent.relatedTarget || nativeEvent.fromElement)) {</span>
        <span class="s0">// If this is an over event with a target, then we've already dispatched</span>
        <span class="s0">// the event in the out event of the other target. If this is replayed,</span>
        <span class="s0">// then it's because we couldn't dispatch against this target previously</span>
        <span class="s0">// so we have to do it now instead.</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!isOutEvent &amp;&amp; !isOverEvent) {</span>
        <span class="s0">// Must not be a mouse or pointer in or out - ignoring.</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">win;</span>

      <span class="s3">if </span><span class="s1">(nativeEventTarget.window === nativeEventTarget) {</span>
        <span class="s0">// `nativeEventTarget` is probably a window object.</span>
        <span class="s1">win = nativeEventTarget;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.</span>
        <span class="s3">var </span><span class="s1">doc = nativeEventTarget.ownerDocument;</span>

        <span class="s3">if </span><span class="s1">(doc) {</span>
          <span class="s1">win = doc.defaultView || doc.parentWindow;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">win = window;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">from;</span>
      <span class="s3">var </span><span class="s1">to;</span>

      <span class="s3">if </span><span class="s1">(isOutEvent) {</span>
        <span class="s1">from = targetInst;</span>
        <span class="s3">var </span><span class="s1">related = nativeEvent.relatedTarget || nativeEvent.toElement;</span>
        <span class="s1">to = related ? getClosestInstanceFromNode(related) : </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(to !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">nearestMounted = getNearestMountedFiber(to);</span>

          <span class="s3">if </span><span class="s1">(to !== nearestMounted || to.tag !== HostComponent &amp;&amp; to.tag !== HostText) {</span>
            <span class="s1">to = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Moving to a node from outside the window.</span>
        <span class="s1">from = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">to = targetInst;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(from === to) {</span>
        <span class="s0">// Nothing pertains to our managed components.</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">eventInterface, leaveEventType, enterEventType, eventTypePrefix;</span>

      <span class="s3">if </span><span class="s1">(topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {</span>
        <span class="s1">eventInterface = SyntheticMouseEvent;</span>
        <span class="s1">leaveEventType = eventTypes$2.mouseLeave;</span>
        <span class="s1">enterEventType = eventTypes$2.mouseEnter;</span>
        <span class="s1">eventTypePrefix = </span><span class="s2">'mouse'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {</span>
        <span class="s1">eventInterface = SyntheticPointerEvent;</span>
        <span class="s1">leaveEventType = eventTypes$2.pointerLeave;</span>
        <span class="s1">enterEventType = eventTypes$2.pointerEnter;</span>
        <span class="s1">eventTypePrefix = </span><span class="s2">'pointer'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">fromNode = from == </span><span class="s3">null </span><span class="s1">? win : getNodeFromInstance$1(from);</span>
      <span class="s3">var </span><span class="s1">toNode = to == </span><span class="s3">null </span><span class="s1">? win : getNodeFromInstance$1(to);</span>
      <span class="s3">var </span><span class="s1">leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);</span>
      <span class="s1">leave.type = eventTypePrefix + </span><span class="s2">'leave'</span><span class="s1">;</span>
      <span class="s1">leave.target = fromNode;</span>
      <span class="s1">leave.relatedTarget = toNode;</span>
      <span class="s3">var </span><span class="s1">enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);</span>
      <span class="s1">enter.type = eventTypePrefix + </span><span class="s2">'enter'</span><span class="s1">;</span>
      <span class="s1">enter.target = toNode;</span>
      <span class="s1">enter.relatedTarget = fromNode;</span>
      <span class="s1">accumulateEnterLeaveDispatches(leave, enter, from, to); </span><span class="s0">// If we are not processing the first ancestor, then we</span>
      <span class="s0">// should not process the same nativeEvent again, as we</span>
      <span class="s0">// will have already processed it in the first ancestor.</span>

      <span class="s3">if </span><span class="s1">((eventSystemFlags &amp; IS_FIRST_ANCESTOR) === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">[leave];</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">[leave, enter];</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * inlined Object.is polyfill to avoid requiring consumers ship their own 
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
   */</span>
  <span class="s3">function </span><span class="s1">is(x, y) {</span>
    <span class="s3">return </span><span class="s1">x === y &amp;&amp; (x !== </span><span class="s4">0 </span><span class="s1">|| </span><span class="s4">1 </span><span class="s1">/ x === </span><span class="s4">1 </span><span class="s1">/ y) || x !== x &amp;&amp; y !== y </span><span class="s0">// eslint-disable-line no-self-compare</span>
    <span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">objectIs = </span><span class="s3">typeof </span><span class="s1">Object.is === </span><span class="s2">'function' </span><span class="s1">? Object.is : is;</span>

  <span class="s3">var </span><span class="s1">hasOwnProperty$2 = Object.prototype.hasOwnProperty;</span>
  <span class="s0">/** 
   * Performs equality by iterating through keys on an object and returning false 
   * when any key has values which are not strictly equal between the arguments. 
   * Returns true when the values of all keys are strictly equal. 
   */</span>

  <span class="s3">function </span><span class="s1">shallowEqual(objA, objB) {</span>
    <span class="s3">if </span><span class="s1">(objectIs(objA, objB)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">objA !== </span><span class="s2">'object' </span><span class="s1">|| objA === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">objB !== </span><span class="s2">'object' </span><span class="s1">|| objB === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">keysA = Object.keys(objA);</span>
    <span class="s3">var </span><span class="s1">keysB = Object.keys(objB);</span>

    <span class="s3">if </span><span class="s1">(keysA.length !== keysB.length) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Test for A's keys different from B.</span>


    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keysA.length; i++) {</span>
      <span class="s3">if </span><span class="s1">(!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">skipSelectionChangeEvent = canUseDOM &amp;&amp; </span><span class="s2">'documentMode' </span><span class="s3">in </span><span class="s1">document &amp;&amp; document.documentMode &lt;= </span><span class="s4">11</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">eventTypes$3 = {</span>
    <span class="s1">select: {</span>
      <span class="s1">phasedRegistrationNames: {</span>
        <span class="s1">bubbled: </span><span class="s2">'onSelect'</span><span class="s1">,</span>
        <span class="s1">captured: </span><span class="s2">'onSelectCapture'</span>
      <span class="s1">},</span>
      <span class="s1">dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">activeElement$1 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">activeElementInst$1 = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">lastSelection = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">mouseDown = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s0">/** 
   * Get an object which is a unique representation of the current selection. 
   * 
   * The return value will not be consistent across nodes or browsers, but 
   * two identical selections on the same node will return identical objects. 
   * 
   * @param {DOMElement} node 
   * @return {object} 
   */</span>

  <span class="s3">function </span><span class="s1">getSelection$1(node) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">'selectionStart' </span><span class="s3">in </span><span class="s1">node &amp;&amp; hasSelectionCapabilities(node)) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">start: node.selectionStart,</span>
        <span class="s1">end: node.selectionEnd</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">win = node.ownerDocument &amp;&amp; node.ownerDocument.defaultView || window;</span>
      <span class="s3">var </span><span class="s1">selection = win.getSelection();</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">anchorNode: selection.anchorNode,</span>
        <span class="s1">anchorOffset: selection.anchorOffset,</span>
        <span class="s1">focusNode: selection.focusNode,</span>
        <span class="s1">focusOffset: selection.focusOffset</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Get document associated with the event target. 
   * 
   * @param {object} nativeEventTarget 
   * @return {Document} 
   */</span>


  <span class="s3">function </span><span class="s1">getEventTargetDocument(eventTarget) {</span>
    <span class="s3">return </span><span class="s1">eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Poll selection to see whether it's changed. 
   * 
   * @param {object} nativeEvent 
   * @param {object} nativeEventTarget 
   * @return {?SyntheticEvent} 
   */</span>


  <span class="s3">function </span><span class="s1">constructSelectEvent(nativeEvent, nativeEventTarget) {</span>
    <span class="s0">// Ensure we have the right element, and that the user is not dragging a</span>
    <span class="s0">// selection (this matches native `select` event behavior). In HTML5, select</span>
    <span class="s0">// fires only on input and textarea thus if there's no focused element we</span>
    <span class="s0">// won't dispatch.</span>
    <span class="s3">var </span><span class="s1">doc = getEventTargetDocument(nativeEventTarget);</span>

    <span class="s3">if </span><span class="s1">(mouseDown || activeElement$1 == </span><span class="s3">null </span><span class="s1">|| activeElement$1 !== getActiveElement(doc)) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Only fire when selection has actually changed.</span>


    <span class="s3">var </span><span class="s1">currentSelection = getSelection$1(activeElement$1);</span>

    <span class="s3">if </span><span class="s1">(!lastSelection || !shallowEqual(lastSelection, currentSelection)) {</span>
      <span class="s1">lastSelection = currentSelection;</span>
      <span class="s3">var </span><span class="s1">syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);</span>
      <span class="s1">syntheticEvent.type = </span><span class="s2">'select'</span><span class="s1">;</span>
      <span class="s1">syntheticEvent.target = activeElement$1;</span>
      <span class="s1">accumulateTwoPhaseDispatches(syntheticEvent);</span>
      <span class="s3">return </span><span class="s1">syntheticEvent;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * This plugin creates an `onSelect` event that normalizes select events 
   * across form elements. 
   * 
   * Supported elements are: 
   * - input (see `isTextInputElement`) 
   * - textarea 
   * - contentEditable 
   * 
   * This differs from native browser implementations in the following ways: 
   * - Fires on contentEditable fields as well as inputs. 
   * - Fires for collapsed selection. 
   * - Fires after user input. 
   */</span>


  <span class="s3">var </span><span class="s1">SelectEventPlugin = {</span>
    <span class="s1">eventTypes: eventTypes$3,</span>
    <span class="s1">extractEvents: </span><span class="s3">function </span><span class="s1">(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, container) {</span>
      <span class="s3">var </span><span class="s1">containerOrDoc = container || getEventTargetDocument(nativeEventTarget); </span><span class="s0">// Track whether all listeners exists for this plugin. If none exist, we do</span>
      <span class="s0">// not extract events. See #3639.</span>

      <span class="s3">if </span><span class="s1">(!containerOrDoc || !isListeningToAllDependencies(</span><span class="s2">'onSelect'</span><span class="s1">, containerOrDoc)) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;</span>

      <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
        <span class="s0">// Track the input node that has focus.</span>
        <span class="s3">case </span><span class="s1">TOP_FOCUS:</span>
          <span class="s3">if </span><span class="s1">(isTextInputElement(targetNode) || targetNode.contentEditable === </span><span class="s2">'true'</span><span class="s1">) {</span>
            <span class="s1">activeElement$1 = targetNode;</span>
            <span class="s1">activeElementInst$1 = targetInst;</span>
            <span class="s1">lastSelection = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_BLUR:</span>
          <span class="s1">activeElement$1 = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">activeElementInst$1 = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">lastSelection = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s0">// Don't fire the event while the user is dragging. This matches the</span>
        <span class="s0">// semantics of the native select event.</span>

        <span class="s3">case </span><span class="s1">TOP_MOUSE_DOWN:</span>
          <span class="s1">mouseDown = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_CONTEXT_MENU:</span>
        <span class="s3">case </span><span class="s1">TOP_MOUSE_UP:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_END:</span>
          <span class="s1">mouseDown = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s1">constructSelectEvent(nativeEvent, nativeEventTarget);</span>
        <span class="s0">// Chrome and IE fire non-standard event when selection is changed (and</span>
        <span class="s0">// sometimes when it hasn't). IE's event fires out of order with respect</span>
        <span class="s0">// to key and input events on deletion, so we discard it.</span>
        <span class="s0">//</span>
        <span class="s0">// Firefox doesn't support selectionchange, so check selection status</span>
        <span class="s0">// after each key entry. The selection changes after keydown and before</span>
        <span class="s0">// keyup, but we check on keydown as well in the case of holding down a</span>
        <span class="s0">// key, when multiple keydown events are fired but only one keyup is.</span>
        <span class="s0">// This is also our approach for IE handling, for the reason above.</span>

        <span class="s3">case </span><span class="s1">TOP_SELECTION_CHANGE:</span>
          <span class="s3">if </span><span class="s1">(skipSelectionChangeEvent) {</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s0">// falls through</span>

        <span class="s3">case </span><span class="s1">TOP_KEY_DOWN:</span>
        <span class="s3">case </span><span class="s1">TOP_KEY_UP:</span>
          <span class="s3">return </span><span class="s1">constructSelectEvent(nativeEvent, nativeEventTarget);</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface 
   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticAnimationEvent = SyntheticEvent.extend({</span>
    <span class="s1">animationName: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">elapsedTime: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pseudoElement: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/clipboard-apis/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticClipboardEvent = SyntheticEvent.extend({</span>
    <span class="s1">clipboardData: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">return </span><span class="s2">'clipboardData' </span><span class="s3">in </span><span class="s1">event ? event.clipboardData : window.clipboardData;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface FocusEvent 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticFocusEvent = SyntheticUIEvent.extend({</span>
    <span class="s1">relatedTarget: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * `charCode` represents the actual &quot;character code&quot; and is safe to use with 
   * `String.fromCharCode`. As such, only keys that correspond to printable 
   * characters produce a valid `charCode`, the only exception to this is Enter. 
   * The Tab-key is considered non-printable and does not have a `charCode`, 
   * presumably because it does not produce a tab-character in browsers. 
   * 
   * @param {object} nativeEvent Native browser event. 
   * @return {number} Normalized `charCode` property. 
   */</span>
  <span class="s3">function </span><span class="s1">getEventCharCode(nativeEvent) {</span>
    <span class="s3">var </span><span class="s1">charCode;</span>
    <span class="s3">var </span><span class="s1">keyCode = nativeEvent.keyCode;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">'charCode' </span><span class="s3">in </span><span class="s1">nativeEvent) {</span>
      <span class="s1">charCode = nativeEvent.charCode; </span><span class="s0">// FF does not set `charCode` for the Enter-key, check against `keyCode`.</span>

      <span class="s3">if </span><span class="s1">(charCode === </span><span class="s4">0 </span><span class="s1">&amp;&amp; keyCode === </span><span class="s4">13</span><span class="s1">) {</span>
        <span class="s1">charCode = </span><span class="s4">13</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// IE8 does not implement `charCode`, but `keyCode` has the correct value.</span>
      <span class="s1">charCode = keyCode;</span>
    <span class="s1">} </span><span class="s0">// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)</span>
    <span class="s0">// report Enter as charCode 10 when ctrl is pressed.</span>


    <span class="s3">if </span><span class="s1">(charCode === </span><span class="s4">10</span><span class="s1">) {</span>
      <span class="s1">charCode = </span><span class="s4">13</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.</span>
    <span class="s0">// Must not discard the (non-)printable Enter-key.</span>


    <span class="s3">if </span><span class="s1">(charCode &gt;= </span><span class="s4">32 </span><span class="s1">|| charCode === </span><span class="s4">13</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">charCode;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Normalization of deprecated HTML5 `key` values 
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names 
   */</span>

  <span class="s3">var </span><span class="s1">normalizeKey = {</span>
    <span class="s1">Esc: </span><span class="s2">'Escape'</span><span class="s1">,</span>
    <span class="s1">Spacebar: </span><span class="s2">' '</span><span class="s1">,</span>
    <span class="s1">Left: </span><span class="s2">'ArrowLeft'</span><span class="s1">,</span>
    <span class="s1">Up: </span><span class="s2">'ArrowUp'</span><span class="s1">,</span>
    <span class="s1">Right: </span><span class="s2">'ArrowRight'</span><span class="s1">,</span>
    <span class="s1">Down: </span><span class="s2">'ArrowDown'</span><span class="s1">,</span>
    <span class="s1">Del: </span><span class="s2">'Delete'</span><span class="s1">,</span>
    <span class="s1">Win: </span><span class="s2">'OS'</span><span class="s1">,</span>
    <span class="s1">Menu: </span><span class="s2">'ContextMenu'</span><span class="s1">,</span>
    <span class="s1">Apps: </span><span class="s2">'ContextMenu'</span><span class="s1">,</span>
    <span class="s1">Scroll: </span><span class="s2">'ScrollLock'</span><span class="s1">,</span>
    <span class="s1">MozPrintableKey: </span><span class="s2">'Unidentified'</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Translation from legacy `keyCode` to HTML5 `key` 
   * Only special keys supported, all others depend on keyboard layout or browser 
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names 
   */</span>

  <span class="s3">var </span><span class="s1">translateToKey = {</span>
    <span class="s2">'8'</span><span class="s1">: </span><span class="s2">'Backspace'</span><span class="s1">,</span>
    <span class="s2">'9'</span><span class="s1">: </span><span class="s2">'Tab'</span><span class="s1">,</span>
    <span class="s2">'12'</span><span class="s1">: </span><span class="s2">'Clear'</span><span class="s1">,</span>
    <span class="s2">'13'</span><span class="s1">: </span><span class="s2">'Enter'</span><span class="s1">,</span>
    <span class="s2">'16'</span><span class="s1">: </span><span class="s2">'Shift'</span><span class="s1">,</span>
    <span class="s2">'17'</span><span class="s1">: </span><span class="s2">'Control'</span><span class="s1">,</span>
    <span class="s2">'18'</span><span class="s1">: </span><span class="s2">'Alt'</span><span class="s1">,</span>
    <span class="s2">'19'</span><span class="s1">: </span><span class="s2">'Pause'</span><span class="s1">,</span>
    <span class="s2">'20'</span><span class="s1">: </span><span class="s2">'CapsLock'</span><span class="s1">,</span>
    <span class="s2">'27'</span><span class="s1">: </span><span class="s2">'Escape'</span><span class="s1">,</span>
    <span class="s2">'32'</span><span class="s1">: </span><span class="s2">' '</span><span class="s1">,</span>
    <span class="s2">'33'</span><span class="s1">: </span><span class="s2">'PageUp'</span><span class="s1">,</span>
    <span class="s2">'34'</span><span class="s1">: </span><span class="s2">'PageDown'</span><span class="s1">,</span>
    <span class="s2">'35'</span><span class="s1">: </span><span class="s2">'End'</span><span class="s1">,</span>
    <span class="s2">'36'</span><span class="s1">: </span><span class="s2">'Home'</span><span class="s1">,</span>
    <span class="s2">'37'</span><span class="s1">: </span><span class="s2">'ArrowLeft'</span><span class="s1">,</span>
    <span class="s2">'38'</span><span class="s1">: </span><span class="s2">'ArrowUp'</span><span class="s1">,</span>
    <span class="s2">'39'</span><span class="s1">: </span><span class="s2">'ArrowRight'</span><span class="s1">,</span>
    <span class="s2">'40'</span><span class="s1">: </span><span class="s2">'ArrowDown'</span><span class="s1">,</span>
    <span class="s2">'45'</span><span class="s1">: </span><span class="s2">'Insert'</span><span class="s1">,</span>
    <span class="s2">'46'</span><span class="s1">: </span><span class="s2">'Delete'</span><span class="s1">,</span>
    <span class="s2">'112'</span><span class="s1">: </span><span class="s2">'F1'</span><span class="s1">,</span>
    <span class="s2">'113'</span><span class="s1">: </span><span class="s2">'F2'</span><span class="s1">,</span>
    <span class="s2">'114'</span><span class="s1">: </span><span class="s2">'F3'</span><span class="s1">,</span>
    <span class="s2">'115'</span><span class="s1">: </span><span class="s2">'F4'</span><span class="s1">,</span>
    <span class="s2">'116'</span><span class="s1">: </span><span class="s2">'F5'</span><span class="s1">,</span>
    <span class="s2">'117'</span><span class="s1">: </span><span class="s2">'F6'</span><span class="s1">,</span>
    <span class="s2">'118'</span><span class="s1">: </span><span class="s2">'F7'</span><span class="s1">,</span>
    <span class="s2">'119'</span><span class="s1">: </span><span class="s2">'F8'</span><span class="s1">,</span>
    <span class="s2">'120'</span><span class="s1">: </span><span class="s2">'F9'</span><span class="s1">,</span>
    <span class="s2">'121'</span><span class="s1">: </span><span class="s2">'F10'</span><span class="s1">,</span>
    <span class="s2">'122'</span><span class="s1">: </span><span class="s2">'F11'</span><span class="s1">,</span>
    <span class="s2">'123'</span><span class="s1">: </span><span class="s2">'F12'</span><span class="s1">,</span>
    <span class="s2">'144'</span><span class="s1">: </span><span class="s2">'NumLock'</span><span class="s1">,</span>
    <span class="s2">'145'</span><span class="s1">: </span><span class="s2">'ScrollLock'</span><span class="s1">,</span>
    <span class="s2">'224'</span><span class="s1">: </span><span class="s2">'Meta'</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * @param {object} nativeEvent Native browser event. 
   * @return {string} Normalized `key` property. 
   */</span>

  <span class="s3">function </span><span class="s1">getEventKey(nativeEvent) {</span>
    <span class="s3">if </span><span class="s1">(nativeEvent.key) {</span>
      <span class="s0">// Normalize inconsistent values reported by browsers due to</span>
      <span class="s0">// implementations of a working draft specification.</span>
      <span class="s0">// FireFox implements `key` but returns `MozPrintableKey` for all</span>
      <span class="s0">// printable characters (normalized to `Unidentified`), ignore it.</span>
      <span class="s3">var </span><span class="s1">key = normalizeKey[nativeEvent.key] || nativeEvent.key;</span>

      <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">'Unidentified'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">key;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Browser does not implement `key`, polyfill as much of it as we can.</span>


    <span class="s3">if </span><span class="s1">(nativeEvent.type === </span><span class="s2">'keypress'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">charCode = getEventCharCode(nativeEvent); </span><span class="s0">// The enter-key is technically both printable and non-printable and can</span>
      <span class="s0">// thus be captured by `keypress`, no other non-printable key should.</span>

      <span class="s3">return </span><span class="s1">charCode === </span><span class="s4">13 </span><span class="s1">? </span><span class="s2">'Enter' </span><span class="s1">: String.fromCharCode(charCode);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nativeEvent.type === </span><span class="s2">'keydown' </span><span class="s1">|| nativeEvent.type === </span><span class="s2">'keyup'</span><span class="s1">) {</span>
      <span class="s0">// While user keyboard layout determines the actual meaning of each</span>
      <span class="s0">// `keyCode` value, almost all function keys have a universal value.</span>
      <span class="s3">return </span><span class="s1">translateToKey[nativeEvent.keyCode] || </span><span class="s2">'Unidentified'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @interface KeyboardEvent 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticKeyboardEvent = SyntheticUIEvent.extend({</span>
    <span class="s1">key: getEventKey,</span>
    <span class="s1">location: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">ctrlKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">shiftKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">altKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">metaKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">repeat: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">locale: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">getModifierState: getEventModifierState,</span>
    <span class="s0">// Legacy Interface</span>
    <span class="s1">charCode: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s0">// `charCode` is the result of a KeyPress event and represents the value of</span>
      <span class="s0">// the actual printable character.</span>
      <span class="s0">// KeyPress is deprecated, but its replacement is not yet final and not</span>
      <span class="s0">// implemented in any major browser. Only KeyPress has charCode.</span>
      <span class="s3">if </span><span class="s1">(event.type === </span><span class="s2">'keypress'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">getEventCharCode(event);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">keyCode: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s0">// `keyCode` is the result of a KeyDown/Up event and represents the value of</span>
      <span class="s0">// physical keyboard key.</span>
      <span class="s0">// The actual meaning of the value depends on the users' keyboard layout</span>
      <span class="s0">// which cannot be detected. Assuming that it is a US keyboard layout</span>
      <span class="s0">// provides a surprisingly accurate mapping for US and European users.</span>
      <span class="s0">// Due to this, it is left to the user to implement at this time.</span>
      <span class="s3">if </span><span class="s1">(event.type === </span><span class="s2">'keydown' </span><span class="s1">|| event.type === </span><span class="s2">'keyup'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">event.keyCode;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">which: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s0">// `which` is an alias for either `keyCode` or `charCode` depending on the</span>
      <span class="s0">// type of the event.</span>
      <span class="s3">if </span><span class="s1">(event.type === </span><span class="s2">'keypress'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">getEventCharCode(event);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(event.type === </span><span class="s2">'keydown' </span><span class="s1">|| event.type === </span><span class="s2">'keyup'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">event.keyCode;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface DragEvent 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticDragEvent = SyntheticMouseEvent.extend({</span>
    <span class="s1">dataTransfer: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface TouchEvent 
   * @see http://www.w3.org/TR/touch-events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticTouchEvent = SyntheticUIEvent.extend({</span>
    <span class="s1">touches: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">targetTouches: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">changedTouches: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">altKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">metaKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">ctrlKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">shiftKey: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">getModifierState: getEventModifierState</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface Event 
   * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events- 
   * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticTransitionEvent = SyntheticEvent.extend({</span>
    <span class="s1">propertyName: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">elapsedTime: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">pseudoElement: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s0">/** 
   * @interface WheelEvent 
   * @see http://www.w3.org/TR/DOM-Level-3-Events/ 
   */</span>

  <span class="s3">var </span><span class="s1">SyntheticWheelEvent = SyntheticMouseEvent.extend({</span>
    <span class="s1">deltaX: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">return </span><span class="s2">'deltaX' </span><span class="s3">in </span><span class="s1">event ? event.deltaX : </span><span class="s0">// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).</span>
      <span class="s2">'wheelDeltaX' </span><span class="s3">in </span><span class="s1">event ? -event.wheelDeltaX : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">deltaY: </span><span class="s3">function </span><span class="s1">(event) {</span>
      <span class="s3">return </span><span class="s2">'deltaY' </span><span class="s3">in </span><span class="s1">event ? event.deltaY : </span><span class="s0">// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).</span>
      <span class="s2">'wheelDeltaY' </span><span class="s3">in </span><span class="s1">event ? -event.wheelDeltaY : </span><span class="s0">// Fallback to `wheelDelta` for IE&lt;9 and normalize (down is positive).</span>
      <span class="s2">'wheelDelta' </span><span class="s3">in </span><span class="s1">event ? -event.wheelDelta : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">deltaZ: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s0">// Browsers without &quot;deltaMode&quot; is reporting in raw wheel delta where one</span>
    <span class="s0">// notch on the scroll is always +/- 120, roughly equivalent to pixels.</span>
    <span class="s0">// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or</span>
    <span class="s0">// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.</span>
    <span class="s1">deltaMode: </span><span class="s3">null</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];</span>
  <span class="s3">var </span><span class="s1">SimpleEventPlugin = {</span>
    <span class="s0">// simpleEventPluginEventTypes gets populated from</span>
    <span class="s0">// the DOMEventProperties module.</span>
    <span class="s1">eventTypes: simpleEventPluginEventTypes,</span>
    <span class="s1">extractEvents: </span><span class="s3">function </span><span class="s1">(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {</span>
      <span class="s3">var </span><span class="s1">dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);</span>

      <span class="s3">if </span><span class="s1">(!dispatchConfig) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">EventConstructor;</span>

      <span class="s3">switch </span><span class="s1">(topLevelType) {</span>
        <span class="s3">case </span><span class="s1">TOP_KEY_PRESS:</span>
          <span class="s0">// Firefox creates a keypress event for function keys too. This removes</span>
          <span class="s0">// the unwanted keypress events. Enter is however both printable and</span>
          <span class="s0">// non-printable. One would expect Tab to be as well (but it isn't).</span>
          <span class="s3">if </span><span class="s1">(getEventCharCode(nativeEvent) === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s0">/* falls through */</span>

        <span class="s3">case </span><span class="s1">TOP_KEY_DOWN:</span>
        <span class="s3">case </span><span class="s1">TOP_KEY_UP:</span>
          <span class="s1">EventConstructor = SyntheticKeyboardEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_BLUR:</span>
        <span class="s3">case </span><span class="s1">TOP_FOCUS:</span>
          <span class="s1">EventConstructor = SyntheticFocusEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_CLICK:</span>
          <span class="s0">// Firefox creates a click event on right mouse clicks. This removes the</span>
          <span class="s0">// unwanted click events.</span>
          <span class="s3">if </span><span class="s1">(nativeEvent.button === </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s0">/* falls through */</span>

        <span class="s3">case </span><span class="s1">TOP_AUX_CLICK:</span>
        <span class="s3">case </span><span class="s1">TOP_DOUBLE_CLICK:</span>
        <span class="s3">case </span><span class="s1">TOP_MOUSE_DOWN:</span>
        <span class="s3">case </span><span class="s1">TOP_MOUSE_MOVE:</span>
        <span class="s3">case </span><span class="s1">TOP_MOUSE_UP: </span><span class="s0">// TODO: Disabled elements should not respond to mouse events</span>

        <span class="s0">/* falls through */</span>

        <span class="s3">case </span><span class="s1">TOP_MOUSE_OUT:</span>
        <span class="s3">case </span><span class="s1">TOP_MOUSE_OVER:</span>
        <span class="s3">case </span><span class="s1">TOP_CONTEXT_MENU:</span>
          <span class="s1">EventConstructor = SyntheticMouseEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_DRAG:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_END:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_ENTER:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_EXIT:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_LEAVE:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_OVER:</span>
        <span class="s3">case </span><span class="s1">TOP_DRAG_START:</span>
        <span class="s3">case </span><span class="s1">TOP_DROP:</span>
          <span class="s1">EventConstructor = SyntheticDragEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_TOUCH_CANCEL:</span>
        <span class="s3">case </span><span class="s1">TOP_TOUCH_END:</span>
        <span class="s3">case </span><span class="s1">TOP_TOUCH_MOVE:</span>
        <span class="s3">case </span><span class="s1">TOP_TOUCH_START:</span>
          <span class="s1">EventConstructor = SyntheticTouchEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_ANIMATION_END:</span>
        <span class="s3">case </span><span class="s1">TOP_ANIMATION_ITERATION:</span>
        <span class="s3">case </span><span class="s1">TOP_ANIMATION_START:</span>
          <span class="s1">EventConstructor = SyntheticAnimationEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_TRANSITION_END:</span>
          <span class="s1">EventConstructor = SyntheticTransitionEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_SCROLL:</span>
          <span class="s1">EventConstructor = SyntheticUIEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_WHEEL:</span>
          <span class="s1">EventConstructor = SyntheticWheelEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_COPY:</span>
        <span class="s3">case </span><span class="s1">TOP_CUT:</span>
        <span class="s3">case </span><span class="s1">TOP_PASTE:</span>
          <span class="s1">EventConstructor = SyntheticClipboardEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">TOP_GOT_POINTER_CAPTURE:</span>
        <span class="s3">case </span><span class="s1">TOP_LOST_POINTER_CAPTURE:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_CANCEL:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_DOWN:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_MOVE:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_OUT:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_OVER:</span>
        <span class="s3">case </span><span class="s1">TOP_POINTER_UP:</span>
          <span class="s1">EventConstructor = SyntheticPointerEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(knownHTMLTopLevelTypes.indexOf(topLevelType) === -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">error(</span><span class="s2">'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' </span><span class="s1">+ </span><span class="s2">'is likely caused by a bug in React. Please file an issue.'</span><span class="s1">, topLevelType);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// HTML Events</span>
          <span class="s0">// @see http://www.w3.org/TR/html5/index.html#events-0</span>


          <span class="s1">EventConstructor = SyntheticEvent;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);</span>
      <span class="s1">accumulateTwoPhaseDispatches(event);</span>
      <span class="s3">return </span><span class="s1">event;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Specifies a deterministic ordering of `EventPlugin`s. A convenient way to 
   * reason about plugins, without having to package every one of them. This 
   * is better than having plugins be ordered in the same order that they 
   * are injected because that ordering would be influenced by the packaging order. 
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that 
   * preventing default on events is convenient in `SimpleEventPlugin` handlers. 
   */</span>

  <span class="s3">var </span><span class="s1">DOMEventPluginOrder = [</span><span class="s2">'ResponderEventPlugin'</span><span class="s1">, </span><span class="s2">'SimpleEventPlugin'</span><span class="s1">, </span><span class="s2">'EnterLeaveEventPlugin'</span><span class="s1">, </span><span class="s2">'ChangeEventPlugin'</span><span class="s1">, </span><span class="s2">'SelectEventPlugin'</span><span class="s1">, </span><span class="s2">'BeforeInputEventPlugin'</span><span class="s1">];</span>
  <span class="s0">/** 
   * Inject modules for resolving DOM hierarchy and plugin ordering. 
   */</span>

  <span class="s1">injectEventPluginOrder(DOMEventPluginOrder);</span>
  <span class="s1">setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);</span>
  <span class="s0">/** 
   * Some important event plugins included by default (without having to require 
   * them). 
   */</span>

  <span class="s1">injectEventPluginsByName({</span>
    <span class="s1">SimpleEventPlugin: SimpleEventPlugin,</span>
    <span class="s1">EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span>
    <span class="s1">ChangeEventPlugin: ChangeEventPlugin,</span>
    <span class="s1">SelectEventPlugin: SelectEventPlugin,</span>
    <span class="s1">BeforeInputEventPlugin: BeforeInputEventPlugin</span>
  <span class="s1">});</span>

  <span class="s0">// Prefix measurements so that it's possible to filter them.</span>
  <span class="s0">// Longer prefixes are hard to read in DevTools.</span>
  <span class="s3">var </span><span class="s1">reactEmoji = </span><span class="s2">&quot;</span><span class="s5">\u269B</span><span class="s2">&quot;</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">warningEmoji = </span><span class="s2">&quot;</span><span class="s5">\u26D4</span><span class="s2">&quot;</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">supportsUserTiming = </span><span class="s3">typeof </span><span class="s1">performance !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.mark === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.clearMarks === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.measure === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.clearMeasures === </span><span class="s2">'function'</span><span class="s1">; </span><span class="s0">// Keep track of current fiber so that we know the path to unwind on pause.</span>
  <span class="s0">// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?</span>

  <span class="s3">var </span><span class="s1">currentFiber = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// If we're in the middle of user code, which fiber and method is it?</span>
  <span class="s0">// Reusing `currentFiber` would be confusing for this because user code fiber</span>
  <span class="s0">// can change during commit phase too, but we don't need to unwind it (since</span>
  <span class="s0">// lifecycles in the commit phase don't resemble a tree).</span>

  <span class="s3">var </span><span class="s1">currentPhase = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">currentPhaseFiber = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Did lifecycle hook schedule an update? This is often a performance problem,</span>
  <span class="s0">// so we will keep track of it, and include it in the report.</span>
  <span class="s0">// Track commits caused by cascading updates.</span>

  <span class="s3">var </span><span class="s1">isCommitting = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasScheduledUpdateInCurrentCommit = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasScheduledUpdateInCurrentPhase = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">commitCountInCurrentWorkLoop = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s0">// to avoid stretch the commit phase with measurement overhead.</span>

  <span class="s3">var </span><span class="s1">labelsInCurrentCommit = </span><span class="s3">new </span><span class="s1">Set();</span>

  <span class="s3">var </span><span class="s1">formatMarkName = </span><span class="s3">function </span><span class="s1">(markName) {</span>
    <span class="s3">return </span><span class="s1">reactEmoji + </span><span class="s2">&quot; &quot; </span><span class="s1">+ markName;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">formatLabel = </span><span class="s3">function </span><span class="s1">(label, warning) {</span>
    <span class="s3">var </span><span class="s1">prefix = warning ? warningEmoji + </span><span class="s2">&quot; &quot; </span><span class="s1">: reactEmoji + </span><span class="s2">&quot; &quot;</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">suffix = warning ? </span><span class="s2">&quot; Warning: &quot; </span><span class="s1">+ warning : </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">&quot;&quot; </span><span class="s1">+ prefix + label + suffix;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">beginMark = </span><span class="s3">function </span><span class="s1">(markName) {</span>
    <span class="s1">performance.mark(formatMarkName(markName));</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">clearMark = </span><span class="s3">function </span><span class="s1">(markName) {</span>
    <span class="s1">performance.clearMarks(formatMarkName(markName));</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">endMark = </span><span class="s3">function </span><span class="s1">(label, markName, warning) {</span>
    <span class="s3">var </span><span class="s1">formattedMarkName = formatMarkName(markName);</span>
    <span class="s3">var </span><span class="s1">formattedLabel = formatLabel(label, warning);</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">performance.measure(formattedLabel, formattedMarkName);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {} </span><span class="s0">// If previous mark was missing for some reason, this will throw.</span>
    <span class="s0">// This could only happen if React crashed in an unexpected place earlier.</span>
    <span class="s0">// Don't pile on with more errors.</span>
    <span class="s0">// Clear marks immediately to avoid growing buffer.</span>


    <span class="s1">performance.clearMarks(formattedMarkName);</span>
    <span class="s1">performance.clearMeasures(formattedLabel);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">getFiberMarkName = </span><span class="s3">function </span><span class="s1">(label, debugID) {</span>
    <span class="s3">return </span><span class="s1">label + </span><span class="s2">&quot; (#&quot; </span><span class="s1">+ debugID + </span><span class="s2">&quot;)&quot;</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">getFiberLabel = </span><span class="s3">function </span><span class="s1">(componentName, isMounted, phase) {</span>
    <span class="s3">if </span><span class="s1">(phase === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// These are composite component total time measurements.</span>
      <span class="s3">return </span><span class="s1">componentName + </span><span class="s2">&quot; [&quot; </span><span class="s1">+ (isMounted ? </span><span class="s2">'update' </span><span class="s1">: </span><span class="s2">'mount'</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Composite component methods.</span>
      <span class="s3">return </span><span class="s1">componentName + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ phase;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">beginFiberMark = </span><span class="s3">function </span><span class="s1">(fiber, phase) {</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentName(fiber.type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">debugID = fiber._debugID;</span>
    <span class="s3">var </span><span class="s1">isMounted = fiber.alternate !== </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">label = getFiberLabel(componentName, isMounted, phase);</span>

    <span class="s3">if </span><span class="s1">(isCommitting &amp;&amp; labelsInCurrentCommit.has(label)) {</span>
      <span class="s0">// During the commit phase, we don't show duplicate labels because</span>
      <span class="s0">// there is a fixed overhead for every measurement, and we don't</span>
      <span class="s0">// want to stretch the commit phase beyond necessary.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">labelsInCurrentCommit.add(label);</span>
    <span class="s3">var </span><span class="s1">markName = getFiberMarkName(label, debugID);</span>
    <span class="s1">beginMark(markName);</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">clearFiberMark = </span><span class="s3">function </span><span class="s1">(fiber, phase) {</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentName(fiber.type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">debugID = fiber._debugID;</span>
    <span class="s3">var </span><span class="s1">isMounted = fiber.alternate !== </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">label = getFiberLabel(componentName, isMounted, phase);</span>
    <span class="s3">var </span><span class="s1">markName = getFiberMarkName(label, debugID);</span>
    <span class="s1">clearMark(markName);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">endFiberMark = </span><span class="s3">function </span><span class="s1">(fiber, phase, warning) {</span>
    <span class="s3">var </span><span class="s1">componentName = getComponentName(fiber.type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">debugID = fiber._debugID;</span>
    <span class="s3">var </span><span class="s1">isMounted = fiber.alternate !== </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">label = getFiberLabel(componentName, isMounted, phase);</span>
    <span class="s3">var </span><span class="s1">markName = getFiberMarkName(label, debugID);</span>
    <span class="s1">endMark(label, markName, warning);</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">shouldIgnoreFiber = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
    <span class="s0">// Host components should be skipped in the timeline.</span>
    <span class="s0">// We could check typeof fiber.type, but does this work with RN?</span>
    <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
      <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">case </span><span class="s1">Fragment:</span>
      <span class="s3">case </span><span class="s1">ContextProvider:</span>
      <span class="s3">case </span><span class="s1">ContextConsumer:</span>
      <span class="s3">case </span><span class="s1">Mode:</span>
        <span class="s3">return true</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">clearPendingPhaseMeasurement = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(currentPhase !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentPhaseFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">clearFiberMark(currentPhaseFiber, currentPhase);</span>
    <span class="s1">}</span>

    <span class="s1">currentPhaseFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">currentPhase = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">hasScheduledUpdateInCurrentPhase = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">pauseTimers = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s0">// Stops all currently active measurements so that they can be resumed</span>
    <span class="s0">// if we continue in a later deferred loop from the same unit of work.</span>
    <span class="s3">var </span><span class="s1">fiber = currentFiber;</span>

    <span class="s3">while </span><span class="s1">(fiber) {</span>
      <span class="s3">if </span><span class="s1">(fiber._debugIsCurrentlyTiming) {</span>
        <span class="s1">endFiberMark(fiber, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">resumeTimersRecursively = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
    <span class="s3">if </span><span class="s1">(fiber.</span><span class="s3">return </span><span class="s1">!== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">resumeTimersRecursively(fiber.</span><span class="s3">return</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(fiber._debugIsCurrentlyTiming) {</span>
      <span class="s1">beginFiberMark(fiber, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">resumeTimers = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s0">// Resumes all measurements that were active during the last deferred loop.</span>
    <span class="s3">if </span><span class="s1">(currentFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">resumeTimersRecursively(currentFiber);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">recordEffect() {</span>
    <span class="s1">{</span>
      <span class="s1">effectCountInCurrentCommit++;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">recordScheduleUpdate() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isCommitting) {</span>
        <span class="s1">hasScheduledUpdateInCurrentCommit = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(currentPhase !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentPhase !== </span><span class="s2">'componentWillMount' </span><span class="s1">&amp;&amp; currentPhase !== </span><span class="s2">'componentWillReceiveProps'</span><span class="s1">) {</span>
        <span class="s1">hasScheduledUpdateInCurrentPhase = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startWorkTimer(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming || shouldIgnoreFiber(fiber)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we pause, this is the fiber to unwind from.</span>


      <span class="s1">currentFiber = fiber;</span>

      <span class="s3">if </span><span class="s1">(!beginFiberMark(fiber, </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">fiber._debugIsCurrentlyTiming = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">cancelWorkTimer(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming || shouldIgnoreFiber(fiber)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Remember we shouldn't complete measurement for this fiber.</span>
      <span class="s0">// Otherwise flamechart will be deep even for small updates.</span>


      <span class="s1">fiber._debugIsCurrentlyTiming = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">clearFiberMark(fiber, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopWorkTimer(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming || shouldIgnoreFiber(fiber)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we pause, its parent is the fiber to unwind from.</span>


      <span class="s1">currentFiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!fiber._debugIsCurrentlyTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">fiber._debugIsCurrentlyTiming = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">endFiberMark(fiber, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopFailedWorkTimer(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming || shouldIgnoreFiber(fiber)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we pause, its parent is the fiber to unwind from.</span>


      <span class="s1">currentFiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!fiber._debugIsCurrentlyTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">fiber._debugIsCurrentlyTiming = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">warning = fiber.tag === SuspenseComponent ? </span><span class="s2">'Rendering was suspended' </span><span class="s1">: </span><span class="s2">'An error was thrown inside this error boundary'</span><span class="s1">;</span>
      <span class="s1">endFiberMark(fiber, </span><span class="s3">null</span><span class="s1">, warning);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startPhaseTimer(fiber, phase) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">clearPendingPhaseMeasurement();</span>

      <span class="s3">if </span><span class="s1">(!beginFiberMark(fiber, phase)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">currentPhaseFiber = fiber;</span>
      <span class="s1">currentPhase = phase;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopPhaseTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(currentPhase !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentPhaseFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">warning = hasScheduledUpdateInCurrentPhase ? </span><span class="s2">'Scheduled a cascading update' </span><span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">endFiberMark(currentPhaseFiber, currentPhase, warning);</span>
      <span class="s1">}</span>

      <span class="s1">currentPhase = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">currentPhaseFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startWorkLoopTimer(nextUnitOfWork) {</span>
    <span class="s1">{</span>
      <span class="s1">currentFiber = nextUnitOfWork;</span>

      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">commitCountInCurrentWorkLoop = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// This is top level call.</span>
      <span class="s0">// Any other measurements are performed within.</span>

      <span class="s1">beginMark(</span><span class="s2">'(React Tree Reconciliation)'</span><span class="s1">); </span><span class="s0">// Resume any measurements that were in progress during the last loop.</span>

      <span class="s1">resumeTimers();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopWorkLoopTimer(interruptedBy, didCompleteRoot) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">warning = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(interruptedBy !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(interruptedBy.tag === HostRoot) {</span>
          <span class="s1">warning = </span><span class="s2">'A top-level update interrupted the previous render'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">componentName = getComponentName(interruptedBy.type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
          <span class="s1">warning = </span><span class="s2">&quot;An update to &quot; </span><span class="s1">+ componentName + </span><span class="s2">&quot; interrupted the previous render&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(commitCountInCurrentWorkLoop &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">warning = </span><span class="s2">'There were cascading updates'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">commitCountInCurrentWorkLoop = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">label = didCompleteRoot ? </span><span class="s2">'(React Tree Reconciliation: Completed Root)' </span><span class="s1">: </span><span class="s2">'(React Tree Reconciliation: Yielded)'</span><span class="s1">; </span><span class="s0">// Pause any measurements until the next loop.</span>

      <span class="s1">pauseTimers();</span>
      <span class="s1">endMark(label, </span><span class="s2">'(React Tree Reconciliation)'</span><span class="s1">, warning);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startCommitTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">isCommitting = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">hasScheduledUpdateInCurrentCommit = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">labelsInCurrentCommit.clear();</span>
      <span class="s1">beginMark(</span><span class="s2">'(Committing Changes)'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopCommitTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">warning = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(hasScheduledUpdateInCurrentCommit) {</span>
        <span class="s1">warning = </span><span class="s2">'Lifecycle hook scheduled a cascading update'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(commitCountInCurrentWorkLoop &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">warning = </span><span class="s2">'Caused by a cascading update in earlier commit'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">hasScheduledUpdateInCurrentCommit = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">commitCountInCurrentWorkLoop++;</span>
      <span class="s1">isCommitting = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">labelsInCurrentCommit.clear();</span>
      <span class="s1">endMark(</span><span class="s2">'(Committing Changes)'</span><span class="s1">, </span><span class="s2">'(Committing Changes)'</span><span class="s1">, warning);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startCommitSnapshotEffectsTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">beginMark(</span><span class="s2">'(Committing Snapshot Effects)'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopCommitSnapshotEffectsTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">count = effectCountInCurrentCommit;</span>
      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">endMark(</span><span class="s2">&quot;(Committing Snapshot Effects: &quot; </span><span class="s1">+ count + </span><span class="s2">&quot; Total)&quot;</span><span class="s1">, </span><span class="s2">'(Committing Snapshot Effects)'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startCommitHostEffectsTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">beginMark(</span><span class="s2">'(Committing Host Effects)'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopCommitHostEffectsTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">count = effectCountInCurrentCommit;</span>
      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">endMark(</span><span class="s2">&quot;(Committing Host Effects: &quot; </span><span class="s1">+ count + </span><span class="s2">&quot; Total)&quot;</span><span class="s1">, </span><span class="s2">'(Committing Host Effects)'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">startCommitLifeCyclesTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">beginMark(</span><span class="s2">'(Calling Lifecycle Methods)'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopCommitLifeCyclesTimer() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!supportsUserTiming) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">count = effectCountInCurrentCommit;</span>
      <span class="s1">effectCountInCurrentCommit = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">endMark(</span><span class="s2">&quot;(Calling Lifecycle Methods: &quot; </span><span class="s1">+ count + </span><span class="s2">&quot; Total)&quot;</span><span class="s1">, </span><span class="s2">'(Calling Lifecycle Methods)'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">valueStack = [];</span>
  <span class="s3">var </span><span class="s1">fiberStack;</span>

  <span class="s1">{</span>
    <span class="s1">fiberStack = [];</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">createCursor(defaultValue) {</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">current: defaultValue</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pop(cursor, fiber) {</span>
    <span class="s3">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'Unexpected pop.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(fiber !== fiberStack[index]) {</span>
        <span class="s1">error(</span><span class="s2">'Unexpected Fiber popped.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">cursor.current = valueStack[index];</span>
    <span class="s1">valueStack[index] = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">fiberStack[index] = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">index--;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">push(cursor, value, fiber) {</span>
    <span class="s1">index++;</span>
    <span class="s1">valueStack[index] = cursor.current;</span>

    <span class="s1">{</span>
      <span class="s1">fiberStack[index] = fiber;</span>
    <span class="s1">}</span>

    <span class="s1">cursor.current = value;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">warnedAboutMissingGetChildContext;</span>

  <span class="s1">{</span>
    <span class="s1">warnedAboutMissingGetChildContext = {};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">emptyContextObject = {};</span>

  <span class="s1">{</span>
    <span class="s1">Object.freeze(emptyContextObject);</span>
  <span class="s1">} </span><span class="s0">// A cursor to the current merged context object on the stack.</span>


  <span class="s3">var </span><span class="s1">contextStackCursor = createCursor(emptyContextObject); </span><span class="s0">// A cursor to a boolean indicating whether the context has changed.</span>

  <span class="s3">var </span><span class="s1">didPerformWorkStackCursor = createCursor(</span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Keep track of the previous context object that was on the stack.</span>
  <span class="s0">// We use this to get access to the parent context after we have already</span>
  <span class="s0">// pushed the next context provider, and now need to merge their contexts.</span>

  <span class="s3">var </span><span class="s1">previousContext = emptyContextObject;</span>

  <span class="s3">function </span><span class="s1">getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(didPushOwnContextIfProvider &amp;&amp; isContextProvider(Component)) {</span>
        <span class="s0">// If the fiber is a context provider itself, when we read its context</span>
        <span class="s0">// we may have already pushed its own child context on the stack. A context</span>
        <span class="s0">// provider should not &quot;see&quot; its own child context. Therefore we read the</span>
        <span class="s0">// previous (parent) context instead for a context provider.</span>
        <span class="s3">return </span><span class="s1">previousContext;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">contextStackCursor.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">cacheContext(workInProgress, unmaskedContext, maskedContext) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
      <span class="s1">instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;</span>
      <span class="s1">instance.__reactInternalMemoizedMaskedChildContext = maskedContext;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getMaskedContext(workInProgress, unmaskedContext) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
      <span class="s3">var </span><span class="s1">contextTypes = type.contextTypes;</span>

      <span class="s3">if </span><span class="s1">(!contextTypes) {</span>
        <span class="s3">return </span><span class="s1">emptyContextObject;</span>
      <span class="s1">} </span><span class="s0">// Avoid recreating masked context unless unmasked context has changed.</span>
      <span class="s0">// Failing to do this will result in unnecessary calls to componentWillReceiveProps.</span>
      <span class="s0">// This may trigger infinite loops if componentWillReceiveProps calls setState.</span>


      <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

      <span class="s3">if </span><span class="s1">(instance &amp;&amp; instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {</span>
        <span class="s3">return </span><span class="s1">instance.__reactInternalMemoizedMaskedChildContext;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">context = {};</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">contextTypes) {</span>
        <span class="s1">context[key] = unmaskedContext[key];</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">name = getComponentName(type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
        <span class="s1">checkPropTypes_1(contextTypes, context, </span><span class="s2">'context'</span><span class="s1">, name, getCurrentFiberStackInDev);</span>
      <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
      <span class="s0">// Context is created before the class component is instantiated so check for instance.</span>


      <span class="s3">if </span><span class="s1">(instance) {</span>
        <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">context;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">hasContextChanged() {</span>
    <span class="s1">{</span>
      <span class="s3">return </span><span class="s1">didPerformWorkStackCursor.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isContextProvider(type) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">childContextTypes = type.childContextTypes;</span>
      <span class="s3">return </span><span class="s1">childContextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popContext(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
      <span class="s1">pop(contextStackCursor, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popTopLevelContextObject(fiber) {</span>
    <span class="s1">{</span>
      <span class="s1">pop(didPerformWorkStackCursor, fiber);</span>
      <span class="s1">pop(contextStackCursor, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushTopLevelContextObject(fiber, context, didChange) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!(contextStackCursor.current === emptyContextObject)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">push(contextStackCursor, context, fiber);</span>
      <span class="s1">push(didPerformWorkStackCursor, didChange, fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">processChildContext(fiber, type, parentContext) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>
      <span class="s3">var </span><span class="s1">childContextTypes = type.childContextTypes; </span><span class="s0">// TODO (bvaughn) Replace this behavior with an invariant() in the future.</span>
      <span class="s0">// It has only been added in Fiber to match the (unintentional) behavior in Stack.</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getChildContext !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">componentName = getComponentName(type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(!warnedAboutMissingGetChildContext[componentName]) {</span>
            <span class="s1">warnedAboutMissingGetChildContext[componentName] = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s2">'%s.childContextTypes is specified but there is no getChildContext() method ' </span><span class="s1">+ </span><span class="s2">'on the instance. You can either define getChildContext() on %s or remove ' </span><span class="s1">+ </span><span class="s2">'childContextTypes from it.'</span><span class="s1">, componentName, componentName);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">parentContext;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">childContext;</span>
      <span class="s1">startPhaseTimer(fiber, </span><span class="s2">'getChildContext'</span><span class="s1">);</span>
      <span class="s1">childContext = instance.getChildContext();</span>
      <span class="s1">stopPhaseTimer();</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">contextKey </span><span class="s3">in </span><span class="s1">childContext) {</span>
        <span class="s3">if </span><span class="s1">(!(contextKey </span><span class="s3">in </span><span class="s1">childContextTypes)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( (getComponentName(type) || </span><span class="s2">'Unknown'</span><span class="s1">) + </span><span class="s2">&quot;.getChildContext(): key </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ contextKey + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">is not defined in childContextTypes.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">name = getComponentName(type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>
        <span class="s1">checkPropTypes_1(childContextTypes, childContext, </span><span class="s2">'child context'</span><span class="s1">, name, </span><span class="s0">// In practice, there is one case in which we won't get a stack. It's when</span>
        <span class="s0">// somebody calls unstable_renderSubtreeIntoContainer() and we process</span>
        <span class="s0">// context from the parent component instance. The stack will be missing</span>
        <span class="s0">// because it's outside of the reconciliation, and so the pointer has not</span>
        <span class="s0">// been set. This is rare and doesn't matter. We'll also remove that API.</span>
        <span class="s1">getCurrentFiberStackInDev);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">_assign({}, parentContext, {}, childContext);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushContextProvider(workInProgress) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// We push the context as early as possible to ensure stack integrity.</span>
      <span class="s0">// If the instance does not exist yet, we will push null at first,</span>
      <span class="s0">// and replace it on the stack later when invalidating the context.</span>

      <span class="s3">var </span><span class="s1">memoizedMergedChildContext = instance &amp;&amp; instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; </span><span class="s0">// Remember the parent context so we can merge with it later.</span>
      <span class="s0">// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.</span>

      <span class="s1">previousContext = contextStackCursor.current;</span>
      <span class="s1">push(contextStackCursor, memoizedMergedChildContext, workInProgress);</span>
      <span class="s1">push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">invalidateContextProvider(workInProgress, type, didChange) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

      <span class="s3">if </span><span class="s1">(!instance) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(didChange) {</span>
        <span class="s0">// Merge parent and own context.</span>
        <span class="s0">// Skip this if we're not updating due to sCU.</span>
        <span class="s0">// This avoids unnecessarily recomputing memoized values.</span>
        <span class="s3">var </span><span class="s1">mergedContext = processChildContext(workInProgress, type, previousContext);</span>
        <span class="s1">instance.__reactInternalMemoizedMergedChildContext = mergedContext; </span><span class="s0">// Replace the old (or empty) context with the new one.</span>
        <span class="s0">// It is important to unwind the context in the reverse order.</span>

        <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
        <span class="s1">pop(contextStackCursor, workInProgress); </span><span class="s0">// Now push the new context and mark that it has changed.</span>

        <span class="s1">push(contextStackCursor, mergedContext, workInProgress);</span>
        <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pop(didPerformWorkStackCursor, workInProgress);</span>
        <span class="s1">push(didPerformWorkStackCursor, didChange, workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findCurrentUnmaskedContext(fiber) {</span>
    <span class="s1">{</span>
      <span class="s0">// Currently this is only used with renderSubtreeIntoContainer; not sure if it</span>
      <span class="s0">// makes sense elsewhere</span>
      <span class="s3">if </span><span class="s1">(!(isFiberMounted(fiber) &amp;&amp; fiber.tag === ClassComponent)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">node = fiber;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">switch </span><span class="s1">(node.tag) {</span>
          <span class="s3">case </span><span class="s1">HostRoot:</span>
            <span class="s3">return </span><span class="s1">node.stateNode.context;</span>

          <span class="s3">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">Component = node.type;</span>

              <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
                <span class="s3">return </span><span class="s1">node.stateNode.__reactInternalMemoizedMergedChildContext;</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">LegacyRoot = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">BlockingRoot = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ConcurrentRoot = </span><span class="s4">2</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactInternals$2 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span>
  <span class="s3">var </span><span class="s1">_ReactInternals$Sched$1 = ReactInternals$2.SchedulerTracing,</span>
      <span class="s1">__interactionsRef = _ReactInternals$Sched$1.__interactionsRef,</span>
      <span class="s1">__subscriberRef = _ReactInternals$Sched$1.__subscriberRef,</span>
      <span class="s1">unstable_clear = _ReactInternals$Sched$1.unstable_clear,</span>
      <span class="s1">unstable_getCurrent = _ReactInternals$Sched$1.unstable_getCurrent,</span>
      <span class="s1">unstable_getThreadID = _ReactInternals$Sched$1.unstable_getThreadID,</span>
      <span class="s1">unstable_subscribe = _ReactInternals$Sched$1.unstable_subscribe,</span>
      <span class="s1">unstable_trace = _ReactInternals$Sched$1.unstable_trace,</span>
      <span class="s1">unstable_unsubscribe = _ReactInternals$Sched$1.unstable_unsubscribe,</span>
      <span class="s1">unstable_wrap = _ReactInternals$Sched$1.unstable_wrap;</span>

  <span class="s3">var </span><span class="s1">Scheduler_runWithPriority = unstable_runWithPriority,</span>
      <span class="s1">Scheduler_scheduleCallback = unstable_scheduleCallback,</span>
      <span class="s1">Scheduler_cancelCallback = unstable_cancelCallback,</span>
      <span class="s1">Scheduler_shouldYield = unstable_shouldYield,</span>
      <span class="s1">Scheduler_requestPaint = unstable_requestPaint,</span>
      <span class="s1">Scheduler_now = unstable_now,</span>
      <span class="s1">Scheduler_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel,</span>
      <span class="s1">Scheduler_ImmediatePriority = unstable_ImmediatePriority,</span>
      <span class="s1">Scheduler_UserBlockingPriority = unstable_UserBlockingPriority,</span>
      <span class="s1">Scheduler_NormalPriority = unstable_NormalPriority,</span>
      <span class="s1">Scheduler_LowPriority = unstable_LowPriority,</span>
      <span class="s1">Scheduler_IdlePriority = unstable_IdlePriority;</span>

  <span class="s1">{</span>
    <span class="s0">// Provide explicit error message when production+profiling bundle of e.g.</span>
    <span class="s0">// react-dom is used with production (non-profiling) bundle of</span>
    <span class="s0">// scheduler/tracing</span>
    <span class="s3">if </span><span class="s1">(!(__interactionsRef != </span><span class="s3">null </span><span class="s1">&amp;&amp; __interactionsRef.current != </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fakeCallbackNode = {}; </span><span class="s0">// Except for NoPriority, these correspond to Scheduler priorities. We use</span>
  <span class="s0">// ascending numbers so we can compare them like numbers. They start at 90 to</span>
  <span class="s0">// avoid clashing with Scheduler's priorities.</span>

  <span class="s3">var </span><span class="s1">ImmediatePriority = </span><span class="s4">99</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">UserBlockingPriority$1 = </span><span class="s4">98</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">NormalPriority = </span><span class="s4">97</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LowPriority = </span><span class="s4">96</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IdlePriority = </span><span class="s4">95</span><span class="s1">; </span><span class="s0">// NoPriority is the absence of priority. Also React-only.</span>

  <span class="s3">var </span><span class="s1">NoPriority = </span><span class="s4">90</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">shouldYield = Scheduler_shouldYield;</span>
  <span class="s3">var </span><span class="s1">requestPaint = </span><span class="s0">// Fall back gracefully if we're running an older version of Scheduler.</span>
  <span class="s1">Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : </span><span class="s3">function </span><span class="s1">() {};</span>
  <span class="s3">var </span><span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">immediateQueueCallbackNode = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isFlushingSyncQueue = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">initialTimeMs = Scheduler_now(); </span><span class="s0">// If the initial timestamp is reasonably small, use Scheduler's `now` directly.</span>
  <span class="s0">// This will be the case for modern browsers that support `performance.now`. In</span>
  <span class="s0">// older browsers, Scheduler falls back to `Date.now`, which returns a Unix</span>
  <span class="s0">// timestamp. In that case, subtract the module initialization time to simulate</span>
  <span class="s0">// the behavior of performance.now and keep our times small enough to fit</span>
  <span class="s0">// within 32 bits.</span>
  <span class="s0">// TODO: Consider lifting this into Scheduler.</span>

  <span class="s3">var </span><span class="s1">now = initialTimeMs &lt; </span><span class="s4">10000 </span><span class="s1">? Scheduler_now : </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">return </span><span class="s1">Scheduler_now() - initialTimeMs;</span>
  <span class="s1">};</span>
  <span class="s3">function </span><span class="s1">getCurrentPriorityLevel() {</span>
    <span class="s3">switch </span><span class="s1">(Scheduler_getCurrentPriorityLevel()) {</span>
      <span class="s3">case </span><span class="s1">Scheduler_ImmediatePriority:</span>
        <span class="s3">return </span><span class="s1">ImmediatePriority;</span>

      <span class="s3">case </span><span class="s1">Scheduler_UserBlockingPriority:</span>
        <span class="s3">return </span><span class="s1">UserBlockingPriority$1;</span>

      <span class="s3">case </span><span class="s1">Scheduler_NormalPriority:</span>
        <span class="s3">return </span><span class="s1">NormalPriority;</span>

      <span class="s3">case </span><span class="s1">Scheduler_LowPriority:</span>
        <span class="s3">return </span><span class="s1">LowPriority;</span>

      <span class="s3">case </span><span class="s1">Scheduler_IdlePriority:</span>
        <span class="s3">return </span><span class="s1">IdlePriority;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unknown priority level.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reactPriorityToSchedulerPriority(reactPriorityLevel) {</span>
    <span class="s3">switch </span><span class="s1">(reactPriorityLevel) {</span>
      <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
        <span class="s3">return </span><span class="s1">Scheduler_ImmediatePriority;</span>

      <span class="s3">case </span><span class="s1">UserBlockingPriority$1:</span>
        <span class="s3">return </span><span class="s1">Scheduler_UserBlockingPriority;</span>

      <span class="s3">case </span><span class="s1">NormalPriority:</span>
        <span class="s3">return </span><span class="s1">Scheduler_NormalPriority;</span>

      <span class="s3">case </span><span class="s1">LowPriority:</span>
        <span class="s3">return </span><span class="s1">Scheduler_LowPriority;</span>

      <span class="s3">case </span><span class="s1">IdlePriority:</span>
        <span class="s3">return </span><span class="s1">Scheduler_IdlePriority;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unknown priority level.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">runWithPriority$1(reactPriorityLevel, fn) {</span>
    <span class="s3">var </span><span class="s1">priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);</span>
    <span class="s3">return </span><span class="s1">Scheduler_runWithPriority(priorityLevel, fn);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">scheduleCallback(reactPriorityLevel, callback, options) {</span>
    <span class="s3">var </span><span class="s1">priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);</span>
    <span class="s3">return </span><span class="s1">Scheduler_scheduleCallback(priorityLevel, callback, options);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">scheduleSyncCallback(callback) {</span>
    <span class="s0">// Push this callback into an internal queue. We'll flush these either in</span>
    <span class="s0">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span>
    <span class="s3">if </span><span class="s1">(syncQueue === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">syncQueue = [callback]; </span><span class="s0">// Flush the queue in the next tick, at the earliest.</span>

      <span class="s1">immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Push onto existing queue. Don't need to schedule a callback because</span>
      <span class="s0">// we already scheduled one when we created the queue.</span>
      <span class="s1">syncQueue.push(callback);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">fakeCallbackNode;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">cancelCallback(callbackNode) {</span>
    <span class="s3">if </span><span class="s1">(callbackNode !== fakeCallbackNode) {</span>
      <span class="s1">Scheduler_cancelCallback(callbackNode);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">flushSyncCallbackQueue() {</span>
    <span class="s3">if </span><span class="s1">(immediateQueueCallbackNode !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">node = immediateQueueCallbackNode;</span>
      <span class="s1">immediateQueueCallbackNode = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">Scheduler_cancelCallback(node);</span>
    <span class="s1">}</span>

    <span class="s1">flushSyncCallbackQueueImpl();</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushSyncCallbackQueueImpl() {</span>
    <span class="s3">if </span><span class="s1">(!isFlushingSyncQueue &amp;&amp; syncQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Prevent re-entrancy.</span>
      <span class="s1">isFlushingSyncQueue = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_isSync = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">queue = syncQueue;</span>
        <span class="s1">runWithPriority$1(ImmediatePriority, </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">for </span><span class="s1">(; i &lt; queue.length; i++) {</span>
            <span class="s3">var </span><span class="s1">callback = queue[i];</span>

            <span class="s3">do </span><span class="s1">{</span>
              <span class="s1">callback = callback(_isSync);</span>
            <span class="s1">} </span><span class="s3">while </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">syncQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s0">// If something throws, leave the remaining callbacks on the queue.</span>
        <span class="s3">if </span><span class="s1">(syncQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">syncQueue = syncQueue.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s0">// Resume flushing in the next tick</span>


        <span class="s1">Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);</span>
        <span class="s3">throw </span><span class="s1">error;</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">isFlushingSyncQueue = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">NoMode = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">StrictMode = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// TODO: Remove BlockingMode and ConcurrentMode by reading from the root</span>
  <span class="s0">// tag instead</span>

  <span class="s3">var </span><span class="s1">BlockingMode = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ConcurrentMode = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ProfileMode = </span><span class="s4">8</span><span class="s1">;</span>

  <span class="s0">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span>
  <span class="s0">// Math.pow(2, 30) - 1</span>
  <span class="s0">// 0b111111111111111111111111111111</span>
  <span class="s3">var </span><span class="s1">MAX_SIGNED_31_BIT_INT = </span><span class="s4">1073741823</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">NoWork = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// TODO: Think of a better name for Never. The key difference with Idle is that</span>
  <span class="s0">// Never work can be committed in an inconsistent state without tearing the UI.</span>
  <span class="s0">// The main example is offscreen content, like a hidden subtree. So one possible</span>
  <span class="s0">// name is Offscreen. However, it also includes dehydrated Suspense boundaries,</span>
  <span class="s0">// which are inconsistent in the sense that they haven't finished yet, but</span>
  <span class="s0">// aren't visibly inconsistent because the server rendered HTML matches what the</span>
  <span class="s0">// hydrated tree would look like.</span>

  <span class="s3">var </span><span class="s1">Never = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Idle is slightly higher priority than Never. It must completely finish in</span>
  <span class="s0">// order to be consistent.</span>

  <span class="s3">var </span><span class="s1">Idle = </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// Continuous Hydration is slightly higher than Idle and is used to increase</span>
  <span class="s0">// priority of hover targets.</span>

  <span class="s3">var </span><span class="s1">ContinuousHydration = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Sync = MAX_SIGNED_31_BIT_INT;</span>
  <span class="s3">var </span><span class="s1">Batched = Sync - </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">UNIT_SIZE = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">MAGIC_NUMBER_OFFSET = Batched - </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// 1 unit of expiration time represents 10ms.</span>

  <span class="s3">function </span><span class="s1">msToExpirationTime(ms) {</span>
    <span class="s0">// Always subtract from the offset so that we don't clash with the magic number for NoWork.</span>
    <span class="s3">return </span><span class="s1">MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">expirationTimeToMs(expirationTime) {</span>
    <span class="s3">return </span><span class="s1">(MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">ceiling(num, precision) {</span>
    <span class="s3">return </span><span class="s1">((num / precision | </span><span class="s4">0</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">) * precision;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {</span>
    <span class="s3">return </span><span class="s1">MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);</span>
  <span class="s1">} </span><span class="s0">// TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update</span>
  <span class="s0">// the names to reflect.</span>


  <span class="s3">var </span><span class="s1">LOW_PRIORITY_EXPIRATION = </span><span class="s4">5000</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LOW_PRIORITY_BATCH_SIZE = </span><span class="s4">250</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">computeAsyncExpiration(currentTime) {</span>
    <span class="s3">return </span><span class="s1">computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">computeSuspenseExpiration(currentTime, timeoutMs) {</span>
    <span class="s0">// TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?</span>
    <span class="s3">return </span><span class="s1">computeExpirationBucket(currentTime, timeoutMs, LOW_PRIORITY_BATCH_SIZE);</span>
  <span class="s1">} </span><span class="s0">// We intentionally set a higher expiration time for interactive updates in</span>
  <span class="s0">// dev than in production.</span>
  <span class="s0">//</span>
  <span class="s0">// If the main thread is being blocked so long that you hit the expiration,</span>
  <span class="s0">// it's a problem that could be solved with better scheduling.</span>
  <span class="s0">//</span>
  <span class="s0">// People will be more likely to notice this and fix it with the long</span>
  <span class="s0">// expiration time in development.</span>
  <span class="s0">//</span>
  <span class="s0">// In production we opt for better UX at the risk of masking scheduling</span>
  <span class="s0">// problems, by expiring fast.</span>

  <span class="s3">var </span><span class="s1">HIGH_PRIORITY_EXPIRATION =  </span><span class="s4">500 </span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HIGH_PRIORITY_BATCH_SIZE = </span><span class="s4">100</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">computeInteractiveExpiration(currentTime) {</span>
    <span class="s3">return </span><span class="s1">computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">inferPriorityFromExpirationTime(currentTime, expirationTime) {</span>
    <span class="s3">if </span><span class="s1">(expirationTime === Sync) {</span>
      <span class="s3">return </span><span class="s1">ImmediatePriority;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(expirationTime === Never || expirationTime === Idle) {</span>
      <span class="s3">return </span><span class="s1">IdlePriority;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);</span>

    <span class="s3">if </span><span class="s1">(msUntil &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">ImmediatePriority;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(msUntil &lt;= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {</span>
      <span class="s3">return </span><span class="s1">UserBlockingPriority$1;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(msUntil &lt;= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {</span>
      <span class="s3">return </span><span class="s1">NormalPriority;</span>
    <span class="s1">} </span><span class="s0">// TODO: Handle LowPriority</span>
    <span class="s0">// Assume anything lower has idle priority</span>


    <span class="s3">return </span><span class="s1">IdlePriority;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactStrictModeWarnings = {</span>
    <span class="s1">recordUnsafeLifecycleWarnings: </span><span class="s3">function </span><span class="s1">(fiber, instance) {},</span>
    <span class="s1">flushPendingUnsafeLifecycleWarnings: </span><span class="s3">function </span><span class="s1">() {},</span>
    <span class="s1">recordLegacyContextWarning: </span><span class="s3">function </span><span class="s1">(fiber, instance) {},</span>
    <span class="s1">flushLegacyContextWarning: </span><span class="s3">function </span><span class="s1">() {},</span>
    <span class="s1">discardPendingWarnings: </span><span class="s3">function </span><span class="s1">() {}</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">findStrictRoot = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
      <span class="s3">var </span><span class="s1">maybeStrictRoot = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">node = fiber;</span>

      <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.mode &amp; StrictMode) {</span>
          <span class="s1">maybeStrictRoot = node;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">maybeStrictRoot;</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">setToSortedString = </span><span class="s3">function </span><span class="s1">(set) {</span>
      <span class="s3">var </span><span class="s1">array = [];</span>
      <span class="s1">set.forEach(</span><span class="s3">function </span><span class="s1">(value) {</span>
        <span class="s1">array.push(value);</span>
      <span class="s1">});</span>
      <span class="s3">return </span><span class="s1">array.sort().join(</span><span class="s2">', '</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">pendingComponentWillMountWarnings = [];</span>
    <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
    <span class="s3">var </span><span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
    <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
    <span class="s3">var </span><span class="s1">pendingComponentWillUpdateWarnings = [];</span>
    <span class="s3">var </span><span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = []; </span><span class="s0">// Tracks components we have already warned about.</span>

    <span class="s3">var </span><span class="s1">didWarnAboutUnsafeLifecycles = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = </span><span class="s3">function </span><span class="s1">(fiber, instance) {</span>
      <span class="s0">// Dedup strategy: Warn once per component.</span>
      <span class="s3">if </span><span class="s1">(didWarnAboutUnsafeLifecycles.has(fiber.type)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s0">// Don't warn about react-lifecycles-compat polyfilled components.</span>
      <span class="s1">instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillMountWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(fiber.mode &amp; StrictMode &amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(fiber.mode &amp; StrictMode &amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillUpdateWarnings.push(fiber);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(fiber.mode &amp; StrictMode &amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s0">// We do an initial pass to gather component names</span>
      <span class="s3">var </span><span class="s1">componentWillMountUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillMountWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillMountUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillMountWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">UNSAFE_componentWillMountUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillMountWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">componentWillReceivePropsUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">UNSAFE_componentWillReceivePropsUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillReceivePropsWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">componentWillUpdateUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingComponentWillUpdateWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">UNSAFE_componentWillUpdateUniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(pendingUNSAFE_ComponentWillUpdateWarnings.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutUnsafeLifecycles.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
      <span class="s1">} </span><span class="s0">// Finally, we flush all the warnings</span>
      <span class="s0">// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'</span>


      <span class="s3">if </span><span class="s1">(UNSAFE_componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);</span>

        <span class="s1">error(</span><span class="s2">'Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, sortedNames);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(UNSAFE_componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);</span>

        <span class="s1">error(</span><span class="s2">'Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' </span><span class="s1">+ </span><span class="s2">'and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;* If you're updating state whenever props change, &quot; </span><span class="s1">+ </span><span class="s2">'refactor your code to use memoization techniques or move it to ' </span><span class="s1">+ </span><span class="s2">'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, _sortedNames);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(UNSAFE_componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);</span>

        <span class="s1">error(</span><span class="s2">'Using UNSAFE_componentWillUpdate in strict mode is not recommended ' </span><span class="s1">+ </span><span class="s2">'and may indicate bugs in your code. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, _sortedNames2);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(componentWillMountUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_sortedNames3 = setToSortedString(componentWillMountUniqueNames);</span>

        <span class="s1">warn(</span><span class="s2">'componentWillMount has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move code with side effects to componentDidMount, and set initial state in the constructor.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' </span><span class="s1">+ </span><span class="s2">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s2">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s2">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, _sortedNames3);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(componentWillReceivePropsUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);</span>

        <span class="s1">warn(</span><span class="s2">'componentWillReceiveProps has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;* If you're updating state whenever props change, refactor your &quot; </span><span class="s1">+ </span><span class="s2">'code to use memoization techniques or move it to ' </span><span class="s1">+ </span><span class="s2">'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' </span><span class="s1">+ </span><span class="s2">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s2">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s2">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, _sortedNames4);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(componentWillUpdateUniqueNames.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);</span>

        <span class="s1">warn(</span><span class="s2">'componentWillUpdate has been renamed, and is not recommended for use. ' </span><span class="s1">+ </span><span class="s2">'See https://fb.me/react-unsafe-component-lifecycles for details.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Move data fetching code or side effects to componentDidUpdate.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' </span><span class="s1">+ </span><span class="s2">'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. ' </span><span class="s1">+ </span><span class="s2">'To rename all deprecated lifecycles to their new names, you can run ' </span><span class="s1">+ </span><span class="s2">'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Please update the following components: %s'</span><span class="s1">, _sortedNames5);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">pendingLegacyContextWarning = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// Tracks components we have already warned about.</span>

    <span class="s3">var </span><span class="s1">didWarnAboutLegacyContext = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning = </span><span class="s3">function </span><span class="s1">(fiber, instance) {</span>
      <span class="s3">var </span><span class="s1">strictRoot = findStrictRoot(fiber);</span>

      <span class="s3">if </span><span class="s1">(strictRoot === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Expected to find a StrictMode component in a strict mode tree. ' </span><span class="s1">+ </span><span class="s2">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s1">);</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Dedup strategy: Warn once per component.</span>


      <span class="s3">if </span><span class="s1">(didWarnAboutLegacyContext.has(fiber.type)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">warningsForRoot = pendingLegacyContextWarning.get(strictRoot);</span>

      <span class="s3">if </span><span class="s1">(fiber.type.contextTypes != </span><span class="s3">null </span><span class="s1">|| fiber.type.childContextTypes != </span><span class="s3">null </span><span class="s1">|| instance !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.getChildContext === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(warningsForRoot === undefined) {</span>
          <span class="s1">warningsForRoot = [];</span>
          <span class="s1">pendingLegacyContextWarning.set(strictRoot, warningsForRoot);</span>
        <span class="s1">}</span>

        <span class="s1">warningsForRoot.push(fiber);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">pendingLegacyContextWarning.forEach(</span><span class="s3">function </span><span class="s1">(fiberArray, strictRoot) {</span>
        <span class="s3">if </span><span class="s1">(fiberArray.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">firstFiber = fiberArray[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">var </span><span class="s1">uniqueNames = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s1">fiberArray.forEach(</span><span class="s3">function </span><span class="s1">(fiber) {</span>
          <span class="s1">uniqueNames.add(getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
          <span class="s1">didWarnAboutLegacyContext.add(fiber.type);</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">sortedNames = setToSortedString(uniqueNames);</span>
        <span class="s3">var </span><span class="s1">firstComponentStack = getStackByFiberInDevAndProd(firstFiber);</span>

        <span class="s1">error(</span><span class="s2">'Legacy context API has been detected within a strict-mode tree.' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">The old API will be supported in all 16.x releases, but applications ' </span><span class="s1">+ </span><span class="s2">'using it should migrate to the new version.' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Please update the following components: %s' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Learn more about this warning here: https://fb.me/react-legacy-context' </span><span class="s1">+ </span><span class="s2">'%s'</span><span class="s1">, sortedNames, firstComponentStack);</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s1">ReactStrictModeWarnings.discardPendingWarnings = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">pendingComponentWillMountWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillMountWarnings = [];</span>
      <span class="s1">pendingComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillReceivePropsWarnings = [];</span>
      <span class="s1">pendingComponentWillUpdateWarnings = [];</span>
      <span class="s1">pendingUNSAFE_ComponentWillUpdateWarnings = [];</span>
      <span class="s1">pendingLegacyContextWarning = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">resolveFamily = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// $FlowFixMe Flow gets confused by a WeakSet feature check below.</span>

  <span class="s3">var </span><span class="s1">failedBoundaries = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">setRefreshHandler = </span><span class="s3">function </span><span class="s1">(handler) {</span>
    <span class="s1">{</span>
      <span class="s1">resolveFamily = handler;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">function </span><span class="s1">resolveFunctionForHotReloading(type) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">family = resolveFamily(type);</span>

      <span class="s3">if </span><span class="s1">(family === undefined) {</span>
        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>


      <span class="s3">return </span><span class="s1">family.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resolveClassForHotReloading(type) {</span>
    <span class="s0">// No implementation differences.</span>
    <span class="s3">return </span><span class="s1">resolveFunctionForHotReloading(type);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resolveForwardRefForHotReloading(type) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">family = resolveFamily(type);</span>

      <span class="s3">if </span><span class="s1">(family === undefined) {</span>
        <span class="s0">// Check if we're dealing with a real forwardRef. Don't want to crash early.</span>
        <span class="s3">if </span><span class="s1">(type !== </span><span class="s3">null </span><span class="s1">&amp;&amp; type !== undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">type.render === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// ForwardRef is special because its resolved .type is an object,</span>
          <span class="s0">// but it's possible that we only have its inner render function in the map.</span>
          <span class="s0">// If that inner render function is different, we'll build a new forwardRef type.</span>
          <span class="s3">var </span><span class="s1">currentRender = resolveFunctionForHotReloading(type.render);</span>

          <span class="s3">if </span><span class="s1">(type.render !== currentRender) {</span>
            <span class="s3">var </span><span class="s1">syntheticType = {</span>
              <span class="s1">$$typeof: REACT_FORWARD_REF_TYPE,</span>
              <span class="s1">render: currentRender</span>
            <span class="s1">};</span>

            <span class="s3">if </span><span class="s1">(type.displayName !== undefined) {</span>
              <span class="s1">syntheticType.displayName = type.displayName;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">syntheticType;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">type;</span>
      <span class="s1">} </span><span class="s0">// Use the latest known implementation.</span>


      <span class="s3">return </span><span class="s1">family.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isCompatibleFamilyForHotReloading(fiber, element) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">prevType = fiber.elementType;</span>
      <span class="s3">var </span><span class="s1">nextType = element.type; </span><span class="s0">// If we got here, we know types aren't === equal.</span>

      <span class="s3">var </span><span class="s1">needsCompareFamilies = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">$$typeofNextType = </span><span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; nextType !== </span><span class="s3">null </span><span class="s1">? nextType.$$typeof : </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
        <span class="s3">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nextType === </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s0">// We don't know the inner type yet.</span>
              <span class="s0">// We're going to assume that the lazy inner type is stable,</span>
              <span class="s0">// and so it is sufficient to avoid reconciling it away.</span>
              <span class="s0">// We're not going to unwrap or actually use the new lazy type.</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">($$typeofNextType === REACT_FORWARD_REF_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">MemoComponent:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">($$typeofNextType === REACT_MEMO_TYPE) {</span>
              <span class="s0">// TODO: if it was but can no longer be simple,</span>
              <span class="s0">// we shouldn't set this.</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">($$typeofNextType === REACT_LAZY_TYPE) {</span>
              <span class="s1">needsCompareFamilies = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Check if both types have a family and it's the same one.</span>


      <span class="s3">if </span><span class="s1">(needsCompareFamilies) {</span>
        <span class="s0">// Note: memo() and forwardRef() we'll compare outer rather than inner type.</span>
        <span class="s0">// This means both of them need to be registered to preserve state.</span>
        <span class="s0">// If we unwrapped and compared the inner types for wrappers instead,</span>
        <span class="s0">// then we would risk falsely saying two separate memo(Foo)</span>
        <span class="s0">// calls are equivalent because they wrap the same Foo function.</span>
        <span class="s3">var </span><span class="s1">prevFamily = resolveFamily(prevType);</span>

        <span class="s3">if </span><span class="s1">(prevFamily !== undefined &amp;&amp; prevFamily === resolveFamily(nextType)) {</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markFailedErrorBoundaryForHotReloading(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">WeakSet !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(failedBoundaries === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">failedBoundaries = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
      <span class="s1">}</span>

      <span class="s1">failedBoundaries.add(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">scheduleRefresh = </span><span class="s3">function </span><span class="s1">(root, update) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Hot reloading is disabled.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">staleFamilies = update.staleFamilies,</span>
          <span class="s1">updatedFamilies = update.updatedFamilies;</span>
      <span class="s1">flushPassiveEffects();</span>
      <span class="s1">flushSync(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">scheduleRoot = </span><span class="s3">function </span><span class="s1">(root, element) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(root.context !== emptyContextObject) {</span>
        <span class="s0">// Super edge case: root has a legacy _renderSubtree context</span>
        <span class="s0">// but we don't know the parentComponent so we can't pass it.</span>
        <span class="s0">// Just ignore. We'll delete this with _renderSubtree code path later.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">flushPassiveEffects();</span>
      <span class="s1">syncUpdates(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">updateContainer(element, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">alternate = fiber.alternate,</span>
          <span class="s1">child = fiber.child,</span>
          <span class="s1">sibling = fiber.sibling,</span>
          <span class="s1">tag = fiber.tag,</span>
          <span class="s1">type = fiber.type;</span>
      <span class="s3">var </span><span class="s1">candidateType = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">switch </span><span class="s1">(tag) {</span>
        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s3">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">candidateType = type;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">candidateType = type.render;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(resolveFamily === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Expected resolveFamily to be set during hot reload.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">needsRender = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">needsRemount = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(candidateType !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">family = resolveFamily(candidateType);</span>

        <span class="s3">if </span><span class="s1">(family !== undefined) {</span>
          <span class="s3">if </span><span class="s1">(staleFamilies.has(family)) {</span>
            <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(updatedFamilies.has(family)) {</span>
            <span class="s3">if </span><span class="s1">(tag === ClassComponent) {</span>
              <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">needsRender = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(failedBoundaries !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(failedBoundaries.has(fiber) || alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; failedBoundaries.has(alternate)) {</span>
          <span class="s1">needsRemount = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(needsRemount) {</span>
        <span class="s1">fiber._debugNeedsRemount = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(needsRemount || needsRender) {</span>
        <span class="s1">scheduleWork(fiber, Sync);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !needsRemount) {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">findHostInstancesForRefresh = </span><span class="s3">function </span><span class="s1">(root, families) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hostInstances = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s3">var </span><span class="s1">types = </span><span class="s3">new </span><span class="s1">Set(families.map(</span><span class="s3">function </span><span class="s1">(family) {</span>
        <span class="s3">return </span><span class="s1">family.current;</span>
      <span class="s1">}));</span>
      <span class="s1">findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);</span>
      <span class="s3">return </span><span class="s1">hostInstances;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">child = fiber.child,</span>
          <span class="s1">sibling = fiber.sibling,</span>
          <span class="s1">tag = fiber.tag,</span>
          <span class="s1">type = fiber.type;</span>
      <span class="s3">var </span><span class="s1">candidateType = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">switch </span><span class="s1">(tag) {</span>
        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s3">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">candidateType = type;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">candidateType = type.render;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">didMatch = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(candidateType !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(types.has(candidateType)) {</span>
          <span class="s1">didMatch = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(didMatch) {</span>
        <span class="s0">// We have a match. This only drills down to the closest host components.</span>
        <span class="s0">// There's no need to search deeper because for the purpose of giving</span>
        <span class="s0">// visual feedback, &quot;flashing&quot; outermost parent rectangles is sufficient.</span>
        <span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// If there's no match, maybe there will be one further down in the child tree.</span>
        <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);</span>

      <span class="s3">if </span><span class="s1">(foundHostInstances) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we didn't find any host children, fallback to closest host parent.</span>


      <span class="s3">var </span><span class="s1">node = fiber;</span>

      <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(node.tag) {</span>
          <span class="s3">case </span><span class="s1">HostComponent:</span>
            <span class="s1">hostInstances.add(node.stateNode);</span>
            <span class="s3">return</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">HostPortal:</span>
            <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
            <span class="s3">return</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">HostRoot:</span>
            <span class="s1">hostInstances.add(node.stateNode.containerInfo);</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Expected to reach root first.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findChildHostInstancesForFiberShallowly(fiber, hostInstances) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">node = fiber;</span>
      <span class="s3">var </span><span class="s1">foundHostInstances = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.tag === HostComponent) {</span>
          <span class="s0">// We got a match.</span>
          <span class="s1">foundHostInstances = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">hostInstances.add(node.stateNode); </span><span class="s0">// There may still be more, so keep searching.</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node === fiber) {</span>
          <span class="s3">return </span><span class="s1">foundHostInstances;</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== fiber) {</span>
            <span class="s3">return </span><span class="s1">foundHostInstances;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resolveDefaultProps(Component, baseProps) {</span>
    <span class="s3">if </span><span class="s1">(Component &amp;&amp; Component.defaultProps) {</span>
      <span class="s0">// Resolve default props. Taken from ReactElement</span>
      <span class="s3">var </span><span class="s1">props = _assign({}, baseProps);</span>

      <span class="s3">var </span><span class="s1">defaultProps = Component.defaultProps;</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">propName </span><span class="s3">in </span><span class="s1">defaultProps) {</span>
        <span class="s3">if </span><span class="s1">(props[propName] === undefined) {</span>
          <span class="s1">props[propName] = defaultProps[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">props;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">baseProps;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">readLazyComponentType(lazyComponent) {</span>
    <span class="s1">initializeLazyComponentType(lazyComponent);</span>

    <span class="s3">if </span><span class="s1">(lazyComponent._status !== Resolved) {</span>
      <span class="s3">throw </span><span class="s1">lazyComponent._result;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">lazyComponent._result;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">valueCursor = createCursor(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">rendererSigil;</span>

  <span class="s1">{</span>
    <span class="s0">// Use this to detect multiple renderers using the same context</span>
    <span class="s1">rendererSigil = {};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">lastContextWithAllBitsObserved = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">resetContextDependencies() {</span>
    <span class="s0">// This is called right before React yields execution, to ensure `readContext`</span>
    <span class="s0">// cannot be called outside the render phase.</span>
    <span class="s1">currentlyRenderingFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">lastContextWithAllBitsObserved = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">enterDisallowedContextReadInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">exitDisallowedContextReadInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">isDisallowedContextReadInDEV = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">pushProvider(providerFiber, nextValue) {</span>
    <span class="s3">var </span><span class="s1">context = providerFiber.type._context;</span>

    <span class="s1">{</span>
      <span class="s1">push(valueCursor, context._currentValue, providerFiber);</span>
      <span class="s1">context._currentValue = nextValue;</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(context._currentRenderer !== undefined &amp;&amp; context._currentRenderer !== </span><span class="s3">null </span><span class="s1">&amp;&amp; context._currentRenderer !== rendererSigil) {</span>
          <span class="s1">error(</span><span class="s2">'Detected multiple renderers concurrently rendering the ' </span><span class="s1">+ </span><span class="s2">'same context provider. This is currently unsupported.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">context._currentRenderer = rendererSigil;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">popProvider(providerFiber) {</span>
    <span class="s3">var </span><span class="s1">currentValue = valueCursor.current;</span>
    <span class="s1">pop(valueCursor, providerFiber);</span>
    <span class="s3">var </span><span class="s1">context = providerFiber.type._context;</span>

    <span class="s1">{</span>
      <span class="s1">context._currentValue = currentValue;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">calculateChangedBits(context, newValue, oldValue) {</span>
    <span class="s3">if </span><span class="s1">(objectIs(oldValue, newValue)) {</span>
      <span class="s0">// No change</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">changedBits = </span><span class="s3">typeof </span><span class="s1">context._calculateChangedBits === </span><span class="s2">'function' </span><span class="s1">? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((changedBits &amp; MAX_SIGNED_31_BIT_INT) !== changedBits) {</span>
          <span class="s1">error(</span><span class="s2">'calculateChangedBits: Expected the return value to be a ' </span><span class="s1">+ </span><span class="s2">'31-bit integer. Instead received: %s'</span><span class="s1">, changedBits);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">changedBits | </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">scheduleWorkOnParentPath(parent, renderExpirationTime) {</span>
    <span class="s0">// Update the child expiration time of all the ancestors, including</span>
    <span class="s0">// the alternates.</span>
    <span class="s3">var </span><span class="s1">node = parent;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">alternate = node.alternate;</span>

      <span class="s3">if </span><span class="s1">(node.childExpirationTime &lt; renderExpirationTime) {</span>
        <span class="s1">node.childExpirationTime = renderExpirationTime;</span>

        <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.childExpirationTime &lt; renderExpirationTime) {</span>
          <span class="s1">alternate.childExpirationTime = renderExpirationTime;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.childExpirationTime &lt; renderExpirationTime) {</span>
        <span class="s1">alternate.childExpirationTime = renderExpirationTime;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Neither alternate was updated, which means the rest of the</span>
        <span class="s0">// ancestor path already has sufficient priority.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">fiber = workInProgress.child;</span>

    <span class="s3">if </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
      <span class="s1">fiber.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">}</span>

    <span class="s3">while </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">nextFiber = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Visit this fiber.</span>

      <span class="s3">var </span><span class="s1">list = fiber.dependencies;</span>

      <span class="s3">if </span><span class="s1">(list !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">nextFiber = fiber.child;</span>
        <span class="s3">var </span><span class="s1">dependency = list.firstContext;</span>

        <span class="s3">while </span><span class="s1">(dependency !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Check if the context matches.</span>
          <span class="s3">if </span><span class="s1">(dependency.context === context &amp;&amp; (dependency.observedBits &amp; changedBits) !== </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">// Match! Schedule an update on this fiber.</span>
            <span class="s3">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
              <span class="s0">// Schedule a force update on the work-in-progress.</span>
              <span class="s3">var </span><span class="s1">update = createUpdate(renderExpirationTime, </span><span class="s3">null</span><span class="s1">);</span>
              <span class="s1">update.tag = ForceUpdate; </span><span class="s0">// TODO: Because we don't have a work-in-progress, this will add the</span>
              <span class="s0">// update to the current fiber, too, which means it will persist even if</span>
              <span class="s0">// this render is thrown away. Since it's a race condition, not sure it's</span>
              <span class="s0">// worth fixing.</span>

              <span class="s1">enqueueUpdate(fiber, update);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(fiber.expirationTime &lt; renderExpirationTime) {</span>
              <span class="s1">fiber.expirationTime = renderExpirationTime;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

            <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.expirationTime &lt; renderExpirationTime) {</span>
              <span class="s1">alternate.expirationTime = renderExpirationTime;</span>
            <span class="s1">}</span>

            <span class="s1">scheduleWorkOnParentPath(fiber.</span><span class="s3">return</span><span class="s1">, renderExpirationTime); </span><span class="s0">// Mark the expiration time on the list, too.</span>

            <span class="s3">if </span><span class="s1">(list.expirationTime &lt; renderExpirationTime) {</span>
              <span class="s1">list.expirationTime = renderExpirationTime;</span>
            <span class="s1">} </span><span class="s0">// Since we already found a match, we can stop traversing the</span>
            <span class="s0">// dependency list.</span>


            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">dependency = dependency.next;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fiber.tag === ContextProvider) {</span>
        <span class="s0">// Don't scan deeper if this is a matching provider</span>
        <span class="s1">nextFiber = fiber.type === workInProgress.type ? </span><span class="s3">null </span><span class="s1">: fiber.child;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Traverse down.</span>
        <span class="s1">nextFiber = fiber.child;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(nextFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Set the return pointer of the child to the work-in-progress fiber.</span>
        <span class="s1">nextFiber.</span><span class="s3">return </span><span class="s1">= fiber;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// No child. Traverse to next sibling.</span>
        <span class="s1">nextFiber = fiber;</span>

        <span class="s3">while </span><span class="s1">(nextFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(nextFiber === workInProgress) {</span>
            <span class="s0">// We're back to the root of this subtree. Exit.</span>
            <span class="s1">nextFiber = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">sibling = nextFiber.sibling;</span>

          <span class="s3">if </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Set the return pointer of the sibling to the work-in-progress fiber.</span>
            <span class="s1">sibling.</span><span class="s3">return </span><span class="s1">= nextFiber.</span><span class="s3">return</span><span class="s1">;</span>
            <span class="s1">nextFiber = sibling;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// No more siblings. Traverse up.</span>


          <span class="s1">nextFiber = nextFiber.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">fiber = nextFiber;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">prepareToReadContext(workInProgress, renderExpirationTime) {</span>
    <span class="s1">currentlyRenderingFiber = workInProgress;</span>
    <span class="s1">lastContextDependency = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">lastContextWithAllBitsObserved = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">dependencies = workInProgress.dependencies;</span>

    <span class="s3">if </span><span class="s1">(dependencies !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">firstContext = dependencies.firstContext;</span>

      <span class="s3">if </span><span class="s1">(firstContext !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(dependencies.expirationTime &gt;= renderExpirationTime) {</span>
          <span class="s0">// Context list has a pending update. Mark that this fiber performed work.</span>
          <span class="s1">markWorkInProgressReceivedUpdate();</span>
        <span class="s1">} </span><span class="s0">// Reset the work-in-progress list</span>


        <span class="s1">dependencies.firstContext = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">readContext(context, observedBits) {</span>
    <span class="s1">{</span>
      <span class="s0">// This warning would fire if you read context inside a Hook like useMemo.</span>
      <span class="s0">// Unlike the class check below, it's not enforced in production for perf.</span>
      <span class="s3">if </span><span class="s1">(isDisallowedContextReadInDEV) {</span>
        <span class="s1">error(</span><span class="s2">'Context can only be read while React is rendering. ' </span><span class="s1">+ </span><span class="s2">'In classes, you can read it in the render method or getDerivedStateFromProps. ' </span><span class="s1">+ </span><span class="s2">'In function components, you can read it directly in the function body, but not ' </span><span class="s1">+ </span><span class="s2">'inside Hooks like useReducer() or useMemo().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(lastContextWithAllBitsObserved === context) ; </span><span class="s3">else if </span><span class="s1">(observedBits === </span><span class="s3">false </span><span class="s1">|| observedBits === </span><span class="s4">0</span><span class="s1">) ; </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">resolvedObservedBits; </span><span class="s0">// Avoid deopting on observable arguments or heterogeneous types.</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">observedBits !== </span><span class="s2">'number' </span><span class="s1">|| observedBits === MAX_SIGNED_31_BIT_INT) {</span>
        <span class="s0">// Observe all updates.</span>
        <span class="s1">lastContextWithAllBitsObserved = context;</span>
        <span class="s1">resolvedObservedBits = MAX_SIGNED_31_BIT_INT;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">resolvedObservedBits = observedBits;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">contextItem = {</span>
        <span class="s1">context: context,</span>
        <span class="s1">observedBits: resolvedObservedBits,</span>
        <span class="s1">next: </span><span class="s3">null</span>
      <span class="s1">};</span>

      <span class="s3">if </span><span class="s1">(lastContextDependency === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(!(currentlyRenderingFiber !== </span><span class="s3">null</span><span class="s1">)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// This is the first dependency for this component. Create a new list.</span>


        <span class="s1">lastContextDependency = contextItem;</span>
        <span class="s1">currentlyRenderingFiber.dependencies = {</span>
          <span class="s1">expirationTime: NoWork,</span>
          <span class="s1">firstContext: contextItem,</span>
          <span class="s1">responders: </span><span class="s3">null</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Append a new context item.</span>
        <span class="s1">lastContextDependency = lastContextDependency.next = contextItem;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return  </span><span class="s1">context._currentValue ;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">UpdateState = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ReplaceState = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ForceUpdate = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">CaptureUpdate = </span><span class="s4">3</span><span class="s1">; </span><span class="s0">// Global state that is reset at the beginning of calling `processUpdateQueue`.</span>
  <span class="s0">// It should only be read right after calling `processUpdateQueue`, via</span>
  <span class="s0">// `checkHasForceUpdateAfterProcessing`.</span>

  <span class="s3">var </span><span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnUpdateInsideUpdate;</span>
  <span class="s3">var </span><span class="s1">currentlyProcessingQueue;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">currentlyProcessingQueue = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">initializeUpdateQueue(fiber) {</span>
    <span class="s3">var </span><span class="s1">queue = {</span>
      <span class="s1">baseState: fiber.memoizedState,</span>
      <span class="s1">baseQueue: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">shared: {</span>
        <span class="s1">pending: </span><span class="s3">null</span>
      <span class="s1">},</span>
      <span class="s1">effects: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s1">fiber.updateQueue = queue;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">cloneUpdateQueue(current, workInProgress) {</span>
    <span class="s0">// Clone the update queue from current. Unless it's already a clone.</span>
    <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
    <span class="s3">var </span><span class="s1">currentQueue = current.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(queue === currentQueue) {</span>
      <span class="s3">var </span><span class="s1">clone = {</span>
        <span class="s1">baseState: currentQueue.baseState,</span>
        <span class="s1">baseQueue: currentQueue.baseQueue,</span>
        <span class="s1">shared: currentQueue.shared,</span>
        <span class="s1">effects: currentQueue.effects</span>
      <span class="s1">};</span>
      <span class="s1">workInProgress.updateQueue = clone;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createUpdate(expirationTime, suspenseConfig) {</span>
    <span class="s3">var </span><span class="s1">update = {</span>
      <span class="s1">expirationTime: expirationTime,</span>
      <span class="s1">suspenseConfig: suspenseConfig,</span>
      <span class="s1">tag: UpdateState,</span>
      <span class="s1">payload: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">callback: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s1">update.next = update;</span>

    <span class="s1">{</span>
      <span class="s1">update.priority = getCurrentPriorityLevel();</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">update;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">enqueueUpdate(fiber, update) {</span>
    <span class="s3">var </span><span class="s1">updateQueue = fiber.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(updateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Only occurs if the fiber has been unmounted.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">sharedQueue = updateQueue.shared;</span>
    <span class="s3">var </span><span class="s1">pending = sharedQueue.pending;</span>

    <span class="s3">if </span><span class="s1">(pending === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">update.next = pending.next;</span>
      <span class="s1">pending.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">sharedQueue.pending = update;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(currentlyProcessingQueue === sharedQueue &amp;&amp; !didWarnUpdateInsideUpdate) {</span>
        <span class="s1">error(</span><span class="s2">'An update (setState, replaceState, or forceUpdate) was scheduled ' </span><span class="s1">+ </span><span class="s2">'from inside an update function. Update functions should be pure, ' </span><span class="s1">+ </span><span class="s2">'with zero side-effects. Consider using componentDidUpdate or a ' </span><span class="s1">+ </span><span class="s2">'callback.'</span><span class="s1">);</span>

        <span class="s1">didWarnUpdateInsideUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">enqueueCapturedUpdate(workInProgress, update) {</span>
    <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Ensure the work-in-progress queue is a clone</span>
      <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s1">} </span><span class="s0">// Captured updates go only on the work-in-progress queue.</span>


    <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue; </span><span class="s0">// Append the update to the end of the list.</span>

    <span class="s3">var </span><span class="s1">last = queue.baseQueue;</span>

    <span class="s3">if </span><span class="s1">(last === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">queue.baseQueue = update.next = update;</span>
      <span class="s1">update.next = update;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">update.next = last.next;</span>
      <span class="s1">last.next = update;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {</span>
    <span class="s3">switch </span><span class="s1">(update.tag) {</span>
      <span class="s3">case </span><span class="s1">ReplaceState:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">payload = update.payload;</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">payload === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">// Updater function</span>
            <span class="s1">{</span>
              <span class="s1">enterDisallowedContextReadInDEV();</span>

              <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
                <span class="s1">payload.call(instance, prevState, nextProps);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">nextState = payload.call(instance, prevState, nextProps);</span>

            <span class="s1">{</span>
              <span class="s1">exitDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">nextState;</span>
          <span class="s1">} </span><span class="s0">// State object</span>


          <span class="s3">return </span><span class="s1">payload;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">CaptureUpdate:</span>
        <span class="s1">{</span>
          <span class="s1">workInProgress.effectTag = workInProgress.effectTag &amp; ~ShouldCapture | DidCapture;</span>
        <span class="s1">}</span>
      <span class="s0">// Intentional fallthrough</span>

      <span class="s3">case </span><span class="s1">UpdateState:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_payload = update.payload;</span>
          <span class="s3">var </span><span class="s1">partialState;</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_payload === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">// Updater function</span>
            <span class="s1">{</span>
              <span class="s1">enterDisallowedContextReadInDEV();</span>

              <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
                <span class="s1">_payload.call(instance, prevState, nextProps);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">partialState = _payload.call(instance, prevState, nextProps);</span>

            <span class="s1">{</span>
              <span class="s1">exitDisallowedContextReadInDEV();</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Partial state object</span>
            <span class="s1">partialState = _payload;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(partialState === </span><span class="s3">null </span><span class="s1">|| partialState === undefined) {</span>
            <span class="s0">// Null and undefined are treated as no-ops.</span>
            <span class="s3">return </span><span class="s1">prevState;</span>
          <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>


          <span class="s3">return </span><span class="s1">_assign({}, prevState, partialState);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ForceUpdate:</span>
        <span class="s1">{</span>
          <span class="s1">hasForceUpdate = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s1">prevState;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">prevState;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">processUpdateQueue(workInProgress, props, instance, renderExpirationTime) {</span>
    <span class="s0">// This is always non-null on a ClassComponent or HostRoot</span>
    <span class="s3">var </span><span class="s1">queue = workInProgress.updateQueue;</span>
    <span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">currentlyProcessingQueue = queue.shared;</span>
    <span class="s1">} </span><span class="s0">// The last rebase update that is NOT part of the base state.</span>


    <span class="s3">var </span><span class="s1">baseQueue = queue.baseQueue; </span><span class="s0">// The last pending update that hasn't been processed yet.</span>

    <span class="s3">var </span><span class="s1">pendingQueue = queue.shared.pending;</span>

    <span class="s3">if </span><span class="s1">(pendingQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We have new updates that haven't been processed yet.</span>
      <span class="s0">// We'll add them to the base queue.</span>
      <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Merge the pending queue and the base queue.</span>
        <span class="s3">var </span><span class="s1">baseFirst = baseQueue.next;</span>
        <span class="s3">var </span><span class="s1">pendingFirst = pendingQueue.next;</span>
        <span class="s1">baseQueue.next = pendingFirst;</span>
        <span class="s1">pendingQueue.next = baseFirst;</span>
      <span class="s1">}</span>

      <span class="s1">baseQueue = pendingQueue;</span>
      <span class="s1">queue.shared.pending = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// TODO: Pass `current` as argument</span>

      <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">currentQueue = current.updateQueue;</span>

        <span class="s3">if </span><span class="s1">(currentQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">currentQueue.baseQueue = pendingQueue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// These values may change as we process the queue.</span>


    <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">first = baseQueue.next; </span><span class="s0">// Iterate through the list of updates to compute the result.</span>

      <span class="s3">var </span><span class="s1">newState = queue.baseState;</span>
      <span class="s3">var </span><span class="s1">newExpirationTime = NoWork;</span>
      <span class="s3">var </span><span class="s1">newBaseState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newBaseQueueFirst = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newBaseQueueLast = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(first !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">update = first;</span>

        <span class="s3">do </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">updateExpirationTime = update.expirationTime;</span>

          <span class="s3">if </span><span class="s1">(updateExpirationTime &lt; renderExpirationTime) {</span>
            <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
            <span class="s0">// skipped update, the previous update/state is the new base</span>
            <span class="s0">// update/state.</span>
            <span class="s3">var </span><span class="s1">clone = {</span>
              <span class="s1">expirationTime: update.expirationTime,</span>
              <span class="s1">suspenseConfig: update.suspenseConfig,</span>
              <span class="s1">tag: update.tag,</span>
              <span class="s1">payload: update.payload,</span>
              <span class="s1">callback: update.callback,</span>
              <span class="s1">next: </span><span class="s3">null</span>
            <span class="s1">};</span>

            <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">newBaseQueueFirst = newBaseQueueLast = clone;</span>
              <span class="s1">newBaseState = newState;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">newBaseQueueLast = newBaseQueueLast.next = clone;</span>
            <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>


            <span class="s3">if </span><span class="s1">(updateExpirationTime &gt; newExpirationTime) {</span>
              <span class="s1">newExpirationTime = updateExpirationTime;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// This update does have sufficient priority.</span>
            <span class="s3">if </span><span class="s1">(newBaseQueueLast !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">_clone = {</span>
                <span class="s1">expirationTime: Sync,</span>
                <span class="s0">// This update is going to be committed so we never want uncommit it.</span>
                <span class="s1">suspenseConfig: update.suspenseConfig,</span>
                <span class="s1">tag: update.tag,</span>
                <span class="s1">payload: update.payload,</span>
                <span class="s1">callback: update.callback,</span>
                <span class="s1">next: </span><span class="s3">null</span>
              <span class="s1">};</span>
              <span class="s1">newBaseQueueLast = newBaseQueueLast.next = _clone;</span>
            <span class="s1">} </span><span class="s0">// Mark the event time of this update as relevant to this render pass.</span>
            <span class="s0">// TODO: This should ideally use the true event time of this update rather than</span>
            <span class="s0">// its priority which is a derived and not reverseable value.</span>
            <span class="s0">// TODO: We should skip this update if it was already committed but currently</span>
            <span class="s0">// we have no way of detecting the difference between a committed and suspended</span>
            <span class="s0">// update here.</span>


            <span class="s1">markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); </span><span class="s0">// Process this update.</span>

            <span class="s1">newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);</span>
            <span class="s3">var </span><span class="s1">callback = update.callback;</span>

            <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">workInProgress.effectTag |= Callback;</span>
              <span class="s3">var </span><span class="s1">effects = queue.effects;</span>

              <span class="s3">if </span><span class="s1">(effects === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">queue.effects = [update];</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">effects.push(update);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">update = update.next;</span>

          <span class="s3">if </span><span class="s1">(update === </span><span class="s3">null </span><span class="s1">|| update === first) {</span>
            <span class="s1">pendingQueue = queue.shared.pending;</span>

            <span class="s3">if </span><span class="s1">(pendingQueue === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s0">// An update was scheduled from inside a reducer. Add the new</span>
              <span class="s0">// pending updates to the end of the list and keep processing.</span>
              <span class="s1">update = baseQueue.next = pendingQueue.next;</span>
              <span class="s1">pendingQueue.next = first;</span>
              <span class="s1">queue.baseQueue = baseQueue = pendingQueue;</span>
              <span class="s1">queue.shared.pending = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newBaseState = newState;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">newBaseQueueLast.next = newBaseQueueFirst;</span>
      <span class="s1">}</span>

      <span class="s1">queue.baseState = newBaseState;</span>
      <span class="s1">queue.baseQueue = newBaseQueueLast; </span><span class="s0">// Set the remaining expiration time to be whatever is remaining in the queue.</span>
      <span class="s0">// This should be fine because the only two other things that contribute to</span>
      <span class="s0">// expiration time are props and context. We're already in the middle of the</span>
      <span class="s0">// begin phase by the time we start processing the queue, so we've already</span>
      <span class="s0">// dealt with the props. Context in components that specify</span>
      <span class="s0">// shouldComponentUpdate is tricky; but we'll have to account for</span>
      <span class="s0">// that regardless.</span>

      <span class="s1">markUnprocessedUpdateTime(newExpirationTime);</span>
      <span class="s1">workInProgress.expirationTime = newExpirationTime;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">currentlyProcessingQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">callCallback(callback, context) {</span>
    <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Invalid argument passed as callback. Expected a function. Instead received: &quot; </span><span class="s1">+ callback );</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">callback.call(context);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resetHasForceUpdateBeforeProcessing() {</span>
    <span class="s1">hasForceUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">checkHasForceUpdateAfterProcessing() {</span>
    <span class="s3">return </span><span class="s1">hasForceUpdate;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">commitUpdateQueue(finishedWork, finishedQueue, instance) {</span>
    <span class="s0">// Commit the effects</span>
    <span class="s3">var </span><span class="s1">effects = finishedQueue.effects;</span>
    <span class="s1">finishedQueue.effects = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(effects !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; effects.length; i++) {</span>
        <span class="s3">var </span><span class="s1">effect = effects[i];</span>
        <span class="s3">var </span><span class="s1">callback = effect.callback;</span>

        <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">effect.callback = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">callCallback(callback, instance);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;</span>
  <span class="s3">function </span><span class="s1">requestCurrentSuspenseConfig() {</span>
    <span class="s3">return </span><span class="s1">ReactCurrentBatchConfig.suspense;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">fakeInternalInstance = {};</span>
  <span class="s3">var </span><span class="s1">isArray = Array.isArray; </span><span class="s0">// React.Component uses a shared frozen object by default.</span>
  <span class="s0">// We'll use it to determine whether we need to initialize legacy refs.</span>

  <span class="s3">var </span><span class="s1">emptyRefsObject = </span><span class="s3">new </span><span class="s1">React.Component().refs;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutStateAssignmentForComponent;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutUninitializedState;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutUndefinedDerivedState;</span>
  <span class="s3">var </span><span class="s1">warnOnUndefinedDerivedState;</span>
  <span class="s3">var </span><span class="s1">warnOnInvalidCallback;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutDirectlyAssigningPropsToState;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutContextTypeAndContextTypes;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutInvalidateContextType;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutStateAssignmentForComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutUninitializedState = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutDirectlyAssigningPropsToState = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutUndefinedDerivedState = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutContextTypeAndContextTypes = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">didWarnAboutInvalidateContextType = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s3">var </span><span class="s1">didWarnOnInvalidCallback = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s1">warnOnInvalidCallback = </span><span class="s3">function </span><span class="s1">(callback, callerName) {</span>
      <span class="s3">if </span><span class="s1">(callback === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">key = callerName + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ callback;</span>

      <span class="s3">if </span><span class="s1">(!didWarnOnInvalidCallback.has(key)) {</span>
        <span class="s1">didWarnOnInvalidCallback.add(key);</span>

        <span class="s1">error(</span><span class="s2">'%s(...): Expected the last optional `callback` argument to be a ' </span><span class="s1">+ </span><span class="s2">'function. Instead received: %s.'</span><span class="s1">, callerName, callback);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnOnUndefinedDerivedState = </span><span class="s3">function </span><span class="s1">(type, partialState) {</span>
      <span class="s3">if </span><span class="s1">(partialState === undefined) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(type) || </span><span class="s2">'Component'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutUndefinedDerivedState.has(componentName)) {</span>
          <span class="s1">didWarnAboutUndefinedDerivedState.add(componentName);</span>

          <span class="s1">error(</span><span class="s2">'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' </span><span class="s1">+ </span><span class="s2">'You have returned undefined.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// This is so gross but it's at least non-critical and can be removed if</span>
    <span class="s0">// it causes problems. This is meant to give a nicer error message for</span>
    <span class="s0">// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,</span>
    <span class="s0">// ...)) which otherwise throws a &quot;_processChildContext is not a function&quot;</span>
    <span class="s0">// exception.</span>


    <span class="s1">Object.defineProperty(fakeInternalInstance, </span><span class="s2">'_processChildContext'</span><span class="s1">, {</span>
      <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">value: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">Object.freeze(fakeInternalInstance);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {</span>
    <span class="s3">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
        <span class="s0">// Invoke the function an extra time to help detect side-effects.</span>
        <span class="s1">getDerivedStateFromProps(nextProps, prevState);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">partialState = getDerivedStateFromProps(nextProps, prevState);</span>

    <span class="s1">{</span>
      <span class="s1">warnOnUndefinedDerivedState(ctor, partialState);</span>
    <span class="s1">} </span><span class="s0">// Merge the partial state and the previous state.</span>


    <span class="s3">var </span><span class="s1">memoizedState = partialState === </span><span class="s3">null </span><span class="s1">|| partialState === undefined ? prevState : _assign({}, prevState, partialState);</span>
    <span class="s1">workInProgress.memoizedState = memoizedState; </span><span class="s0">// Once the update queue is empty, persist the derived state onto the</span>
    <span class="s0">// base state.</span>

    <span class="s3">if </span><span class="s1">(workInProgress.expirationTime === NoWork) {</span>
      <span class="s0">// Queue is always non-null for classes</span>
      <span class="s3">var </span><span class="s1">updateQueue = workInProgress.updateQueue;</span>
      <span class="s1">updateQueue.baseState = memoizedState;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">classComponentUpdater = {</span>
    <span class="s1">isMounted: isMounted,</span>
    <span class="s1">enqueueSetState: </span><span class="s3">function </span><span class="s1">(inst, payload, callback) {</span>
      <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
      <span class="s3">var </span><span class="s1">suspenseConfig = requestCurrentSuspenseConfig();</span>
      <span class="s3">var </span><span class="s1">expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);</span>
      <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, suspenseConfig);</span>
      <span class="s1">update.payload = payload;</span>

      <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">'setState'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s1">enqueueUpdate(fiber, update);</span>
      <span class="s1">scheduleWork(fiber, expirationTime);</span>
    <span class="s1">},</span>
    <span class="s1">enqueueReplaceState: </span><span class="s3">function </span><span class="s1">(inst, payload, callback) {</span>
      <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
      <span class="s3">var </span><span class="s1">suspenseConfig = requestCurrentSuspenseConfig();</span>
      <span class="s3">var </span><span class="s1">expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);</span>
      <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, suspenseConfig);</span>
      <span class="s1">update.tag = ReplaceState;</span>
      <span class="s1">update.payload = payload;</span>

      <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">'replaceState'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s1">enqueueUpdate(fiber, update);</span>
      <span class="s1">scheduleWork(fiber, expirationTime);</span>
    <span class="s1">},</span>
    <span class="s1">enqueueForceUpdate: </span><span class="s3">function </span><span class="s1">(inst, callback) {</span>
      <span class="s3">var </span><span class="s1">fiber = get(inst);</span>
      <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
      <span class="s3">var </span><span class="s1">suspenseConfig = requestCurrentSuspenseConfig();</span>
      <span class="s3">var </span><span class="s1">expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);</span>
      <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, suspenseConfig);</span>
      <span class="s1">update.tag = ForceUpdate;</span>

      <span class="s3">if </span><span class="s1">(callback !== undefined &amp;&amp; callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">warnOnInvalidCallback(callback, </span><span class="s2">'forceUpdate'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">update.callback = callback;</span>
      <span class="s1">}</span>

      <span class="s1">enqueueUpdate(fiber, update);</span>
      <span class="s1">scheduleWork(fiber, expirationTime);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.shouldComponentUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
          <span class="s0">// Invoke the function an extra time to help detect side-effects.</span>
          <span class="s1">instance.shouldComponentUpdate(newProps, newState, nextContext);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">startPhaseTimer(workInProgress, </span><span class="s2">'shouldComponentUpdate'</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);</span>
      <span class="s1">stopPhaseTimer();</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(shouldUpdate === undefined) {</span>
          <span class="s1">error(</span><span class="s2">'%s.shouldComponentUpdate(): Returned undefined instead of a ' </span><span class="s1">+ </span><span class="s2">'boolean value. Make sure to return true or false.'</span><span class="s1">, getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">shouldUpdate;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {</span>
      <span class="s3">return </span><span class="s1">!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">checkClassInstance(workInProgress, ctor, newProps) {</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">name = getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">renderPresent = instance.render;</span>

      <span class="s3">if </span><span class="s1">(!renderPresent) {</span>
        <span class="s3">if </span><span class="s1">(ctor.prototype &amp;&amp; </span><span class="s3">typeof </span><span class="s1">ctor.prototype.render === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'%s(...): No `render` method found on the returned component ' </span><span class="s1">+ </span><span class="s2">'instance: did you accidentally return an object from the constructor?'</span><span class="s1">, name);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s2">'%s(...): No `render` method found on the returned component ' </span><span class="s1">+ </span><span class="s2">'instance: you may have forgotten to define `render`.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(instance.getInitialState &amp;&amp; !instance.getInitialState.isReactClassApproved &amp;&amp; !instance.state) {</span>
        <span class="s1">error(</span><span class="s2">'getInitialState was defined on %s, a plain JavaScript class. ' </span><span class="s1">+ </span><span class="s2">'This is only supported for classes created using React.createClass. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to define a state property instead?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(instance.getDefaultProps &amp;&amp; !instance.getDefaultProps.isReactClassApproved) {</span>
        <span class="s1">error(</span><span class="s2">'getDefaultProps was defined on %s, a plain JavaScript class. ' </span><span class="s1">+ </span><span class="s2">'This is only supported for classes created using React.createClass. ' </span><span class="s1">+ </span><span class="s2">'Use a static property to define defaultProps instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(instance.propTypes) {</span>
        <span class="s1">error(</span><span class="s2">'propTypes was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s2">'property to define propTypes instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(instance.contextType) {</span>
        <span class="s1">error(</span><span class="s2">'contextType was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s2">'property to define contextType instead.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(instance.contextTypes) {</span>
          <span class="s1">error(</span><span class="s2">'contextTypes was defined as an instance property on %s. Use a static ' </span><span class="s1">+ </span><span class="s2">'property to define contextTypes instead.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(ctor.contextType &amp;&amp; ctor.contextTypes &amp;&amp; !didWarnAboutContextTypeAndContextTypes.has(ctor)) {</span>
          <span class="s1">didWarnAboutContextTypeAndContextTypes.add(ctor);</span>

          <span class="s1">error(</span><span class="s2">'%s declares both contextTypes and contextType static properties. ' </span><span class="s1">+ </span><span class="s2">'The legacy contextTypes property will be ignored.'</span><span class="s1">, name);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentShouldUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called ' </span><span class="s1">+ </span><span class="s2">'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' </span><span class="s1">+ </span><span class="s2">'The name is phrased as a question because the function is ' </span><span class="s1">+ </span><span class="s2">'expected to return a value.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent &amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.shouldComponentUpdate !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called shouldComponentUpdate(). ' </span><span class="s1">+ </span><span class="s2">'shouldComponentUpdate should not be used when extending React.PureComponent. ' </span><span class="s1">+ </span><span class="s2">'Please extend React.Component if shouldComponentUpdate is used.'</span><span class="s1">, getComponentName(ctor) || </span><span class="s2">'A pure component'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUnmount === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called ' </span><span class="s1">+ </span><span class="s2">'componentDidUnmount(). But there is no such lifecycle method. ' </span><span class="s1">+ </span><span class="s2">'Did you mean componentWillUnmount()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidReceiveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called ' </span><span class="s1">+ </span><span class="s2">'componentDidReceiveProps(). But there is no such lifecycle method. ' </span><span class="s1">+ </span><span class="s2">'If you meant to update the state in response to changing props, ' </span><span class="s1">+ </span><span class="s2">'use componentWillReceiveProps(). If you meant to fetch data or ' </span><span class="s1">+ </span><span class="s2">'run side-effects or mutations after React has updated the UI, use componentDidUpdate().'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillRecieveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called ' </span><span class="s1">+ </span><span class="s2">'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillRecieveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s has a method called ' </span><span class="s1">+ </span><span class="s2">'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">hasMutatedProps = instance.props !== newProps;</span>

      <span class="s3">if </span><span class="s1">(instance.props !== undefined &amp;&amp; hasMutatedProps) {</span>
        <span class="s1">error(</span><span class="s2">'%s(...): When calling super() in `%s`, make sure to pass ' </span><span class="s1">+ </span><span class="s2">&quot;up the same props that your component's constructor was passed.&quot;</span><span class="s1">, name, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(instance.defaultProps) {</span>
        <span class="s1">error(</span><span class="s2">'Setting defaultProps as an instance property on %s is not supported and will be ignored.' </span><span class="s1">+ </span><span class="s2">' Instead, define defaultProps as a static property on %s.'</span><span class="s1">, name, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate !== </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {</span>
        <span class="s1">didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);</span>

        <span class="s1">error(</span><span class="s2">'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' </span><span class="s1">+ </span><span class="s2">'This component defines getSnapshotBeforeUpdate() only.'</span><span class="s1">, getComponentName(ctor));</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s: getDerivedStateFromProps() is defined as an instance method ' </span><span class="s1">+ </span><span class="s2">'and will be ignored. Instead, declare it as a static method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getDerivedStateFromError === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s: getDerivedStateFromError() is defined as an instance method ' </span><span class="s1">+ </span><span class="s2">'and will be ignored. Instead, declare it as a static method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s: getSnapshotBeforeUpdate() is defined as a static method ' </span><span class="s1">+ </span><span class="s2">'and will be ignored. Instead, declare it as an instance method.'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">_state = instance.state;</span>

      <span class="s3">if </span><span class="s1">(_state &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">_state !== </span><span class="s2">'object' </span><span class="s1">|| isArray(_state))) {</span>
        <span class="s1">error(</span><span class="s2">'%s.state: must be set to an object or null'</span><span class="s1">, name);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getChildContext === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">ctor.childContextTypes !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s.getChildContext(): childContextTypes must be defined in order to ' </span><span class="s1">+ </span><span class="s2">'use getChildContext().'</span><span class="s1">, name);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">adoptClassInstance(workInProgress, instance) {</span>
    <span class="s1">instance.updater = classComponentUpdater;</span>
    <span class="s1">workInProgress.stateNode = instance; </span><span class="s0">// The instance needs access to the fiber so that it can schedule updates</span>

    <span class="s1">set(instance, workInProgress);</span>

    <span class="s1">{</span>
      <span class="s1">instance._reactInternalInstance = fakeInternalInstance;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">constructClassInstance(workInProgress, ctor, props) {</span>
    <span class="s3">var </span><span class="s1">isLegacyContextConsumer = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">unmaskedContext = emptyContextObject;</span>
    <span class="s3">var </span><span class="s1">context = emptyContextObject;</span>
    <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'contextType' </span><span class="s3">in </span><span class="s1">ctor) {</span>
        <span class="s3">var </span><span class="s1">isValid = </span><span class="s0">// Allow null for conditional declaration</span>
        <span class="s1">contextType === </span><span class="s3">null </span><span class="s1">|| contextType !== undefined &amp;&amp; contextType.$$typeof === REACT_CONTEXT_TYPE &amp;&amp; contextType._context === undefined; </span><span class="s0">// Not a &lt;Context.Consumer&gt;</span>

        <span class="s3">if </span><span class="s1">(!isValid &amp;&amp; !didWarnAboutInvalidateContextType.has(ctor)) {</span>
          <span class="s1">didWarnAboutInvalidateContextType.add(ctor);</span>
          <span class="s3">var </span><span class="s1">addendum = </span><span class="s2">''</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(contextType === undefined) {</span>
            <span class="s1">addendum = </span><span class="s2">' However, it is set to undefined. ' </span><span class="s1">+ </span><span class="s2">'This can be caused by a typo or by mixing up named and default imports. ' </span><span class="s1">+ </span><span class="s2">'This can also happen due to a circular dependency, so ' </span><span class="s1">+ </span><span class="s2">'try moving the createContext() call to a separate file.'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType !== </span><span class="s2">'object'</span><span class="s1">) {</span>
            <span class="s1">addendum = </span><span class="s2">' However, it is set to a ' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">contextType + </span><span class="s2">'.'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(contextType.$$typeof === REACT_PROVIDER_TYPE) {</span>
            <span class="s1">addendum = </span><span class="s2">' Did you accidentally pass the Context.Provider instead?'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(contextType._context !== undefined) {</span>
            <span class="s0">// &lt;Context.Consumer&gt;</span>
            <span class="s1">addendum = </span><span class="s2">' Did you accidentally pass the Context.Consumer instead?'</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">addendum = </span><span class="s2">' However, it is set to an object with keys {' </span><span class="s1">+ Object.keys(contextType).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">'}.'</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">error(</span><span class="s2">'%s defines an invalid contextType. ' </span><span class="s1">+ </span><span class="s2">'contextType should point to the Context object returned by React.createContext().%s'</span><span class="s1">, getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">, addendum);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">context = readContext(contextType);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">contextTypes = ctor.contextTypes;</span>
      <span class="s1">isLegacyContextConsumer = contextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; contextTypes !== undefined;</span>
      <span class="s1">context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;</span>
    <span class="s1">} </span><span class="s0">// Instantiate twice to help detect side-effects.</span>


    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
        <span class="s3">new </span><span class="s1">ctor(props, context); </span><span class="s0">// eslint-disable-line no-new</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">instance = </span><span class="s3">new </span><span class="s1">ctor(props, context);</span>
    <span class="s3">var </span><span class="s1">state = workInProgress.memoizedState = instance.state !== </span><span class="s3">null </span><span class="s1">&amp;&amp; instance.state !== undefined ? instance.state : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">adoptClassInstance(workInProgress, instance);</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; state === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutUninitializedState.has(componentName)) {</span>
          <span class="s1">didWarnAboutUninitializedState.add(componentName);</span>

          <span class="s1">error(</span><span class="s2">'`%s` uses `getDerivedStateFromProps` but its initial state is ' </span><span class="s1">+ </span><span class="s2">'%s. This is not recommended. Instead, define the initial state by ' </span><span class="s1">+ </span><span class="s2">'assigning an object to `this.state` in the constructor of `%s`. ' </span><span class="s1">+ </span><span class="s2">'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.'</span><span class="s1">, componentName, instance.state === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s2">'undefined'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// If new component APIs are defined, &quot;unsafe&quot; lifecycles won't be called.</span>
      <span class="s0">// Warn about these lifecycles if they are present.</span>
      <span class="s0">// Don't warn about react-lifecycles-compat polyfilled methods though.</span>


      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">foundWillMountName = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">foundWillReceivePropsName = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">foundWillUpdateName = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; instance.componentWillMount.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">foundWillMountName = </span><span class="s2">'componentWillMount'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillMountName = </span><span class="s2">'UNSAFE_componentWillMount'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; instance.componentWillReceiveProps.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">foundWillReceivePropsName = </span><span class="s2">'componentWillReceiveProps'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillReceivePropsName = </span><span class="s2">'UNSAFE_componentWillReceiveProps'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; instance.componentWillUpdate.__suppressDeprecationWarning !== </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">foundWillUpdateName = </span><span class="s2">'componentWillUpdate'</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">foundWillUpdateName = </span><span class="s2">'UNSAFE_componentWillUpdate'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(foundWillMountName !== </span><span class="s3">null </span><span class="s1">|| foundWillReceivePropsName !== </span><span class="s3">null </span><span class="s1">|| foundWillUpdateName !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">_componentName = getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">;</span>

          <span class="s3">var </span><span class="s1">newApiName = </span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps === </span><span class="s2">'function' </span><span class="s1">? </span><span class="s2">'getDerivedStateFromProps()' </span><span class="s1">: </span><span class="s2">'getSnapshotBeforeUpdate()'</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {</span>
            <span class="s1">didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);</span>

            <span class="s1">error(</span><span class="s2">'Unsafe legacy lifecycles will not be called for components using new component APIs.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'%s uses %s but also contains the following legacy lifecycles:%s%s%s</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'The above lifecycles should be removed. Learn more about this warning here:</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-unsafe-component-lifecycles'</span><span class="s1">, _componentName, newApiName, foundWillMountName !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillMountName : </span><span class="s2">''</span><span class="s1">, foundWillReceivePropsName !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillReceivePropsName : </span><span class="s2">''</span><span class="s1">, foundWillUpdateName !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;</span><span class="s5">\n  </span><span class="s2">&quot; </span><span class="s1">+ foundWillUpdateName : </span><span class="s2">''</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span>
    <span class="s0">// ReactFiberContext usually updates this cache but can't for newly-created instances.</span>


    <span class="s3">if </span><span class="s1">(isLegacyContextConsumer) {</span>
      <span class="s1">cacheContext(workInProgress, unmaskedContext, context);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">instance;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">callComponentWillMount(workInProgress, instance) {</span>
    <span class="s1">startPhaseTimer(workInProgress, </span><span class="s2">'componentWillMount'</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">oldState = instance.state;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.componentWillMount();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.UNSAFE_componentWillMount();</span>
    <span class="s1">}</span>

    <span class="s1">stopPhaseTimer();</span>

    <span class="s3">if </span><span class="s1">(oldState !== instance.state) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'%s.componentWillMount(): Assigning directly to this.state is ' </span><span class="s1">+ </span><span class="s2">&quot;deprecated (except inside a component's &quot; </span><span class="s1">+ </span><span class="s2">'constructor). Use setState instead.'</span><span class="s1">, getComponentName(workInProgress.type) || </span><span class="s2">'Component'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {</span>
    <span class="s3">var </span><span class="s1">oldState = instance.state;</span>
    <span class="s1">startPhaseTimer(workInProgress, </span><span class="s2">'componentWillReceiveProps'</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.componentWillReceiveProps(newProps, nextContext);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);</span>
    <span class="s1">}</span>

    <span class="s1">stopPhaseTimer();</span>

    <span class="s3">if </span><span class="s1">(instance.state !== oldState) {</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(workInProgress.type) || </span><span class="s2">'Component'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutStateAssignmentForComponent.has(componentName)) {</span>
          <span class="s1">didWarnAboutStateAssignmentForComponent.add(componentName);</span>

          <span class="s1">error(</span><span class="s2">'%s.componentWillReceiveProps(): Assigning directly to ' </span><span class="s1">+ </span><span class="s2">&quot;this.state is deprecated (except inside a component's &quot; </span><span class="s1">+ </span><span class="s2">'constructor). Use setState instead.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">classComponentUpdater.enqueueReplaceState(instance, instance.state, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Invokes the mount life-cycles on a previously never rendered instance.</span>


  <span class="s3">function </span><span class="s1">mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {</span>
    <span class="s1">{</span>
      <span class="s1">checkClassInstance(workInProgress, ctor, newProps);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">instance.refs = emptyRefsObject;</span>
    <span class="s1">initializeUpdateQueue(workInProgress);</span>
    <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">instance.context = readContext(contextType);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">instance.context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(instance.state === newProps) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(ctor) || </span><span class="s2">'Component'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {</span>
          <span class="s1">didWarnAboutDirectlyAssigningPropsToState.add(componentName);</span>

          <span class="s1">error(</span><span class="s2">'%s: It is not recommended to assign props directly to state ' </span><span class="s1">+ </span><span class="s2">&quot;because updates to props won't be reflected in state. &quot; </span><span class="s1">+ </span><span class="s2">'In most cases, it is better to use props directly.'</span><span class="s1">, componentName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; StrictMode) {</span>
        <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s1">ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);</span>
    <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">} </span><span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>


    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromProps !== </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate !== </span><span class="s2">'function' </span><span class="s1">&amp;&amp; (</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s1">callComponentWillMount(workInProgress, instance); </span><span class="s0">// If we had additional state updates during this life-cycle, let's</span>
      <span class="s0">// process them now.</span>

      <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);</span>
      <span class="s1">instance.state = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">workInProgress.effectTag |= Update;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s3">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s1">instance.props = oldProps;</span>
    <span class="s3">var </span><span class="s1">oldContext = instance.context;</span>
    <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>
    <span class="s3">var </span><span class="s1">nextContext = emptyContextObject;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nextContext = readContext(contextType);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
    <span class="s3">var </span><span class="s1">hasNewLifecycles = </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
    <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
    <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

    <span class="s3">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s3">if </span><span class="s1">(oldProps !== newProps || oldContext !== nextContext) {</span>
        <span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
    <span class="s3">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s3">var </span><span class="s1">newState = instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing()) {</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.effectTag |= Update;</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">newState = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);</span>

    <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
      <span class="s3">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function'</span><span class="s1">)) {</span>
        <span class="s1">startPhaseTimer(workInProgress, </span><span class="s2">'componentWillMount'</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.componentWillMount();</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.UNSAFE_componentWillMount();</span>
        <span class="s1">}</span>

        <span class="s1">stopPhaseTimer();</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.effectTag |= Update;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidMount === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.effectTag |= Update;</span>
      <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
      <span class="s0">// memoized state to indicate that this work can be reused.</span>


      <span class="s1">workInProgress.memoizedProps = newProps;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
    <span class="s0">// if shouldComponentUpdate returns false.</span>


    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = newState;</span>
    <span class="s1">instance.context = nextContext;</span>
    <span class="s3">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">} </span><span class="s0">// Invokes the update life-cycles and returns false if it shouldn't rerender.</span>


  <span class="s3">function </span><span class="s1">updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s3">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s1">instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);</span>
    <span class="s3">var </span><span class="s1">oldContext = instance.context;</span>
    <span class="s3">var </span><span class="s1">contextType = ctor.contextType;</span>
    <span class="s3">var </span><span class="s1">nextContext = emptyContextObject;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">contextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nextContext = readContext(contextType);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">getDerivedStateFromProps = ctor.getDerivedStateFromProps;</span>
    <span class="s3">var </span><span class="s1">hasNewLifecycles = </span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">; </span><span class="s0">// Note: During these life-cycles, instance.props/instance.state are what</span>
    <span class="s0">// ever the previously attempted to render - not the &quot;current&quot;. However,</span>
    <span class="s0">// during componentDidUpdate we pass the &quot;current&quot; props.</span>
    <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
    <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>

    <span class="s3">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillReceiveProps === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentWillReceiveProps === </span><span class="s2">'function'</span><span class="s1">)) {</span>
      <span class="s3">if </span><span class="s1">(oldProps !== newProps || oldContext !== nextContext) {</span>
        <span class="s1">callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">resetHasForceUpdateBeforeProcessing();</span>
    <span class="s3">var </span><span class="s1">oldState = workInProgress.memoizedState;</span>
    <span class="s3">var </span><span class="s1">newState = instance.state = oldState;</span>
    <span class="s1">processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);</span>
    <span class="s1">newState = workInProgress.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !hasContextChanged() &amp;&amp; !checkHasForceUpdateAfterProcessing()) {</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(oldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.effectTag |= Update;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(oldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.effectTag |= Snapshot;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);</span>
      <span class="s1">newState = workInProgress.memoizedState;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);</span>

    <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
      <span class="s0">// In order to support react-lifecycles-compat polyfilled components,</span>
      <span class="s0">// Unsafe lifecycles should not be invoked for components using the new APIs.</span>
      <span class="s3">if </span><span class="s1">(!hasNewLifecycles &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">'function'</span><span class="s1">)) {</span>
        <span class="s1">startPhaseTimer(workInProgress, </span><span class="s2">'componentWillUpdate'</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.componentWillUpdate(newProps, newState, nextContext);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.UNSAFE_componentWillUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);</span>
        <span class="s1">}</span>

        <span class="s1">stopPhaseTimer();</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.effectTag |= Update;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">workInProgress.effectTag |= Snapshot;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If an update was already in progress, we should schedule an Update</span>
      <span class="s0">// effect even though we're bailing out, so that cWU/cDU are called.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentDidUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(oldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.effectTag |= Update;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.getSnapshotBeforeUpdate === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(oldProps !== current.memoizedProps || oldState !== current.memoizedState) {</span>
          <span class="s1">workInProgress.effectTag |= Snapshot;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// If shouldComponentUpdate returned false, we should still update the</span>
      <span class="s0">// memoized props/state to indicate that this work can be reused.</span>


      <span class="s1">workInProgress.memoizedProps = newProps;</span>
      <span class="s1">workInProgress.memoizedState = newState;</span>
    <span class="s1">} </span><span class="s0">// Update the existing instance's state, props, and context pointers even</span>
    <span class="s0">// if shouldComponentUpdate returns false.</span>


    <span class="s1">instance.props = newProps;</span>
    <span class="s1">instance.state = newState;</span>
    <span class="s1">instance.context = nextContext;</span>
    <span class="s3">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnAboutMaps;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutGenerators;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutStringRefs;</span>
  <span class="s3">var </span><span class="s1">ownerHasKeyUseWarning;</span>
  <span class="s3">var </span><span class="s1">ownerHasFunctionTypeWarning;</span>

  <span class="s3">var </span><span class="s1">warnForMissingKey = </span><span class="s3">function </span><span class="s1">(child) {};</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutMaps = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutGenerators = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutStringRefs = {};</span>
    <span class="s0">/** 
     * Warn if there's no key explicitly set on dynamic arrays of children or 
     * object keys are not valid. This allows us to keep track of children between 
     * updates. 
     */</span>

    <span class="s1">ownerHasKeyUseWarning = {};</span>
    <span class="s1">ownerHasFunctionTypeWarning = {};</span>

    <span class="s1">warnForMissingKey = </span><span class="s3">function </span><span class="s1">(child) {</span>
      <span class="s3">if </span><span class="s1">(child === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">child !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!child._store || child._store.validated || child.key != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">child._store === </span><span class="s2">'object'</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">child._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">currentComponentErrorInfo = </span><span class="s2">'Each child in a list should have a unique ' </span><span class="s1">+ </span><span class="s2">'&quot;key&quot; prop. See https://fb.me/react-warning-keys for ' </span><span class="s1">+ </span><span class="s2">'more information.' </span><span class="s1">+ getCurrentFiberStackInDev();</span>

      <span class="s3">if </span><span class="s1">(ownerHasKeyUseWarning[currentComponentErrorInfo]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ownerHasKeyUseWarning[currentComponentErrorInfo] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Each child in a list should have a unique ' </span><span class="s1">+ </span><span class="s2">'&quot;key&quot; prop. See https://fb.me/react-warning-keys for ' </span><span class="s1">+ </span><span class="s2">'more information.'</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">isArray$1 = Array.isArray;</span>

  <span class="s3">function </span><span class="s1">coerceRef(returnFiber, current, element) {</span>
    <span class="s3">var </span><span class="s1">mixedRef = element.ref;</span>

    <span class="s3">if </span><span class="s1">(mixedRef !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">mixedRef !== </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">mixedRef !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s0">// TODO: Clean this up once we turn on the string ref warning for</span>
        <span class="s0">// everyone, because the strict mode case will no longer be relevant</span>
        <span class="s3">if </span><span class="s1">((returnFiber.mode &amp; StrictMode || warnAboutStringRefs) &amp;&amp; </span><span class="s0">// We warn in ReactElement.js if owner and self are equal for string refs</span>
        <span class="s0">// because these cannot be automatically converted to an arrow function</span>
        <span class="s0">// using a codemod. Therefore, we don't have to warn about string refs again.</span>
        <span class="s1">!(element._owner &amp;&amp; element._self &amp;&amp; element._owner.stateNode !== element._self)) {</span>
          <span class="s3">var </span><span class="s1">componentName = getComponentName(returnFiber.type) || </span><span class="s2">'Component'</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
            <span class="s1">{</span>
              <span class="s1">error(</span><span class="s2">'A string ref, &quot;%s&quot;, has been found within a strict mode tree. ' </span><span class="s1">+ </span><span class="s2">'String refs are a source of potential bugs and should be avoided. ' </span><span class="s1">+ </span><span class="s2">'We recommend using useRef() or createRef() instead. ' </span><span class="s1">+ </span><span class="s2">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-strict-mode-string-ref%s'</span><span class="s1">, mixedRef, getStackByFiberInDevAndProd(returnFiber));</span>
            <span class="s1">}</span>

            <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(element._owner) {</span>
        <span class="s3">var </span><span class="s1">owner = element._owner;</span>
        <span class="s3">var </span><span class="s1">inst;</span>

        <span class="s3">if </span><span class="s1">(owner) {</span>
          <span class="s3">var </span><span class="s1">ownerFiber = owner;</span>

          <span class="s3">if </span><span class="s1">(!(ownerFiber.tag === ClassComponent)) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">inst = ownerFiber.stateNode;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!inst) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Missing owner for string ref &quot; </span><span class="s1">+ mixedRef + </span><span class="s2">&quot;. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">stringRef = </span><span class="s2">'' </span><span class="s1">+ mixedRef; </span><span class="s0">// Check if previous string ref matches new string ref</span>

        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.ref !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">current.ref === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; current.ref._stringRef === stringRef) {</span>
          <span class="s3">return </span><span class="s1">current.ref;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">ref = </span><span class="s3">function </span><span class="s1">(value) {</span>
          <span class="s3">var </span><span class="s1">refs = inst.refs;</span>

          <span class="s3">if </span><span class="s1">(refs === emptyRefsObject) {</span>
            <span class="s0">// This is a lazy pooled frozen object, so we need to initialize.</span>
            <span class="s1">refs = inst.refs = {};</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(value === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">delete </span><span class="s1">refs[stringRef];</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">refs[stringRef] = value;</span>
          <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s1">ref._stringRef = stringRef;</span>
        <span class="s3">return </span><span class="s1">ref;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">mixedRef === </span><span class="s2">'string'</span><span class="s1">)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected ref to be a function, a string, an object returned by React.createRef(), or null.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!element._owner) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Element ref was specified as a string (&quot; </span><span class="s1">+ mixedRef + </span><span class="s2">&quot;) but no owner was set. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s2">1. You may be adding a ref to a function component</span><span class="s5">\n</span><span class="s2">2. You may be adding a ref to a component that was not created inside a component's render method</span><span class="s5">\n</span><span class="s2">3. You have multiple copies of React loaded</span><span class="s5">\n</span><span class="s2">See https://fb.me/react-refs-must-have-owner for more information.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">mixedRef;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">throwOnInvalidObjectType(returnFiber, newChild) {</span>
    <span class="s3">if </span><span class="s1">(returnFiber.type !== </span><span class="s2">'textarea'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">addendum = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">addendum = </span><span class="s2">' If you meant to render a collection of children, use an array ' </span><span class="s1">+ </span><span class="s2">'instead.' </span><span class="s1">+ getCurrentFiberStackInDev();</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+ (Object.prototype.toString.call(newChild) === </span><span class="s2">'[object Object]' </span><span class="s1">? </span><span class="s2">'object with keys {' </span><span class="s1">+ Object.keys(newChild).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">'}' </span><span class="s1">: newChild) + </span><span class="s2">&quot;).&quot; </span><span class="s1">+ addendum );</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnOnFunctionType() {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">currentComponentErrorInfo = </span><span class="s2">'Functions are not valid as a React child. This may happen if ' </span><span class="s1">+ </span><span class="s2">'you return a Component instead of &lt;Component /&gt; from render. ' </span><span class="s1">+ </span><span class="s2">'Or maybe you meant to call this function rather than return it.' </span><span class="s1">+ getCurrentFiberStackInDev();</span>

      <span class="s3">if </span><span class="s1">(ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">ownerHasFunctionTypeWarning[currentComponentErrorInfo] = </span><span class="s3">true</span><span class="s1">;</span>

      <span class="s1">error(</span><span class="s2">'Functions are not valid as a React child. This may happen if ' </span><span class="s1">+ </span><span class="s2">'you return a Component instead of &lt;Component /&gt; from render. ' </span><span class="s1">+ </span><span class="s2">'Or maybe you meant to call this function rather than return it.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This wrapper function exists because I expect to clone the code in each path</span>
  <span class="s0">// to be able to optimize each path individually by branching early. This needs</span>
  <span class="s0">// a compiler or we can do it manually. Helpers that don't need this branching</span>
  <span class="s0">// live outside of this function.</span>


  <span class="s3">function </span><span class="s1">ChildReconciler(shouldTrackSideEffects) {</span>
    <span class="s3">function </span><span class="s1">deleteChild(returnFiber, childToDelete) {</span>
      <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// Noop.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Deletions are added in reversed order so we add it to the front.</span>
      <span class="s0">// At this point, the return fiber's effect list is empty except for</span>
      <span class="s0">// deletions, so we can just append the deletion to the list. The remaining</span>
      <span class="s0">// effects aren't added until the complete phase. Once we implement</span>
      <span class="s0">// resuming, this may not be true.</span>


      <span class="s3">var </span><span class="s1">last = returnFiber.lastEffect;</span>

      <span class="s3">if </span><span class="s1">(last !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">last.nextEffect = childToDelete;</span>
        <span class="s1">returnFiber.lastEffect = childToDelete;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;</span>
      <span class="s1">}</span>

      <span class="s1">childToDelete.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">childToDelete.effectTag = Deletion;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild) {</span>
      <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// Noop.</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// TODO: For the shouldClone case, this could be micro-optimized a bit by</span>
      <span class="s0">// assuming that after the first child we've already added everything.</span>


      <span class="s3">var </span><span class="s1">childToDelete = currentFirstChild;</span>

      <span class="s3">while </span><span class="s1">(childToDelete !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">deleteChild(returnFiber, childToDelete);</span>
        <span class="s1">childToDelete = childToDelete.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">mapRemainingChildren(returnFiber, currentFirstChild) {</span>
      <span class="s0">// Add the remaining children to a temporary map so that we can find them by</span>
      <span class="s0">// keys quickly. Implicit (null) keys get added to this set with their index</span>
      <span class="s0">// instead.</span>
      <span class="s3">var </span><span class="s1">existingChildren = </span><span class="s3">new </span><span class="s1">Map();</span>
      <span class="s3">var </span><span class="s1">existingChild = currentFirstChild;</span>

      <span class="s3">while </span><span class="s1">(existingChild !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(existingChild.key !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">existingChildren.set(existingChild.key, existingChild);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">existingChildren.set(existingChild.index, existingChild);</span>
        <span class="s1">}</span>

        <span class="s1">existingChild = existingChild.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">existingChildren;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">useFiber(fiber, pendingProps) {</span>
      <span class="s0">// We currently set sibling to null and index to 0 here because it is easy</span>
      <span class="s0">// to forget to do before returning it. E.g. for the single child case.</span>
      <span class="s3">var </span><span class="s1">clone = createWorkInProgress(fiber, pendingProps);</span>
      <span class="s1">clone.index = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">clone.sibling = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">clone;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">placeChild(newFiber, lastPlacedIndex, newIndex) {</span>
      <span class="s1">newFiber.index = newIndex;</span>

      <span class="s3">if </span><span class="s1">(!shouldTrackSideEffects) {</span>
        <span class="s0">// Noop.</span>
        <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">current = newFiber.alternate;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">oldIndex = current.index;</span>

        <span class="s3">if </span><span class="s1">(oldIndex &lt; lastPlacedIndex) {</span>
          <span class="s0">// This is a move.</span>
          <span class="s1">newFiber.effectTag = Placement;</span>
          <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// This item can stay in place.</span>
          <span class="s3">return </span><span class="s1">oldIndex;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// This is an insertion.</span>
        <span class="s1">newFiber.effectTag = Placement;</span>
        <span class="s3">return </span><span class="s1">lastPlacedIndex;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">placeSingleChild(newFiber) {</span>
      <span class="s0">// This is simpler for the single child case. We only need to do a</span>
      <span class="s0">// placement for inserting new children.</span>
      <span class="s3">if </span><span class="s1">(shouldTrackSideEffects &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newFiber.effectTag = Placement;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">newFiber;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updateTextNode(returnFiber, current, textContent, expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.tag !== HostText) {</span>
        <span class="s0">// Insert</span>
        <span class="s3">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, expirationTime);</span>
        <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s3">var </span><span class="s1">existing = useFiber(current, textContent);</span>
        <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updateElement(returnFiber, current, element, expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(current.elementType === element.type || ( </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
         <span class="s1">isCompatibleFamilyForHotReloading(current, element) )) {</span>
          <span class="s0">// Move based on index</span>
          <span class="s3">var </span><span class="s1">existing = useFiber(current, element.props);</span>
          <span class="s1">existing.ref = coerceRef(returnFiber, current, element);</span>
          <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

          <span class="s1">{</span>
            <span class="s1">existing._debugSource = element._source;</span>
            <span class="s1">existing._debugOwner = element._owner;</span>
          <span class="s1">}</span>

          <span class="s3">return </span><span class="s1">existing;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Insert</span>


      <span class="s3">var </span><span class="s1">created = createFiberFromElement(element, returnFiber.mode, expirationTime);</span>
      <span class="s1">created.ref = coerceRef(returnFiber, current, element);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updatePortal(returnFiber, current, portal, expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {</span>
        <span class="s0">// Insert</span>
        <span class="s3">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);</span>
        <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s3">var </span><span class="s1">existing = useFiber(current, portal.children || []);</span>
        <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updateFragment(returnFiber, current, fragment, expirationTime, key) {</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.tag !== Fragment) {</span>
        <span class="s0">// Insert</span>
        <span class="s3">var </span><span class="s1">created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);</span>
        <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Update</span>
        <span class="s3">var </span><span class="s1">existing = useFiber(current, fragment);</span>
        <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">existing;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">createChild(returnFiber, newChild, expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
        <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
        <span class="s0">// node.</span>
        <span class="s3">var </span><span class="s1">created = createFiberFromText(</span><span class="s2">'' </span><span class="s1">+ newChild, returnFiber.mode, expirationTime);</span>
        <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">created;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">_created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);</span>

              <span class="s1">_created.ref = coerceRef(returnFiber, </span><span class="s3">null</span><span class="s1">, newChild);</span>
              <span class="s1">_created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
              <span class="s3">return </span><span class="s1">_created;</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">_created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);</span>

              <span class="s1">_created2.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
              <span class="s3">return </span><span class="s1">_created2;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(isArray$1(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s3">var </span><span class="s1">_created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s1">_created3.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
          <span class="s3">return </span><span class="s1">_created3;</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updateSlot(returnFiber, oldFiber, newChild, expirationTime) {</span>
      <span class="s0">// Update the fiber if the keys match, otherwise return null.</span>
      <span class="s3">var </span><span class="s1">key = oldFiber !== </span><span class="s3">null </span><span class="s1">? oldFiber.key : </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys. If the previous node is implicitly keyed</span>
        <span class="s0">// we can continue to replace it without aborting even if it is not a text</span>
        <span class="s0">// node.</span>
        <span class="s3">if </span><span class="s1">(key !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">updateTextNode(returnFiber, oldFiber, </span><span class="s2">'' </span><span class="s1">+ newChild, expirationTime);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(newChild.key === key) {</span>
                <span class="s3">if </span><span class="s1">(newChild.type === REACT_FRAGMENT_TYPE) {</span>
                  <span class="s3">return </span><span class="s1">updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);</span>
                <span class="s1">}</span>

                <span class="s3">return </span><span class="s1">updateElement(returnFiber, oldFiber, newChild, expirationTime);</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(newChild.key === key) {</span>
                <span class="s3">return </span><span class="s1">updatePortal(returnFiber, oldFiber, newChild, expirationTime);</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(isArray$1(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s3">if </span><span class="s1">(key !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">return </span><span class="s1">updateFragment(returnFiber, oldFiber, newChild, expirationTime, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s0">// Text nodes don't have keys, so we neither have to check the old nor</span>
        <span class="s0">// new node for the key. If both are text nodes, they match.</span>
        <span class="s3">var </span><span class="s1">matchedFiber = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">updateTextNode(returnFiber, matchedFiber, </span><span class="s2">'' </span><span class="s1">+ newChild, expirationTime);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">_matchedFiber = existingChildren.get(newChild.key === </span><span class="s3">null </span><span class="s1">? newIdx : newChild.key) || </span><span class="s3">null</span><span class="s1">;</span>

              <span class="s3">if </span><span class="s1">(newChild.type === REACT_FRAGMENT_TYPE) {</span>
                <span class="s3">return </span><span class="s1">updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);</span>
              <span class="s1">}</span>

              <span class="s3">return </span><span class="s1">updateElement(returnFiber, _matchedFiber, newChild, expirationTime);</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">_matchedFiber2 = existingChildren.get(newChild.key === </span><span class="s3">null </span><span class="s1">? newIdx : newChild.key) || </span><span class="s3">null</span><span class="s1">;</span>

              <span class="s3">return </span><span class="s1">updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(isArray$1(newChild) || getIteratorFn(newChild)) {</span>
          <span class="s3">var </span><span class="s1">_matchedFiber3 = existingChildren.get(newIdx) || </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">return </span><span class="s1">updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * Warns if there is a duplicate or missing key 
     */</span>


    <span class="s3">function </span><span class="s1">warnOnInvalidKey(child, knownKeys) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">child !== </span><span class="s2">'object' </span><span class="s1">|| child === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return </span><span class="s1">knownKeys;</span>
        <span class="s1">}</span>

        <span class="s3">switch </span><span class="s1">(child.$$typeof) {</span>
          <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
          <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s1">warnForMissingKey(child);</span>
            <span class="s3">var </span><span class="s1">key = child.key;</span>

            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">key !== </span><span class="s2">'string'</span><span class="s1">) {</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(knownKeys === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">knownKeys = </span><span class="s3">new </span><span class="s1">Set();</span>
              <span class="s1">knownKeys.add(key);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(!knownKeys.has(key)) {</span>
              <span class="s1">knownKeys.add(key);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">error(</span><span class="s2">'Encountered two children with the same key, `%s`. ' </span><span class="s1">+ </span><span class="s2">'Keys should be unique so that components maintain their identity ' </span><span class="s1">+ </span><span class="s2">'across updates. Non-unique keys may cause children to be ' </span><span class="s1">+ </span><span class="s2">'duplicated and/or omitted — the behavior is unsupported and ' </span><span class="s1">+ </span><span class="s2">'could change in a future version.'</span><span class="s1">, key);</span>

            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">knownKeys;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {</span>
      <span class="s0">// This algorithm can't optimize by searching from both ends since we</span>
      <span class="s0">// don't have backpointers on fibers. I'm trying to see how far we can get</span>
      <span class="s0">// with that model. If it ends up not being worth the tradeoffs, we can</span>
      <span class="s0">// add it later.</span>
      <span class="s0">// Even with a two ended optimization, we'd want to optimize for the case</span>
      <span class="s0">// where there are few changes and brute force the comparison instead of</span>
      <span class="s0">// going for the Map. It'd like to explore hitting that path first in</span>
      <span class="s0">// forward-only mode and only go for the Map once we notice that we need</span>
      <span class="s0">// lots of look ahead. This doesn't handle reversal as well as two ended</span>
      <span class="s0">// search but that's unusual. Besides, for the two ended optimization to</span>
      <span class="s0">// work on Iterables, we'd need to copy the whole set.</span>
      <span class="s0">// In this first iteration, we'll just live with hitting the bad case</span>
      <span class="s0">// (adding everything to a Map) in for every insert/move.</span>
      <span class="s0">// If you change this code, also update reconcileChildrenIterator() which</span>
      <span class="s0">// uses the same algorithm.</span>
      <span class="s1">{</span>
        <span class="s0">// First, validate keys.</span>
        <span class="s3">var </span><span class="s1">knownKeys = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; newChildren.length; i++) {</span>
          <span class="s3">var </span><span class="s1">child = newChildren[i];</span>
          <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">resultingFirstChild = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">previousNewFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">oldFiber = currentFirstChild;</span>
      <span class="s3">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s1">(; oldFiber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; newIdx &lt; newChildren.length; newIdx++) {</span>
        <span class="s3">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
          <span class="s1">nextOldFiber = oldFiber;</span>
          <span class="s1">oldFiber = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">nextOldFiber = oldFiber.sibling;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);</span>

        <span class="s3">if </span><span class="s1">(newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
          <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
          <span class="s0">// a better way to communicate whether this was a miss or null,</span>
          <span class="s0">// boolean, undefined, etc.</span>
          <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">oldFiber = nextOldFiber;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s3">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
            <span class="s0">// need to delete the existing child.</span>
            <span class="s1">deleteChild(returnFiber, oldFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = newFiber;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
          <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
          <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
          <span class="s0">// with the previous one.</span>
          <span class="s1">previousNewFiber.sibling = newFiber;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = newFiber;</span>
        <span class="s1">oldFiber = nextOldFiber;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(newIdx === newChildren.length) {</span>
        <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>
        <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
        <span class="s0">// since the rest will all be insertions.</span>
        <span class="s3">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
          <span class="s3">var </span><span class="s1">_newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);</span>

          <span class="s3">if </span><span class="s1">(_newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);</span>

          <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
            <span class="s1">resultingFirstChild = _newFiber;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>


      <span class="s3">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="s3">for </span><span class="s1">(; newIdx &lt; newChildren.length; newIdx++) {</span>
        <span class="s3">var </span><span class="s1">_newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);</span>

        <span class="s3">if </span><span class="s1">(_newFiber2 !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
            <span class="s3">if </span><span class="s1">(_newFiber2.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
              <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
              <span class="s0">// it from the child list so that we don't add it to the deletion</span>
              <span class="s0">// list.</span>
              <span class="s1">existingChildren.</span><span class="s3">delete</span><span class="s1">(_newFiber2.key === </span><span class="s3">null </span><span class="s1">? newIdx : _newFiber2.key);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);</span>

          <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">resultingFirstChild = _newFiber2;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber2;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber2;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
        <span class="s0">// to add them to the deletion list.</span>
        <span class="s1">existingChildren.forEach(</span><span class="s3">function </span><span class="s1">(child) {</span>
          <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {</span>
      <span class="s0">// This is the same implementation as reconcileChildrenArray(),</span>
      <span class="s0">// but using the iterator instead.</span>
      <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(newChildrenIterable);</span>

      <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// We don't support rendering Generators because it's a mutation.</span>
        <span class="s0">// See https://github.com/facebook/react/issues/12995</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; </span><span class="s0">// $FlowFixMe Flow doesn't know about toStringTag</span>
        <span class="s1">newChildrenIterable[Symbol.toStringTag] === </span><span class="s2">'Generator'</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(!didWarnAboutGenerators) {</span>
            <span class="s1">error(</span><span class="s2">'Using Generators as children is unsupported and will likely yield ' </span><span class="s1">+ </span><span class="s2">'unexpected results because enumerating a generator mutates it. ' </span><span class="s1">+ </span><span class="s2">'You may convert it to an array with `Array.from()` or the ' </span><span class="s1">+ </span><span class="s2">'`[...spread]` operator before rendering. Keep in mind ' </span><span class="s1">+ </span><span class="s2">'you might need to polyfill these features for older browsers.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">didWarnAboutGenerators = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Warn about using Maps as children</span>


        <span class="s3">if </span><span class="s1">(newChildrenIterable.entries === iteratorFn) {</span>
          <span class="s3">if </span><span class="s1">(!didWarnAboutMaps) {</span>
            <span class="s1">error(</span><span class="s2">'Using Maps as children is unsupported and will likely yield ' </span><span class="s1">+ </span><span class="s2">'unexpected results. Convert it to a sequence/iterable of keyed ' </span><span class="s1">+ </span><span class="s2">'ReactElements instead.'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">didWarnAboutMaps = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// First, validate keys.</span>
        <span class="s0">// We'll get a different iterator later for the main pass.</span>


        <span class="s3">var </span><span class="s1">_newChildren = iteratorFn.call(newChildrenIterable);</span>

        <span class="s3">if </span><span class="s1">(_newChildren) {</span>
          <span class="s3">var </span><span class="s1">knownKeys = </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">var </span><span class="s1">_step = _newChildren.next();</span>

          <span class="s3">for </span><span class="s1">(; !_step.done; _step = _newChildren.next()) {</span>
            <span class="s3">var </span><span class="s1">child = _step.value;</span>
            <span class="s1">knownKeys = warnOnInvalidKey(child, knownKeys);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">newChildren = iteratorFn.call(newChildrenIterable);</span>

      <span class="s3">if </span><span class="s1">(!(newChildren != </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;An iterable object provided no iterator.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">resultingFirstChild = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">previousNewFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">oldFiber = currentFirstChild;</span>
      <span class="s3">var </span><span class="s1">lastPlacedIndex = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newIdx = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">nextOldFiber = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">step = newChildren.next();</span>

      <span class="s3">for </span><span class="s1">(; oldFiber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !step.done; newIdx++, step = newChildren.next()) {</span>
        <span class="s3">if </span><span class="s1">(oldFiber.index &gt; newIdx) {</span>
          <span class="s1">nextOldFiber = oldFiber;</span>
          <span class="s1">oldFiber = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">nextOldFiber = oldFiber.sibling;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);</span>

        <span class="s3">if </span><span class="s1">(newFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: This breaks on empty slots like null children. That's</span>
          <span class="s0">// unfortunate because it triggers the slow path all the time. We need</span>
          <span class="s0">// a better way to communicate whether this was a miss or null,</span>
          <span class="s0">// boolean, undefined, etc.</span>
          <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">oldFiber = nextOldFiber;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
          <span class="s3">if </span><span class="s1">(oldFiber &amp;&amp; newFiber.alternate === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We matched the slot, but we didn't reuse the existing fiber, so we</span>
            <span class="s0">// need to delete the existing child.</span>
            <span class="s1">deleteChild(returnFiber, oldFiber);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span>

        <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
          <span class="s1">resultingFirstChild = newFiber;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// TODO: Defer siblings if we're not at the right index for this slot.</span>
          <span class="s0">// I.e. if we had null values before, then we want to defer this</span>
          <span class="s0">// for each null value. However, we also don't want to call updateSlot</span>
          <span class="s0">// with the previous one.</span>
          <span class="s1">previousNewFiber.sibling = newFiber;</span>
        <span class="s1">}</span>

        <span class="s1">previousNewFiber = newFiber;</span>
        <span class="s1">oldFiber = nextOldFiber;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(step.done) {</span>
        <span class="s0">// We've reached the end of the new children. We can delete the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, oldFiber);</span>
        <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(oldFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If we don't have any more existing children we can choose a fast path</span>
        <span class="s0">// since the rest will all be insertions.</span>
        <span class="s3">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
          <span class="s3">var </span><span class="s1">_newFiber3 = createChild(returnFiber, step.value, expirationTime);</span>

          <span class="s3">if </span><span class="s1">(_newFiber3 === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);</span>

          <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// TODO: Move out of the loop. This only happens for the first run.</span>
            <span class="s1">resultingFirstChild = _newFiber3;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber3;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber3;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
      <span class="s1">} </span><span class="s0">// Add all children to a key map for quick lookups.</span>


      <span class="s3">var </span><span class="s1">existingChildren = mapRemainingChildren(returnFiber, oldFiber); </span><span class="s0">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="s3">for </span><span class="s1">(; !step.done; newIdx++, step = newChildren.next()) {</span>
        <span class="s3">var </span><span class="s1">_newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);</span>

        <span class="s3">if </span><span class="s1">(_newFiber4 !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
            <span class="s3">if </span><span class="s1">(_newFiber4.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// The new fiber is a work in progress, but if there exists a</span>
              <span class="s0">// current, that means that we reused the fiber. We need to delete</span>
              <span class="s0">// it from the child list so that we don't add it to the deletion</span>
              <span class="s0">// list.</span>
              <span class="s1">existingChildren.</span><span class="s3">delete</span><span class="s1">(_newFiber4.key === </span><span class="s3">null </span><span class="s1">? newIdx : _newFiber4.key);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);</span>

          <span class="s3">if </span><span class="s1">(previousNewFiber === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">resultingFirstChild = _newFiber4;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">previousNewFiber.sibling = _newFiber4;</span>
          <span class="s1">}</span>

          <span class="s1">previousNewFiber = _newFiber4;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(shouldTrackSideEffects) {</span>
        <span class="s0">// Any existing children that weren't consumed above were deleted. We need</span>
        <span class="s0">// to add them to the deletion list.</span>
        <span class="s1">existingChildren.forEach(</span><span class="s3">function </span><span class="s1">(child) {</span>
          <span class="s3">return </span><span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">resultingFirstChild;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {</span>
      <span class="s0">// There's no need to check for keys on text nodes since we don't have a</span>
      <span class="s0">// way to define them.</span>
      <span class="s3">if </span><span class="s1">(currentFirstChild !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentFirstChild.tag === HostText) {</span>
        <span class="s0">// We already have an existing node so let's just update it and delete</span>
        <span class="s0">// the rest.</span>
        <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span>
        <span class="s3">var </span><span class="s1">existing = useFiber(currentFirstChild, textContent);</span>
        <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">existing;</span>
      <span class="s1">} </span><span class="s0">// The existing first child is not a text node so we need to create one</span>
      <span class="s0">// and delete the existing ones.</span>


      <span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
      <span class="s3">var </span><span class="s1">created = createFiberFromText(textContent, returnFiber.mode, expirationTime);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {</span>
      <span class="s3">var </span><span class="s1">key = element.key;</span>
      <span class="s3">var </span><span class="s1">child = currentFirstChild;</span>

      <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
        <span class="s0">// the first item in the list.</span>
        <span class="s3">if </span><span class="s1">(child.key === key) {</span>
          <span class="s3">switch </span><span class="s1">(child.tag) {</span>
            <span class="s3">case </span><span class="s1">Fragment:</span>
              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(element.type === REACT_FRAGMENT_TYPE) {</span>
                  <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
                  <span class="s3">var </span><span class="s1">existing = useFiber(child, element.props.children);</span>
                  <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

                  <span class="s1">{</span>
                    <span class="s1">existing._debugSource = element._source;</span>
                    <span class="s1">existing._debugOwner = element._owner;</span>
                  <span class="s1">}</span>

                  <span class="s3">return </span><span class="s1">existing;</span>
                <span class="s1">}</span>

                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">case </span><span class="s1">Block:</span>

            <span class="s0">// We intentionally fallthrough here if enableBlocksAPI is not on.</span>
            <span class="s0">// eslint-disable-next-lined no-fallthrough</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(child.elementType === element.type || ( </span><span class="s0">// Keep this check inline so it only runs on the false path:</span>
                 <span class="s1">isCompatibleFamilyForHotReloading(child, element) )) {</span>
                  <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>

                  <span class="s3">var </span><span class="s1">_existing3 = useFiber(child, element.props);</span>

                  <span class="s1">_existing3.ref = coerceRef(returnFiber, child, element);</span>
                  <span class="s1">_existing3.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>

                  <span class="s1">{</span>
                    <span class="s1">_existing3._debugSource = element._source;</span>
                    <span class="s1">_existing3._debugOwner = element._owner;</span>
                  <span class="s1">}</span>

                  <span class="s3">return </span><span class="s1">_existing3;</span>
                <span class="s1">}</span>

                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Didn't match.</span>


          <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">}</span>

        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(element.type === REACT_FRAGMENT_TYPE) {</span>
        <span class="s3">var </span><span class="s1">created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);</span>
        <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">created;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);</span>

        <span class="s1">_created4.ref = coerceRef(returnFiber, currentFirstChild, element);</span>
        <span class="s1">_created4.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
        <span class="s3">return </span><span class="s1">_created4;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {</span>
      <span class="s3">var </span><span class="s1">key = portal.key;</span>
      <span class="s3">var </span><span class="s1">child = currentFirstChild;</span>

      <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// TODO: If key === null and child.key === null, then this only applies to</span>
        <span class="s0">// the first item in the list.</span>
        <span class="s3">if </span><span class="s1">(child.key === key) {</span>
          <span class="s3">if </span><span class="s1">(child.tag === HostPortal &amp;&amp; child.stateNode.containerInfo === portal.containerInfo &amp;&amp; child.stateNode.implementation === portal.implementation) {</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child.sibling);</span>
            <span class="s3">var </span><span class="s1">existing = useFiber(child, portal.children || []);</span>
            <span class="s1">existing.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
            <span class="s3">return </span><span class="s1">existing;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">deleteRemainingChildren(returnFiber, child);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">deleteChild(returnFiber, child);</span>
        <span class="s1">}</span>

        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);</span>
      <span class="s1">created.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
      <span class="s3">return </span><span class="s1">created;</span>
    <span class="s1">} </span><span class="s0">// This API will tag the children with the side-effect of the reconciliation</span>
    <span class="s0">// itself. They will be added to the side-effect list as we pass through the</span>
    <span class="s0">// children and the parent.</span>


    <span class="s3">function </span><span class="s1">reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {</span>
      <span class="s0">// This function is not recursive.</span>
      <span class="s0">// If the top level item is an array, we treat it as a set of children,</span>
      <span class="s0">// not as a fragment. Nested arrays on the other hand will be treated as</span>
      <span class="s0">// fragment nodes. Recursion happens at the normal flow.</span>
      <span class="s0">// Handle top level unkeyed fragments as if they were arrays.</span>
      <span class="s0">// This leads to an ambiguity between &lt;&gt;{[...]}&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span>
      <span class="s0">// We treat the ambiguous cases above the same.</span>
      <span class="s3">var </span><span class="s1">isUnkeyedTopLevelFragment = </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null </span><span class="s1">&amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(isUnkeyedTopLevelFragment) {</span>
        <span class="s1">newChild = newChild.props.children;</span>
      <span class="s1">} </span><span class="s0">// Handle object types</span>


      <span class="s3">var </span><span class="s1">isObject = </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; newChild !== </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(isObject) {</span>
        <span class="s3">switch </span><span class="s1">(newChild.$$typeof) {</span>
          <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s3">return </span><span class="s1">placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));</span>

          <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
            <span class="s3">return </span><span class="s1">placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, </span><span class="s2">'' </span><span class="s1">+ newChild, expirationTime));</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isArray$1(newChild)) {</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(getIteratorFn(newChild)) {</span>
        <span class="s3">return </span><span class="s1">reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isObject) {</span>
        <span class="s1">throwOnInvalidObjectType(returnFiber, newChild);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">warnOnFunctionType();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newChild === </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; !isUnkeyedTopLevelFragment) {</span>
        <span class="s0">// If the new child is undefined, and the return fiber is a composite</span>
        <span class="s0">// component, throw an error. If Fiber return types are disabled,</span>
        <span class="s0">// we already threw above.</span>
        <span class="s3">switch </span><span class="s1">(returnFiber.tag) {</span>
          <span class="s3">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s1">{</span>
                <span class="s3">var </span><span class="s1">instance = returnFiber.stateNode;</span>

                <span class="s3">if </span><span class="s1">(instance.render._isMockFunction) {</span>
                  <span class="s0">// We allow auto-mocks to proceed as if they're returning null.</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s0">// Intentionally fall through to the next case, which handles both</span>
          <span class="s0">// functions and classes</span>
          <span class="s0">// eslint-disable-next-lined no-fallthrough</span>

          <span class="s3">case </span><span class="s1">FunctionComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">Component = returnFiber.type;</span>

              <span class="s1">{</span>
                <span class="s1">{</span>
                  <span class="s3">throw </span><span class="s1">Error( (Component.displayName || Component.name || </span><span class="s2">'Component'</span><span class="s1">) + </span><span class="s2">&quot;(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.&quot; </span><span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Remaining cases are all treated as empty.</span>


      <span class="s3">return </span><span class="s1">deleteRemainingChildren(returnFiber, currentFirstChild);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">reconcileChildFibers;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">reconcileChildFibers = ChildReconciler(</span><span class="s3">true</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">mountChildFibers = ChildReconciler(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s3">function </span><span class="s1">cloneChildFibers(current, workInProgress) {</span>
    <span class="s3">if </span><span class="s1">(!(current === </span><span class="s3">null </span><span class="s1">|| workInProgress.child === current.child)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Resuming work not yet implemented.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress.child === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">currentChild = workInProgress.child;</span>
    <span class="s3">var </span><span class="s1">newChild = createWorkInProgress(currentChild, currentChild.pendingProps);</span>
    <span class="s1">workInProgress.child = newChild;</span>
    <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>

    <span class="s3">while </span><span class="s1">(currentChild.sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">currentChild = currentChild.sibling;</span>
      <span class="s1">newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);</span>
      <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">}</span>

    <span class="s1">newChild.sibling = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Reset a workInProgress child set to prepare it for a second pass.</span>

  <span class="s3">function </span><span class="s1">resetChildFibers(workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">child = workInProgress.child;</span>

    <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">resetWorkInProgress(child, renderExpirationTime);</span>
      <span class="s1">child = child.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">NO_CONTEXT = {};</span>
  <span class="s3">var </span><span class="s1">contextStackCursor$1 = createCursor(NO_CONTEXT);</span>
  <span class="s3">var </span><span class="s1">contextFiberStackCursor = createCursor(NO_CONTEXT);</span>
  <span class="s3">var </span><span class="s1">rootInstanceStackCursor = createCursor(NO_CONTEXT);</span>

  <span class="s3">function </span><span class="s1">requiredContext(c) {</span>
    <span class="s3">if </span><span class="s1">(!(c !== NO_CONTEXT)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">c;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getRootHostContainer() {</span>
    <span class="s3">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
    <span class="s3">return </span><span class="s1">rootInstance;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushHostContainer(fiber, nextRootInstance) {</span>
    <span class="s0">// Push current root instance onto the stack;</span>
    <span class="s0">// This allows us to reset root when portals are popped.</span>
    <span class="s1">push(rootInstanceStackCursor, nextRootInstance, fiber); </span><span class="s0">// Track the context and the Fiber that provided it.</span>
    <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>

    <span class="s1">push(contextFiberStackCursor, fiber, fiber); </span><span class="s0">// Finally, we need to push the host context to the stack.</span>
    <span class="s0">// However, we can't just call getRootHostContext() and push it because</span>
    <span class="s0">// we'd have a different number of entries on the stack depending on</span>
    <span class="s0">// whether getRootHostContext() throws somewhere in renderer code or not.</span>
    <span class="s0">// So we push an empty value first. This lets us safely unwind on errors.</span>

    <span class="s1">push(contextStackCursor$1, NO_CONTEXT, fiber);</span>
    <span class="s3">var </span><span class="s1">nextRootContext = getRootHostContext(nextRootInstance); </span><span class="s0">// Now that we know this function doesn't throw, replace it.</span>

    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">push(contextStackCursor$1, nextRootContext, fiber);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popHostContainer(fiber) {</span>
    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">pop(contextFiberStackCursor, fiber);</span>
    <span class="s1">pop(rootInstanceStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getHostContext() {</span>
    <span class="s3">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
    <span class="s3">return </span><span class="s1">context;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushHostContext(fiber) {</span>
    <span class="s3">var </span><span class="s1">rootInstance = requiredContext(rootInstanceStackCursor.current);</span>
    <span class="s3">var </span><span class="s1">context = requiredContext(contextStackCursor$1.current);</span>
    <span class="s3">var </span><span class="s1">nextContext = getChildHostContext(context, fiber.type); </span><span class="s0">// Don't push this Fiber's context unless it's unique.</span>

    <span class="s3">if </span><span class="s1">(context === nextContext) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Track the context and the Fiber that provided it.</span>
    <span class="s0">// This enables us to pop only Fibers that provide unique contexts.</span>


    <span class="s1">push(contextFiberStackCursor, fiber, fiber);</span>
    <span class="s1">push(contextStackCursor$1, nextContext, fiber);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popHostContext(fiber) {</span>
    <span class="s0">// Do not pop unless this Fiber provided the current context.</span>
    <span class="s0">// pushHostContext() only pushes Fibers that provide unique contexts.</span>
    <span class="s3">if </span><span class="s1">(contextFiberStackCursor.current !== fiber) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">pop(contextStackCursor$1, fiber);</span>
    <span class="s1">pop(contextFiberStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">DefaultSuspenseContext = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// The Suspense Context is split into two parts. The lower bits is</span>
  <span class="s0">// inherited deeply down the subtree. The upper bits only affect</span>
  <span class="s0">// this immediate suspense boundary and gets reset each new</span>
  <span class="s0">// boundary or suspense list.</span>

  <span class="s3">var </span><span class="s1">SubtreeSuspenseContextMask = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Subtree Flags:</span>
  <span class="s0">// InvisibleParentSuspenseContext indicates that one of our parent Suspense</span>
  <span class="s0">// boundaries is not currently showing visible main content.</span>
  <span class="s0">// Either because it is already showing a fallback or is not mounted at all.</span>
  <span class="s0">// We can use this to determine if it is desirable to trigger a fallback at</span>
  <span class="s0">// the parent. If not, then we might need to trigger undesirable boundaries</span>
  <span class="s0">// and/or suspend the commit to avoid hiding the parent content.</span>

  <span class="s3">var </span><span class="s1">InvisibleParentSuspenseContext = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Shallow Flags:</span>
  <span class="s0">// ForceSuspenseFallback can be used by SuspenseList to force newly added</span>
  <span class="s0">// items into their fallback state during one of the render passes.</span>

  <span class="s3">var </span><span class="s1">ForceSuspenseFallback = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">suspenseStackCursor = createCursor(DefaultSuspenseContext);</span>
  <span class="s3">function </span><span class="s1">hasSuspenseContext(parentContext, flag) {</span>
    <span class="s3">return </span><span class="s1">(parentContext &amp; flag) !== </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setDefaultShallowSuspenseContext(parentContext) {</span>
    <span class="s3">return </span><span class="s1">parentContext &amp; SubtreeSuspenseContextMask;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">setShallowSuspenseContext(parentContext, shallowContext) {</span>
    <span class="s3">return </span><span class="s1">parentContext &amp; SubtreeSuspenseContextMask | shallowContext;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">addSubtreeSuspenseContext(parentContext, subtreeContext) {</span>
    <span class="s3">return </span><span class="s1">parentContext | subtreeContext;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">pushSuspenseContext(fiber, newContext) {</span>
    <span class="s1">push(suspenseStackCursor, newContext, fiber);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">popSuspenseContext(fiber) {</span>
    <span class="s1">pop(suspenseStackCursor, fiber);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">shouldCaptureSuspense(workInProgress, hasInvisibleParent) {</span>
    <span class="s0">// If it was the primary children that just suspended, capture and render the</span>
    <span class="s0">// fallback. Otherwise, don't capture and bubble to the next boundary.</span>
    <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(nextState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(nextState.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// A dehydrated boundary always captures.</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">props = workInProgress.memoizedProps; </span><span class="s0">// In order to capture, the Suspense component must have a fallback prop.</span>

    <span class="s3">if </span><span class="s1">(props.fallback === undefined) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Regular boundaries always capture.</span>


    <span class="s3">if </span><span class="s1">(props.unstable_avoidThisFallback !== </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If it's a boundary we should avoid, then we prefer to bubble up to the</span>
    <span class="s0">// parent boundary if it is currently invisible.</span>


    <span class="s3">if </span><span class="s1">(hasInvisibleParent) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If the parent is not able to handle it, we must handle it.</span>


    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">findFirstSuspended(row) {</span>
    <span class="s3">var </span><span class="s1">node = row;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
        <span class="s3">var </span><span class="s1">state = node.memoizedState;</span>

        <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">dehydrated = state.dehydrated;</span>

          <span class="s3">if </span><span class="s1">(dehydrated === </span><span class="s3">null </span><span class="s1">|| isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {</span>
            <span class="s3">return </span><span class="s1">node;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === SuspenseListComponent &amp;&amp; </span><span class="s0">// revealOrder undefined can't be trusted because it don't</span>
      <span class="s0">// keep track of whether it suspended or not.</span>
      <span class="s1">node.memoizedProps.revealOrder !== undefined) {</span>
        <span class="s3">var </span><span class="s1">didSuspend = (node.effectTag &amp; DidCapture) !== NoEffect;</span>

        <span class="s3">if </span><span class="s1">(didSuspend) {</span>
          <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === row) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== row) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createDeprecatedResponderListener(responder, props) {</span>
    <span class="s3">var </span><span class="s1">eventResponderListener = {</span>
      <span class="s1">responder: responder,</span>
      <span class="s1">props: props</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">Object.freeze(eventResponderListener);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">eventResponderListener;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">HasEffect =</span>
  <span class="s0">/* */</span>
  <span class="s4">1</span><span class="s1">; </span><span class="s0">// Represents the phase in which the effect (not the clean-up) fires.</span>

  <span class="s3">var </span><span class="s1">Layout =</span>
  <span class="s0">/*    */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">Passive$1 =</span>
  <span class="s0">/*   */</span>
  <span class="s4">4</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,</span>
      <span class="s1">ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutMismatchedHooksForComponent;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutMismatchedHooksForComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s0">// These are set right before calling the component.</span>
  <span class="s3">var </span><span class="s1">renderExpirationTime = NoWork; </span><span class="s0">// The work-in-progress fiber. I've named it differently to distinguish it from</span>
  <span class="s0">// the work-in-progress hook.</span>

  <span class="s3">var </span><span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Hooks are stored as a linked list on the fiber's memoizedState field. The</span>
  <span class="s0">// current hook list is the list that belongs to the current fiber. The</span>
  <span class="s0">// work-in-progress hook list is a new list that will be added to the</span>
  <span class="s0">// work-in-progress fiber.</span>

  <span class="s3">var </span><span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Whether an update was scheduled at any point during the render phase. This</span>
  <span class="s0">// does not get reset if we do another render pass; only when we're completely</span>
  <span class="s0">// finished evaluating this component. This is an optimization so we know</span>
  <span class="s0">// whether we need to clear render phase updates after a throw.</span>

  <span class="s3">var </span><span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RE_RENDER_LIMIT = </span><span class="s4">25</span><span class="s1">; </span><span class="s0">// In DEV, this is the name of the currently executing primitive hook</span>

  <span class="s3">var </span><span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// In DEV, this list ensures that hooks are called in the same order between renders.</span>
  <span class="s0">// The list stores the order of hooks used during the initial render (mount).</span>
  <span class="s0">// Subsequent renders (updates) reference this list.</span>

  <span class="s3">var </span><span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// In DEV, this tracks whether currently rendering component needs to ignore</span>
  <span class="s0">// the dependencies for Hooks that need them (e.g. useEffect or useMemo).</span>
  <span class="s0">// When true, such Hooks will always be &quot;remounted&quot;. Only used during hot reload.</span>

  <span class="s3">var </span><span class="s1">ignorePreviousDependencies = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">mountHookTypesDev() {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hookName = currentHookNameInDev;</span>

      <span class="s3">if </span><span class="s1">(hookTypesDev === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">hookTypesDev = [hookName];</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">hookTypesDev.push(hookName);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateHookTypesDev() {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hookName = currentHookNameInDev;</span>

      <span class="s3">if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">hookTypesUpdateIndexDev++;</span>

        <span class="s3">if </span><span class="s1">(hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {</span>
          <span class="s1">warnOnHookMismatchInDev(hookName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">checkDepsAreArrayDev(deps) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(deps !== undefined &amp;&amp; deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !Array.isArray(deps)) {</span>
        <span class="s0">// Verify deps, but only on mount to avoid extra checks.</span>
        <span class="s0">// It's unlikely their type would change as usually you define them inline.</span>
        <span class="s1">error(</span><span class="s2">'%s received a final argument that is not an array (instead, received `%s`). When ' </span><span class="s1">+ </span><span class="s2">'specified, the final argument must be an array.'</span><span class="s1">, currentHookNameInDev, </span><span class="s3">typeof </span><span class="s1">deps);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnOnHookMismatchInDev(currentHookName) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">componentName = getComponentName(currentlyRenderingFiber$1.type);</span>

      <span class="s3">if </span><span class="s1">(!didWarnAboutMismatchedHooksForComponent.has(componentName)) {</span>
        <span class="s1">didWarnAboutMismatchedHooksForComponent.add(componentName);</span>

        <span class="s3">if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">table = </span><span class="s2">''</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">secondColumnStart = </span><span class="s4">30</span><span class="s1">;</span>

          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= hookTypesUpdateIndexDev; i++) {</span>
            <span class="s3">var </span><span class="s1">oldHookName = hookTypesDev[i];</span>
            <span class="s3">var </span><span class="s1">newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;</span>
            <span class="s3">var </span><span class="s1">row = i + </span><span class="s4">1 </span><span class="s1">+ </span><span class="s2">&quot;. &quot; </span><span class="s1">+ oldHookName; </span><span class="s0">// Extra space so second column lines up</span>
            <span class="s0">// lol @ IE not supporting String#repeat</span>

            <span class="s3">while </span><span class="s1">(row.length &lt; secondColumnStart) {</span>
              <span class="s1">row += </span><span class="s2">' '</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">row += newHookName + </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">;</span>
            <span class="s1">table += row;</span>
          <span class="s1">}</span>

          <span class="s1">error(</span><span class="s2">'React has detected a change in the order of Hooks called by %s. ' </span><span class="s1">+ </span><span class="s2">'This will lead to bugs and errors if not fixed. ' </span><span class="s1">+ </span><span class="s2">'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'   Previous render            Next render</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'   ------------------------------------------------------</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'%s' </span><span class="s1">+ </span><span class="s2">'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">, componentName, table);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">throwInvalidHookError() {</span>
    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s2">1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s2">2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s2">3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s2">See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">areHookInputsEqual(nextDeps, prevDeps) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(ignorePreviousDependencies) {</span>
        <span class="s0">// Only true when this component is being hot reloaded.</span>
        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(prevDeps === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'%s received a final argument during this render, but not during ' </span><span class="s1">+ </span><span class="s2">'the previous render. Even though the final argument is optional, ' </span><span class="s1">+ </span><span class="s2">'its type cannot change between renders.'</span><span class="s1">, currentHookNameInDev);</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Don't bother comparing lengths in prod because these arrays should be</span>
      <span class="s0">// passed inline.</span>
      <span class="s3">if </span><span class="s1">(nextDeps.length !== prevDeps.length) {</span>
        <span class="s1">error(</span><span class="s2">'The final argument passed to %s changed size between renders. The ' </span><span class="s1">+ </span><span class="s2">'order and size of this array must remain constant.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'Previous: %s</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'Incoming: %s'</span><span class="s1">, currentHookNameInDev, </span><span class="s2">&quot;[&quot; </span><span class="s1">+ prevDeps.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">, </span><span class="s2">&quot;[&quot; </span><span class="s1">+ nextDeps.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) {</span>
      <span class="s3">if </span><span class="s1">(objectIs(nextDeps[i], prevDeps[i])) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderExpirationTime) {</span>
    <span class="s1">renderExpirationTime = nextRenderExpirationTime;</span>
    <span class="s1">currentlyRenderingFiber$1 = workInProgress;</span>

    <span class="s1">{</span>
      <span class="s1">hookTypesDev = current !== </span><span class="s3">null </span><span class="s1">? current._debugHookTypes : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Used for hot reloading:</span>

      <span class="s1">ignorePreviousDependencies = current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.type !== workInProgress.type;</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.expirationTime = NoWork; </span><span class="s0">// The following should have already been reset</span>
    <span class="s0">// currentHook = null;</span>
    <span class="s0">// workInProgressHook = null;</span>
    <span class="s0">// didScheduleRenderPhaseUpdate = false;</span>
    <span class="s0">// TODO Warn if no hooks are used at all during mount, then some are used during update.</span>
    <span class="s0">// Currently we will identify the update render as a mount because memoizedState === null.</span>
    <span class="s0">// This is tricky because it's valid for certain types of components (e.g. React.lazy)</span>
    <span class="s0">// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.</span>
    <span class="s0">// Non-stateful hooks (e.g. context) don't get added to memoizedState,</span>
    <span class="s0">// so memoizedState would be null during updates and mounts.</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(hookTypesDev !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This dispatcher handles an edge case where a component is updating,</span>
        <span class="s0">// but no stateful hooks have been used.</span>
        <span class="s0">// We want to match the production code behavior (which will use HooksDispatcherOnMount),</span>
        <span class="s0">// but with the extra DEV validation to ensure hooks ordering hasn't changed.</span>
        <span class="s0">// This dispatcher does that.</span>
        <span class="s1">ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">children = Component(props, secondArg); </span><span class="s0">// Check if there was a render phase update</span>

    <span class="s3">if </span><span class="s1">(workInProgress.expirationTime === renderExpirationTime) {</span>
      <span class="s0">// Keep rendering in a loop for as long as render phase updates continue to</span>
      <span class="s0">// be scheduled. Use a counter to prevent infinite loops.</span>
      <span class="s3">var </span><span class="s1">numberOfReRenders = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">workInProgress.expirationTime = NoWork;</span>

        <span class="s3">if </span><span class="s1">(!(numberOfReRenders &lt; RE_RENDER_LIMIT)) {</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Too many re-renders. React limits the number of renders to prevent an infinite loop.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">numberOfReRenders += </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s0">// Even when hot reloading, allow dependencies to stabilize</span>
          <span class="s0">// after first render to prevent infinite render phase updates.</span>
          <span class="s1">ignorePreviousDependencies = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Start over from the beginning of the list</span>


        <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s0">// Also validate hook order for cascading updates.</span>
          <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">ReactCurrentDispatcher.current =  HooksDispatcherOnRerenderInDEV ;</span>
        <span class="s1">children = Component(props, secondArg);</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(workInProgress.expirationTime === renderExpirationTime);</span>
    <span class="s1">} </span><span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
    <span class="s0">// at the beginning of the render phase and there's no re-entrancy.</span>


    <span class="s1">ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress._debugHookTypes = hookTypesDev;</span>
    <span class="s1">} </span><span class="s0">// This check uses currentHook so that it works the same in DEV and prod bundles.</span>
    <span class="s0">// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</span>


    <span class="s3">var </span><span class="s1">didRenderTooFewHooks = currentHook !== </span><span class="s3">null </span><span class="s1">&amp;&amp; currentHook.next !== </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">renderExpirationTime = NoWork;</span>
    <span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!!didRenderTooFewHooks) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Rendered fewer hooks than expected. This may be caused by an accidental early return statement.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">children;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">bailoutHooks(current, workInProgress, expirationTime) {</span>
    <span class="s1">workInProgress.updateQueue = current.updateQueue;</span>
    <span class="s1">workInProgress.effectTag &amp;= ~(Passive | Update);</span>

    <span class="s3">if </span><span class="s1">(current.expirationTime &lt;= expirationTime) {</span>
      <span class="s1">current.expirationTime = NoWork;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resetHooksAfterThrow() {</span>
    <span class="s0">// We can assume the previous dispatcher is always this one, since we set it</span>
    <span class="s0">// at the beginning of the render phase and there's no re-entrancy.</span>
    <span class="s1">ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span>

    <span class="s3">if </span><span class="s1">(didScheduleRenderPhaseUpdate) {</span>
      <span class="s0">// There were render phase updates. These are only valid for this render</span>
      <span class="s0">// phase, which we are now aborting. Remove the updates from the queues so</span>
      <span class="s0">// they do not persist to the next render. Do not remove updates from hooks</span>
      <span class="s0">// that weren't processed.</span>
      <span class="s0">//</span>
      <span class="s0">// Only reset the updates from the queue if it has a clone. If it does</span>
      <span class="s0">// not have a clone, that means it wasn't processed, and the updates were</span>
      <span class="s0">// scheduled before we entered the render phase.</span>
      <span class="s3">var </span><span class="s1">hook = currentlyRenderingFiber$1.memoizedState;</span>

      <span class="s3">while </span><span class="s1">(hook !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

        <span class="s3">if </span><span class="s1">(queue !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">hook = hook.next;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">renderExpirationTime = NoWork;</span>
    <span class="s1">currentlyRenderingFiber$1 = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">currentHook = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressHook = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">hookTypesDev = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">hookTypesUpdateIndexDev = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">currentHookNameInDev = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountWorkInProgressHook() {</span>
    <span class="s3">var </span><span class="s1">hook = {</span>
      <span class="s1">memoizedState: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">baseState: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">baseQueue: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">queue: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first hook in the list</span>
      <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Append to the end of the list</span>
      <span class="s1">workInProgressHook = workInProgressHook.next = hook;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgressHook;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateWorkInProgressHook() {</span>
    <span class="s0">// This function is used both for updates and for re-renders triggered by a</span>
    <span class="s0">// render phase update. It assumes there is either a current hook we can</span>
    <span class="s0">// clone, or a work-in-progress hook from a previous render pass that we can</span>
    <span class="s0">// use as a base. When we reach the end of the base list, we must switch to</span>
    <span class="s0">// the dispatcher used for mounts.</span>
    <span class="s3">var </span><span class="s1">nextCurrentHook;</span>

    <span class="s3">if </span><span class="s1">(currentHook === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">current = currentlyRenderingFiber$1.alternate;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">nextCurrentHook = current.memoizedState;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nextCurrentHook = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nextCurrentHook = currentHook.next;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextWorkInProgressHook;</span>

    <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nextWorkInProgressHook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// There's already a work-in-progress. Reuse it.</span>
      <span class="s1">workInProgressHook = nextWorkInProgressHook;</span>
      <span class="s1">nextWorkInProgressHook = workInProgressHook.next;</span>
      <span class="s1">currentHook = nextCurrentHook;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Clone from the current hook.</span>
      <span class="s3">if </span><span class="s1">(!(nextCurrentHook !== </span><span class="s3">null</span><span class="s1">)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Rendered more hooks than during the previous render.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">currentHook = nextCurrentHook;</span>
      <span class="s3">var </span><span class="s1">newHook = {</span>
        <span class="s1">memoizedState: currentHook.memoizedState,</span>
        <span class="s1">baseState: currentHook.baseState,</span>
        <span class="s1">baseQueue: currentHook.baseQueue,</span>
        <span class="s1">queue: currentHook.queue,</span>
        <span class="s1">next: </span><span class="s3">null</span>
      <span class="s1">};</span>

      <span class="s3">if </span><span class="s1">(workInProgressHook === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This is the first hook in the list.</span>
        <span class="s1">currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Append to the end of the list.</span>
        <span class="s1">workInProgressHook = workInProgressHook.next = newHook;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgressHook;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createFunctionComponentUpdateQueue() {</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">lastEffect: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">basicStateReducer(state, action) {</span>
    <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
    <span class="s3">return typeof </span><span class="s1">action === </span><span class="s2">'function' </span><span class="s1">? action(state) : action;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountReducer(reducer, initialArg, init) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">initialState;</span>

    <span class="s3">if </span><span class="s1">(init !== undefined) {</span>
      <span class="s1">initialState = init(initialArg);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">initialState = initialArg;</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
    <span class="s3">var </span><span class="s1">queue = hook.queue = {</span>
      <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">lastRenderedReducer: reducer,</span>
      <span class="s1">lastRenderedState: initialState</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">dispatch = queue.dispatch = dispatchAction.bind(</span><span class="s3">null</span><span class="s1">, currentlyRenderingFiber$1, queue);</span>
    <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateReducer(reducer, initialArg, init) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

    <span class="s3">if </span><span class="s1">(!(queue !== </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastRenderedReducer = reducer;</span>
    <span class="s3">var </span><span class="s1">current = currentHook; </span><span class="s0">// The last rebase update that is NOT part of the base state.</span>

    <span class="s3">var </span><span class="s1">baseQueue = current.baseQueue; </span><span class="s0">// The last pending update that hasn't been processed yet.</span>

    <span class="s3">var </span><span class="s1">pendingQueue = queue.pending;</span>

    <span class="s3">if </span><span class="s1">(pendingQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We have new updates that haven't been processed yet.</span>
      <span class="s0">// We'll add them to the base queue.</span>
      <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Merge the pending queue and the base queue.</span>
        <span class="s3">var </span><span class="s1">baseFirst = baseQueue.next;</span>
        <span class="s3">var </span><span class="s1">pendingFirst = pendingQueue.next;</span>
        <span class="s1">baseQueue.next = pendingFirst;</span>
        <span class="s1">pendingQueue.next = baseFirst;</span>
      <span class="s1">}</span>

      <span class="s1">current.baseQueue = baseQueue = pendingQueue;</span>
      <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(baseQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We have a queue to process.</span>
      <span class="s3">var </span><span class="s1">first = baseQueue.next;</span>
      <span class="s3">var </span><span class="s1">newState = current.baseState;</span>
      <span class="s3">var </span><span class="s1">newBaseState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newBaseQueueFirst = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">newBaseQueueLast = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">update = first;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">updateExpirationTime = update.expirationTime;</span>

        <span class="s3">if </span><span class="s1">(updateExpirationTime &lt; renderExpirationTime) {</span>
          <span class="s0">// Priority is insufficient. Skip this update. If this is the first</span>
          <span class="s0">// skipped update, the previous update/state is the new base</span>
          <span class="s0">// update/state.</span>
          <span class="s3">var </span><span class="s1">clone = {</span>
            <span class="s1">expirationTime: update.expirationTime,</span>
            <span class="s1">suspenseConfig: update.suspenseConfig,</span>
            <span class="s1">action: update.action,</span>
            <span class="s1">eagerReducer: update.eagerReducer,</span>
            <span class="s1">eagerState: update.eagerState,</span>
            <span class="s1">next: </span><span class="s3">null</span>
          <span class="s1">};</span>

          <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">newBaseQueueFirst = newBaseQueueLast = clone;</span>
            <span class="s1">newBaseState = newState;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">newBaseQueueLast = newBaseQueueLast.next = clone;</span>
          <span class="s1">} </span><span class="s0">// Update the remaining priority in the queue.</span>


          <span class="s3">if </span><span class="s1">(updateExpirationTime &gt; currentlyRenderingFiber$1.expirationTime) {</span>
            <span class="s1">currentlyRenderingFiber$1.expirationTime = updateExpirationTime;</span>
            <span class="s1">markUnprocessedUpdateTime(updateExpirationTime);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// This update does have sufficient priority.</span>
          <span class="s3">if </span><span class="s1">(newBaseQueueLast !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">_clone = {</span>
              <span class="s1">expirationTime: Sync,</span>
              <span class="s0">// This update is going to be committed so we never want uncommit it.</span>
              <span class="s1">suspenseConfig: update.suspenseConfig,</span>
              <span class="s1">action: update.action,</span>
              <span class="s1">eagerReducer: update.eagerReducer,</span>
              <span class="s1">eagerState: update.eagerState,</span>
              <span class="s1">next: </span><span class="s3">null</span>
            <span class="s1">};</span>
            <span class="s1">newBaseQueueLast = newBaseQueueLast.next = _clone;</span>
          <span class="s1">} </span><span class="s0">// Mark the event time of this update as relevant to this render pass.</span>
          <span class="s0">// TODO: This should ideally use the true event time of this update rather than</span>
          <span class="s0">// its priority which is a derived and not reverseable value.</span>
          <span class="s0">// TODO: We should skip this update if it was already committed but currently</span>
          <span class="s0">// we have no way of detecting the difference between a committed and suspended</span>
          <span class="s0">// update here.</span>


          <span class="s1">markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); </span><span class="s0">// Process this update.</span>

          <span class="s3">if </span><span class="s1">(update.eagerReducer === reducer) {</span>
            <span class="s0">// If this update was processed eagerly, and its reducer matches the</span>
            <span class="s0">// current reducer, we can use the eagerly computed state.</span>
            <span class="s1">newState = update.eagerState;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">action = update.action;</span>
            <span class="s1">newState = reducer(newState, action);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">update = update.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(update !== </span><span class="s3">null </span><span class="s1">&amp;&amp; update !== first);</span>

      <span class="s3">if </span><span class="s1">(newBaseQueueLast === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">newBaseState = newState;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">newBaseQueueLast.next = newBaseQueueFirst;</span>
      <span class="s1">} </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
      <span class="s0">// different from the current state.</span>


      <span class="s3">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
        <span class="s1">markWorkInProgressReceivedUpdate();</span>
      <span class="s1">}</span>

      <span class="s1">hook.memoizedState = newState;</span>
      <span class="s1">hook.baseState = newBaseState;</span>
      <span class="s1">hook.baseQueue = newBaseQueueLast;</span>
      <span class="s1">queue.lastRenderedState = newState;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">dispatch = queue.dispatch;</span>
    <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">rerenderReducer(reducer, initialArg, init) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">queue = hook.queue;</span>

    <span class="s3">if </span><span class="s1">(!(queue !== </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">queue.lastRenderedReducer = reducer; </span><span class="s0">// This is a re-render. Apply the new render phase updates to the previous</span>
    <span class="s0">// work-in-progress hook.</span>

    <span class="s3">var </span><span class="s1">dispatch = queue.dispatch;</span>
    <span class="s3">var </span><span class="s1">lastRenderPhaseUpdate = queue.pending;</span>
    <span class="s3">var </span><span class="s1">newState = hook.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(lastRenderPhaseUpdate !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// The queue doesn't persist past this render pass.</span>
      <span class="s1">queue.pending = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;</span>
      <span class="s3">var </span><span class="s1">update = firstRenderPhaseUpdate;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s0">// Process this render phase update. We don't have to check the</span>
        <span class="s0">// priority because it will always be the same as the current</span>
        <span class="s0">// render's.</span>
        <span class="s3">var </span><span class="s1">action = update.action;</span>
        <span class="s1">newState = reducer(newState, action);</span>
        <span class="s1">update = update.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(update !== firstRenderPhaseUpdate); </span><span class="s0">// Mark that the fiber performed work, but only if the new state is</span>
      <span class="s0">// different from the current state.</span>


      <span class="s3">if </span><span class="s1">(!objectIs(newState, hook.memoizedState)) {</span>
        <span class="s1">markWorkInProgressReceivedUpdate();</span>
      <span class="s1">}</span>

      <span class="s1">hook.memoizedState = newState; </span><span class="s0">// Don't persist the state accumulated from the render phase updates to</span>
      <span class="s0">// the base state unless the queue is empty.</span>
      <span class="s0">// TODO: Not sure if this is the desired semantics, but it's what we</span>
      <span class="s0">// do for gDSFP. I can't remember why.</span>

      <span class="s3">if </span><span class="s1">(hook.baseQueue === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">hook.baseState = newState;</span>
      <span class="s1">}</span>

      <span class="s1">queue.lastRenderedState = newState;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">[newState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountState(initialState) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">initialState === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s0">// $FlowFixMe: Flow doesn't like mixed types</span>
      <span class="s1">initialState = initialState();</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = hook.baseState = initialState;</span>
    <span class="s3">var </span><span class="s1">queue = hook.queue = {</span>
      <span class="s1">pending: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">dispatch: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">lastRenderedReducer: basicStateReducer,</span>
      <span class="s1">lastRenderedState: initialState</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">dispatch = queue.dispatch = dispatchAction.bind(</span><span class="s3">null</span><span class="s1">, currentlyRenderingFiber$1, queue);</span>
    <span class="s3">return </span><span class="s1">[hook.memoizedState, dispatch];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateState(initialState) {</span>
    <span class="s3">return </span><span class="s1">updateReducer(basicStateReducer);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">rerenderState(initialState) {</span>
    <span class="s3">return </span><span class="s1">rerenderReducer(basicStateReducer);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushEffect(tag, create, destroy, deps) {</span>
    <span class="s3">var </span><span class="s1">effect = {</span>
      <span class="s1">tag: tag,</span>
      <span class="s1">create: create,</span>
      <span class="s1">destroy: destroy,</span>
      <span class="s1">deps: deps,</span>
      <span class="s0">// Circular</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(componentUpdateQueue === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">componentUpdateQueue = createFunctionComponentUpdateQueue();</span>
      <span class="s1">currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;</span>
      <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">lastEffect = componentUpdateQueue.lastEffect;</span>

      <span class="s3">if </span><span class="s1">(lastEffect === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">componentUpdateQueue.lastEffect = effect.next = effect;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
        <span class="s1">lastEffect.next = effect;</span>
        <span class="s1">effect.next = firstEffect;</span>
        <span class="s1">componentUpdateQueue.lastEffect = effect;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">effect;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountRef(initialValue) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">ref = {</span>
      <span class="s1">current: initialValue</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">Object.seal(ref);</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = ref;</span>
    <span class="s3">return </span><span class="s1">ref;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateRef(initialValue) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">return </span><span class="s1">hook.memoizedState;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s1">currentlyRenderingFiber$1.effectTag |= fiberEffectTag;</span>
    <span class="s1">hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, undefined, nextDeps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s3">var </span><span class="s1">destroy = undefined;</span>

    <span class="s3">if </span><span class="s1">(currentHook !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevEffect = currentHook.memoizedState;</span>
      <span class="s1">destroy = prevEffect.destroy;</span>

      <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevDeps = prevEffect.deps;</span>

        <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s1">pushEffect(hookEffectTag, create, destroy, nextDeps);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">currentlyRenderingFiber$1.effectTag |= fiberEffectTag;</span>
    <span class="s1">hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, destroy, nextDeps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountEffect(create, deps) {</span>
    <span class="s1">{</span>
      <span class="s0">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'undefined' </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">jest) {</span>
        <span class="s1">warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">mountEffectImpl(Update | Passive, Passive$1, create, deps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateEffect(create, deps) {</span>
    <span class="s1">{</span>
      <span class="s0">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'undefined' </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">jest) {</span>
        <span class="s1">warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updateEffectImpl(Update | Passive, Passive$1, create, deps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountLayoutEffect(create, deps) {</span>
    <span class="s3">return </span><span class="s1">mountEffectImpl(Update, Layout, create, deps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateLayoutEffect(create, deps) {</span>
    <span class="s3">return </span><span class="s1">updateEffectImpl(Update, Layout, create, deps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">imperativeHandleEffect(create, ref) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">refCallback = ref;</span>

      <span class="s3">var </span><span class="s1">_inst = create();</span>

      <span class="s1">refCallback(_inst);</span>
      <span class="s3">return function </span><span class="s1">() {</span>
        <span class="s1">refCallback(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ref !== </span><span class="s3">null </span><span class="s1">&amp;&amp; ref !== undefined) {</span>
      <span class="s3">var </span><span class="s1">refObject = ref;</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!refObject.hasOwnProperty(</span><span class="s2">'current'</span><span class="s1">)) {</span>
          <span class="s1">error(</span><span class="s2">'Expected useImperativeHandle() first argument to either be a ' </span><span class="s1">+ </span><span class="s2">'ref callback or React.createRef() object. Instead received: %s.'</span><span class="s1">, </span><span class="s2">'an object with keys {' </span><span class="s1">+ Object.keys(refObject).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">'}'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">_inst2 = create();</span>

      <span class="s1">refObject.current = _inst2;</span>
      <span class="s3">return function </span><span class="s1">() {</span>
        <span class="s1">refObject.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountImperativeHandle(ref, create, deps) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">create !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Expected useImperativeHandle() second argument to be a function ' </span><span class="s1">+ </span><span class="s2">'that creates a handle. Instead received: %s.'</span><span class="s1">, create !== </span><span class="s3">null </span><span class="s1">? </span><span class="s3">typeof </span><span class="s1">create : </span><span class="s2">'null'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>


    <span class="s3">var </span><span class="s1">effectDeps = deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref), effectDeps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateImperativeHandle(ref, create, deps) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">create !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Expected useImperativeHandle() second argument to be a function ' </span><span class="s1">+ </span><span class="s2">'that creates a handle. Instead received: %s.'</span><span class="s1">, create !== </span><span class="s3">null </span><span class="s1">? </span><span class="s3">typeof </span><span class="s1">create : </span><span class="s2">'null'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: If deps are provided, should we skip comparing the ref itself?</span>


    <span class="s3">var </span><span class="s1">effectDeps = deps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; deps !== undefined ? deps.concat([ref]) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(</span><span class="s3">null</span><span class="s1">, create, ref), effectDeps);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountDebugValue(value, formatterFn) {</span><span class="s0">// This hook is normally a no-op.</span>
    <span class="s0">// The react-debug-hooks package injects its own implementation</span>
    <span class="s0">// so that e.g. DevTools can display custom hook values.</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">updateDebugValue = mountDebugValue;</span>

  <span class="s3">function </span><span class="s1">mountCallback(callback, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
    <span class="s3">return </span><span class="s1">callback;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateCallback(callback, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hook.memoizedState = [callback, nextDeps];</span>
    <span class="s3">return </span><span class="s1">callback;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountMemo(nextCreate, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = mountWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s3">var </span><span class="s1">nextValue = nextCreate();</span>
    <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
    <span class="s3">return </span><span class="s1">nextValue;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateMemo(nextCreate, deps) {</span>
    <span class="s3">var </span><span class="s1">hook = updateWorkInProgressHook();</span>
    <span class="s3">var </span><span class="s1">nextDeps = deps === undefined ? </span><span class="s3">null </span><span class="s1">: deps;</span>
    <span class="s3">var </span><span class="s1">prevState = hook.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span>
      <span class="s3">if </span><span class="s1">(nextDeps !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevDeps = prevState[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(areHookInputsEqual(nextDeps, prevDeps)) {</span>
          <span class="s3">return </span><span class="s1">prevState[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextValue = nextCreate();</span>
    <span class="s1">hook.memoizedState = [nextValue, nextDeps];</span>
    <span class="s3">return </span><span class="s1">nextValue;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountDeferredValue(value, config) {</span>
    <span class="s3">var </span><span class="s1">_mountState = mountState(value),</span>
        <span class="s1">prevValue = _mountState[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setValue = _mountState[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s1">mountEffect(</span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">previousConfig = ReactCurrentBatchConfig$1.suspense;</span>
      <span class="s1">ReactCurrentBatchConfig$1.suspense = config === undefined ? </span><span class="s3">null </span><span class="s1">: config;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setValue(value);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentBatchConfig$1.suspense = previousConfig;</span>
      <span class="s1">}</span>
    <span class="s1">}, [value, config]);</span>
    <span class="s3">return </span><span class="s1">prevValue;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateDeferredValue(value, config) {</span>
    <span class="s3">var </span><span class="s1">_updateState = updateState(),</span>
        <span class="s1">prevValue = _updateState[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setValue = _updateState[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s1">updateEffect(</span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">previousConfig = ReactCurrentBatchConfig$1.suspense;</span>
      <span class="s1">ReactCurrentBatchConfig$1.suspense = config === undefined ? </span><span class="s3">null </span><span class="s1">: config;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setValue(value);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentBatchConfig$1.suspense = previousConfig;</span>
      <span class="s1">}</span>
    <span class="s1">}, [value, config]);</span>
    <span class="s3">return </span><span class="s1">prevValue;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">rerenderDeferredValue(value, config) {</span>
    <span class="s3">var </span><span class="s1">_rerenderState = rerenderState(),</span>
        <span class="s1">prevValue = _rerenderState[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setValue = _rerenderState[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s1">updateEffect(</span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">previousConfig = ReactCurrentBatchConfig$1.suspense;</span>
      <span class="s1">ReactCurrentBatchConfig$1.suspense = config === undefined ? </span><span class="s3">null </span><span class="s1">: config;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setValue(value);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentBatchConfig$1.suspense = previousConfig;</span>
      <span class="s1">}</span>
    <span class="s1">}, [value, config]);</span>
    <span class="s3">return </span><span class="s1">prevValue;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">startTransition(setPending, config, callback) {</span>
    <span class="s3">var </span><span class="s1">priorityLevel = getCurrentPriorityLevel();</span>
    <span class="s1">runWithPriority$1(priorityLevel &lt; UserBlockingPriority$1 ? UserBlockingPriority$1 : priorityLevel, </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">setPending(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">});</span>
    <span class="s1">runWithPriority$1(priorityLevel &gt; NormalPriority ? NormalPriority : priorityLevel, </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">previousConfig = ReactCurrentBatchConfig$1.suspense;</span>
      <span class="s1">ReactCurrentBatchConfig$1.suspense = config === undefined ? </span><span class="s3">null </span><span class="s1">: config;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">setPending(</span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">callback();</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">ReactCurrentBatchConfig$1.suspense = previousConfig;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountTransition(config) {</span>
    <span class="s3">var </span><span class="s1">_mountState2 = mountState(</span><span class="s3">false</span><span class="s1">),</span>
        <span class="s1">isPending = _mountState2[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setPending = _mountState2[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s3">var </span><span class="s1">start = mountCallback(startTransition.bind(</span><span class="s3">null</span><span class="s1">, setPending, config), [setPending, config]);</span>
    <span class="s3">return </span><span class="s1">[start, isPending];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateTransition(config) {</span>
    <span class="s3">var </span><span class="s1">_updateState2 = updateState(),</span>
        <span class="s1">isPending = _updateState2[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setPending = _updateState2[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s3">var </span><span class="s1">start = updateCallback(startTransition.bind(</span><span class="s3">null</span><span class="s1">, setPending, config), [setPending, config]);</span>
    <span class="s3">return </span><span class="s1">[start, isPending];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">rerenderTransition(config) {</span>
    <span class="s3">var </span><span class="s1">_rerenderState2 = rerenderState(),</span>
        <span class="s1">isPending = _rerenderState2[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">setPending = _rerenderState2[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s3">var </span><span class="s1">start = updateCallback(startTransition.bind(</span><span class="s3">null</span><span class="s1">, setPending, config), [setPending, config]);</span>
    <span class="s3">return </span><span class="s1">[start, isPending];</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">dispatchAction(fiber, queue, action) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">arguments[</span><span class="s4">3</span><span class="s1">] === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">&quot;State updates from the useState() and useReducer() Hooks don't support the &quot; </span><span class="s1">+ </span><span class="s2">'second callback argument. To execute a side effect after ' </span><span class="s1">+ </span><span class="s2">'rendering, declare it in the component body with useEffect().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
    <span class="s3">var </span><span class="s1">suspenseConfig = requestCurrentSuspenseConfig();</span>
    <span class="s3">var </span><span class="s1">expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);</span>
    <span class="s3">var </span><span class="s1">update = {</span>
      <span class="s1">expirationTime: expirationTime,</span>
      <span class="s1">suspenseConfig: suspenseConfig,</span>
      <span class="s1">action: action,</span>
      <span class="s1">eagerReducer: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">eagerState: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">next: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">update.priority = getCurrentPriorityLevel();</span>
    <span class="s1">} </span><span class="s0">// Append the update to the end of the list.</span>


    <span class="s3">var </span><span class="s1">pending = queue.pending;</span>

    <span class="s3">if </span><span class="s1">(pending === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This is the first update. Create a circular list.</span>
      <span class="s1">update.next = update;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">update.next = pending.next;</span>
      <span class="s1">pending.next = update;</span>
    <span class="s1">}</span>

    <span class="s1">queue.pending = update;</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(fiber === currentlyRenderingFiber$1 || alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate === currentlyRenderingFiber$1) {</span>
      <span class="s0">// This is a render phase update. Stash it in a lazily-created map of</span>
      <span class="s0">// queue -&gt; linked list of updates. After this render pass, we'll restart</span>
      <span class="s0">// and apply the stashed updates on top of the work-in-progress hook.</span>
      <span class="s1">didScheduleRenderPhaseUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">update.expirationTime = renderExpirationTime;</span>
      <span class="s1">currentlyRenderingFiber$1.expirationTime = renderExpirationTime;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(fiber.expirationTime === NoWork &amp;&amp; (alternate === </span><span class="s3">null </span><span class="s1">|| alternate.expirationTime === NoWork)) {</span>
        <span class="s0">// The queue is currently empty, which means we can eagerly compute the</span>
        <span class="s0">// next state before entering the render phase. If the new state is the</span>
        <span class="s0">// same as the current state, we may be able to bail out entirely.</span>
        <span class="s3">var </span><span class="s1">lastRenderedReducer = queue.lastRenderedReducer;</span>

        <span class="s3">if </span><span class="s1">(lastRenderedReducer !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">prevDispatcher;</span>

          <span class="s1">{</span>
            <span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
            <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>
          <span class="s1">}</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">currentState = queue.lastRenderedState;</span>
            <span class="s3">var </span><span class="s1">eagerState = lastRenderedReducer(currentState, action); </span><span class="s0">// Stash the eagerly computed state, and the reducer used to compute</span>
            <span class="s0">// it, on the update object. If the reducer hasn't changed by the</span>
            <span class="s0">// time we enter the render phase, then the eager state can be used</span>
            <span class="s0">// without calling the reducer again.</span>

            <span class="s1">update.eagerReducer = lastRenderedReducer;</span>
            <span class="s1">update.eagerState = eagerState;</span>

            <span class="s3">if </span><span class="s1">(objectIs(eagerState, currentState)) {</span>
              <span class="s0">// Fast path. We can bail out without scheduling React to re-render.</span>
              <span class="s0">// It's still possible that we'll need to rebase this update later,</span>
              <span class="s0">// if the component re-renders for a different reason and by that</span>
              <span class="s0">// time the reducer has changed.</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span><span class="s0">// Suppress the error. It will throw again in the render phase.</span>
          <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s0">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">'undefined' </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">jest) {</span>
          <span class="s1">warnIfNotScopedWithMatchingAct(fiber);</span>
          <span class="s1">warnIfNotCurrentlyActingUpdatesInDev(fiber);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">scheduleWork(fiber, expirationTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ContextOnlyDispatcher = {</span>
    <span class="s1">readContext: readContext,</span>
    <span class="s1">useCallback: throwInvalidHookError,</span>
    <span class="s1">useContext: throwInvalidHookError,</span>
    <span class="s1">useEffect: throwInvalidHookError,</span>
    <span class="s1">useImperativeHandle: throwInvalidHookError,</span>
    <span class="s1">useLayoutEffect: throwInvalidHookError,</span>
    <span class="s1">useMemo: throwInvalidHookError,</span>
    <span class="s1">useReducer: throwInvalidHookError,</span>
    <span class="s1">useRef: throwInvalidHookError,</span>
    <span class="s1">useState: throwInvalidHookError,</span>
    <span class="s1">useDebugValue: throwInvalidHookError,</span>
    <span class="s1">useResponder: throwInvalidHookError,</span>
    <span class="s1">useDeferredValue: throwInvalidHookError,</span>
    <span class="s1">useTransition: throwInvalidHookError</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">HooksDispatcherOnMountInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HooksDispatcherOnUpdateInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">HooksDispatcherOnRerenderInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">warnInvalidContextAccess = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">error(</span><span class="s2">'Context can only be read while React is rendering. ' </span><span class="s1">+ </span><span class="s2">'In classes, you can read it in the render method or getDerivedStateFromProps. ' </span><span class="s1">+ </span><span class="s2">'In function components, you can read it directly in the function body, but not ' </span><span class="s1">+ </span><span class="s2">'inside Hooks like useReducer() or useMemo().'</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">warnInvalidHookAccess = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">error(</span><span class="s2">'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' </span><span class="s1">+ </span><span class="s2">'You can only call Hooks at the top level of your React function. ' </span><span class="s1">+ </span><span class="s2">'For more information, see ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/rules-of-hooks'</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s1">HooksDispatcherOnMountInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s1">checkDepsAreArrayDev(deps);</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">HooksDispatcherOnMountWithHookTypesInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">HooksDispatcherOnUpdateInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">HooksDispatcherOnRerenderInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">rerenderState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">rerenderDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">rerenderTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">InvalidNestedHooksDispatcherOnMountInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountRef(initialValue);</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">mountHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">mountTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">InvalidNestedHooksDispatcherOnUpdateInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">InvalidNestedHooksDispatcherOnRerenderInDEV = {</span>
      <span class="s1">readContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">warnInvalidContextAccess();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useCallback: </span><span class="s3">function </span><span class="s1">(callback, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useCallback'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateCallback(callback, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useContext: </span><span class="s3">function </span><span class="s1">(context, observedBits) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useContext'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">readContext(context, observedBits);</span>
      <span class="s1">},</span>
      <span class="s1">useEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useImperativeHandle: </span><span class="s3">function </span><span class="s1">(ref, create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useImperativeHandle'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateImperativeHandle(ref, create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useLayoutEffect: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useLayoutEffect'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateLayoutEffect(create, deps);</span>
      <span class="s1">},</span>
      <span class="s1">useMemo: </span><span class="s3">function </span><span class="s1">(create, deps) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useMemo'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateMemo(create, deps);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useReducer: </span><span class="s3">function </span><span class="s1">(reducer, initialArg, init) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useReducer'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">rerenderReducer(reducer, initialArg, init);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useRef: </span><span class="s3">function </span><span class="s1">(initialValue) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useRef'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateRef();</span>
      <span class="s1">},</span>
      <span class="s1">useState: </span><span class="s3">function </span><span class="s1">(initialState) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useState'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher.current;</span>
        <span class="s1">ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">rerenderState(initialState);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">ReactCurrentDispatcher.current = prevDispatcher;</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">useDebugValue: </span><span class="s3">function </span><span class="s1">(value, formatterFn) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDebugValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">updateDebugValue();</span>
      <span class="s1">},</span>
      <span class="s1">useResponder: </span><span class="s3">function </span><span class="s1">(responder, props) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useResponder'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">createDeprecatedResponderListener(responder, props);</span>
      <span class="s1">},</span>
      <span class="s1">useDeferredValue: </span><span class="s3">function </span><span class="s1">(value, config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useDeferredValue'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">rerenderDeferredValue(value, config);</span>
      <span class="s1">},</span>
      <span class="s1">useTransition: </span><span class="s3">function </span><span class="s1">(config) {</span>
        <span class="s1">currentHookNameInDev = </span><span class="s2">'useTransition'</span><span class="s1">;</span>
        <span class="s1">warnInvalidHookAccess();</span>
        <span class="s1">updateHookTypesDev();</span>
        <span class="s3">return </span><span class="s1">rerenderTransition(config);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">now$1 = unstable_now;</span>
  <span class="s3">var </span><span class="s1">commitTime = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">getCommitTime() {</span>
    <span class="s3">return </span><span class="s1">commitTime;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">recordCommitTime() {</span>

    <span class="s1">commitTime = now$1();</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">startProfilerTimer(fiber) {</span>

    <span class="s1">profilerStartTime = now$1();</span>

    <span class="s3">if </span><span class="s1">(fiber.actualStartTime &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">fiber.actualStartTime = now$1();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">stopProfilerTimerIfRunning(fiber) {</span>

    <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {</span>

    <span class="s3">if </span><span class="s1">(profilerStartTime &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">elapsedTime = now$1() - profilerStartTime;</span>
      <span class="s1">fiber.actualDuration += elapsedTime;</span>

      <span class="s3">if </span><span class="s1">(overrideBaseTime) {</span>
        <span class="s1">fiber.selfBaseDuration = elapsedTime;</span>
      <span class="s1">}</span>

      <span class="s1">profilerStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// This may have been an insertion or a hydration.</span>

  <span class="s3">var </span><span class="s1">hydrationParentFiber = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nextHydratableInstance = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isHydrating = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">enterHydrationState(fiber) {</span>

    <span class="s3">var </span><span class="s1">parentInstance = fiber.stateNode.containerInfo;</span>
    <span class="s1">nextHydratableInstance = getFirstHydratableChild(parentInstance);</span>
    <span class="s1">hydrationParentFiber = fiber;</span>
    <span class="s1">isHydrating = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">deleteHydratableInstance(returnFiber, instance) {</span>
    <span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(returnFiber.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s1">didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">HostComponent:</span>
          <span class="s1">didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">childToDelete = createFiberFromHostInstanceForDeletion();</span>
    <span class="s1">childToDelete.stateNode = instance;</span>
    <span class="s1">childToDelete.</span><span class="s3">return </span><span class="s1">= returnFiber;</span>
    <span class="s1">childToDelete.effectTag = Deletion; </span><span class="s0">// This might seem like it belongs on progressedFirstDeletion. However,</span>
    <span class="s0">// these children are not part of the reconciliation list of children.</span>
    <span class="s0">// Even if we abort and rereconcile the children, that will try to hydrate</span>
    <span class="s0">// again and the nodes are still in the host tree so these will be</span>
    <span class="s0">// recreated.</span>

    <span class="s3">if </span><span class="s1">(returnFiber.lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">returnFiber.lastEffect.nextEffect = childToDelete;</span>
      <span class="s1">returnFiber.lastEffect = childToDelete;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">insertNonHydratedInstance(returnFiber, fiber) {</span>
    <span class="s1">fiber.effectTag = fiber.effectTag &amp; ~Hydrating | Placement;</span>

    <span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(returnFiber.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">parentContainer = returnFiber.stateNode.containerInfo;</span>

            <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
              <span class="s3">case </span><span class="s1">HostComponent:</span>
                <span class="s3">var </span><span class="s1">type = fiber.type;</span>
                <span class="s3">var </span><span class="s1">props = fiber.pendingProps;</span>
                <span class="s1">didNotFindHydratableContainerInstance(parentContainer, type);</span>
                <span class="s3">break</span><span class="s1">;</span>

              <span class="s3">case </span><span class="s1">HostText:</span>
                <span class="s3">var </span><span class="s1">text = fiber.pendingProps;</span>
                <span class="s1">didNotFindHydratableContainerTextInstance(parentContainer, text);</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">HostComponent:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">parentType = returnFiber.type;</span>
            <span class="s3">var </span><span class="s1">parentProps = returnFiber.memoizedProps;</span>
            <span class="s3">var </span><span class="s1">parentInstance = returnFiber.stateNode;</span>

            <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
              <span class="s3">case </span><span class="s1">HostComponent:</span>
                <span class="s3">var </span><span class="s1">_type = fiber.type;</span>
                <span class="s3">var </span><span class="s1">_props = fiber.pendingProps;</span>
                <span class="s1">didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);</span>
                <span class="s3">break</span><span class="s1">;</span>

              <span class="s3">case </span><span class="s1">HostText:</span>
                <span class="s3">var </span><span class="s1">_text = fiber.pendingProps;</span>
                <span class="s1">didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);</span>
                <span class="s3">break</span><span class="s1">;</span>

              <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
                <span class="s1">didNotFindHydratableSuspenseInstance(parentType, parentProps);</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">tryHydrate(fiber, nextInstance) {</span>
    <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">type = fiber.type;</span>
          <span class="s3">var </span><span class="s1">props = fiber.pendingProps;</span>
          <span class="s3">var </span><span class="s1">instance = canHydrateInstance(nextInstance, type);</span>

          <span class="s3">if </span><span class="s1">(instance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">fiber.stateNode = instance;</span>
            <span class="s3">return true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">text = fiber.pendingProps;</span>
          <span class="s3">var </span><span class="s1">textInstance = canHydrateTextInstance(nextInstance, text);</span>

          <span class="s3">if </span><span class="s1">(textInstance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">fiber.stateNode = textInstance;</span>
            <span class="s3">return true</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>

          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">tryToClaimNextHydratableInstance(fiber) {</span>
    <span class="s3">if </span><span class="s1">(!isHydrating) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextInstance = nextHydratableInstance;</span>

    <span class="s3">if </span><span class="s1">(!nextInstance) {</span>
      <span class="s0">// Nothing to hydrate. Make it an insertion.</span>
      <span class="s1">insertNonHydratedInstance(hydrationParentFiber, fiber);</span>
      <span class="s1">isHydrating = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">hydrationParentFiber = fiber;</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">firstAttemptedInstance = nextInstance;</span>

    <span class="s3">if </span><span class="s1">(!tryHydrate(fiber, nextInstance)) {</span>
      <span class="s0">// If we can't hydrate this instance let's try the next one.</span>
      <span class="s0">// We use this as a heuristic. It's based on intuition and not data so it</span>
      <span class="s0">// might be flawed or unnecessary.</span>
      <span class="s1">nextInstance = getNextHydratableSibling(firstAttemptedInstance);</span>

      <span class="s3">if </span><span class="s1">(!nextInstance || !tryHydrate(fiber, nextInstance)) {</span>
        <span class="s0">// Nothing to hydrate. Make it an insertion.</span>
        <span class="s1">insertNonHydratedInstance(hydrationParentFiber, fiber);</span>
        <span class="s1">isHydrating = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">hydrationParentFiber = fiber;</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// We matched the next one, we'll now assume that the first one was</span>
      <span class="s0">// superfluous and we'll delete it. Since we can't eagerly delete it</span>
      <span class="s0">// we'll have to schedule a deletion. To do that, this node needs a dummy</span>
      <span class="s0">// fiber associated with it.</span>


      <span class="s1">deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);</span>
    <span class="s1">}</span>

    <span class="s1">hydrationParentFiber = fiber;</span>
    <span class="s1">nextHydratableInstance = getFirstHydratableChild(nextInstance);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {</span>

    <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>
    <span class="s3">var </span><span class="s1">updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); </span><span class="s0">// TODO: Type this specific to this type of component.</span>

    <span class="s1">fiber.updateQueue = updatePayload; </span><span class="s0">// If the update payload indicates that there is a change or if there</span>
    <span class="s0">// is a new ref we mark this as an update.</span>

    <span class="s3">if </span><span class="s1">(updatePayload !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">prepareToHydrateHostTextInstance(fiber) {</span>

    <span class="s3">var </span><span class="s1">textInstance = fiber.stateNode;</span>
    <span class="s3">var </span><span class="s1">textContent = fiber.memoizedProps;</span>
    <span class="s3">var </span><span class="s1">shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(shouldUpdate) {</span>
        <span class="s0">// We assume that prepareToHydrateHostTextInstance is called in a context where the</span>
        <span class="s0">// hydration parent is the parent host component of this host text.</span>
        <span class="s3">var </span><span class="s1">returnFiber = hydrationParentFiber;</span>

        <span class="s3">if </span><span class="s1">(returnFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">switch </span><span class="s1">(returnFiber.tag) {</span>
            <span class="s3">case </span><span class="s1">HostRoot:</span>
              <span class="s1">{</span>
                <span class="s3">var </span><span class="s1">parentContainer = returnFiber.stateNode.containerInfo;</span>
                <span class="s1">didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">case </span><span class="s1">HostComponent:</span>
              <span class="s1">{</span>
                <span class="s3">var </span><span class="s1">parentType = returnFiber.type;</span>
                <span class="s3">var </span><span class="s1">parentProps = returnFiber.memoizedProps;</span>
                <span class="s3">var </span><span class="s1">parentInstance = returnFiber.stateNode;</span>
                <span class="s1">didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">shouldUpdate;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">skipPastDehydratedSuspenseInstance(fiber) {</span>

    <span class="s3">var </span><span class="s1">suspenseState = fiber.memoizedState;</span>
    <span class="s3">var </span><span class="s1">suspenseInstance = suspenseState !== </span><span class="s3">null </span><span class="s1">? suspenseState.dehydrated : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!suspenseInstance) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popToNextHostParent(fiber) {</span>
    <span class="s3">var </span><span class="s1">parent = fiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(parent !== </span><span class="s3">null </span><span class="s1">&amp;&amp; parent.tag !== HostComponent &amp;&amp; parent.tag !== HostRoot &amp;&amp; parent.tag !== SuspenseComponent) {</span>
      <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">hydrationParentFiber = parent;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popHydrationState(fiber) {</span>

    <span class="s3">if </span><span class="s1">(fiber !== hydrationParentFiber) {</span>
      <span class="s0">// We're deeper than the current hydration context, inside an inserted</span>
      <span class="s0">// tree.</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!isHydrating) {</span>
      <span class="s0">// If we're not currently hydrating but we're in a hydration context, then</span>
      <span class="s0">// we were an insertion and now need to pop up reenter hydration of our</span>
      <span class="s0">// siblings.</span>
      <span class="s1">popToNextHostParent(fiber);</span>
      <span class="s1">isHydrating = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">type = fiber.type; </span><span class="s0">// If we have any remaining hydratable nodes, we need to delete them now.</span>
    <span class="s0">// We only do this deeper than head and body since they tend to have random</span>
    <span class="s0">// other nodes in them. We also ignore components with pure text content in</span>
    <span class="s0">// side of them.</span>
    <span class="s0">// TODO: Better heuristic.</span>

    <span class="s3">if </span><span class="s1">(fiber.tag !== HostComponent || type !== </span><span class="s2">'head' </span><span class="s1">&amp;&amp; type !== </span><span class="s2">'body' </span><span class="s1">&amp;&amp; !shouldSetTextContent(type, fiber.memoizedProps)) {</span>
      <span class="s3">var </span><span class="s1">nextInstance = nextHydratableInstance;</span>

      <span class="s3">while </span><span class="s1">(nextInstance) {</span>
        <span class="s1">deleteHydratableInstance(fiber, nextInstance);</span>
        <span class="s1">nextInstance = getNextHydratableSibling(nextInstance);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">popToNextHostParent(fiber);</span>

    <span class="s3">if </span><span class="s1">(fiber.tag === SuspenseComponent) {</span>
      <span class="s1">nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resetHydrationState() {</span>

    <span class="s1">hydrationParentFiber = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">nextHydratableInstance = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">isHydrating = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;</span>
  <span class="s3">var </span><span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutBadClass;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutModulePatternComponent;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutContextTypeOnFunctionComponent;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutFunctionRefs;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutReassigningProps;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutRevealOrder;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutTailOptions;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutBadClass = {};</span>
    <span class="s1">didWarnAboutModulePatternComponent = {};</span>
    <span class="s1">didWarnAboutContextTypeOnFunctionComponent = {};</span>
    <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent = {};</span>
    <span class="s1">didWarnAboutFunctionRefs = {};</span>
    <span class="s1">didWarnAboutReassigningProps = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutRevealOrder = {};</span>
    <span class="s1">didWarnAboutTailOptions = {};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If this is a fresh new component that hasn't been rendered yet, we</span>
      <span class="s0">// won't update its child set by applying minimal side-effects. Instead,</span>
      <span class="s0">// we will add them all to the child before it gets rendered. That means</span>
      <span class="s0">// we can optimize this reconciliation pass by not tracking side-effects.</span>
      <span class="s1">workInProgress.child = mountChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextChildren, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If the current child is the same as the work in progress, it means that</span>
      <span class="s0">// we haven't yet started any work on these children. Therefore, we use</span>
      <span class="s0">// the clone algorithm to create a copy of all the current children.</span>
      <span class="s0">// If we had any progressed work already, that is invalid at this point so</span>
      <span class="s0">// let's throw it out.</span>
      <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime) {</span>
    <span class="s0">// This function is fork of reconcileChildren. It's used in cases where we</span>
    <span class="s0">// want to reconcile without matching against the existing set. This has the</span>
    <span class="s0">// effect of all current children being unmounted; even if the type and key</span>
    <span class="s0">// are the same, the old child is unmounted and a new child is created.</span>
    <span class="s0">//</span>
    <span class="s0">// To do this, we're going to go through the reconcile algorithm twice. In</span>
    <span class="s0">// the first pass, we schedule a deletion for all the current children by</span>
    <span class="s0">// passing null.</span>
    <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, current.child, </span><span class="s3">null</span><span class="s1">, renderExpirationTime); </span><span class="s0">// In the second pass, we mount the new children. The trick here is that we</span>
    <span class="s0">// pass null in place of where we usually pass the current child set. This has</span>
    <span class="s0">// the effect of remounting all children regardless of whether their</span>
    <span class="s0">// identities match.</span>

    <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextChildren, renderExpirationTime);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateForwardRef(current, workInProgress, Component, nextProps, renderExpirationTime) {</span>
    <span class="s0">// TODO: current can be non-null here even if the component</span>
    <span class="s0">// hasn't yet mounted. This happens after the first render suspends.</span>
    <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes_1(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">'prop'</span><span class="s1">, getComponentName(Component), getCurrentFiberStackInDev);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">render = Component.render;</span>
    <span class="s3">var </span><span class="s1">ref = workInProgress.ref; </span><span class="s0">// The rest is a fork of updateFunctionComponent</span>

    <span class="s3">var </span><span class="s1">nextChildren;</span>
    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);</span>

      <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
        <span class="s0">// Only double-render components with Hooks</span>
        <span class="s3">if </span><span class="s1">(workInProgress.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
      <span class="s1">bailoutHooks(current, workInProgress, renderExpirationTime);</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">type = Component.type;</span>

      <span class="s3">if </span><span class="s1">(isSimpleFunctionComponent(type) &amp;&amp; Component.compare === </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s0">// SimpleMemoComponent codepath doesn't resolve outer props either.</span>
      <span class="s1">Component.defaultProps === undefined) {</span>
        <span class="s3">var </span><span class="s1">resolvedType = type;</span>

        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveFunctionForHotReloading(type);</span>
        <span class="s1">} </span><span class="s0">// If this is a plain function component without default props,</span>
        <span class="s0">// and with only the default shallow comparison, we upgrade it</span>
        <span class="s0">// to a SimpleMemoComponent to allow fast path updates.</span>


        <span class="s1">workInProgress.tag = SimpleMemoComponent;</span>
        <span class="s1">workInProgress.type = resolvedType;</span>

        <span class="s1">{</span>
          <span class="s1">validateFunctionComponentInDev(workInProgress, type);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateExpirationTime, renderExpirationTime);</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">innerPropTypes = type.propTypes;</span>

        <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
          <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
          <span class="s1">checkPropTypes_1(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">'prop'</span><span class="s1">, getComponentName(type), getCurrentFiberStackInDev);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">child = createFiberFromTypeAndProps(Component.type, </span><span class="s3">null</span><span class="s1">, nextProps, </span><span class="s3">null</span><span class="s1">, workInProgress.mode, renderExpirationTime);</span>
      <span class="s1">child.ref = workInProgress.ref;</span>
      <span class="s1">child.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
      <span class="s1">workInProgress.child = child;</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_type = Component.type;</span>
      <span class="s3">var </span><span class="s1">_innerPropTypes = _type.propTypes;</span>

      <span class="s3">if </span><span class="s1">(_innerPropTypes) {</span>
        <span class="s0">// Inner memo component props aren't currently validated in createElement.</span>
        <span class="s0">// We could move it there, but we'd still need this for lazy code path.</span>
        <span class="s1">checkPropTypes_1(_innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
        <span class="s2">'prop'</span><span class="s1">, getComponentName(_type), getCurrentFiberStackInDev);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">currentChild = current.child; </span><span class="s0">// This is always exactly one child</span>

    <span class="s3">if </span><span class="s1">(updateExpirationTime &lt; renderExpirationTime) {</span>
      <span class="s0">// This will be the props with resolved defaultProps,</span>
      <span class="s0">// unlike current.memoizedProps which will be the unresolved ones.</span>
      <span class="s3">var </span><span class="s1">prevProps = currentChild.memoizedProps; </span><span class="s0">// Default to shallow comparison</span>

      <span class="s3">var </span><span class="s1">compare = Component.compare;</span>
      <span class="s1">compare = compare !== </span><span class="s3">null </span><span class="s1">? compare : shallowEqual;</span>

      <span class="s3">if </span><span class="s1">(compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) {</span>
        <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>
    <span class="s3">var </span><span class="s1">newChild = createWorkInProgress(currentChild, nextProps);</span>
    <span class="s1">newChild.ref = workInProgress.ref;</span>
    <span class="s1">newChild.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
    <span class="s1">workInProgress.child = newChild;</span>
    <span class="s3">return </span><span class="s1">newChild;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {</span>
    <span class="s0">// TODO: current can be non-null here even if the component</span>
    <span class="s0">// hasn't yet mounted. This happens when the inner render suspends.</span>
    <span class="s0">// We'll need to figure out if this is fine or can cause issues.</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s3">var </span><span class="s1">outerMemoType = workInProgress.elementType;</span>

        <span class="s3">if </span><span class="s1">(outerMemoType.$$typeof === REACT_LAZY_TYPE) {</span>
          <span class="s0">// We warn when you define propTypes on lazy()</span>
          <span class="s0">// so let's just skip over it to find memo() outer wrapper.</span>
          <span class="s0">// Inner props for memo are validated later.</span>
          <span class="s1">outerMemoType = refineResolvedLazyComponent(outerMemoType);</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">outerPropTypes = outerMemoType &amp;&amp; outerMemoType.propTypes;</span>

        <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
          <span class="s1">checkPropTypes_1(outerPropTypes, nextProps, </span><span class="s0">// Resolved (SimpleMemoComponent has no defaultProps)</span>
          <span class="s2">'prop'</span><span class="s1">, getComponentName(outerMemoType), getCurrentFiberStackInDev);</span>
        <span class="s1">} </span><span class="s0">// Inner propTypes will be validated in the function component path.</span>

      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps;</span>

      <span class="s3">if </span><span class="s1">(shallowEqual(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref &amp;&amp; ( </span><span class="s0">// Prevent bailout if the implementation changed due to hot reload.</span>
       <span class="s1">workInProgress.type === current.type )) {</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(updateExpirationTime &lt; renderExpirationTime) {</span>
          <span class="s0">// The pending update priority was cleared at the beginning of</span>
          <span class="s0">// beginWork. We're about to bail out, but there might be additional</span>
          <span class="s0">// updates at a lower priority. Usually, the priority level of the</span>
          <span class="s0">// remaining updates is accumlated during the evaluation of the</span>
          <span class="s0">// component (i.e. when processing the update queue). But since since</span>
          <span class="s0">// we're bailing out early *without* evaluating the component, we need</span>
          <span class="s0">// to account for it here, too. Reset to the value of the current fiber.</span>
          <span class="s0">// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,</span>
          <span class="s0">// because a MemoComponent fiber does not have hooks or an update queue;</span>
          <span class="s0">// rather, it wraps around an inner component, which may or may not</span>
          <span class="s0">// contains hooks.</span>
          <span class="s0">// TODO: Move the reset at in beginWork out of the common path so that</span>
          <span class="s0">// this is no longer necessary.</span>
          <span class="s1">workInProgress.expirationTime = current.expirationTime;</span>
          <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateFragment(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateMode(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateProfiler(current, workInProgress, renderExpirationTime) {</span>
    <span class="s1">{</span>
      <span class="s1">workInProgress.effectTag |= Update;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">nextChildren = nextProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markRef(current, workInProgress) {</span>
    <span class="s3">var </span><span class="s1">ref = workInProgress.ref;</span>

    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">&amp;&amp; ref !== </span><span class="s3">null </span><span class="s1">|| current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; current.ref !== ref) {</span>
      <span class="s0">// Schedule a Ref effect</span>
      <span class="s1">workInProgress.effectTag |= Ref;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes_1(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">'prop'</span><span class="s1">, getComponentName(Component), getCurrentFiberStackInDev);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">context;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextChildren;</span>
    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);</span>

      <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
        <span class="s0">// Only double-render components with Hooks</span>
        <span class="s3">if </span><span class="s1">(workInProgress.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didReceiveUpdate) {</span>
      <span class="s1">bailoutHooks(current, workInProgress, renderExpirationTime);</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateClassComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
        <span class="s0">// Lazy component props can't be validated in createElement</span>
        <span class="s0">// because they're only guaranteed to be resolved here.</span>
        <span class="s3">var </span><span class="s1">innerPropTypes = Component.propTypes;</span>

        <span class="s3">if </span><span class="s1">(innerPropTypes) {</span>
          <span class="s1">checkPropTypes_1(innerPropTypes, nextProps, </span><span class="s0">// Resolved props</span>
          <span class="s2">'prop'</span><span class="s1">, getComponentName(Component), getCurrentFiberStackInDev);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
    <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
    <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>


    <span class="s3">var </span><span class="s1">hasContext;</span>

    <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">pushContextProvider(workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>
    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
    <span class="s3">var </span><span class="s1">shouldUpdate;</span>

    <span class="s3">if </span><span class="s1">(instance === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// A class component without an instance only mounts if it suspended</span>
        <span class="s0">// inside a non-concurrent tree, in an inconsistent state. We want to</span>
        <span class="s0">// treat it like a new mount, even though an empty version of it already</span>
        <span class="s0">// committed. Disconnect the alternate pointers.</span>
        <span class="s1">current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">workInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        <span class="s1">workInProgress.effectTag |= Placement;</span>
      <span class="s1">} </span><span class="s0">// In the initial pass we might need to construct the instance.</span>


      <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
      <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);</span>
      <span class="s1">shouldUpdate = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// In a resume, we'll already have an instance we can reuse.</span>
      <span class="s1">shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">inst = workInProgress.stateNode;</span>

      <span class="s3">if </span><span class="s1">(inst.props !== nextProps) {</span>
        <span class="s3">if </span><span class="s1">(!didWarnAboutReassigningProps) {</span>
          <span class="s1">error(</span><span class="s2">'It looks like %s is reassigning its own `this.props` while rendering. ' </span><span class="s1">+ </span><span class="s2">'This is not supported and can lead to confusing bugs.'</span><span class="s1">, getComponentName(workInProgress.type) || </span><span class="s2">'a component'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">didWarnAboutReassigningProps = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">nextUnitOfWork;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {</span>
    <span class="s0">// Refs should update even if shouldComponentUpdate returns false</span>
    <span class="s1">markRef(current, workInProgress);</span>
    <span class="s3">var </span><span class="s1">didCaptureError = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;</span>

    <span class="s3">if </span><span class="s1">(!shouldUpdate &amp;&amp; !didCaptureError) {</span>
      <span class="s0">// Context providers should defer to sCU for rendering</span>
      <span class="s3">if </span><span class="s1">(hasContext) {</span>
        <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode; </span><span class="s0">// Rerender</span>

    <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
    <span class="s3">var </span><span class="s1">nextChildren;</span>

    <span class="s3">if </span><span class="s1">(didCaptureError &amp;&amp; </span><span class="s3">typeof </span><span class="s1">Component.getDerivedStateFromError !== </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s0">// If we captured an error, but getDerivedStateFromError is not defined,</span>
      <span class="s0">// unmount all the children. componentDidCatch will schedule an update to</span>
      <span class="s0">// re-render a fallback. This is temporary until we migrate everyone to</span>
      <span class="s0">// the new API.</span>
      <span class="s0">// TODO: Warn in a future release.</span>
      <span class="s1">nextChildren = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">stopProfilerTimerIfRunning();</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">nextChildren = instance.render();</span>

        <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
          <span class="s1">instance.render();</span>
        <span class="s1">}</span>

        <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; didCaptureError) {</span>
      <span class="s0">// If we're recovering from an error, reconcile without reusing any of</span>
      <span class="s0">// the existing children. Conceptually, the normal children and the children</span>
      <span class="s0">// that are shown on error are two different sets, so we shouldn't reuse</span>
      <span class="s0">// normal children even if their identities match.</span>
      <span class="s1">forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s0">// Memoize state using the values we just used to render.</span>
    <span class="s0">// TODO: Restructure so we never read values from the instance.</span>


    <span class="s1">workInProgress.memoizedState = instance.state; </span><span class="s0">// The context might have changed so we need to recalculate it.</span>

    <span class="s3">if </span><span class="s1">(hasContext) {</span>
      <span class="s1">invalidateContextProvider(workInProgress, Component, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushHostRootContext(workInProgress) {</span>
    <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(root.pendingContext) {</span>
      <span class="s1">pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(root.context) {</span>
      <span class="s0">// Should always be set</span>
      <span class="s1">pushTopLevelContextObject(workInProgress, root.context, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">pushHostContainer(workInProgress, root.containerInfo);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateHostRoot(current, workInProgress, renderExpirationTime) {</span>
    <span class="s1">pushHostRootContext(workInProgress);</span>
    <span class="s3">var </span><span class="s1">updateQueue = workInProgress.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(!(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; updateQueue !== </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">prevState = workInProgress.memoizedState;</span>
    <span class="s3">var </span><span class="s1">prevChildren = prevState !== </span><span class="s3">null </span><span class="s1">? prevState.element : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">cloneUpdateQueue(current, workInProgress);</span>
    <span class="s1">processUpdateQueue(workInProgress, nextProps, </span><span class="s3">null</span><span class="s1">, renderExpirationTime);</span>
    <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState; </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
    <span class="s0">// being called &quot;element&quot;.</span>

    <span class="s3">var </span><span class="s1">nextChildren = nextState.element;</span>

    <span class="s3">if </span><span class="s1">(nextChildren === prevChildren) {</span>
      <span class="s0">// If the state is the same as before, that's a bailout because we had</span>
      <span class="s0">// no work that expires at this time.</span>
      <span class="s1">resetHydrationState();</span>
      <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = workInProgress.stateNode;</span>

    <span class="s3">if </span><span class="s1">(root.hydrate &amp;&amp; enterHydrationState(workInProgress)) {</span>
      <span class="s0">// If we don't have any current children this might be the first pass.</span>
      <span class="s0">// We always try to hydrate. If this isn't a hydration pass there won't</span>
      <span class="s0">// be any children to hydrate which is effectively the same thing as</span>
      <span class="s0">// not hydrating.</span>
      <span class="s3">var </span><span class="s1">child = mountChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextChildren, renderExpirationTime);</span>
      <span class="s1">workInProgress.child = child;</span>
      <span class="s3">var </span><span class="s1">node = child;</span>

      <span class="s3">while </span><span class="s1">(node) {</span>
        <span class="s0">// Mark each child as hydrating. This is a fast path to know whether this</span>
        <span class="s0">// tree is part of a hydrating tree. This is used to determine if a child</span>
        <span class="s0">// node has fully mounted yet, and for scheduling event replaying.</span>
        <span class="s0">// Conceptually this is similar to Placement in that a new subtree is</span>
        <span class="s0">// inserted into the React tree here. It just happens to not need DOM</span>
        <span class="s0">// mutations because it already exists.</span>
        <span class="s1">node.effectTag = node.effectTag &amp; ~Placement | Hydrating;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Otherwise reset hydration state in case we aborted and resumed another</span>
      <span class="s0">// root.</span>
      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
      <span class="s1">resetHydrationState();</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateHostComponent(current, workInProgress, renderExpirationTime) {</span>
    <span class="s1">pushHostContext(workInProgress);</span>

    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">tryToClaimNextHydratableInstance(workInProgress);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
    <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">prevProps = current !== </span><span class="s3">null </span><span class="s1">? current.memoizedProps : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">nextChildren = nextProps.children;</span>
    <span class="s3">var </span><span class="s1">isDirectTextChild = shouldSetTextContent(type, nextProps);</span>

    <span class="s3">if </span><span class="s1">(isDirectTextChild) {</span>
      <span class="s0">// We special case a direct text child of a host node. This is a common</span>
      <span class="s0">// case. We won't handle it as a reified child. We will instead handle</span>
      <span class="s0">// this in the host environment that also has access to this prop. That</span>
      <span class="s0">// avoids allocating another HostText fiber and traversing it.</span>
      <span class="s1">nextChildren = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(prevProps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; shouldSetTextContent(type, prevProps)) {</span>
      <span class="s0">// If we're switching from a direct text child to a normal child, or to</span>
      <span class="s0">// empty, we need to schedule the text content to be reset.</span>
      <span class="s1">workInProgress.effectTag |= ContentReset;</span>
    <span class="s1">}</span>

    <span class="s1">markRef(current, workInProgress); </span><span class="s0">// Check the host config to see if the children are offscreen/hidden.</span>

    <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; ConcurrentMode &amp;&amp; renderExpirationTime !== Never &amp;&amp; shouldDeprioritizeSubtree(type, nextProps)) {</span>
      <span class="s1">{</span>
        <span class="s1">markSpawnedWork(Never);</span>
      <span class="s1">} </span><span class="s0">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>


      <span class="s1">workInProgress.expirationTime = workInProgress.childExpirationTime = Never;</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateHostText(current, workInProgress) {</span>
    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">tryToClaimNextHydratableInstance(workInProgress);</span>
    <span class="s1">} </span><span class="s0">// Nothing to do here. This is terminal. We'll do the completion step</span>
    <span class="s0">// immediately after.</span>


    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(_current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// A lazy component only mounts if it suspended inside a non-</span>
      <span class="s0">// concurrent tree, in an inconsistent state. We want to treat it like</span>
      <span class="s0">// a new mount, even though an empty version of it already committed.</span>
      <span class="s0">// Disconnect the alternate pointers.</span>
      <span class="s1">_current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      <span class="s1">workInProgress.effectTag |= Placement;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">props = workInProgress.pendingProps; </span><span class="s0">// We can't start a User Timing measurement with correct label yet.</span>
    <span class="s0">// Cancel and resume right after we know the tag.</span>

    <span class="s1">cancelWorkTimer(workInProgress);</span>
    <span class="s3">var </span><span class="s1">Component = readLazyComponentType(elementType); </span><span class="s0">// Store the unwrapped component in the type.</span>

    <span class="s1">workInProgress.type = Component;</span>
    <span class="s3">var </span><span class="s1">resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);</span>
    <span class="s1">startWorkTimer(workInProgress);</span>
    <span class="s3">var </span><span class="s1">resolvedProps = resolveDefaultProps(Component, props);</span>
    <span class="s3">var </span><span class="s1">child;</span>

    <span class="s3">switch </span><span class="s1">(resolvedTag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
            <span class="s1">workInProgress.type = Component = resolveFunctionForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateFunctionComponent(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderExpirationTime);</span>
          <span class="s3">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">workInProgress.type = Component = resolveClassForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateClassComponent(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderExpirationTime);</span>
          <span class="s3">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">workInProgress.type = Component = resolveForwardRefForHotReloading(Component);</span>
          <span class="s1">}</span>

          <span class="s1">child = updateForwardRef(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, resolvedProps, renderExpirationTime);</span>
          <span class="s3">return </span><span class="s1">child;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">MemoComponent:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
              <span class="s3">var </span><span class="s1">outerPropTypes = Component.propTypes;</span>

              <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
                <span class="s1">checkPropTypes_1(outerPropTypes, resolvedProps, </span><span class="s0">// Resolved for outer only</span>
                <span class="s2">'prop'</span><span class="s1">, getComponentName(Component), getCurrentFiberStackInDev);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">child = updateMemoComponent(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), </span><span class="s0">// The inner type can have defaults too</span>
          <span class="s1">updateExpirationTime, renderExpirationTime);</span>
          <span class="s3">return </span><span class="s1">child;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">hint = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(Component !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">Component === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; Component.$$typeof === REACT_LAZY_TYPE) {</span>
        <span class="s1">hint = </span><span class="s2">' Did you wrap a component in React.lazy() more than once?'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// This message intentionally doesn't mention ForwardRef or MemoComponent</span>
    <span class="s0">// because the fact that it's a separate type of work is an</span>
    <span class="s0">// implementation detail.</span>


    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Element type is invalid. Received a promise that resolves to: &quot; </span><span class="s1">+ Component + </span><span class="s2">&quot;. Lazy element type must resolve to a class or function.&quot; </span><span class="s1">+ hint );</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(_current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// An incomplete component only mounts if it suspended inside a non-</span>
      <span class="s0">// concurrent tree, in an inconsistent state. We want to treat it like</span>
      <span class="s0">// a new mount, even though an empty version of it already committed.</span>
      <span class="s0">// Disconnect the alternate pointers.</span>
      <span class="s1">_current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      <span class="s1">workInProgress.effectTag |= Placement;</span>
    <span class="s1">} </span><span class="s0">// Promote the fiber to a class and try rendering again.</span>


    <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// The rest of this function is a fork of `updateClassComponent`</span>
    <span class="s0">// Push context providers early to prevent context stack mismatches.</span>
    <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
    <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

    <span class="s3">var </span><span class="s1">hasContext;</span>

    <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
      <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">pushContextProvider(workInProgress);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>
    <span class="s1">constructClassInstance(workInProgress, Component, nextProps);</span>
    <span class="s1">mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">finishClassComponent(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, </span><span class="s3">true</span><span class="s1">, hasContext, renderExpirationTime);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(_current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// An indeterminate component only mounts if it suspended inside a non-</span>
      <span class="s0">// concurrent tree, in an inconsistent state. We want to treat it like</span>
      <span class="s0">// a new mount, even though an empty version of it already committed.</span>
      <span class="s0">// Disconnect the alternate pointers.</span>
      <span class="s1">_current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      <span class="s1">workInProgress.effectTag |= Placement;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">props = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">context;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">unmaskedContext = getUnmaskedContext(workInProgress, Component, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">context = getMaskedContext(workInProgress, unmaskedContext);</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>
    <span class="s3">var </span><span class="s1">value;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(Component.prototype &amp;&amp; </span><span class="s3">typeof </span><span class="s1">Component.prototype.render === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(Component) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutBadClass[componentName]) {</span>
          <span class="s1">error(</span><span class="s2">&quot;The &lt;%s /&gt; component appears to have a render method, but doesn't extend React.Component. &quot; </span><span class="s1">+ </span><span class="s2">'This is likely to cause errors. Change %s to extend React.Component instead.'</span><span class="s1">, componentName, componentName);</span>

          <span class="s1">didWarnAboutBadClass[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; StrictMode) {</span>
        <span class="s1">ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">value = renderWithHooks(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, props, context, renderExpirationTime);</span>
      <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">value.render === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; value.$$typeof === undefined) {</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_componentName = getComponentName(Component) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutModulePatternComponent[_componentName]) {</span>
          <span class="s1">error(</span><span class="s2">'The &lt;%s /&gt; component appears to be a function component that returns a class instance. ' </span><span class="s1">+ </span><span class="s2">'Change %s to a class that extends React.Component instead. ' </span><span class="s1">+ </span><span class="s2">&quot;If you can't use a class try assigning the prototype on the function as a workaround. &quot; </span><span class="s1">+ </span><span class="s2">&quot;`%s.prototype = React.Component.prototype`. Don't use an arrow function since it &quot; </span><span class="s1">+ </span><span class="s2">'cannot be called with `new` by React.'</span><span class="s1">, _componentName, _componentName, _componentName);</span>

          <span class="s1">didWarnAboutModulePatternComponent[_componentName] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Proceed under the assumption that this is a class instance</span>


      <span class="s1">workInProgress.tag = ClassComponent; </span><span class="s0">// Throw out any hooks that were used.</span>

      <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Push context providers early to prevent context stack mismatches.</span>
      <span class="s0">// During mounting we don't know the child context yet as the instance doesn't exist.</span>
      <span class="s0">// We will invalidate the child context in finishClassComponent() right after rendering.</span>

      <span class="s3">var </span><span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s1">hasContext = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">pushContextProvider(workInProgress);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">hasContext = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress.memoizedState = value.state !== </span><span class="s3">null </span><span class="s1">&amp;&amp; value.state !== undefined ? value.state : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">initializeUpdateQueue(workInProgress);</span>
      <span class="s3">var </span><span class="s1">getDerivedStateFromProps = Component.getDerivedStateFromProps;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);</span>
      <span class="s1">}</span>

      <span class="s1">adoptClassInstance(workInProgress, value);</span>
      <span class="s1">mountClassInstance(workInProgress, Component, props, renderExpirationTime);</span>
      <span class="s3">return </span><span class="s1">finishClassComponent(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, </span><span class="s3">true</span><span class="s1">, hasContext, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Proceed under the assumption that this is a function component</span>
      <span class="s1">workInProgress.tag = FunctionComponent;</span>

      <span class="s1">{</span>

        <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; StrictMode) {</span>
          <span class="s0">// Only double-render components with Hooks</span>
          <span class="s3">if </span><span class="s1">(workInProgress.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">value = renderWithHooks(</span><span class="s3">null</span><span class="s1">, workInProgress, Component, props, context, renderExpirationTime);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">reconcileChildren(</span><span class="s3">null</span><span class="s1">, workInProgress, value, renderExpirationTime);</span>

      <span class="s1">{</span>
        <span class="s1">validateFunctionComponentInDev(workInProgress, Component);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">workInProgress.child;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateFunctionComponentInDev(workInProgress, Component) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(Component) {</span>
        <span class="s3">if </span><span class="s1">(Component.childContextTypes) {</span>
          <span class="s1">error(</span><span class="s2">'%s(...): childContextTypes cannot be defined on a function component.'</span><span class="s1">, Component.displayName || Component.name || </span><span class="s2">'Component'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgress.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">ownerName = getCurrentFiberOwnerNameInDevOrNull();</span>

        <span class="s3">if </span><span class="s1">(ownerName) {</span>
          <span class="s1">info += </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check the render method of `' </span><span class="s1">+ ownerName + </span><span class="s2">'`.'</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">warningKey = ownerName || workInProgress._debugID || </span><span class="s2">''</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">debugSource = workInProgress._debugSource;</span>

        <span class="s3">if </span><span class="s1">(debugSource) {</span>
          <span class="s1">warningKey = debugSource.fileName + </span><span class="s2">':' </span><span class="s1">+ debugSource.lineNumber;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutFunctionRefs[warningKey]) {</span>
          <span class="s1">didWarnAboutFunctionRefs[warningKey] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'Function components cannot be given refs. ' </span><span class="s1">+ </span><span class="s2">'Attempts to access this ref will fail. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to use React.forwardRef()?%s'</span><span class="s1">, info);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Component.getDerivedStateFromProps === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_componentName2 = getComponentName(Component) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {</span>
          <span class="s1">error(</span><span class="s2">'%s: Function components do not support getDerivedStateFromProps.'</span><span class="s1">, _componentName2);</span>

          <span class="s1">didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Component.contextType === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; Component.contextType !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_componentName3 = getComponentName(Component) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {</span>
          <span class="s1">error(</span><span class="s2">'%s: Function components do not support contextType.'</span><span class="s1">, _componentName3);</span>

          <span class="s1">didWarnAboutContextTypeOnFunctionComponent[_componentName3] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">SUSPENDED_MARKER = {</span>
    <span class="s1">dehydrated: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">retryTime: NoWork</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">shouldRemainOnFallback(suspenseContext, current, workInProgress) {</span>
    <span class="s0">// If the context is telling us that we should show a fallback, and we're not</span>
    <span class="s0">// already showing content, then we should show the fallback instead.</span>
    <span class="s3">return </span><span class="s1">hasSuspenseContext(suspenseContext, ForceSuspenseFallback) &amp;&amp; (current === </span><span class="s3">null </span><span class="s1">|| current.memoizedState !== </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">mode = workInProgress.mode;</span>
    <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps; </span><span class="s0">// This is used by DevTools to force a boundary to suspend.</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(shouldSuspend(workInProgress)) {</span>
        <span class="s1">workInProgress.effectTag |= DidCapture;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
    <span class="s3">var </span><span class="s1">nextDidTimeout = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">didSuspend = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;</span>

    <span class="s3">if </span><span class="s1">(didSuspend || shouldRemainOnFallback(suspenseContext, current)) {</span>
      <span class="s0">// Something in this boundary's subtree already suspended. Switch to</span>
      <span class="s0">// rendering the fallback children.</span>
      <span class="s1">nextDidTimeout = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">workInProgress.effectTag &amp;= ~DidCapture;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Attempting the main content</span>
      <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.memoizedState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This is a new mount or this boundary is already showing a fallback state.</span>
        <span class="s0">// Mark this subtree context as having at least one invisible parent that could</span>
        <span class="s0">// handle the fallback state.</span>
        <span class="s0">// Boundaries without fallbacks or should be avoided are not considered since</span>
        <span class="s0">// they cannot handle preferred fallback states.</span>
        <span class="s3">if </span><span class="s1">(nextProps.fallback !== undefined &amp;&amp; nextProps.unstable_avoidThisFallback !== </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
    <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// This next part is a bit confusing. If the children timeout, we switch to</span>
    <span class="s0">// showing the fallback children in place of the &quot;primary&quot; children.</span>
    <span class="s0">// However, we don't want to delete the primary children because then their</span>
    <span class="s0">// state will be lost (both the React state and the host state, e.g.</span>
    <span class="s0">// uncontrolled form inputs). Instead we keep them mounted and hide them.</span>
    <span class="s0">// Both the fallback children AND the primary children are rendered at the</span>
    <span class="s0">// same time. Once the primary children are un-suspended, we can delete</span>
    <span class="s0">// the fallback children — don't need to preserve their state.</span>
    <span class="s0">//</span>
    <span class="s0">// The two sets of children are siblings in the host environment, but</span>
    <span class="s0">// semantically, for purposes of reconciliation, they are two separate sets.</span>
    <span class="s0">// So we store them using two fragment fibers.</span>
    <span class="s0">//</span>
    <span class="s0">// However, we want to avoid allocating extra fibers for every placeholder.</span>
    <span class="s0">// They're only necessary when the children time out, because that's the</span>
    <span class="s0">// only time when both sets are mounted.</span>
    <span class="s0">//</span>
    <span class="s0">// So, the extra fragment fibers are only used if the children time out.</span>
    <span class="s0">// Otherwise, we render the primary children directly. This requires some</span>
    <span class="s0">// custom reconciliation logic to preserve the state of the primary</span>
    <span class="s0">// children. It's essentially a very basic form of re-parenting.</span>

    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If we're currently hydrating, try to hydrate this boundary.</span>
      <span class="s0">// But only if this has a fallback.</span>
      <span class="s3">if </span><span class="s1">(nextProps.fallback !== undefined) {</span>
        <span class="s1">tryToClaimNextHydratableInstance(workInProgress); </span><span class="s0">// This could've been a dehydrated suspense component.</span>
      <span class="s1">} </span><span class="s0">// This is the initial mount. This branch is pretty simple because there's</span>
      <span class="s0">// no previous state that needs to be preserved.</span>


      <span class="s3">if </span><span class="s1">(nextDidTimeout) {</span>
        <span class="s0">// Mount separate fragments for primary and fallback children.</span>
        <span class="s3">var </span><span class="s1">nextFallbackChildren = nextProps.fallback;</span>
        <span class="s3">var </span><span class="s1">primaryChildFragment = createFiberFromFragment(</span><span class="s3">null</span><span class="s1">, mode, NoWork, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">primaryChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>

        <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; BlockingMode) === NoMode) {</span>
          <span class="s0">// Outside of blocking mode, we commit the effects from the</span>
          <span class="s0">// partially completed, timed-out tree, too.</span>
          <span class="s3">var </span><span class="s1">progressedState = workInProgress.memoizedState;</span>
          <span class="s3">var </span><span class="s1">progressedPrimaryChild = progressedState !== </span><span class="s3">null </span><span class="s1">? workInProgress.child.child : workInProgress.child;</span>
          <span class="s1">primaryChildFragment.child = progressedPrimaryChild;</span>
          <span class="s3">var </span><span class="s1">progressedChild = progressedPrimaryChild;</span>

          <span class="s3">while </span><span class="s1">(progressedChild !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">progressedChild.</span><span class="s3">return </span><span class="s1">= primaryChildFragment;</span>
            <span class="s1">progressedChild = progressedChild.sibling;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">fallbackChildFragment.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
        <span class="s1">primaryChildFragment.sibling = fallbackChildFragment; </span><span class="s0">// Skip the primary children, and continue working on the</span>
        <span class="s0">// fallback children.</span>

        <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
        <span class="s1">workInProgress.child = primaryChildFragment;</span>
        <span class="s3">return </span><span class="s1">fallbackChildFragment;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Mount the primary children without an intermediate fragment fiber.</span>
        <span class="s3">var </span><span class="s1">nextPrimaryChildren = nextProps.children;</span>
        <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">workInProgress.child = mountChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextPrimaryChildren, renderExpirationTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This is an update. This branch is more complicated because we need to</span>
      <span class="s0">// ensure the state of the primary children is preserved.</span>
      <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>

      <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// wrapped in a fragment fiber.</span>


        <span class="s3">var </span><span class="s1">currentPrimaryChildFragment = current.child;</span>
        <span class="s3">var </span><span class="s1">currentFallbackChildFragment = currentPrimaryChildFragment.sibling;</span>

        <span class="s3">if </span><span class="s1">(nextDidTimeout) {</span>
          <span class="s0">// Still timed out. Reuse the current primary children by cloning</span>
          <span class="s0">// its fragment. We're going to skip over these entirely.</span>
          <span class="s3">var </span><span class="s1">_nextFallbackChildren2 = nextProps.fallback;</span>

          <span class="s3">var </span><span class="s1">_primaryChildFragment2 = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps);</span>

          <span class="s1">_primaryChildFragment2.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>

          <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; BlockingMode) === NoMode) {</span>
            <span class="s0">// Outside of blocking mode, we commit the effects from the</span>
            <span class="s0">// partially completed, timed-out tree, too.</span>
            <span class="s3">var </span><span class="s1">_progressedState = workInProgress.memoizedState;</span>

            <span class="s3">var </span><span class="s1">_progressedPrimaryChild = _progressedState !== </span><span class="s3">null </span><span class="s1">? workInProgress.child.child : workInProgress.child;</span>

            <span class="s3">if </span><span class="s1">(_progressedPrimaryChild !== currentPrimaryChildFragment.child) {</span>
              <span class="s1">_primaryChildFragment2.child = _progressedPrimaryChild;</span>
              <span class="s3">var </span><span class="s1">_progressedChild2 = _progressedPrimaryChild;</span>

              <span class="s3">while </span><span class="s1">(_progressedChild2 !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">_progressedChild2.</span><span class="s3">return </span><span class="s1">= _primaryChildFragment2;</span>
                <span class="s1">_progressedChild2 = _progressedChild2.sibling;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Because primaryChildFragment is a new fiber that we're inserting as the</span>
          <span class="s0">// parent of a new tree, we need to set its treeBaseDuration.</span>


          <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; ProfileMode) {</span>
            <span class="s0">// treeBaseDuration is the sum of all the child tree base durations.</span>
            <span class="s3">var </span><span class="s1">_treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">_hiddenChild = _primaryChildFragment2.child;</span>

            <span class="s3">while </span><span class="s1">(_hiddenChild !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">_treeBaseDuration += _hiddenChild.treeBaseDuration;</span>
              <span class="s1">_hiddenChild = _hiddenChild.sibling;</span>
            <span class="s1">}</span>

            <span class="s1">_primaryChildFragment2.treeBaseDuration = _treeBaseDuration;</span>
          <span class="s1">} </span><span class="s0">// Clone the fallback child fragment, too. These we'll continue</span>
          <span class="s0">// working on.</span>


          <span class="s3">var </span><span class="s1">_fallbackChildFragment2 = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren2);</span>

          <span class="s1">_fallbackChildFragment2.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
          <span class="s1">_primaryChildFragment2.sibling = _fallbackChildFragment2;</span>
          <span class="s1">_primaryChildFragment2.childExpirationTime = NoWork; </span><span class="s0">// Skip the primary children, and continue working on the</span>
          <span class="s0">// fallback children.</span>

          <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
          <span class="s1">workInProgress.child = _primaryChildFragment2;</span>
          <span class="s3">return </span><span class="s1">_fallbackChildFragment2;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// No longer suspended. Switch back to showing the primary children,</span>
          <span class="s0">// and remove the intermediate fragment fiber.</span>
          <span class="s3">var </span><span class="s1">_nextPrimaryChildren = nextProps.children;</span>
          <span class="s3">var </span><span class="s1">currentPrimaryChild = currentPrimaryChildFragment.child;</span>
          <span class="s3">var </span><span class="s1">primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime); </span><span class="s0">// If this render doesn't suspend, we need to delete the fallback</span>
          <span class="s0">// children. Wait until the complete phase, after we've confirmed the</span>
          <span class="s0">// fallback is no longer needed.</span>
          <span class="s0">// TODO: Would it be better to store the fallback fragment on</span>
          <span class="s0">// the stateNode?</span>
          <span class="s0">// Continue rendering the children, like we normally do.</span>

          <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s1">workInProgress.child = primaryChild;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// The current tree has not already timed out. That means the primary</span>
        <span class="s0">// children are not wrapped in a fragment fiber.</span>
        <span class="s3">var </span><span class="s1">_currentPrimaryChild = current.child;</span>

        <span class="s3">if </span><span class="s1">(nextDidTimeout) {</span>
          <span class="s0">// Timed out. Wrap the children in a fragment fiber to keep them</span>
          <span class="s0">// separate from the fallback children.</span>
          <span class="s3">var </span><span class="s1">_nextFallbackChildren3 = nextProps.fallback;</span>

          <span class="s3">var </span><span class="s1">_primaryChildFragment3 = createFiberFromFragment( </span><span class="s0">// It shouldn't matter what the pending props are because we aren't</span>
          <span class="s0">// going to render this fragment.</span>
          <span class="s3">null</span><span class="s1">, mode, NoWork, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s1">_primaryChildFragment3.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
          <span class="s1">_primaryChildFragment3.child = _currentPrimaryChild;</span>

          <span class="s3">if </span><span class="s1">(_currentPrimaryChild !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">_currentPrimaryChild.</span><span class="s3">return </span><span class="s1">= _primaryChildFragment3;</span>
          <span class="s1">} </span><span class="s0">// Even though we're creating a new fiber, there are no new children,</span>
          <span class="s0">// because we're reusing an already mounted tree. So we don't need to</span>
          <span class="s0">// schedule a placement.</span>
          <span class="s0">// primaryChildFragment.effectTag |= Placement;</span>


          <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; BlockingMode) === NoMode) {</span>
            <span class="s0">// Outside of blocking mode, we commit the effects from the</span>
            <span class="s0">// partially completed, timed-out tree, too.</span>
            <span class="s3">var </span><span class="s1">_progressedState2 = workInProgress.memoizedState;</span>

            <span class="s3">var </span><span class="s1">_progressedPrimaryChild2 = _progressedState2 !== </span><span class="s3">null </span><span class="s1">? workInProgress.child.child : workInProgress.child;</span>

            <span class="s1">_primaryChildFragment3.child = _progressedPrimaryChild2;</span>
            <span class="s3">var </span><span class="s1">_progressedChild3 = _progressedPrimaryChild2;</span>

            <span class="s3">while </span><span class="s1">(_progressedChild3 !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">_progressedChild3.</span><span class="s3">return </span><span class="s1">= _primaryChildFragment3;</span>
              <span class="s1">_progressedChild3 = _progressedChild3.sibling;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Because primaryChildFragment is a new fiber that we're inserting as the</span>
          <span class="s0">// parent of a new tree, we need to set its treeBaseDuration.</span>


          <span class="s3">if </span><span class="s1">( workInProgress.mode &amp; ProfileMode) {</span>
            <span class="s0">// treeBaseDuration is the sum of all the child tree base durations.</span>
            <span class="s3">var </span><span class="s1">_treeBaseDuration2 = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">_hiddenChild2 = _primaryChildFragment3.child;</span>

            <span class="s3">while </span><span class="s1">(_hiddenChild2 !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">_treeBaseDuration2 += _hiddenChild2.treeBaseDuration;</span>
              <span class="s1">_hiddenChild2 = _hiddenChild2.sibling;</span>
            <span class="s1">}</span>

            <span class="s1">_primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;</span>
          <span class="s1">} </span><span class="s0">// Create a fragment from the fallback children, too.</span>


          <span class="s3">var </span><span class="s1">_fallbackChildFragment3 = createFiberFromFragment(_nextFallbackChildren3, mode, renderExpirationTime, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s1">_fallbackChildFragment3.</span><span class="s3">return </span><span class="s1">= workInProgress;</span>
          <span class="s1">_primaryChildFragment3.sibling = _fallbackChildFragment3;</span>
          <span class="s1">_fallbackChildFragment3.effectTag |= Placement;</span>
          <span class="s1">_primaryChildFragment3.childExpirationTime = NoWork; </span><span class="s0">// Skip the primary children, and continue working on the</span>
          <span class="s0">// fallback children.</span>

          <span class="s1">workInProgress.memoizedState = SUSPENDED_MARKER;</span>
          <span class="s1">workInProgress.child = _primaryChildFragment3;</span>
          <span class="s3">return </span><span class="s1">_fallbackChildFragment3;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// Still haven't timed out. Continue rendering the children, like we</span>
          <span class="s0">// normally do.</span>
          <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">_nextPrimaryChildren2 = nextProps.children;</span>
          <span class="s3">return </span><span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">scheduleWorkOnFiber(fiber, renderExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">(fiber.expirationTime &lt; renderExpirationTime) {</span>
      <span class="s1">fiber.expirationTime = renderExpirationTime;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.expirationTime &lt; renderExpirationTime) {</span>
      <span class="s1">alternate.expirationTime = renderExpirationTime;</span>
    <span class="s1">}</span>

    <span class="s1">scheduleWorkOnParentPath(fiber.</span><span class="s3">return</span><span class="s1">, renderExpirationTime);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">propagateSuspenseContextChange(workInProgress, firstChild, renderExpirationTime) {</span>
    <span class="s0">// Mark any Suspense boundaries with fallbacks as having work to do.</span>
    <span class="s0">// If they were previously forced into fallbacks, they may now be able</span>
    <span class="s0">// to unblock.</span>
    <span class="s3">var </span><span class="s1">node = firstChild;</span>

    <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(node.tag === SuspenseComponent) {</span>
        <span class="s3">var </span><span class="s1">state = node.memoizedState;</span>

        <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">scheduleWorkOnFiber(node, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === SuspenseListComponent) {</span>
        <span class="s0">// If the tail is hidden there might not be an Suspense boundaries</span>
        <span class="s0">// to schedule work on. In this case we have to schedule it on the</span>
        <span class="s0">// list itself.</span>
        <span class="s0">// We don't have to traverse to the children of the list since</span>
        <span class="s0">// the list will propagate the change when it rerenders.</span>
        <span class="s1">scheduleWorkOnFiber(node, renderExpirationTime);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === workInProgress) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findLastContentRow(firstChild) {</span>
    <span class="s0">// This is going to find the last row among these children that is already</span>
    <span class="s0">// showing content on the screen, as opposed to being in fallback state or</span>
    <span class="s0">// new. If a row has multiple Suspense boundaries, any of them being in the</span>
    <span class="s0">// fallback state, counts as the whole row being in a fallback state.</span>
    <span class="s0">// Note that the &quot;rows&quot; will be workInProgress, but any nested children</span>
    <span class="s0">// will still be current since we haven't rendered them yet. The mounted</span>
    <span class="s0">// order may not be the same as the new order. We use the new order.</span>
    <span class="s3">var </span><span class="s1">row = firstChild;</span>
    <span class="s3">var </span><span class="s1">lastContentRow = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

      <span class="s3">if </span><span class="s1">(currentRow !== </span><span class="s3">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">lastContentRow = row;</span>
      <span class="s1">}</span>

      <span class="s1">row = row.sibling;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">lastContentRow;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateRevealOrder(revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(revealOrder !== undefined &amp;&amp; revealOrder !== </span><span class="s2">'forwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s2">'backwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s2">'together' </span><span class="s1">&amp;&amp; !didWarnAboutRevealOrder[revealOrder]) {</span>
        <span class="s1">didWarnAboutRevealOrder[revealOrder] = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">revealOrder === </span><span class="s2">'string'</span><span class="s1">) {</span>
          <span class="s3">switch </span><span class="s1">(revealOrder.toLowerCase()) {</span>
            <span class="s3">case </span><span class="s2">'together'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'forwards'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'backwards'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s1">error(</span><span class="s2">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s2">'Use lowercase &quot;%s&quot; instead.'</span><span class="s1">, revealOrder, revealOrder.toLowerCase());</span>

                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">case </span><span class="s2">'forward'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'backward'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s1">error(</span><span class="s2">'&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s2">'React uses the -s suffix in the spelling. Use &quot;%ss&quot; instead.'</span><span class="s1">, revealOrder, revealOrder.toLowerCase());</span>

                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s1">error(</span><span class="s2">'&quot;%s&quot; is not a supported revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s2">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">, revealOrder);</span>

              <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">error(</span><span class="s2">'%s is not a supported value for revealOrder on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s2">'Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?'</span><span class="s1">, revealOrder);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateTailOptions(tailMode, revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(tailMode !== undefined &amp;&amp; !didWarnAboutTailOptions[tailMode]) {</span>
        <span class="s3">if </span><span class="s1">(tailMode !== </span><span class="s2">'collapsed' </span><span class="s1">&amp;&amp; tailMode !== </span><span class="s2">'hidden'</span><span class="s1">) {</span>
          <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'&quot;%s&quot; is not a supported value for tail on &lt;SuspenseList /&gt;. ' </span><span class="s1">+ </span><span class="s2">'Did you mean &quot;collapsed&quot; or &quot;hidden&quot;?'</span><span class="s1">, tailMode);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(revealOrder !== </span><span class="s2">'forwards' </span><span class="s1">&amp;&amp; revealOrder !== </span><span class="s2">'backwards'</span><span class="s1">) {</span>
          <span class="s1">didWarnAboutTailOptions[tailMode] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'&lt;SuspenseList tail=&quot;%s&quot; /&gt; is only valid if revealOrder is ' </span><span class="s1">+ </span><span class="s2">'&quot;forwards&quot; or &quot;backwards&quot;. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to specify revealOrder=&quot;forwards&quot;?'</span><span class="s1">, tailMode);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateSuspenseListNestedChild(childSlot, index) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">isArray = Array.isArray(childSlot);</span>
      <span class="s3">var </span><span class="s1">isIterable = !isArray &amp;&amp; </span><span class="s3">typeof </span><span class="s1">getIteratorFn(childSlot) === </span><span class="s2">'function'</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(isArray || isIterable) {</span>
        <span class="s3">var </span><span class="s1">type = isArray ? </span><span class="s2">'array' </span><span class="s1">: </span><span class="s2">'iterable'</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'A nested %s was passed to row #%s in &lt;SuspenseList /&gt;. Wrap it in ' </span><span class="s1">+ </span><span class="s2">'an additional SuspenseList to configure its revealOrder: ' </span><span class="s1">+ </span><span class="s2">'&lt;SuspenseList revealOrder=...&gt; ... ' </span><span class="s1">+ </span><span class="s2">'&lt;SuspenseList revealOrder=...&gt;{%s}&lt;/SuspenseList&gt; ... ' </span><span class="s1">+ </span><span class="s2">'&lt;/SuspenseList&gt;'</span><span class="s1">, type, index, type);</span>

        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">validateSuspenseListChildren(children, revealOrder) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">((revealOrder === </span><span class="s2">'forwards' </span><span class="s1">|| revealOrder === </span><span class="s2">'backwards'</span><span class="s1">) &amp;&amp; children !== undefined &amp;&amp; children !== </span><span class="s3">null </span><span class="s1">&amp;&amp; children !== </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(Array.isArray(children)) {</span>
          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
            <span class="s3">if </span><span class="s1">(!validateSuspenseListNestedChild(children[i], i)) {</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(children);</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">childrenIterator = iteratorFn.call(children);</span>

            <span class="s3">if </span><span class="s1">(childrenIterator) {</span>
              <span class="s3">var </span><span class="s1">step = childrenIterator.next();</span>
              <span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s3">for </span><span class="s1">(; !step.done; step = childrenIterator.next()) {</span>
                <span class="s3">if </span><span class="s1">(!validateSuspenseListNestedChild(step.value, _i)) {</span>
                  <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">_i++;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">error(</span><span class="s2">'A single row was passed to a &lt;SuspenseList revealOrder=&quot;%s&quot; /&gt;. ' </span><span class="s1">+ </span><span class="s2">'This is not useful since it needs multiple rows. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to pass multiple children or an array?'</span><span class="s1">, revealOrder);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {</span>
    <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(renderState === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">workInProgress.memoizedState = {</span>
        <span class="s1">isBackwards: isBackwards,</span>
        <span class="s1">rendering: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">renderingStartTime: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">last: lastContentRow,</span>
        <span class="s1">tail: tail,</span>
        <span class="s1">tailExpiration: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">tailMode: tailMode,</span>
        <span class="s1">lastEffect: lastEffectBeforeRendering</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// We can reuse the existing object from previous renders.</span>
      <span class="s1">renderState.isBackwards = isBackwards;</span>
      <span class="s1">renderState.rendering = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">renderState.renderingStartTime = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">renderState.last = lastContentRow;</span>
      <span class="s1">renderState.tail = tail;</span>
      <span class="s1">renderState.tailExpiration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">renderState.tailMode = tailMode;</span>
      <span class="s1">renderState.lastEffect = lastEffectBeforeRendering;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This can end up rendering this component multiple passes.</span>
  <span class="s0">// The first pass splits the children fibers into two sets. A head and tail.</span>
  <span class="s0">// We first render the head. If anything is in fallback state, we do another</span>
  <span class="s0">// pass through beginWork to rerender all children (including the tail) with</span>
  <span class="s0">// the force suspend context. If the first render didn't have anything in</span>
  <span class="s0">// in fallback state. Then we render each row in the tail one-by-one.</span>
  <span class="s0">// That happens in the completeWork phase without going back to beginWork.</span>


  <span class="s3">function </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">nextProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">revealOrder = nextProps.revealOrder;</span>
    <span class="s3">var </span><span class="s1">tailMode = nextProps.tail;</span>
    <span class="s3">var </span><span class="s1">newChildren = nextProps.children;</span>
    <span class="s1">validateRevealOrder(revealOrder);</span>
    <span class="s1">validateTailOptions(tailMode, revealOrder);</span>
    <span class="s1">validateSuspenseListChildren(newChildren, revealOrder);</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);</span>
    <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>
    <span class="s3">var </span><span class="s1">shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>

    <span class="s3">if </span><span class="s1">(shouldForceFallback) {</span>
      <span class="s1">suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
      <span class="s1">workInProgress.effectTag |= DidCapture;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">didSuspendBefore = current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; (current.effectTag &amp; DidCapture) !== NoEffect;</span>

      <span class="s3">if </span><span class="s1">(didSuspendBefore) {</span>
        <span class="s0">// If we previously forced a fallback, we need to schedule work</span>
        <span class="s0">// on any nested boundaries to let them know to try to render</span>
        <span class="s0">// again. This is the same as context updating.</span>
        <span class="s1">propagateSuspenseContextChange(workInProgress, workInProgress.child, renderExpirationTime);</span>
      <span class="s1">}</span>

      <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
    <span class="s1">}</span>

    <span class="s1">pushSuspenseContext(workInProgress, suspenseContext);</span>

    <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; BlockingMode) === NoMode) {</span>
      <span class="s0">// Outside of blocking mode, SuspenseList doesn't work so we just</span>
      <span class="s0">// use make it a noop by treating it as the default revealOrder.</span>
      <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(revealOrder) {</span>
        <span class="s3">case </span><span class="s2">'forwards'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">lastContentRow = findLastContentRow(workInProgress.child);</span>
            <span class="s3">var </span><span class="s1">tail;</span>

            <span class="s3">if </span><span class="s1">(lastContentRow === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// The whole list is part of the tail.</span>
              <span class="s0">// TODO: We could fast path by just rendering the tail now.</span>
              <span class="s1">tail = workInProgress.child;</span>
              <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s0">// Disconnect the tail rows after the content row.</span>
              <span class="s0">// We're going to render them separately later.</span>
              <span class="s1">tail = lastContentRow.sibling;</span>
              <span class="s1">lastContentRow.sibling = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s1">tail, lastContentRow, tailMode, workInProgress.lastEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s2">'backwards'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s0">// We're going to find the first row that has existing content.</span>
            <span class="s0">// At the same time we're going to reverse the list of everything</span>
            <span class="s0">// we pass in the meantime. That's going to be our tail in reverse</span>
            <span class="s0">// order.</span>
            <span class="s3">var </span><span class="s1">_tail = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">row = workInProgress.child;</span>
            <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>

            <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">currentRow = row.alternate; </span><span class="s0">// New rows can't be content rows.</span>

              <span class="s3">if </span><span class="s1">(currentRow !== </span><span class="s3">null </span><span class="s1">&amp;&amp; findFirstSuspended(currentRow) === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// This is the beginning of the main content.</span>
                <span class="s1">workInProgress.child = row;</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s3">var </span><span class="s1">nextRow = row.sibling;</span>
              <span class="s1">row.sibling = _tail;</span>
              <span class="s1">_tail = row;</span>
              <span class="s1">row = nextRow;</span>
            <span class="s1">} </span><span class="s0">// TODO: If workInProgress.child is null, we can continue on the tail immediately.</span>


            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s3">true</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s1">_tail, </span><span class="s3">null</span><span class="s1">, </span><span class="s0">// last</span>
            <span class="s1">tailMode, workInProgress.lastEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s2">'together'</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s1">initSuspenseListRenderState(workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s0">// isBackwards</span>
            <span class="s3">null</span><span class="s1">, </span><span class="s0">// tail</span>
            <span class="s3">null</span><span class="s1">, </span><span class="s0">// last</span>
            <span class="s1">undefined, workInProgress.lastEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s0">// The default reveal order is the same as not having</span>
            <span class="s0">// a boundary.</span>
            <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updatePortalComponent(current, workInProgress, renderExpirationTime) {</span>
    <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
    <span class="s3">var </span><span class="s1">nextChildren = workInProgress.pendingProps;</span>

    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Portals are special because we don't append the children during mount</span>
      <span class="s0">// but at commit. Therefore we need to track insertions which the normal</span>
      <span class="s0">// flow doesn't do during mount. This doesn't happen at the root because</span>
      <span class="s0">// the root always starts with a &quot;current&quot; with a null child.</span>
      <span class="s0">// TODO: Consider unifying this with how the root works.</span>
      <span class="s1">workInProgress.child = reconcileChildFibers(workInProgress, </span><span class="s3">null</span><span class="s1">, nextChildren, renderExpirationTime);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">updateContextProvider(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">providerType = workInProgress.type;</span>
    <span class="s3">var </span><span class="s1">context = providerType._context;</span>
    <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">oldProps = workInProgress.memoizedProps;</span>
    <span class="s3">var </span><span class="s1">newValue = newProps.value;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">providerPropTypes = workInProgress.type.propTypes;</span>

      <span class="s3">if </span><span class="s1">(providerPropTypes) {</span>
        <span class="s1">checkPropTypes_1(providerPropTypes, newProps, </span><span class="s2">'prop'</span><span class="s1">, </span><span class="s2">'Context.Provider'</span><span class="s1">, getCurrentFiberStackInDev);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">pushProvider(workInProgress, newValue);</span>

    <span class="s3">if </span><span class="s1">(oldProps !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">oldValue = oldProps.value;</span>
      <span class="s3">var </span><span class="s1">changedBits = calculateChangedBits(context, newValue, oldValue);</span>

      <span class="s3">if </span><span class="s1">(changedBits === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// No change. Bailout early if children are the same.</span>
        <span class="s3">if </span><span class="s1">(oldProps.children === newProps.children &amp;&amp; !hasContextChanged()) {</span>
          <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// The context value changed. Search for matching consumers and schedule</span>
        <span class="s0">// them to update.</span>
        <span class="s1">propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">newChildren = newProps.children;</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">updateContextConsumer(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">context = workInProgress.type; </span><span class="s0">// The logic below for Context differs depending on PROD or DEV mode. In</span>
    <span class="s0">// DEV mode, we create a separate object for Context.Consumer that acts</span>
    <span class="s0">// like a proxy to Context. This proxy object adds unnecessary code in PROD</span>
    <span class="s0">// so we use the old behaviour (Context.Consumer references Context) to</span>
    <span class="s0">// reduce size and overhead. The separate object references context via</span>
    <span class="s0">// a property called &quot;_context&quot;, which also gives us the ability to check</span>
    <span class="s0">// in DEV mode if this property exists or not and warn if it does not.</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(context._context === undefined) {</span>
        <span class="s0">// This may be because it's a Context (rather than a Consumer).</span>
        <span class="s0">// Or it may be because it's older React where they're the same thing.</span>
        <span class="s0">// We only want to warn if we're sure it's a new React.</span>
        <span class="s3">if </span><span class="s1">(context !== context.Consumer) {</span>
          <span class="s3">if </span><span class="s1">(!hasWarnedAboutUsingContextAsConsumer) {</span>
            <span class="s1">hasWarnedAboutUsingContextAsConsumer = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s2">'Rendering &lt;Context&gt; directly is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s2">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">context = context._context;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>
    <span class="s3">var </span><span class="s1">render = newProps.children;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">render !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'A context consumer was rendered with multiple children, or a child ' </span><span class="s1">+ </span><span class="s2">&quot;that isn't a function. A context consumer expects a single child &quot; </span><span class="s1">+ </span><span class="s2">'that is a function. If you did pass a function, make sure there ' </span><span class="s1">+ </span><span class="s2">'is no trailing or leading whitespace around it.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">prepareToReadContext(workInProgress, renderExpirationTime);</span>
    <span class="s3">var </span><span class="s1">newValue = readContext(context, newProps.unstable_observedBits);</span>
    <span class="s3">var </span><span class="s1">newChildren;</span>

    <span class="s1">{</span>
      <span class="s1">ReactCurrentOwner$1.current = workInProgress;</span>
      <span class="s1">setIsRendering(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">newChildren = render(newValue);</span>
      <span class="s1">setIsRendering(</span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// React DevTools reads this flag.</span>


    <span class="s1">workInProgress.effectTag |= PerformedWork;</span>
    <span class="s1">reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);</span>
    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markWorkInProgressReceivedUpdate() {</span>
    <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime) {</span>
    <span class="s1">cancelWorkTimer(workInProgress);</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Reuse previous dependencies</span>
      <span class="s1">workInProgress.dependencies = current.dependencies;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s0">// Don't update &quot;base&quot; render times for bailouts.</span>
      <span class="s1">stopProfilerTimerIfRunning();</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">updateExpirationTime = workInProgress.expirationTime;</span>

    <span class="s3">if </span><span class="s1">(updateExpirationTime !== NoWork) {</span>
      <span class="s1">markUnprocessedUpdateTime(updateExpirationTime);</span>
    <span class="s1">} </span><span class="s0">// Check if the children have any pending work.</span>


    <span class="s3">var </span><span class="s1">childExpirationTime = workInProgress.childExpirationTime;</span>

    <span class="s3">if </span><span class="s1">(childExpirationTime &lt; renderExpirationTime) {</span>
      <span class="s0">// The children don't have any work either. We can skip them.</span>
      <span class="s0">// TODO: Once we add back resuming, we should check if the children are</span>
      <span class="s0">// a work-in-progress set. If so, we need to transfer their effects.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// This fiber doesn't have work, but its subtree does. Clone the child</span>
      <span class="s0">// fibers and continue.</span>
      <span class="s1">cloneChildFibers(current, workInProgress);</span>
      <span class="s3">return </span><span class="s1">workInProgress.child;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">remountFiber(current, oldWorkInProgress, newWorkInProgress) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">returnFiber = oldWorkInProgress.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(returnFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Cannot swap the root fiber.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Disconnect from the old current.</span>
      <span class="s0">// It will get deleted.</span>


      <span class="s1">current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">oldWorkInProgress.alternate = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Connect to the new tree.</span>

      <span class="s1">newWorkInProgress.index = oldWorkInProgress.index;</span>
      <span class="s1">newWorkInProgress.sibling = oldWorkInProgress.sibling;</span>
      <span class="s1">newWorkInProgress.</span><span class="s3">return </span><span class="s1">= oldWorkInProgress.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">newWorkInProgress.ref = oldWorkInProgress.ref; </span><span class="s0">// Replace the child/sibling pointers above it.</span>

      <span class="s3">if </span><span class="s1">(oldWorkInProgress === returnFiber.child) {</span>
        <span class="s1">returnFiber.child = newWorkInProgress;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">prevSibling = returnFiber.child;</span>

        <span class="s3">if </span><span class="s1">(prevSibling === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Expected parent to have a child.'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(prevSibling.sibling !== oldWorkInProgress) {</span>
          <span class="s1">prevSibling = prevSibling.sibling;</span>

          <span class="s3">if </span><span class="s1">(prevSibling === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Expected to find the previous sibling.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">prevSibling.sibling = newWorkInProgress;</span>
      <span class="s1">} </span><span class="s0">// Delete the old fiber and place the new one.</span>
      <span class="s0">// Since the old fiber is disconnected, we have to schedule it manually.</span>


      <span class="s3">var </span><span class="s1">last = returnFiber.lastEffect;</span>

      <span class="s3">if </span><span class="s1">(last !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">last.nextEffect = current;</span>
        <span class="s1">returnFiber.lastEffect = current;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">returnFiber.firstEffect = returnFiber.lastEffect = current;</span>
      <span class="s1">}</span>

      <span class="s1">current.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">current.effectTag = Deletion;</span>
      <span class="s1">newWorkInProgress.effectTag |= Placement; </span><span class="s0">// Restart work from the new fiber.</span>

      <span class="s3">return </span><span class="s1">newWorkInProgress;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">beginWork(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">updateExpirationTime = workInProgress.expirationTime;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(workInProgress._debugNeedsRemount &amp;&amp; current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This will restart the begin phase with a new fiber.</span>
        <span class="s3">return </span><span class="s1">remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || </span><span class="s3">null</span><span class="s1">, workInProgress.mode, workInProgress.expirationTime));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">oldProps = current.memoizedProps;</span>
      <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>

      <span class="s3">if </span><span class="s1">(oldProps !== newProps || hasContextChanged() || ( </span><span class="s0">// Force a re-render if the implementation changed due to hot reload:</span>
       <span class="s1">workInProgress.type !== current.type )) {</span>
        <span class="s0">// If props or context changed, mark the fiber as having performed work.</span>
        <span class="s0">// This may be unset if the props are determined to be equal later (memo).</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(updateExpirationTime &lt; renderExpirationTime) {</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// This fiber does not have any pending work. Bailout without entering</span>
        <span class="s0">// the begin phase. There's still some bookkeeping we that needs to be done</span>
        <span class="s0">// in this optimized path, mostly pushing stuff onto the stack.</span>

        <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
          <span class="s3">case </span><span class="s1">HostRoot:</span>
            <span class="s1">pushHostRootContext(workInProgress);</span>
            <span class="s1">resetHydrationState();</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">HostComponent:</span>
            <span class="s1">pushHostContext(workInProgress);</span>

            <span class="s3">if </span><span class="s1">(workInProgress.mode &amp; ConcurrentMode &amp;&amp; renderExpirationTime !== Never &amp;&amp; shouldDeprioritizeSubtree(workInProgress.type, newProps)) {</span>
              <span class="s1">{</span>
                <span class="s1">markSpawnedWork(Never);</span>
              <span class="s1">} </span><span class="s0">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>


              <span class="s1">workInProgress.expirationTime = workInProgress.childExpirationTime = Never;</span>
              <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

              <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
                <span class="s1">pushContextProvider(workInProgress);</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">HostPortal:</span>
            <span class="s1">pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">ContextProvider:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">newValue = workInProgress.memoizedProps.value;</span>
              <span class="s1">pushProvider(workInProgress, newValue);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">Profiler:</span>
            <span class="s1">{</span>
              <span class="s0">// Profiler should only call onRender when one of its descendants actually rendered.</span>
              <span class="s3">var </span><span class="s1">hasChildWork = workInProgress.childExpirationTime &gt;= renderExpirationTime;</span>

              <span class="s3">if </span><span class="s1">(hasChildWork) {</span>
                <span class="s1">workInProgress.effectTag |= Update;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">state = workInProgress.memoizedState;</span>

              <span class="s3">if </span><span class="s1">(state !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// whether to retry the primary children, or to skip over it and</span>
                <span class="s0">// go straight to the fallback. Check the priority of the primary</span>
                <span class="s0">// child fragment.</span>


                <span class="s3">var </span><span class="s1">primaryChildFragment = workInProgress.child;</span>
                <span class="s3">var </span><span class="s1">primaryChildExpirationTime = primaryChildFragment.childExpirationTime;</span>

                <span class="s3">if </span><span class="s1">(primaryChildExpirationTime !== NoWork &amp;&amp; primaryChildExpirationTime &gt;= renderExpirationTime) {</span>
                  <span class="s0">// The primary children have pending work. Use the normal path</span>
                  <span class="s0">// to attempt to render the primary children again.</span>
                  <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderExpirationTime);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s1">pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); </span><span class="s0">// The primary children do not have pending work with sufficient</span>
                  <span class="s0">// priority. Bailout.</span>

                  <span class="s3">var </span><span class="s1">child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>

                  <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s0">// The fallback children have pending work. Skip over the</span>
                    <span class="s0">// primary children and work on the fallback.</span>
                    <span class="s3">return </span><span class="s1">child.sibling;</span>
                  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return null</span><span class="s1">;</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">didSuspendBefore = (current.effectTag &amp; DidCapture) !== NoEffect;</span>

              <span class="s3">var </span><span class="s1">_hasChildWork = workInProgress.childExpirationTime &gt;= renderExpirationTime;</span>

              <span class="s3">if </span><span class="s1">(didSuspendBefore) {</span>
                <span class="s3">if </span><span class="s1">(_hasChildWork) {</span>
                  <span class="s0">// If something was in fallback state last time, and we have all the</span>
                  <span class="s0">// same children then we're still in progressive loading state.</span>
                  <span class="s0">// Something might get unblocked by state updates or retries in the</span>
                  <span class="s0">// tree which will affect the tail. So we need to use the normal</span>
                  <span class="s0">// path to compute the correct tail.</span>
                  <span class="s3">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderExpirationTime);</span>
                <span class="s1">} </span><span class="s0">// If none of the children had any work, that means that none of</span>
                <span class="s0">// them got retried so they'll still be blocked in the same way</span>
                <span class="s0">// as before. We can fast bail out.</span>


                <span class="s1">workInProgress.effectTag |= DidCapture;</span>
              <span class="s1">} </span><span class="s0">// If nothing suspended before and we're rendering the same children,</span>
              <span class="s0">// then the tail doesn't matter. Anything new that suspends will work</span>
              <span class="s0">// in the &quot;together&quot; mode, so we can continue from the state we had.</span>


              <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

              <span class="s3">if </span><span class="s1">(renderState !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// Reset to the &quot;together&quot; mode in case we've started a different</span>
                <span class="s0">// update in the past but didn't complete it.</span>
                <span class="s1">renderState.rendering = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s1">pushSuspenseContext(workInProgress, suspenseStackCursor.current);</span>

              <span class="s3">if </span><span class="s1">(_hasChildWork) {</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// If none of the children had any work, that means that none of</span>
                <span class="s0">// them got retried so they'll still be blocked in the same way</span>
                <span class="s0">// as before. We can fast bail out.</span>
                <span class="s3">return null</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// An update was scheduled on this fiber, but there are no new props</span>
        <span class="s0">// nor legacy context. Set this to false. If an update queue or context</span>
        <span class="s0">// consumer produces a changed value, it will set this to true. Otherwise,</span>
        <span class="s0">// the component will assume the children have not changed and bail out.</span>
        <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">didReceiveUpdate = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Before entering the begin phase, clear pending update priority.</span>
    <span class="s0">// TODO: This assumes that we're about to evaluate the component and process</span>
    <span class="s0">// the update queue. However, there's an exception: SimpleMemoComponent</span>
    <span class="s0">// sometimes bails out later in the begin phase. This indicates that we should</span>
    <span class="s0">// move this assignment out of the common path and into each branch.</span>


    <span class="s1">workInProgress.expirationTime = NoWork;</span>

    <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
        <span class="s1">{</span>
          <span class="s3">return </span><span class="s1">mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">LazyComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">elementType = workInProgress.elementType;</span>
          <span class="s3">return </span><span class="s1">mountLazyComponent(current, workInProgress, elementType, updateExpirationTime, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_Component = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">unresolvedProps = workInProgress.pendingProps;</span>
          <span class="s3">var </span><span class="s1">resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);</span>
          <span class="s3">return </span><span class="s1">updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_Component2 = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">_unresolvedProps = workInProgress.pendingProps;</span>

          <span class="s3">var </span><span class="s1">_resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);</span>

          <span class="s3">return </span><span class="s1">updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s3">return </span><span class="s1">updateHostRoot(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s3">return </span><span class="s1">updateHostComponent(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">HostText:</span>
        <span class="s3">return </span><span class="s1">updateHostText(current, workInProgress);</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s3">return </span><span class="s1">updateSuspenseComponent(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s3">return </span><span class="s1">updatePortalComponent(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">_unresolvedProps2 = workInProgress.pendingProps;</span>

          <span class="s3">var </span><span class="s1">_resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);</span>

          <span class="s3">return </span><span class="s1">updateForwardRef(current, workInProgress, type, _resolvedProps2, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">Fragment:</span>
        <span class="s3">return </span><span class="s1">updateFragment(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">Mode:</span>
        <span class="s3">return </span><span class="s1">updateMode(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">Profiler:</span>
        <span class="s3">return </span><span class="s1">updateProfiler(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">ContextProvider:</span>
        <span class="s3">return </span><span class="s1">updateContextProvider(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">ContextConsumer:</span>
        <span class="s3">return </span><span class="s1">updateContextConsumer(current, workInProgress, renderExpirationTime);</span>

      <span class="s3">case </span><span class="s1">MemoComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_type2 = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">_unresolvedProps3 = workInProgress.pendingProps; </span><span class="s0">// Resolve outer props first, then resolve inner props.</span>

          <span class="s3">var </span><span class="s1">_resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);</span>

          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(workInProgress.type !== workInProgress.elementType) {</span>
              <span class="s3">var </span><span class="s1">outerPropTypes = _type2.propTypes;</span>

              <span class="s3">if </span><span class="s1">(outerPropTypes) {</span>
                <span class="s1">checkPropTypes_1(outerPropTypes, _resolvedProps3, </span><span class="s0">// Resolved for outer only</span>
                <span class="s2">'prop'</span><span class="s1">, getComponentName(_type2), getCurrentFiberStackInDev);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">_resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);</span>
          <span class="s3">return </span><span class="s1">updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_Component3 = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">_unresolvedProps4 = workInProgress.pendingProps;</span>

          <span class="s3">var </span><span class="s1">_resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);</span>

          <span class="s3">return </span><span class="s1">mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderExpirationTime);</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s3">return </span><span class="s1">updateSuspenseListComponent(current, workInProgress, renderExpirationTime);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+ workInProgress.tag + </span><span class="s2">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markUpdate(workInProgress) {</span>
    <span class="s0">// Tag the fiber with an update effect. This turns a Placement into</span>
    <span class="s0">// a PlacementAndUpdate.</span>
    <span class="s1">workInProgress.effectTag |= Update;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markRef$1(workInProgress) {</span>
    <span class="s1">workInProgress.effectTag |= Ref;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">appendAllChildren;</span>
  <span class="s3">var </span><span class="s1">updateHostContainer;</span>
  <span class="s3">var </span><span class="s1">updateHostComponent$1;</span>
  <span class="s3">var </span><span class="s1">updateHostText$1;</span>

  <span class="s1">{</span>
    <span class="s0">// Mutation mode</span>
    <span class="s1">appendAllChildren = </span><span class="s3">function </span><span class="s1">(parent, workInProgress, needsVisibilityToggle, isHidden) {</span>
      <span class="s0">// We only have the top Fiber that was created but we need recurse down its</span>
      <span class="s0">// children to find all the terminal nodes.</span>
      <span class="s3">var </span><span class="s1">node = workInProgress.child;</span>

      <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
          <span class="s1">appendInitialChild(parent, node.stateNode);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostPortal) ; </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node === workInProgress) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== workInProgress) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">updateHostContainer = </span><span class="s3">function </span><span class="s1">(workInProgress) {</span><span class="s0">// Noop</span>
    <span class="s1">};</span>

    <span class="s1">updateHostComponent$1 = </span><span class="s3">function </span><span class="s1">(current, workInProgress, type, newProps, rootContainerInstance) {</span>
      <span class="s0">// If we have an alternate, that means this is an update and we need to</span>
      <span class="s0">// schedule a side-effect to do the updates.</span>
      <span class="s3">var </span><span class="s1">oldProps = current.memoizedProps;</span>

      <span class="s3">if </span><span class="s1">(oldProps === newProps) {</span>
        <span class="s0">// In mutation mode, this is sufficient for a bailout because</span>
        <span class="s0">// we won't touch this node even if children changed.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we get updated because one of our children updated, we don't</span>
      <span class="s0">// have newProps so we'll have to reuse them.</span>
      <span class="s0">// TODO: Split the update API as separate for the props vs. children.</span>
      <span class="s0">// Even better would be if children weren't special cased at all tho.</span>


      <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>
      <span class="s3">var </span><span class="s1">currentHostContext = getHostContext(); </span><span class="s0">// TODO: Experiencing an error where oldProps is null. Suggests a host</span>
      <span class="s0">// component is hitting the resume path. Figure out why. Possibly</span>
      <span class="s0">// related to `hidden`.</span>

      <span class="s3">var </span><span class="s1">updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); </span><span class="s0">// TODO: Type this specific to this type of component.</span>

      <span class="s1">workInProgress.updateQueue = updatePayload; </span><span class="s0">// If the update payload indicates that there is a change or if there</span>
      <span class="s0">// is a new ref we mark this as an update. All the work is done in commitWork.</span>

      <span class="s3">if </span><span class="s1">(updatePayload) {</span>
        <span class="s1">markUpdate(workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">updateHostText$1 = </span><span class="s3">function </span><span class="s1">(current, workInProgress, oldText, newText) {</span>
      <span class="s0">// If the text differs, mark it as an update. All the work in done in commitWork.</span>
      <span class="s3">if </span><span class="s1">(oldText !== newText) {</span>
        <span class="s1">markUpdate(workInProgress);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {</span>
    <span class="s3">switch </span><span class="s1">(renderState.tailMode) {</span>
      <span class="s3">case </span><span class="s2">'hidden'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// Any insertions at the end of the tail list after this point</span>
          <span class="s0">// should be invisible. If there are already mounted boundaries</span>
          <span class="s0">// anything before them are not considered for collapsing.</span>
          <span class="s0">// Therefore we need to go through the whole tail to find if</span>
          <span class="s0">// there are any.</span>
          <span class="s3">var </span><span class="s1">tailNode = renderState.tail;</span>
          <span class="s3">var </span><span class="s1">lastTailNode = </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">while </span><span class="s1">(tailNode !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(tailNode.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">lastTailNode = tailNode;</span>
            <span class="s1">}</span>

            <span class="s1">tailNode = tailNode.sibling;</span>
          <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
          <span class="s0">// last rendered item.</span>


          <span class="s3">if </span><span class="s1">(lastTailNode === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// All remaining items in the tail are insertions.</span>
            <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Detach the insertion after the last node that was already</span>
            <span class="s0">// inserted.</span>
            <span class="s1">lastTailNode.sibling = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'collapsed'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// Any insertions at the end of the tail list after this point</span>
          <span class="s0">// should be invisible. If there are already mounted boundaries</span>
          <span class="s0">// anything before them are not considered for collapsing.</span>
          <span class="s0">// Therefore we need to go through the whole tail to find if</span>
          <span class="s0">// there are any.</span>
          <span class="s3">var </span><span class="s1">_tailNode = renderState.tail;</span>
          <span class="s3">var </span><span class="s1">_lastTailNode = </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">while </span><span class="s1">(_tailNode !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(_tailNode.alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">_lastTailNode = _tailNode;</span>
            <span class="s1">}</span>

            <span class="s1">_tailNode = _tailNode.sibling;</span>
          <span class="s1">} </span><span class="s0">// Next we're simply going to delete all insertions after the</span>
          <span class="s0">// last rendered item.</span>


          <span class="s3">if </span><span class="s1">(_lastTailNode === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// All remaining items in the tail are insertions.</span>
            <span class="s3">if </span><span class="s1">(!hasRenderedATailFallback &amp;&amp; renderState.tail !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// We suspended during the head. We want to show at least one</span>
              <span class="s0">// row at the tail. So we'll keep on and cut off the rest.</span>
              <span class="s1">renderState.tail.sibling = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">renderState.tail = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Detach the insertion after the last node that was already</span>
            <span class="s0">// inserted.</span>
            <span class="s1">_lastTailNode.sibling = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">completeWork(current, workInProgress, renderExpirationTime) {</span>
    <span class="s3">var </span><span class="s1">newProps = workInProgress.pendingProps;</span>

    <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
      <span class="s3">case </span><span class="s1">LazyComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">Fragment:</span>
      <span class="s3">case </span><span class="s1">Mode:</span>
      <span class="s3">case </span><span class="s1">Profiler:</span>
      <span class="s3">case </span><span class="s1">ContextConsumer:</span>
      <span class="s3">case </span><span class="s1">MemoComponent:</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

          <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContainer(workInProgress);</span>
          <span class="s1">popTopLevelContextObject(workInProgress);</span>
          <span class="s3">var </span><span class="s1">fiberRoot = workInProgress.stateNode;</span>

          <span class="s3">if </span><span class="s1">(fiberRoot.pendingContext) {</span>
            <span class="s1">fiberRoot.context = fiberRoot.pendingContext;</span>
            <span class="s1">fiberRoot.pendingContext = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">|| current.child === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// If we hydrated, pop so that we can delete any remaining children</span>
            <span class="s0">// that weren't hydrated.</span>
            <span class="s3">var </span><span class="s1">wasHydrated = popHydrationState(workInProgress);</span>

            <span class="s3">if </span><span class="s1">(wasHydrated) {</span>
              <span class="s0">// If we hydrated, then we'll need to schedule an update for</span>
              <span class="s0">// the commit side-effects on the root.</span>
              <span class="s1">markUpdate(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">updateHostContainer(workInProgress);</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContext(workInProgress);</span>
          <span class="s3">var </span><span class="s1">rootContainerInstance = getRootHostContainer();</span>
          <span class="s3">var </span><span class="s1">type = workInProgress.type;</span>

          <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; workInProgress.stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);</span>

            <span class="s3">if </span><span class="s1">(current.ref !== workInProgress.ref) {</span>
              <span class="s1">markRef$1(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(!newProps) {</span>
              <span class="s3">if </span><span class="s1">(!(workInProgress.stateNode !== </span><span class="s3">null</span><span class="s1">)) {</span>
                <span class="s1">{</span>
                  <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>


              <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">currentHostContext = getHostContext(); </span><span class="s0">// TODO: Move createInstance to beginWork and keep it on a context</span>
            <span class="s0">// &quot;stack&quot; as the parent. Then append children as we go in beginWork</span>
            <span class="s0">// or completeWork depending on whether we want to add them top-&gt;down or</span>
            <span class="s0">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span>

            <span class="s3">var </span><span class="s1">_wasHydrated = popHydrationState(workInProgress);</span>

            <span class="s3">if </span><span class="s1">(_wasHydrated) {</span>
              <span class="s0">// TODO: Move this and createInstance step into the beginPhase</span>
              <span class="s0">// to consolidate.</span>
              <span class="s3">if </span><span class="s1">(prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {</span>
                <span class="s0">// If changes to the hydrated node need to be applied at the</span>
                <span class="s0">// commit-phase we mark this as such.</span>
                <span class="s1">markUpdate(workInProgress);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span>
              <span class="s1">appendAllChildren(instance, workInProgress, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// This needs to be set before we mount Flare event listeners</span>

              <span class="s1">workInProgress.stateNode = instance;</span>
              <span class="s0">// (eg DOM renderer supports auto-focus for certain elements).</span>
              <span class="s0">// Make sure such renderers get scheduled for later work.</span>


              <span class="s3">if </span><span class="s1">(finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {</span>
                <span class="s1">markUpdate(workInProgress);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(workInProgress.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// If there is a ref on a host node we need to schedule a callback</span>
              <span class="s1">markRef$1(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">newText = newProps;</span>

          <span class="s3">if </span><span class="s1">(current &amp;&amp; workInProgress.stateNode != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">oldText = current.memoizedProps; </span><span class="s0">// If we have an alternate, that means this is an update and we need</span>
            <span class="s0">// to schedule a side-effect to do the updates.</span>

            <span class="s1">updateHostText$1(current, workInProgress, oldText, newText);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">newText !== </span><span class="s2">'string'</span><span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(!(workInProgress.stateNode !== </span><span class="s3">null</span><span class="s1">)) {</span>
                <span class="s1">{</span>
                  <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s0">// This can happen when we abort work.</span>

            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_rootContainerInstance = getRootHostContainer();</span>

            <span class="s3">var </span><span class="s1">_currentHostContext = getHostContext();</span>

            <span class="s3">var </span><span class="s1">_wasHydrated2 = popHydrationState(workInProgress);</span>

            <span class="s3">if </span><span class="s1">(_wasHydrated2) {</span>
              <span class="s3">if </span><span class="s1">(prepareToHydrateHostTextInstance(workInProgress)) {</span>
                <span class="s1">markUpdate(workInProgress);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>
          <span class="s3">var </span><span class="s1">nextState = workInProgress.memoizedState;</span>

          <span class="s3">if </span><span class="s1">((workInProgress.effectTag &amp; DidCapture) !== NoEffect) {</span>
            <span class="s0">// Something suspended. Re-render with the fallback children.</span>
            <span class="s1">workInProgress.expirationTime = renderExpirationTime; </span><span class="s0">// Do not reset the effect list.</span>

            <span class="s3">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">nextDidTimeout = nextState !== </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">prevDidTimeout = </span><span class="s3">false</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(workInProgress.memoizedProps.fallback !== undefined) {</span>
              <span class="s1">popHydrationState(workInProgress);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>
            <span class="s1">prevDidTimeout = prevState !== </span><span class="s3">null</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(!nextDidTimeout &amp;&amp; prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s0">// We just switched from the fallback to the normal children.</span>
              <span class="s0">// Delete the fallback.</span>
              <span class="s0">// TODO: Would it be better to store the fallback fragment on</span>
              <span class="s0">// the stateNode during the begin phase?</span>
              <span class="s3">var </span><span class="s1">currentFallbackChild = current.child.sibling;</span>

              <span class="s3">if </span><span class="s1">(currentFallbackChild !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// Deletions go at the beginning of the return fiber's effect list</span>
                <span class="s3">var </span><span class="s1">first = workInProgress.firstEffect;</span>

                <span class="s3">if </span><span class="s1">(first !== </span><span class="s3">null</span><span class="s1">) {</span>
                  <span class="s1">workInProgress.firstEffect = currentFallbackChild;</span>
                  <span class="s1">currentFallbackChild.nextEffect = first;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s1">workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;</span>
                  <span class="s1">currentFallbackChild.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">currentFallbackChild.effectTag = Deletion;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(nextDidTimeout &amp;&amp; !prevDidTimeout) {</span>
            <span class="s0">// If this subtreee is running in blocking mode we can suspend,</span>
            <span class="s0">// otherwise we won't suspend.</span>
            <span class="s0">// TODO: This will still suspend a synchronous tree if anything</span>
            <span class="s0">// in the concurrent tree already suspended during this render.</span>
            <span class="s0">// This is a known bug.</span>
            <span class="s3">if </span><span class="s1">((workInProgress.mode &amp; BlockingMode) !== NoMode) {</span>
              <span class="s0">// TODO: Move this back to throwException because this is too late</span>
              <span class="s0">// if this is a large tree which is common for initial loads. We</span>
              <span class="s0">// don't know if we should restart a render or not until we get</span>
              <span class="s0">// this marker, and this is too late.</span>
              <span class="s0">// If this render already had a ping or lower pri updates,</span>
              <span class="s0">// and this is the first time we know we're going to suspend we</span>
              <span class="s0">// should be able to immediately restart from within throwException.</span>
              <span class="s3">var </span><span class="s1">hasInvisibleChildContext = current === </span><span class="s3">null </span><span class="s1">&amp;&amp; workInProgress.memoizedProps.unstable_avoidThisFallback !== </span><span class="s3">true</span><span class="s1">;</span>

              <span class="s3">if </span><span class="s1">(hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {</span>
                <span class="s0">// If this was in an invisible tree or a new render, then showing</span>
                <span class="s0">// this boundary is ok.</span>
                <span class="s1">renderDidSuspend();</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// Otherwise, we're going to have to hide content so we should</span>
                <span class="s0">// suspend for longer if possible.</span>
                <span class="s1">renderDidSuspendDelayIfPossible();</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">{</span>
            <span class="s0">// TODO: Only schedule updates if these values are non equal, i.e. it changed.</span>
            <span class="s3">if </span><span class="s1">(nextDidTimeout || prevDidTimeout) {</span>
              <span class="s0">// If this boundary just timed out, schedule an effect to attach a</span>
              <span class="s0">// retry listener to the promise. This flag is also used to hide the</span>
              <span class="s0">// primary children. In mutation mode, we also need the flag to</span>
              <span class="s0">// *unhide* children that were previously hidden, so check if this</span>
              <span class="s0">// is currently timed out, too.</span>
              <span class="s1">workInProgress.effectTag |= Update;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(workInProgress);</span>
        <span class="s1">updateHostContainer(workInProgress);</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ContextProvider:</span>
        <span class="s0">// Pop provider fiber</span>
        <span class="s1">popProvider(workInProgress);</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s1">{</span>
          <span class="s0">// Same as class component case. I put it down here so that the tags are</span>
          <span class="s0">// sequential to ensure this switch is compiled to a jump table.</span>
          <span class="s3">var </span><span class="s1">_Component = workInProgress.type;</span>

          <span class="s3">if </span><span class="s1">(isContextProvider(_Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>
          <span class="s3">var </span><span class="s1">renderState = workInProgress.memoizedState;</span>

          <span class="s3">if </span><span class="s1">(renderState === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We're running in the default, &quot;independent&quot; mode.</span>
            <span class="s0">// We don't do anything in this mode.</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">didSuspendAlready = (workInProgress.effectTag &amp; DidCapture) !== NoEffect;</span>
          <span class="s3">var </span><span class="s1">renderedTail = renderState.rendering;</span>

          <span class="s3">if </span><span class="s1">(renderedTail === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We just rendered the head.</span>
            <span class="s3">if </span><span class="s1">(!didSuspendAlready) {</span>
              <span class="s0">// This is the first pass. We need to figure out if anything is still</span>
              <span class="s0">// suspended in the rendered set.</span>
              <span class="s0">// If new content unsuspended, but there's still some content that</span>
              <span class="s0">// didn't. Then we need to do a second pass that forces everything</span>
              <span class="s0">// to keep showing their fallbacks.</span>
              <span class="s0">// We might be suspended if something in this render pass suspended, or</span>
              <span class="s0">// something in the previous committed pass suspended. Otherwise,</span>
              <span class="s0">// there's no chance so we can skip the expensive call to</span>
              <span class="s0">// findFirstSuspended.</span>
              <span class="s3">var </span><span class="s1">cannotBeSuspended = renderHasNotSuspendedYet() &amp;&amp; (current === </span><span class="s3">null </span><span class="s1">|| (current.effectTag &amp; DidCapture) === NoEffect);</span>

              <span class="s3">if </span><span class="s1">(!cannotBeSuspended) {</span>
                <span class="s3">var </span><span class="s1">row = workInProgress.child;</span>

                <span class="s3">while </span><span class="s1">(row !== </span><span class="s3">null</span><span class="s1">) {</span>
                  <span class="s3">var </span><span class="s1">suspended = findFirstSuspended(row);</span>

                  <span class="s3">if </span><span class="s1">(suspended !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">workInProgress.effectTag |= DidCapture;</span>
                    <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// If this is a newly suspended tree, it might not get committed as</span>
                    <span class="s0">// part of the second pass. In that case nothing will subscribe to</span>
                    <span class="s0">// its thennables. Instead, we'll transfer its thennables to the</span>
                    <span class="s0">// SuspenseList so that it can retry if they resolve.</span>
                    <span class="s0">// There might be multiple of these in the list but since we're</span>
                    <span class="s0">// going to wait for all of them anyway, it doesn't really matter</span>
                    <span class="s0">// which ones gets to ping. In theory we could get clever and keep</span>
                    <span class="s0">// track of how many dependencies remain but it gets tricky because</span>
                    <span class="s0">// in the meantime, we can add/remove/change items and dependencies.</span>
                    <span class="s0">// We might bail out of the loop before finding any but that</span>
                    <span class="s0">// doesn't matter since that means that the other boundaries that</span>
                    <span class="s0">// we did find already has their listeners attached.</span>

                    <span class="s3">var </span><span class="s1">newThennables = suspended.updateQueue;</span>

                    <span class="s3">if </span><span class="s1">(newThennables !== </span><span class="s3">null</span><span class="s1">) {</span>
                      <span class="s1">workInProgress.updateQueue = newThennables;</span>
                      <span class="s1">workInProgress.effectTag |= Update;</span>
                    <span class="s1">} </span><span class="s0">// Rerender the whole list, but this time, we'll force fallbacks</span>
                    <span class="s0">// to stay in place.</span>
                    <span class="s0">// Reset the effect list before doing the second pass since that's now invalid.</span>


                    <span class="s3">if </span><span class="s1">(renderState.lastEffect === </span><span class="s3">null</span><span class="s1">) {</span>
                      <span class="s1">workInProgress.firstEffect = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">}</span>

                    <span class="s1">workInProgress.lastEffect = renderState.lastEffect; </span><span class="s0">// Reset the child fibers to their original state.</span>

                    <span class="s1">resetChildFibers(workInProgress, renderExpirationTime); </span><span class="s0">// Set up the Suspense Context to force suspense and immediately</span>
                    <span class="s0">// rerender the children.</span>

                    <span class="s1">pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));</span>
                    <span class="s3">return </span><span class="s1">workInProgress.child;</span>
                  <span class="s1">}</span>

                  <span class="s1">row = row.sibling;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s0">// Next we're going to render the tail.</span>

          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// Append the rendered row to the child list.</span>
            <span class="s3">if </span><span class="s1">(!didSuspendAlready) {</span>
              <span class="s3">var </span><span class="s1">_suspended = findFirstSuspended(renderedTail);</span>

              <span class="s3">if </span><span class="s1">(_suspended !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">workInProgress.effectTag |= DidCapture;</span>
                <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Ensure we transfer the update queue to the parent so that it doesn't</span>
                <span class="s0">// get lost if this row ends up dropped during a second pass.</span>

                <span class="s3">var </span><span class="s1">_newThennables = _suspended.updateQueue;</span>

                <span class="s3">if </span><span class="s1">(_newThennables !== </span><span class="s3">null</span><span class="s1">) {</span>
                  <span class="s1">workInProgress.updateQueue = _newThennables;</span>
                  <span class="s1">workInProgress.effectTag |= Update;</span>
                <span class="s1">}</span>

                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">true</span><span class="s1">); </span><span class="s0">// This might have been modified.</span>

                <span class="s3">if </span><span class="s1">(renderState.tail === </span><span class="s3">null </span><span class="s1">&amp;&amp; renderState.tailMode === </span><span class="s2">'hidden' </span><span class="s1">&amp;&amp; !renderedTail.alternate) {</span>
                  <span class="s0">// We need to delete the row we just rendered.</span>
                  <span class="s0">// Reset the effect list to what it was before we rendered this</span>
                  <span class="s0">// child. The nested children have already appended themselves.</span>
                  <span class="s3">var </span><span class="s1">lastEffect = workInProgress.lastEffect = renderState.lastEffect; </span><span class="s0">// Remove any effects that were appended after this point.</span>

                  <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">lastEffect.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
                  <span class="s1">} </span><span class="s0">// We're done.</span>


                  <span class="s3">return null</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else if </span><span class="s1">( </span><span class="s0">// The time it took to render last row is greater than time until</span>
              <span class="s0">// the expiration.</span>
              <span class="s1">now() * </span><span class="s4">2 </span><span class="s1">- renderState.renderingStartTime &gt; renderState.tailExpiration &amp;&amp; renderExpirationTime &gt; Never) {</span>
                <span class="s0">// We have now passed our CPU deadline and we'll just give up further</span>
                <span class="s0">// attempts to render the main content and only render fallbacks.</span>
                <span class="s0">// The assumption is that this is usually faster.</span>
                <span class="s1">workInProgress.effectTag |= DidCapture;</span>
                <span class="s1">didSuspendAlready = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">cutOffTailIfNeeded(renderState, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Since nothing actually suspended, there will nothing to ping this</span>
                <span class="s0">// to get it started back up to attempt the next item. If we can show</span>
                <span class="s0">// them, then they really have the same priority as this render.</span>
                <span class="s0">// So we'll pick it back up the very next render pass once we've had</span>
                <span class="s0">// an opportunity to yield for paint.</span>

                <span class="s3">var </span><span class="s1">nextPriority = renderExpirationTime - </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;</span>

                <span class="s1">{</span>
                  <span class="s1">markSpawnedWork(nextPriority);</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(renderState.isBackwards) {</span>
              <span class="s0">// The effect list of the backwards tail will have been added</span>
              <span class="s0">// to the end. This breaks the guarantee that life-cycles fire in</span>
              <span class="s0">// sibling order but that isn't a strong guarantee promised by React.</span>
              <span class="s0">// Especially since these might also just pop in during future commits.</span>
              <span class="s0">// Append to the beginning of the list.</span>
              <span class="s1">renderedTail.sibling = workInProgress.child;</span>
              <span class="s1">workInProgress.child = renderedTail;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">previousSibling = renderState.last;</span>

              <span class="s3">if </span><span class="s1">(previousSibling !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">previousSibling.sibling = renderedTail;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">workInProgress.child = renderedTail;</span>
              <span class="s1">}</span>

              <span class="s1">renderState.last = renderedTail;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(renderState.tail !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We still have tail rows to render.</span>
            <span class="s3">if </span><span class="s1">(renderState.tailExpiration === </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s0">// Heuristic for how long we're willing to spend rendering rows</span>
              <span class="s0">// until we just give up and show what we have so far.</span>
              <span class="s3">var </span><span class="s1">TAIL_EXPIRATION_TIMEOUT_MS = </span><span class="s4">500</span><span class="s1">;</span>
              <span class="s1">renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS; </span><span class="s0">// TODO: This is meant to mimic the train model or JND but this</span>
              <span class="s0">// is a per component value. It should really be since the start</span>
              <span class="s0">// of the total render or last commit. Consider using something like</span>
              <span class="s0">// globalMostRecentFallbackTime. That doesn't account for being</span>
              <span class="s0">// suspended for part of the time or when it's a new render.</span>
              <span class="s0">// It should probably use a global start time value instead.</span>
            <span class="s1">} </span><span class="s0">// Pop a row.</span>


            <span class="s3">var </span><span class="s1">next = renderState.tail;</span>
            <span class="s1">renderState.rendering = next;</span>
            <span class="s1">renderState.tail = next.sibling;</span>
            <span class="s1">renderState.lastEffect = workInProgress.lastEffect;</span>
            <span class="s1">renderState.renderingStartTime = now();</span>
            <span class="s1">next.sibling = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Restore the context.</span>
            <span class="s0">// TODO: We can probably just avoid popping it instead and only</span>
            <span class="s0">// setting it the first time we go from not suspended to suspended.</span>

            <span class="s3">var </span><span class="s1">suspenseContext = suspenseStackCursor.current;</span>

            <span class="s3">if </span><span class="s1">(didSuspendAlready) {</span>
              <span class="s1">suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);</span>
            <span class="s1">}</span>

            <span class="s1">pushSuspenseContext(workInProgress, suspenseContext); </span><span class="s0">// Do a pass over the next row.</span>

            <span class="s3">return </span><span class="s1">next;</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unknown unit of work tag (&quot; </span><span class="s1">+ workInProgress.tag + </span><span class="s2">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unwindWork(workInProgress, renderExpirationTime) {</span>
    <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">Component = workInProgress.type;</span>

          <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
            <span class="s1">popContext(workInProgress);</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">effectTag = workInProgress.effectTag;</span>

          <span class="s3">if </span><span class="s1">(effectTag &amp; ShouldCapture) {</span>
            <span class="s1">workInProgress.effectTag = effectTag &amp; ~ShouldCapture | DidCapture;</span>
            <span class="s3">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContainer(workInProgress);</span>
          <span class="s1">popTopLevelContextObject(workInProgress);</span>
          <span class="s3">var </span><span class="s1">_effectTag = workInProgress.effectTag;</span>

          <span class="s3">if </span><span class="s1">(!((_effectTag &amp; DidCapture) === NoEffect)) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;The root failed to unmount after an error. This is likely a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">workInProgress.effectTag = _effectTag &amp; ~ShouldCapture | DidCapture;</span>
          <span class="s3">return </span><span class="s1">workInProgress;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s0">// TODO: popHydrationState</span>
          <span class="s1">popHostContext(workInProgress);</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress);</span>

          <span class="s3">var </span><span class="s1">_effectTag2 = workInProgress.effectTag;</span>

          <span class="s3">if </span><span class="s1">(_effectTag2 &amp; ShouldCapture) {</span>
            <span class="s1">workInProgress.effectTag = _effectTag2 &amp; ~ShouldCapture | DidCapture; </span><span class="s0">// Captured a suspense effect. Re-render the boundary.</span>

            <span class="s3">return </span><span class="s1">workInProgress;</span>
          <span class="s1">}</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popSuspenseContext(workInProgress); </span><span class="s0">// SuspenseList doesn't actually catch anything. It should've been</span>
          <span class="s0">// caught by a nested boundary. If not, it should bubble through.</span>

          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(workInProgress);</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ContextProvider:</span>
        <span class="s1">popProvider(workInProgress);</span>
        <span class="s3">return null</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unwindInterruptedWork(interruptedWork) {</span>
    <span class="s3">switch </span><span class="s1">(interruptedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">childContextTypes = interruptedWork.type.childContextTypes;</span>

          <span class="s3">if </span><span class="s1">(childContextTypes !== </span><span class="s3">null </span><span class="s1">&amp;&amp; childContextTypes !== undefined) {</span>
            <span class="s1">popContext(interruptedWork);</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContainer(interruptedWork);</span>
          <span class="s1">popTopLevelContextObject(interruptedWork);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s1">popHostContext(interruptedWork);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">popHostContainer(interruptedWork);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">popSuspenseContext(interruptedWork);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">popSuspenseContext(interruptedWork);</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">ContextProvider:</span>
        <span class="s1">popProvider(interruptedWork);</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createCapturedValue(value, source) {</span>
    <span class="s0">// If the value is an error, call this function immediately after it is thrown</span>
    <span class="s0">// so the stack is accurate.</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">value: value,</span>
      <span class="s1">source: source,</span>
      <span class="s1">stack: getStackByFiberInDevAndProd(source)</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">logCapturedError(capturedError) {</span>

    <span class="s3">var </span><span class="s1">error = capturedError.error;</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">componentName = capturedError.componentName,</span>
          <span class="s1">componentStack = capturedError.componentStack,</span>
          <span class="s1">errorBoundaryName = capturedError.errorBoundaryName,</span>
          <span class="s1">errorBoundaryFound = capturedError.errorBoundaryFound,</span>
          <span class="s1">willRetry = capturedError.willRetry; </span><span class="s0">// Browsers support silencing uncaught errors by calling</span>
      <span class="s0">// `preventDefault()` in window `error` handler.</span>
      <span class="s0">// We record this information as an expando on the error.</span>

      <span class="s3">if </span><span class="s1">(error != </span><span class="s3">null </span><span class="s1">&amp;&amp; error._suppressLogging) {</span>
        <span class="s3">if </span><span class="s1">(errorBoundaryFound &amp;&amp; willRetry) {</span>
          <span class="s0">// The error is recoverable and was silenced.</span>
          <span class="s0">// Ignore it and don't print the stack addendum.</span>
          <span class="s0">// This is handy for testing error boundaries without noise.</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// The error is fatal. Since the silencing might have</span>
        <span class="s0">// been accidental, we'll surface it anyway.</span>
        <span class="s0">// However, the browser would have silenced the original error</span>
        <span class="s0">// so we'll print it first, and then print the stack addendum.</span>


        <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](error); </span><span class="s0">// Don't transform to our wrapper</span>
        <span class="s0">// For a more detailed description of this block, see:</span>
        <span class="s0">// https://github.com/facebook/react/pull/13384</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">componentNameMessage = componentName ? </span><span class="s2">&quot;The above error occurred in the &lt;&quot; </span><span class="s1">+ componentName + </span><span class="s2">&quot;&gt; component:&quot; </span><span class="s1">: </span><span class="s2">'The above error occurred in one of your React components:'</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">errorBoundaryMessage; </span><span class="s0">// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.</span>

      <span class="s3">if </span><span class="s1">(errorBoundaryFound &amp;&amp; errorBoundaryName) {</span>
        <span class="s3">if </span><span class="s1">(willRetry) {</span>
          <span class="s1">errorBoundaryMessage = </span><span class="s2">&quot;React will try to recreate this component tree from scratch &quot; </span><span class="s1">+ (</span><span class="s2">&quot;using the error boundary you provided, &quot; </span><span class="s1">+ errorBoundaryName + </span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">errorBoundaryMessage = </span><span class="s2">&quot;This error was initially handled by the error boundary &quot; </span><span class="s1">+ errorBoundaryName + </span><span class="s2">&quot;.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">&quot;Recreating the tree from scratch failed so React will unmount the tree.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">errorBoundaryMessage = </span><span class="s2">'Consider adding an error boundary to your tree to customize error handling behavior.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">combinedMessage = </span><span class="s2">&quot;&quot; </span><span class="s1">+ componentNameMessage + componentStack + </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ (</span><span class="s2">&quot;&quot; </span><span class="s1">+ errorBoundaryMessage); </span><span class="s0">// In development, we provide our own message with just the component stack.</span>
      <span class="s0">// We don't include the original error message and JS stack because the browser</span>
      <span class="s0">// has already printed it. Even if the application swallows the error, it is still</span>
      <span class="s0">// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.</span>

      <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](combinedMessage); </span><span class="s0">// Don't transform to our wrapper</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutUndefinedSnapshotBeforeUpdate = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">PossiblyWeakSet = </span><span class="s3">typeof </span><span class="s1">WeakSet === </span><span class="s2">'function' </span><span class="s1">? WeakSet : Set;</span>
  <span class="s3">function </span><span class="s1">logError(boundary, errorInfo) {</span>
    <span class="s3">var </span><span class="s1">source = errorInfo.source;</span>
    <span class="s3">var </span><span class="s1">stack = errorInfo.stack;</span>

    <span class="s3">if </span><span class="s1">(stack === </span><span class="s3">null </span><span class="s1">&amp;&amp; source !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">stack = getStackByFiberInDevAndProd(source);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">capturedError = {</span>
      <span class="s1">componentName: source !== </span><span class="s3">null </span><span class="s1">? getComponentName(source.type) : </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">componentStack: stack !== </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">''</span><span class="s1">,</span>
      <span class="s1">error: errorInfo.value,</span>
      <span class="s1">errorBoundary: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">errorBoundaryName: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">errorBoundaryFound: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">willRetry: </span><span class="s3">false</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(boundary !== </span><span class="s3">null </span><span class="s1">&amp;&amp; boundary.tag === ClassComponent) {</span>
      <span class="s1">capturedError.errorBoundary = boundary.stateNode;</span>
      <span class="s1">capturedError.errorBoundaryName = getComponentName(boundary.type);</span>
      <span class="s1">capturedError.errorBoundaryFound = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">capturedError.willRetry = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">logCapturedError(capturedError);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s0">// This method must not throw, or React internal state will get messed up.</span>
      <span class="s0">// If console.error is overridden, or logCapturedError() shows a dialog that throws,</span>
      <span class="s0">// we want to report this error outside of the normal stack as a last resort.</span>
      <span class="s0">// https://github.com/facebook/react/issues/13188</span>
      <span class="s1">setTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">throw </span><span class="s1">e;</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">callComponentWillUnmountWithTimer = </span><span class="s3">function </span><span class="s1">(current, instance) {</span>
    <span class="s1">startPhaseTimer(current, </span><span class="s2">'componentWillUnmount'</span><span class="s1">);</span>
    <span class="s1">instance.props = current.memoizedProps;</span>
    <span class="s1">instance.state = current.memoizedState;</span>
    <span class="s1">instance.componentWillUnmount();</span>
    <span class="s1">stopPhaseTimer();</span>
  <span class="s1">}; </span><span class="s0">// Capture errors so they don't interrupt unmounting.</span>


  <span class="s3">function </span><span class="s1">safelyCallComponentWillUnmount(current, instance) {</span>
    <span class="s1">{</span>
      <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, callComponentWillUnmountWithTimer, </span><span class="s3">null</span><span class="s1">, current, instance);</span>

      <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
        <span class="s3">var </span><span class="s1">unmountError = clearCaughtError();</span>
        <span class="s1">captureCommitPhaseError(current, unmountError);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">safelyDetachRef(current) {</span>
    <span class="s3">var </span><span class="s1">ref = current.ref;</span>

    <span class="s3">if </span><span class="s1">(ref !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, ref, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
            <span class="s3">var </span><span class="s1">refError = clearCaughtError();</span>
            <span class="s1">captureCommitPhaseError(current, refError);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">ref.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">safelyCallDestroy(current, destroy) {</span>
    <span class="s1">{</span>
      <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, destroy, </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
        <span class="s3">var </span><span class="s1">error = clearCaughtError();</span>
        <span class="s1">captureCommitPhaseError(current, error);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitBeforeMutationLifeCycles(current, finishedWork) {</span>
    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">Block:</span>
        <span class="s1">{</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(finishedWork.effectTag &amp; Snapshot) {</span>
            <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">prevProps = current.memoizedProps;</span>
              <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>
              <span class="s1">startPhaseTimer(finishedWork, </span><span class="s2">'getSnapshotBeforeUpdate'</span><span class="s1">);</span>
              <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode; </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>

              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                  <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s2">'getSnapshotBeforeUpdate. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s2">'getSnapshotBeforeUpdate. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s3">var </span><span class="s1">snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);</span>

              <span class="s1">{</span>
                <span class="s3">var </span><span class="s1">didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;</span>

                <span class="s3">if </span><span class="s1">(snapshot === undefined &amp;&amp; !didWarnSet.has(finishedWork.type)) {</span>
                  <span class="s1">didWarnSet.add(finishedWork.type);</span>

                  <span class="s1">error(</span><span class="s2">'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' </span><span class="s1">+ </span><span class="s2">'must be returned. You have returned undefined.'</span><span class="s1">, getComponentName(finishedWork.type));</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span>
              <span class="s1">stopPhaseTimer();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
      <span class="s3">case </span><span class="s1">HostText:</span>
      <span class="s3">case </span><span class="s1">HostPortal:</span>
      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s0">// Nothing to do for these component types</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitHookEffectListUnmount(tag, finishedWork) {</span>
    <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
    <span class="s3">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s3">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
      <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((effect.tag &amp; tag) === tag) {</span>
          <span class="s0">// Unmount</span>
          <span class="s3">var </span><span class="s1">destroy = effect.destroy;</span>
          <span class="s1">effect.destroy = undefined;</span>

          <span class="s3">if </span><span class="s1">(destroy !== undefined) {</span>
            <span class="s1">destroy();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">effect = effect.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitHookEffectListMount(tag, finishedWork) {</span>
    <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>
    <span class="s3">var </span><span class="s1">lastEffect = updateQueue !== </span><span class="s3">null </span><span class="s1">? updateQueue.lastEffect : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>
      <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((effect.tag &amp; tag) === tag) {</span>
          <span class="s0">// Mount</span>
          <span class="s3">var </span><span class="s1">create = effect.create;</span>
          <span class="s1">effect.destroy = create();</span>

          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">destroy = effect.destroy;</span>

            <span class="s3">if </span><span class="s1">(destroy !== undefined &amp;&amp; </span><span class="s3">typeof </span><span class="s1">destroy !== </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">addendum = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s3">if </span><span class="s1">(destroy === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">addendum = </span><span class="s2">' You returned null. If your effect does not require clean ' </span><span class="s1">+ </span><span class="s2">'up, return undefined (or nothing).'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">destroy.then === </span><span class="s2">'function'</span><span class="s1">) {</span>
                <span class="s1">addendum = </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">It looks like you wrote useEffect(async () =&gt; ...) or returned a Promise. ' </span><span class="s1">+ </span><span class="s2">'Instead, write the async function inside your effect ' </span><span class="s1">+ </span><span class="s2">'and call it immediately:</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'useEffect(() =&gt; {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  async function fetchData() {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    // You can await here</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    const response = await MyAPI.getData(someId);</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    // ...</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  }</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  fetchData();</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching'</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">addendum = </span><span class="s2">' You returned: ' </span><span class="s1">+ destroy;</span>
              <span class="s1">}</span>

              <span class="s1">error(</span><span class="s2">'An effect function must not return anything besides a function, ' </span><span class="s1">+ </span><span class="s2">'which is used for clean-up.%s%s'</span><span class="s1">, addendum, getStackByFiberInDevAndProd(finishedWork));</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">effect = effect.next;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitPassiveHookEffects(finishedWork) {</span>
    <span class="s3">if </span><span class="s1">((finishedWork.effectTag &amp; Passive) !== NoEffect) {</span>
      <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s3">case </span><span class="s1">ForwardRef:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
        <span class="s3">case </span><span class="s1">Block:</span>
          <span class="s1">{</span>
            <span class="s0">// TODO (#17945) We should call all passive destroy functions (for all fibers)</span>
            <span class="s0">// before calling any create functions. The current approach only serializes</span>
            <span class="s0">// these for a single fiber.</span>
            <span class="s1">commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork);</span>
            <span class="s1">commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitLifeCycles(finishedRoot, current, finishedWork, committedExpirationTime) {</span>
    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">Block:</span>
        <span class="s1">{</span>
          <span class="s0">// At this point layout effects have already been destroyed (during mutation phase).</span>
          <span class="s0">// This is done to prevent sibling component effects from interfering with each other,</span>
          <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
          <span class="s0">// by a create function in another component during the same commit.</span>
          <span class="s1">commitHookEffectListMount(Layout | HasEffect, finishedWork);</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode;</span>

          <span class="s3">if </span><span class="s1">(finishedWork.effectTag &amp; Update) {</span>
            <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">startPhaseTimer(finishedWork, </span><span class="s2">'componentDidMount'</span><span class="s1">); </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>

              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                  <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s2">'componentDidMount. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s2">'componentDidMount. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">instance.componentDidMount();</span>
              <span class="s1">stopPhaseTimer();</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">var </span><span class="s1">prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);</span>
              <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>
              <span class="s1">startPhaseTimer(finishedWork, </span><span class="s2">'componentDidUpdate'</span><span class="s1">); </span><span class="s0">// We could update instance props and state here,</span>
              <span class="s0">// but instead we rely on them being set during last render.</span>
              <span class="s0">// TODO: revisit this when we implement resuming.</span>

              <span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                  <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s2">'componentDidUpdate. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                    <span class="s1">error(</span><span class="s2">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s2">'componentDidUpdate. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);</span>
              <span class="s1">stopPhaseTimer();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">updateQueue = finishedWork.updateQueue;</span>

          <span class="s3">if </span><span class="s1">(updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(finishedWork.type === finishedWork.elementType &amp;&amp; !didWarnAboutReassigningProps) {</span>
                <span class="s3">if </span><span class="s1">(instance.props !== finishedWork.memoizedProps) {</span>
                  <span class="s1">error(</span><span class="s2">'Expected %s props to match memoized props before ' </span><span class="s1">+ </span><span class="s2">'processing the update queue. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(instance.state !== finishedWork.memoizedState) {</span>
                  <span class="s1">error(</span><span class="s2">'Expected %s state to match memoized state before ' </span><span class="s1">+ </span><span class="s2">'processing the update queue. ' </span><span class="s1">+ </span><span class="s2">'This might either be because of a bug in React, or because ' </span><span class="s1">+ </span><span class="s2">'a component reassigns its own `this.props`. ' </span><span class="s1">+ </span><span class="s2">'Please file an issue.'</span><span class="s1">, getComponentName(finishedWork.type) || </span><span class="s2">'instance'</span><span class="s1">);</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s0">// We could update instance props and state here,</span>
            <span class="s0">// but instead we rely on them being set during last render.</span>
            <span class="s0">// TODO: revisit this when we implement resuming.</span>


            <span class="s1">commitUpdateQueue(finishedWork, updateQueue, instance);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_updateQueue = finishedWork.updateQueue;</span>

          <span class="s3">if </span><span class="s1">(_updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">_instance = </span><span class="s3">null</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(finishedWork.child !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">switch </span><span class="s1">(finishedWork.child.tag) {</span>
                <span class="s3">case </span><span class="s1">HostComponent:</span>
                  <span class="s1">_instance = getPublicInstance(finishedWork.child.stateNode);</span>
                  <span class="s3">break</span><span class="s1">;</span>

                <span class="s3">case </span><span class="s1">ClassComponent:</span>
                  <span class="s1">_instance = finishedWork.child.stateNode;</span>
                  <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">commitUpdateQueue(finishedWork, _updateQueue, _instance);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">_instance2 = finishedWork.stateNode; </span><span class="s0">// Renderers may schedule work to be done after host components are mounted</span>
          <span class="s0">// (eg DOM renderer may schedule auto-focus for inputs and form controls).</span>
          <span class="s0">// These effects should only be committed when components are first mounted,</span>
          <span class="s0">// aka when there is no current/alternate.</span>

          <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null </span><span class="s1">&amp;&amp; finishedWork.effectTag &amp; Update) {</span>
            <span class="s3">var </span><span class="s1">type = finishedWork.type;</span>
            <span class="s3">var </span><span class="s1">props = finishedWork.memoizedProps;</span>
            <span class="s1">commitMount(_instance2, type, props);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s0">// We have no life-cycles associated with text.</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">{</span>
          <span class="s0">// We have no life-cycles associated with portals.</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">Profiler:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">onRender = finishedWork.memoizedProps.onRender;</span>

            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onRender === </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s1">{</span>
                <span class="s1">onRender(finishedWork.memoizedProps.id, current === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">'mount' </span><span class="s1">: </span><span class="s2">'update'</span><span class="s1">, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
      <span class="s3">case </span><span class="s1">FundamentalComponent:</span>
      <span class="s3">case </span><span class="s1">ScopeComponent:</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">hideOrUnhideAllChildren(finishedWork, isHidden) {</span>
    <span class="s1">{</span>
      <span class="s0">// We only have the top Fiber that was inserted but we need to recurse down its</span>
      <span class="s0">// children to find all the terminal nodes.</span>
      <span class="s3">var </span><span class="s1">node = finishedWork;</span>

      <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.tag === HostComponent) {</span>
          <span class="s3">var </span><span class="s1">instance = node.stateNode;</span>

          <span class="s3">if </span><span class="s1">(isHidden) {</span>
            <span class="s1">hideInstance(instance);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">unhideInstance(node.stateNode, node.memoizedProps);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostText) {</span>
          <span class="s3">var </span><span class="s1">_instance3 = node.stateNode;</span>

          <span class="s3">if </span><span class="s1">(isHidden) {</span>
            <span class="s1">hideTextInstance(_instance3);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">unhideTextInstance(_instance3, node.memoizedProps);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === SuspenseComponent &amp;&amp; node.memoizedState !== </span><span class="s3">null </span><span class="s1">&amp;&amp; node.memoizedState.dehydrated === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Found a nested Suspense component that timed out. Skip over the</span>
          <span class="s0">// primary child fragment, which should remain hidden.</span>
          <span class="s3">var </span><span class="s1">fallbackChildFragment = node.child.sibling;</span>
          <span class="s1">fallbackChildFragment.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = fallbackChildFragment;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node === finishedWork) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== finishedWork) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">node = node.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitAttachRef(finishedWork) {</span>
    <span class="s3">var </span><span class="s1">ref = finishedWork.ref;</span>

    <span class="s3">if </span><span class="s1">(ref !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode;</span>
      <span class="s3">var </span><span class="s1">instanceToUse;</span>

      <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
        <span class="s3">case </span><span class="s1">HostComponent:</span>
          <span class="s1">instanceToUse = getPublicInstance(instance);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">instanceToUse = instance;</span>
      <span class="s1">} </span><span class="s0">// Moved outside to ensure DCE works with this flag</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ref === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">ref(instanceToUse);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(!ref.hasOwnProperty(</span><span class="s2">'current'</span><span class="s1">)) {</span>
            <span class="s1">error(</span><span class="s2">'Unexpected ref object provided for %s. ' </span><span class="s1">+ </span><span class="s2">'Use either a ref-setter function or React.createRef().%s'</span><span class="s1">, getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">ref.current = instanceToUse;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitDetachRef(current) {</span>
    <span class="s3">var </span><span class="s1">currentRef = current.ref;</span>

    <span class="s3">if </span><span class="s1">(currentRef !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">currentRef === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">currentRef(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">currentRef.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// User-originating errors (lifecycles and refs) should not interrupt</span>
  <span class="s0">// deletion, so don't let them throw. Host-originating errors should</span>
  <span class="s0">// interrupt deletion, so it's okay</span>


  <span class="s3">function </span><span class="s1">commitUnmount(finishedRoot, current, renderPriorityLevel) {</span>
    <span class="s1">onCommitUnmount(current);</span>

    <span class="s3">switch </span><span class="s1">(current.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">MemoComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">Block:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">updateQueue = current.updateQueue;</span>

          <span class="s3">if </span><span class="s1">(updateQueue !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">lastEffect = updateQueue.lastEffect;</span>

            <span class="s3">if </span><span class="s1">(lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">firstEffect = lastEffect.next;</span>

              <span class="s1">{</span>
                <span class="s0">// When the owner fiber is deleted, the destroy function of a passive</span>
                <span class="s0">// effect hook is called during the synchronous commit phase. This is</span>
                <span class="s0">// a concession to implementation complexity. Calling it in the</span>
                <span class="s0">// passive effect phase (like they usually are, when dependencies</span>
                <span class="s0">// change during an update) would require either traversing the</span>
                <span class="s0">// children of the deleted fiber again, or including unmount effects</span>
                <span class="s0">// as part of the fiber effect list.</span>
                <span class="s0">//</span>
                <span class="s0">// Because this is during the sync commit phase, we need to change</span>
                <span class="s0">// the priority.</span>
                <span class="s0">//</span>
                <span class="s0">// TODO: Reconsider this implementation trade off.</span>
                <span class="s3">var </span><span class="s1">priorityLevel = renderPriorityLevel &gt; NormalPriority ? NormalPriority : renderPriorityLevel;</span>
                <span class="s1">runWithPriority$1(priorityLevel, </span><span class="s3">function </span><span class="s1">() {</span>
                  <span class="s3">var </span><span class="s1">effect = firstEffect;</span>

                  <span class="s3">do </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">_destroy = effect.destroy;</span>

                    <span class="s3">if </span><span class="s1">(_destroy !== undefined) {</span>
                      <span class="s1">safelyCallDestroy(current, _destroy);</span>
                    <span class="s1">}</span>

                    <span class="s1">effect = effect.next;</span>
                  <span class="s1">} </span><span class="s3">while </span><span class="s1">(effect !== firstEffect);</span>
                <span class="s1">});</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s1">safelyDetachRef(current);</span>
          <span class="s3">var </span><span class="s1">instance = current.stateNode;</span>

          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">instance.componentWillUnmount === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">safelyCallComponentWillUnmount(current, instance);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>

          <span class="s1">safelyDetachRef(current);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">{</span>
          <span class="s0">// TODO: this is recursive.</span>
          <span class="s0">// We are also not using this parent because</span>
          <span class="s0">// the portal will get pushed immediately.</span>
          <span class="s1">{</span>
            <span class="s1">unmountHostComponents(finishedRoot, current, renderPriorityLevel);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">FundamentalComponent:</span>
        <span class="s1">{</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">DehydratedFragment:</span>
        <span class="s1">{</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ScopeComponent:</span>
        <span class="s1">{</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {</span>
    <span class="s0">// While we're inside a removed host node we don't want to call</span>
    <span class="s0">// removeChild on the inner nodes because they're removed by the top</span>
    <span class="s0">// call anyway. We also want to call componentWillUnmount on all</span>
    <span class="s0">// composites before this host node is removed from the tree. Therefore</span>
    <span class="s0">// we do an inner loop while we're still inside the host node.</span>
    <span class="s3">var </span><span class="s1">node = root;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s1">commitUnmount(finishedRoot, node, renderPriorityLevel); </span><span class="s0">// Visit children because they may contain more composite or host nodes.</span>
      <span class="s0">// Skip portals because commitUnmount() currently visits them recursively.</span>

      <span class="s3">if </span><span class="s1">(node.child !== </span><span class="s3">null </span><span class="s1">&amp;&amp; ( </span><span class="s0">// If we use mutation we drill down into portals using commitUnmount above.</span>
      <span class="s0">// If we don't use mutation we drill down into portals here instead.</span>
       <span class="s1">node.tag !== HostPortal)) {</span>
        <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
        <span class="s1">node = node.child;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === root) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== root) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">detachFiber(current) {</span>
    <span class="s3">var </span><span class="s1">alternate = current.alternate; </span><span class="s0">// Cut off the return pointers to disconnect it from the tree. Ideally, we</span>
    <span class="s0">// should clear the child pointer of the parent alternate to let this</span>
    <span class="s0">// get GC:ed but we don't know which for sure which parent is the current</span>
    <span class="s0">// one so we'll settle for GC:ing the subtree of this child. This child</span>
    <span class="s0">// itself will be GC:ed when the parent updates the next time.</span>

    <span class="s1">current.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.child = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.alternate = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.firstEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.pendingProps = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">current.stateNode = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">detachFiber(alternate);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getHostParentFiber(fiber) {</span>
    <span class="s3">var </span><span class="s1">parent = fiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(parent !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isHostParent(parent)) {</span>
        <span class="s3">return </span><span class="s1">parent;</span>
      <span class="s1">}</span>

      <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isHostParent(fiber) {</span>
    <span class="s3">return </span><span class="s1">fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getHostSibling(fiber) {</span>
    <span class="s0">// We're going to search forward into the tree until we find a sibling host</span>
    <span class="s0">// node. Unfortunately, if multiple insertions are done in a row we have to</span>
    <span class="s0">// search past them. This leads to exponential search for the next sibling.</span>
    <span class="s0">// TODO: Find a more efficient way to do this.</span>
    <span class="s3">var </span><span class="s1">node = fiber;</span>

    <span class="s1">siblings: </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s0">// If we didn't find anything, let's try the next sibling.</span>
      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| isHostParent(node.</span><span class="s3">return</span><span class="s1">)) {</span>
          <span class="s0">// If we pop out of the root or hit the parent the fiber we are the</span>
          <span class="s0">// last sibling.</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>

      <span class="s3">while </span><span class="s1">(node.tag !== HostComponent &amp;&amp; node.tag !== HostText &amp;&amp; node.tag !== DehydratedFragment) {</span>
        <span class="s0">// If it is not host node and, we might have a host node inside it.</span>
        <span class="s0">// Try to search down until we find one.</span>
        <span class="s3">if </span><span class="s1">(node.effectTag &amp; Placement) {</span>
          <span class="s0">// If we don't have a child, try the siblings instead.</span>
          <span class="s3">continue </span><span class="s1">siblings;</span>
        <span class="s1">} </span><span class="s0">// If we don't have a child, try the siblings instead.</span>
        <span class="s0">// We also skip portals because they are not part of this host tree.</span>


        <span class="s3">if </span><span class="s1">(node.child === </span><span class="s3">null </span><span class="s1">|| node.tag === HostPortal) {</span>
          <span class="s3">continue </span><span class="s1">siblings;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Check if this host node is stable or about to be placed.</span>


      <span class="s3">if </span><span class="s1">(!(node.effectTag &amp; Placement)) {</span>
        <span class="s0">// Found it!</span>
        <span class="s3">return </span><span class="s1">node.stateNode;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitPlacement(finishedWork) {</span>


    <span class="s3">var </span><span class="s1">parentFiber = getHostParentFiber(finishedWork); </span><span class="s0">// Note: these two variables *must* always be updated together.</span>

    <span class="s3">var </span><span class="s1">parent;</span>
    <span class="s3">var </span><span class="s1">isContainer;</span>
    <span class="s3">var </span><span class="s1">parentStateNode = parentFiber.stateNode;</span>

    <span class="s3">switch </span><span class="s1">(parentFiber.tag) {</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">parent = parentStateNode;</span>
        <span class="s1">isContainer = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">parent = parentStateNode.containerInfo;</span>
        <span class="s1">isContainer = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">HostPortal:</span>
        <span class="s1">parent = parentStateNode.containerInfo;</span>
        <span class="s1">isContainer = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">FundamentalComponent:</span>

      <span class="s0">// eslint-disable-next-line-no-fallthrough</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(parentFiber.effectTag &amp; ContentReset) {</span>
      <span class="s0">// Reset the text content of the parent before doing any insertions</span>
      <span class="s1">resetTextContent(parent); </span><span class="s0">// Clear ContentReset from the effect tag</span>

      <span class="s1">parentFiber.effectTag &amp;= ~ContentReset;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">before = getHostSibling(finishedWork); </span><span class="s0">// We only have the top Fiber that was inserted but we need to recurse down its</span>
    <span class="s0">// children to find all the terminal nodes.</span>

    <span class="s3">if </span><span class="s1">(isContainer) {</span>
      <span class="s1">insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">insertOrAppendPlacementNode(finishedWork, before, parent);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">insertOrAppendPlacementNodeIntoContainer(node, before, parent) {</span>
    <span class="s3">var </span><span class="s1">tag = node.tag;</span>
    <span class="s3">var </span><span class="s1">isHost = tag === HostComponent || tag === HostText;</span>

    <span class="s3">if </span><span class="s1">(isHost || enableFundamentalAPI ) {</span>
      <span class="s3">var </span><span class="s1">stateNode = isHost ? node.stateNode : node.stateNode.instance;</span>

      <span class="s3">if </span><span class="s1">(before) {</span>
        <span class="s1">insertInContainerBefore(parent, stateNode, before);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">appendChildToContainer(parent, stateNode);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tag === HostPortal) ; </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">child = node.child;</span>

      <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">insertOrAppendPlacementNodeIntoContainer(child, before, parent);</span>
        <span class="s3">var </span><span class="s1">sibling = child.sibling;</span>

        <span class="s3">while </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);</span>
          <span class="s1">sibling = sibling.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">insertOrAppendPlacementNode(node, before, parent) {</span>
    <span class="s3">var </span><span class="s1">tag = node.tag;</span>
    <span class="s3">var </span><span class="s1">isHost = tag === HostComponent || tag === HostText;</span>

    <span class="s3">if </span><span class="s1">(isHost || enableFundamentalAPI ) {</span>
      <span class="s3">var </span><span class="s1">stateNode = isHost ? node.stateNode : node.stateNode.instance;</span>

      <span class="s3">if </span><span class="s1">(before) {</span>
        <span class="s1">insertBefore(parent, stateNode, before);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">appendChild(parent, stateNode);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tag === HostPortal) ; </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">child = node.child;</span>

      <span class="s3">if </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">insertOrAppendPlacementNode(child, before, parent);</span>
        <span class="s3">var </span><span class="s1">sibling = child.sibling;</span>

        <span class="s3">while </span><span class="s1">(sibling !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">insertOrAppendPlacementNode(sibling, before, parent);</span>
          <span class="s1">sibling = sibling.sibling;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unmountHostComponents(finishedRoot, current, renderPriorityLevel) {</span>
    <span class="s0">// We only have the top Fiber that was deleted but we need to recurse down its</span>
    <span class="s0">// children to find all the terminal nodes.</span>
    <span class="s3">var </span><span class="s1">node = current; </span><span class="s0">// Each iteration, currentParent is populated with node's host parent if not</span>
    <span class="s0">// currentParentIsValid.</span>

    <span class="s3">var </span><span class="s1">currentParentIsValid = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// Note: these two variables *must* always be updated together.</span>

    <span class="s3">var </span><span class="s1">currentParent;</span>
    <span class="s3">var </span><span class="s1">currentParentIsContainer;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(!currentParentIsValid) {</span>
        <span class="s3">var </span><span class="s1">parent = node.</span><span class="s3">return</span><span class="s1">;</span>

        <span class="s1">findParent: </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(!(parent !== </span><span class="s3">null</span><span class="s1">)) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">parentStateNode = parent.stateNode;</span>

          <span class="s3">switch </span><span class="s1">(parent.tag) {</span>
            <span class="s3">case </span><span class="s1">HostComponent:</span>
              <span class="s1">currentParent = parentStateNode;</span>
              <span class="s1">currentParentIsContainer = </span><span class="s3">false</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">findParent;</span>

            <span class="s3">case </span><span class="s1">HostRoot:</span>
              <span class="s1">currentParent = parentStateNode.containerInfo;</span>
              <span class="s1">currentParentIsContainer = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">findParent;</span>

            <span class="s3">case </span><span class="s1">HostPortal:</span>
              <span class="s1">currentParent = parentStateNode.containerInfo;</span>
              <span class="s1">currentParentIsContainer = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s3">break </span><span class="s1">findParent;</span>

          <span class="s1">}</span>

          <span class="s1">parent = parent.</span><span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">currentParentIsValid = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node.tag === HostComponent || node.tag === HostText) {</span>
        <span class="s1">commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); </span><span class="s0">// After all the children have unmounted, it is now safe to remove the</span>
        <span class="s0">// node from the tree.</span>

        <span class="s3">if </span><span class="s1">(currentParentIsContainer) {</span>
          <span class="s1">removeChildFromContainer(currentParent, node.stateNode);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">removeChild(currentParent, node.stateNode);</span>
        <span class="s1">} </span><span class="s0">// Don't visit children because we already visited them.</span>

      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.tag === HostPortal) {</span>
        <span class="s3">if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// When we go into a portal, it becomes the parent to remove from.</span>
          <span class="s0">// We will reassign it back when we pop the portal on the way up.</span>
          <span class="s1">currentParent = node.stateNode.containerInfo;</span>
          <span class="s1">currentParentIsContainer = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Visit children because portals might contain host components.</span>

          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">commitUnmount(finishedRoot, node, renderPriorityLevel); </span><span class="s0">// Visit children because we may find more host components below.</span>

        <span class="s3">if </span><span class="s1">(node.child !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">node.child.</span><span class="s3">return </span><span class="s1">= node;</span>
          <span class="s1">node = node.child;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(node === current) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">while </span><span class="s1">(node.sibling === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| node.</span><span class="s3">return </span><span class="s1">=== current) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(node.tag === HostPortal) {</span>
          <span class="s0">// When we go out of the portal, we need to restore the parent.</span>
          <span class="s0">// Since we don't keep a stack of them, we will search for it.</span>
          <span class="s1">currentParentIsValid = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node.sibling.</span><span class="s3">return </span><span class="s1">= node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">node = node.sibling;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitDeletion(finishedRoot, current, renderPriorityLevel) {</span>
    <span class="s1">{</span>
      <span class="s0">// Recursively delete all host nodes from the parent.</span>
      <span class="s0">// Detach refs and call componentWillUnmount() on the whole subtree.</span>
      <span class="s1">unmountHostComponents(finishedRoot, current, renderPriorityLevel);</span>
    <span class="s1">}</span>

    <span class="s1">detachFiber(current);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitWork(current, finishedWork) {</span>

    <span class="s3">switch </span><span class="s1">(finishedWork.tag) {</span>
      <span class="s3">case </span><span class="s1">FunctionComponent:</span>
      <span class="s3">case </span><span class="s1">ForwardRef:</span>
      <span class="s3">case </span><span class="s1">MemoComponent:</span>
      <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
      <span class="s3">case </span><span class="s1">Block:</span>
        <span class="s1">{</span>
          <span class="s0">// Layout effects are destroyed during the mutation phase so that all</span>
          <span class="s0">// destroy functions for all fibers are called before any create functions.</span>
          <span class="s0">// This prevents sibling component effects from interfering with each other,</span>
          <span class="s0">// e.g. a destroy function in one component should never override a ref set</span>
          <span class="s0">// by a create function in another component during the same commit.</span>
          <span class="s1">commitHookEffectListUnmount(Layout | HasEffect, finishedWork);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">ClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">instance = finishedWork.stateNode;</span>

          <span class="s3">if </span><span class="s1">(instance != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Commit the work prepared earlier.</span>
            <span class="s3">var </span><span class="s1">newProps = finishedWork.memoizedProps; </span><span class="s0">// For hydration we reuse the update path but we treat the oldProps</span>
            <span class="s0">// as the newProps. The updatePayload will contain the real change in</span>
            <span class="s0">// this case.</span>

            <span class="s3">var </span><span class="s1">oldProps = current !== </span><span class="s3">null </span><span class="s1">? current.memoizedProps : newProps;</span>
            <span class="s3">var </span><span class="s1">type = finishedWork.type; </span><span class="s0">// TODO: Type the updateQueue to be specific to host components.</span>

            <span class="s3">var </span><span class="s1">updatePayload = finishedWork.updateQueue;</span>
            <span class="s1">finishedWork.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(updatePayload !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">commitUpdate(instance, updatePayload, type, oldProps, newProps);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostText:</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(!(finishedWork.stateNode !== </span><span class="s3">null</span><span class="s1">)) {</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">textInstance = finishedWork.stateNode;</span>
          <span class="s3">var </span><span class="s1">newText = finishedWork.memoizedProps; </span><span class="s0">// For hydration we reuse the update path but we treat the oldProps</span>
          <span class="s0">// as the newProps. The updatePayload will contain the real change in</span>
          <span class="s0">// this case.</span>

          <span class="s3">var </span><span class="s1">oldText = current !== </span><span class="s3">null </span><span class="s1">? current.memoizedProps : newText;</span>
          <span class="s1">commitTextUpdate(textInstance, oldText, newText);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">HostRoot:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">_root = finishedWork.stateNode;</span>

            <span class="s3">if </span><span class="s1">(_root.hydrate) {</span>
              <span class="s0">// We've just hydrated. No need to hydrate again.</span>
              <span class="s1">_root.hydrate = </span><span class="s3">false</span><span class="s1">;</span>
              <span class="s1">commitHydratedContainer(_root.containerInfo);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">Profiler:</span>
        <span class="s1">{</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseComponent:</span>
        <span class="s1">{</span>
          <span class="s1">commitSuspenseComponent(finishedWork);</span>
          <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">SuspenseListComponent:</span>
        <span class="s1">{</span>
          <span class="s1">attachSuspenseRetryListeners(finishedWork);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">IncompleteClassComponent:</span>
        <span class="s1">{</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitSuspenseComponent(finishedWork) {</span>
    <span class="s3">var </span><span class="s1">newState = finishedWork.memoizedState;</span>
    <span class="s3">var </span><span class="s1">newDidTimeout;</span>
    <span class="s3">var </span><span class="s1">primaryChildParent = finishedWork;</span>

    <span class="s3">if </span><span class="s1">(newState === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">newDidTimeout = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">newDidTimeout = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">primaryChildParent = finishedWork.child;</span>
      <span class="s1">markCommitTimeOfFallback();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">( primaryChildParent !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {</span>

    <span class="s3">var </span><span class="s1">newState = finishedWork.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(newState === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">current = finishedWork.alternate;</span>

      <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevState = current.memoizedState;</span>

        <span class="s3">if </span><span class="s1">(prevState !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">suspenseInstance = prevState.dehydrated;</span>

          <span class="s3">if </span><span class="s1">(suspenseInstance !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">commitHydratedSuspenseInstance(suspenseInstance);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">attachSuspenseRetryListeners(finishedWork) {</span>
    <span class="s0">// If this boundary just timed out, then it will have a set of thenables.</span>
    <span class="s0">// For each thenable, attach a listener so that when it resolves, React</span>
    <span class="s0">// attempts to re-render the boundary in the primary (pre-timeout) state.</span>
    <span class="s3">var </span><span class="s1">thenables = finishedWork.updateQueue;</span>

    <span class="s3">if </span><span class="s1">(thenables !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">finishedWork.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">retryCache = finishedWork.stateNode;</span>

      <span class="s3">if </span><span class="s1">(retryCache === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">retryCache = finishedWork.stateNode = </span><span class="s3">new </span><span class="s1">PossiblyWeakSet();</span>
      <span class="s1">}</span>

      <span class="s1">thenables.forEach(</span><span class="s3">function </span><span class="s1">(thenable) {</span>
        <span class="s0">// Memoize using the boundary fiber to prevent redundant listeners.</span>
        <span class="s3">var </span><span class="s1">retry = resolveRetryThenable.bind(</span><span class="s3">null</span><span class="s1">, finishedWork, thenable);</span>

        <span class="s3">if </span><span class="s1">(!retryCache.has(thenable)) {</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(thenable.__reactDoNotTraceInteractions !== </span><span class="s3">true</span><span class="s1">) {</span>
              <span class="s1">retry = unstable_wrap(retry);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">retryCache.add(thenable);</span>
          <span class="s1">thenable.then(retry, retry);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitResetTextContent(current) {</span>

    <span class="s1">resetTextContent(current.stateNode);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">PossiblyWeakMap$1 = </span><span class="s3">typeof </span><span class="s1">WeakMap === </span><span class="s2">'function' </span><span class="s1">? WeakMap : Map;</span>

  <span class="s3">function </span><span class="s1">createRootErrorUpdate(fiber, errorInfo, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, </span><span class="s3">null</span><span class="s1">); </span><span class="s0">// Unmount the root by rendering null.</span>

    <span class="s1">update.tag = CaptureUpdate; </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
    <span class="s0">// being called &quot;element&quot;.</span>

    <span class="s1">update.payload = {</span>
      <span class="s1">element: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">error = errorInfo.value;</span>

    <span class="s1">update.callback = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">onUncaughtError(error);</span>
      <span class="s1">logError(fiber, errorInfo);</span>
    <span class="s1">};</span>

    <span class="s3">return </span><span class="s1">update;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createClassErrorUpdate(fiber, errorInfo, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">update.tag = CaptureUpdate;</span>
    <span class="s3">var </span><span class="s1">getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">error$1 = errorInfo.value;</span>

      <span class="s1">update.payload = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">logError(fiber, errorInfo);</span>
        <span class="s3">return </span><span class="s1">getDerivedStateFromError(error$1);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">inst = fiber.stateNode;</span>

    <span class="s3">if </span><span class="s1">(inst !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">inst.componentDidCatch === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">update.callback = </span><span class="s3">function </span><span class="s1">callback() {</span>
        <span class="s1">{</span>
          <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// To preserve the preexisting retry behavior of error boundaries,</span>
          <span class="s0">// we keep track of which ones already failed during this batch.</span>
          <span class="s0">// This gets reset before we yield back to the browser.</span>
          <span class="s0">// TODO: Warn in strict mode if getDerivedStateFromError is</span>
          <span class="s0">// not defined.</span>
          <span class="s1">markLegacyErrorBoundaryAsFailed(</span><span class="s3">this</span><span class="s1">); </span><span class="s0">// Only log here if componentDidCatch is the only error boundary method defined</span>

          <span class="s1">logError(fiber, errorInfo);</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">error$1 = errorInfo.value;</span>
        <span class="s3">var </span><span class="s1">stack = errorInfo.stack;</span>
        <span class="s3">this</span><span class="s1">.componentDidCatch(error$1, {</span>
          <span class="s1">componentStack: stack !== </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">''</span>
        <span class="s1">});</span>

        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">getDerivedStateFromError !== </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s0">// If componentDidCatch is the only error boundary method defined,</span>
            <span class="s0">// then it needs to call setState to recover from errors.</span>
            <span class="s0">// If no state update is scheduled then the boundary will swallow the error.</span>
            <span class="s3">if </span><span class="s1">(fiber.expirationTime !== Sync) {</span>
              <span class="s1">error(</span><span class="s2">'%s: Error boundaries should implement getDerivedStateFromError(). ' </span><span class="s1">+ </span><span class="s2">'In that method, return a state update to display an error message or fallback UI.'</span><span class="s1">, getComponentName(fiber.type) || </span><span class="s2">'Unknown'</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">update.callback = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">markFailedErrorBoundaryForHotReloading(fiber);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">update;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">attachPingListener(root, renderExpirationTime, thenable) {</span>
    <span class="s0">// Attach a listener to the promise to &quot;ping&quot; the root and retry. But</span>
    <span class="s0">// only if one does not already exist for the current render expiration</span>
    <span class="s0">// time (which acts like a &quot;thread ID&quot; here).</span>
    <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>
    <span class="s3">var </span><span class="s1">threadIDs;</span>

    <span class="s3">if </span><span class="s1">(pingCache === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">pingCache = root.pingCache = </span><span class="s3">new </span><span class="s1">PossiblyWeakMap$1();</span>
      <span class="s1">threadIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">pingCache.set(thenable, threadIDs);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">threadIDs = pingCache.get(thenable);</span>

      <span class="s3">if </span><span class="s1">(threadIDs === undefined) {</span>
        <span class="s1">threadIDs = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s1">pingCache.set(thenable, threadIDs);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!threadIDs.has(renderExpirationTime)) {</span>
      <span class="s0">// Memoize using the thread ID to prevent redundant listeners.</span>
      <span class="s1">threadIDs.add(renderExpirationTime);</span>
      <span class="s3">var </span><span class="s1">ping = pingSuspendedRoot.bind(</span><span class="s3">null</span><span class="s1">, root, thenable, renderExpirationTime);</span>
      <span class="s1">thenable.then(ping, ping);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {</span>
    <span class="s0">// The source fiber did not complete.</span>
    <span class="s1">sourceFiber.effectTag |= Incomplete; </span><span class="s0">// Its effect list is no longer valid.</span>

    <span class="s1">sourceFiber.firstEffect = sourceFiber.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">value === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">value.then === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s0">// This is a thenable.</span>
      <span class="s3">var </span><span class="s1">thenable = value;</span>

      <span class="s3">if </span><span class="s1">((sourceFiber.mode &amp; BlockingMode) === NoMode) {</span>
        <span class="s0">// Reset the memoizedState to what it was before we attempted</span>
        <span class="s0">// to render it.</span>
        <span class="s3">var </span><span class="s1">currentSource = sourceFiber.alternate;</span>

        <span class="s3">if </span><span class="s1">(currentSource) {</span>
          <span class="s1">sourceFiber.updateQueue = currentSource.updateQueue;</span>
          <span class="s1">sourceFiber.memoizedState = currentSource.memoizedState;</span>
          <span class="s1">sourceFiber.expirationTime = currentSource.expirationTime;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">sourceFiber.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">sourceFiber.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); </span><span class="s0">// Schedule the nearest Suspense to re-render the timed out view.</span>

      <span class="s3">var </span><span class="s1">_workInProgress = returnFiber;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(_workInProgress.tag === SuspenseComponent &amp;&amp; shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {</span>
          <span class="s0">// Found the nearest boundary.</span>
          <span class="s0">// Stash the promise on the boundary fiber. If the boundary times out, we'll</span>
          <span class="s0">// attach another listener to flip the boundary back to its normal state.</span>
          <span class="s3">var </span><span class="s1">thenables = _workInProgress.updateQueue;</span>

          <span class="s3">if </span><span class="s1">(thenables === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">updateQueue = </span><span class="s3">new </span><span class="s1">Set();</span>
            <span class="s1">updateQueue.add(thenable);</span>
            <span class="s1">_workInProgress.updateQueue = updateQueue;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">thenables.add(thenable);</span>
          <span class="s1">} </span><span class="s0">// If the boundary is outside of blocking mode, we should *not*</span>
          <span class="s0">// suspend the commit. Pretend as if the suspended component rendered</span>
          <span class="s0">// null and keep rendering. In the commit phase, we'll schedule a</span>
          <span class="s0">// subsequent synchronous update to re-render the Suspense.</span>
          <span class="s0">//</span>
          <span class="s0">// Note: It doesn't matter whether the component that suspended was</span>
          <span class="s0">// inside a blocking mode tree. If the Suspense is outside of it, we</span>
          <span class="s0">// should *not* suspend the commit.</span>


          <span class="s3">if </span><span class="s1">((_workInProgress.mode &amp; BlockingMode) === NoMode) {</span>
            <span class="s1">_workInProgress.effectTag |= DidCapture; </span><span class="s0">// We're going to commit this fiber even though it didn't complete.</span>
            <span class="s0">// But we shouldn't call any lifecycle methods or callbacks. Remove</span>
            <span class="s0">// all lifecycle effect tags.</span>

            <span class="s1">sourceFiber.effectTag &amp;= ~(LifecycleEffectMask | Incomplete);</span>

            <span class="s3">if </span><span class="s1">(sourceFiber.tag === ClassComponent) {</span>
              <span class="s3">var </span><span class="s1">currentSourceFiber = sourceFiber.alternate;</span>

              <span class="s3">if </span><span class="s1">(currentSourceFiber === </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s0">// This is a new mount. Change the tag so it's not mistaken for a</span>
                <span class="s0">// completed class component. For example, we should not call</span>
                <span class="s0">// componentWillUnmount if it is deleted.</span>
                <span class="s1">sourceFiber.tag = IncompleteClassComponent;</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s0">// When we try rendering again, we should not reuse the current fiber,</span>
                <span class="s0">// since it's known to be in an inconsistent state. Use a force update to</span>
                <span class="s0">// prevent a bail out.</span>
                <span class="s3">var </span><span class="s1">update = createUpdate(Sync, </span><span class="s3">null</span><span class="s1">);</span>
                <span class="s1">update.tag = ForceUpdate;</span>
                <span class="s1">enqueueUpdate(sourceFiber, update);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s0">// The source fiber did not complete. Mark it with Sync priority to</span>
            <span class="s0">// indicate that it still has pending work.</span>


            <span class="s1">sourceFiber.expirationTime = Sync; </span><span class="s0">// Exit without suspending.</span>

            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Confirmed that the boundary is in a concurrent mode tree. Continue</span>
          <span class="s0">// with the normal suspend path.</span>
          <span class="s0">//</span>
          <span class="s0">// After this we'll use a set of heuristics to determine whether this</span>
          <span class="s0">// render pass will run to completion or restart or &quot;suspend&quot; the commit.</span>
          <span class="s0">// The actual logic for this is spread out in different places.</span>
          <span class="s0">//</span>
          <span class="s0">// This first principle is that if we're going to suspend when we complete</span>
          <span class="s0">// a root, then we should also restart if we get an update or ping that</span>
          <span class="s0">// might unsuspend it, and vice versa. The only reason to suspend is</span>
          <span class="s0">// because you think you might want to restart before committing. However,</span>
          <span class="s0">// it doesn't make sense to restart only while in the period we're suspended.</span>
          <span class="s0">//</span>
          <span class="s0">// Restarting too aggressively is also not good because it starves out any</span>
          <span class="s0">// intermediate loading state. So we use heuristics to determine when.</span>
          <span class="s0">// Suspense Heuristics</span>
          <span class="s0">//</span>
          <span class="s0">// If nothing threw a Promise or all the same fallbacks are already showing,</span>
          <span class="s0">// then don't suspend/restart.</span>
          <span class="s0">//</span>
          <span class="s0">// If this is an initial render of a new tree of Suspense boundaries and</span>
          <span class="s0">// those trigger a fallback, then don't suspend/restart. We want to ensure</span>
          <span class="s0">// that we can show the initial loading state as quickly as possible.</span>
          <span class="s0">//</span>
          <span class="s0">// If we hit a &quot;Delayed&quot; case, such as when we'd switch from content back into</span>
          <span class="s0">// a fallback, then we should always suspend/restart. SuspenseConfig applies to</span>
          <span class="s0">// this case. If none is defined, JND is used instead.</span>
          <span class="s0">//</span>
          <span class="s0">// If we're already showing a fallback and it gets &quot;retried&quot;, allowing us to show</span>
          <span class="s0">// another level, but there's still an inner boundary that would show a fallback,</span>
          <span class="s0">// then we suspend/restart for 500ms since the last time we showed a fallback</span>
          <span class="s0">// anywhere in the tree. This effectively throttles progressive loading into a</span>
          <span class="s0">// consistent train of commits. This also gives us an opportunity to restart to</span>
          <span class="s0">// get to the completed state slightly earlier.</span>
          <span class="s0">//</span>
          <span class="s0">// If there's ambiguity due to batching it's resolved in preference of:</span>
          <span class="s0">// 1) &quot;delayed&quot;, 2) &quot;initial render&quot;, 3) &quot;retry&quot;.</span>
          <span class="s0">//</span>
          <span class="s0">// We want to ensure that a &quot;busy&quot; state doesn't get force committed. We want to</span>
          <span class="s0">// ensure that new initial loading states can commit as soon as possible.</span>


          <span class="s1">attachPingListener(root, renderExpirationTime, thenable);</span>
          <span class="s1">_workInProgress.effectTag |= ShouldCapture;</span>
          <span class="s1">_workInProgress.expirationTime = renderExpirationTime;</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// This boundary already captured during this render. Continue to the next</span>
        <span class="s0">// boundary.</span>


        <span class="s1">_workInProgress = _workInProgress.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(_workInProgress !== </span><span class="s3">null</span><span class="s1">); </span><span class="s0">// No boundary was found. Fallthrough to error mode.</span>
      <span class="s0">// TODO: Use invariant so the message is stripped in prod?</span>


      <span class="s1">value = </span><span class="s3">new </span><span class="s1">Error((getComponentName(sourceFiber.type) || </span><span class="s2">'A React component'</span><span class="s1">) + </span><span class="s2">' suspended while rendering, but no fallback UI was specified.</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'Add a &lt;Suspense fallback=...&gt; component higher in the tree to ' </span><span class="s1">+ </span><span class="s2">'provide a loading indicator or placeholder to display.' </span><span class="s1">+ getStackByFiberInDevAndProd(sourceFiber));</span>
    <span class="s1">} </span><span class="s0">// We didn't find a boundary that could handle this type of exception. Start</span>
    <span class="s0">// over and traverse parent path again, this time treating the exception</span>
    <span class="s0">// as an error.</span>


    <span class="s1">renderDidError();</span>
    <span class="s1">value = createCapturedValue(value, sourceFiber);</span>
    <span class="s3">var </span><span class="s1">workInProgress = returnFiber;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
        <span class="s3">case </span><span class="s1">HostRoot:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">_errorInfo = value;</span>
            <span class="s1">workInProgress.effectTag |= ShouldCapture;</span>
            <span class="s1">workInProgress.expirationTime = renderExpirationTime;</span>

            <span class="s3">var </span><span class="s1">_update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);</span>

            <span class="s1">enqueueCapturedUpdate(workInProgress, _update);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">ClassComponent:</span>
          <span class="s0">// Capture and retry</span>
          <span class="s3">var </span><span class="s1">errorInfo = value;</span>
          <span class="s3">var </span><span class="s1">ctor = workInProgress.type;</span>
          <span class="s3">var </span><span class="s1">instance = workInProgress.stateNode;</span>

          <span class="s3">if </span><span class="s1">((workInProgress.effectTag &amp; DidCapture) === NoEffect &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s2">'function' </span><span class="s1">|| instance !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance))) {</span>
            <span class="s1">workInProgress.effectTag |= ShouldCapture;</span>
            <span class="s1">workInProgress.expirationTime = renderExpirationTime; </span><span class="s0">// Schedule the error boundary to re-render using updated state</span>

            <span class="s3">var </span><span class="s1">_update2 = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);</span>

            <span class="s1">enqueueCapturedUpdate(workInProgress, _update2);</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress = workInProgress.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ceil = Math.ceil;</span>
  <span class="s3">var </span><span class="s1">ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,</span>
      <span class="s1">ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,</span>
      <span class="s1">IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;</span>
  <span class="s3">var </span><span class="s1">NoContext =</span>
  <span class="s0">/*                    */</span>
  <span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">BatchedContext =</span>
  <span class="s0">/*               */</span>
  <span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">EventContext =</span>
  <span class="s0">/*                 */</span>
  <span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">DiscreteEventContext =</span>
  <span class="s0">/*         */</span>
  <span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LegacyUnbatchedContext =</span>
  <span class="s0">/*       */</span>
  <span class="s4">8</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RenderContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">16</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">CommitContext =</span>
  <span class="s0">/*                */</span>
  <span class="s4">32</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootIncomplete = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootFatalErrored = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootErrored = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootSuspended = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootSuspendedWithDelay = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">RootCompleted = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s0">// Describes where we are in the React execution stack</span>
  <span class="s3">var </span><span class="s1">executionContext = NoContext; </span><span class="s0">// The root we're working on</span>

  <span class="s3">var </span><span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The fiber we're working on</span>

  <span class="s3">var </span><span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The expiration time we're rendering</span>

  <span class="s3">var </span><span class="s1">renderExpirationTime$1 = NoWork; </span><span class="s0">// Whether to root completed, errored, suspended, etc.</span>

  <span class="s3">var </span><span class="s1">workInProgressRootExitStatus = RootIncomplete; </span><span class="s0">// A fatal error, if one is thrown</span>

  <span class="s3">var </span><span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Most recent event time among processed updates during this render.</span>
  <span class="s0">// This is conceptually a time stamp but expressed in terms of an ExpirationTime</span>
  <span class="s0">// because we deal mostly with expiration times in the hot path, so this avoids</span>
  <span class="s0">// the conversion happening in the hot path.</span>

  <span class="s3">var </span><span class="s1">workInProgressRootLatestProcessedExpirationTime = Sync;</span>
  <span class="s3">var </span><span class="s1">workInProgressRootLatestSuspenseTimeout = Sync;</span>
  <span class="s3">var </span><span class="s1">workInProgressRootCanSuspendUsingConfig = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The work left over by components that were visited during this render. Only</span>
  <span class="s0">// includes unprocessed updates, not work in bailed out children.</span>

  <span class="s3">var </span><span class="s1">workInProgressRootNextUnprocessedUpdateTime = NoWork; </span><span class="s0">// If we're pinged while rendering we don't always restart immediately.</span>
  <span class="s0">// This flag determines if it might be worthwhile to restart if an opportunity</span>
  <span class="s0">// happens latere.</span>

  <span class="s3">var </span><span class="s1">workInProgressRootHasPendingPing = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// The most recent time we committed a fallback. This lets us ensure a train</span>
  <span class="s0">// model where we don't commit new loading states in too quick succession.</span>

  <span class="s3">var </span><span class="s1">globalMostRecentFallbackTime = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">FALLBACK_THROTTLE_MS = </span><span class="s4">500</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasUncaughtError = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">firstUncaughtError = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">pendingPassiveEffectsRenderPriority = NoPriority;</span>
  <span class="s3">var </span><span class="s1">pendingPassiveEffectsExpirationTime = NoWork;</span>
  <span class="s3">var </span><span class="s1">rootsWithPendingDiscreteUpdates = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Use these to prevent an infinite loop of nested updates</span>

  <span class="s3">var </span><span class="s1">NESTED_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">NESTED_PASSIVE_UPDATE_LIMIT = </span><span class="s4">50</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">interruptedBy = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Marks the need to reschedule pending interactions at these expiration times</span>
  <span class="s0">// during the commit phase. This enables them to be traced across components</span>
  <span class="s0">// that spawn new work during render. E.g. hidden boundaries, suspended SSR</span>
  <span class="s0">// hydration or SuspenseList.</span>

  <span class="s3">var </span><span class="s1">spawnedWorkDuringRender = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Expiration times are computed by adding to the current time (the start</span>
  <span class="s0">// time). However, if two updates are scheduled within the same event, we</span>
  <span class="s0">// should treat their start times as simultaneous, even if the actual clock</span>
  <span class="s0">// time has advanced between the first and second call.</span>
  <span class="s0">// In other words, because expiration times determine how updates are batched,</span>
  <span class="s0">// we want all updates of like priority that occur within the same event to</span>
  <span class="s0">// receive the same expiration time. Otherwise we get tearing.</span>

  <span class="s3">var </span><span class="s1">currentEventTime = NoWork;</span>
  <span class="s3">function </span><span class="s1">requestCurrentTimeForUpdate() {</span>
    <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s0">// We're inside React, so it's fine to read the actual time.</span>
      <span class="s3">return </span><span class="s1">msToExpirationTime(now());</span>
    <span class="s1">} </span><span class="s0">// We're not inside React, so we may be in the middle of a browser event.</span>


    <span class="s3">if </span><span class="s1">(currentEventTime !== NoWork) {</span>
      <span class="s0">// Use the same start time for all updates until we enter React again.</span>
      <span class="s3">return </span><span class="s1">currentEventTime;</span>
    <span class="s1">} </span><span class="s0">// This is the first update since React yielded. Compute a new start time.</span>


    <span class="s1">currentEventTime = msToExpirationTime(now());</span>
    <span class="s3">return </span><span class="s1">currentEventTime;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getCurrentTime() {</span>
    <span class="s3">return </span><span class="s1">msToExpirationTime(now());</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">computeExpirationForFiber(currentTime, fiber, suspenseConfig) {</span>
    <span class="s3">var </span><span class="s1">mode = fiber.mode;</span>

    <span class="s3">if </span><span class="s1">((mode &amp; BlockingMode) === NoMode) {</span>
      <span class="s3">return </span><span class="s1">Sync;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">priorityLevel = getCurrentPriorityLevel();</span>

    <span class="s3">if </span><span class="s1">((mode &amp; ConcurrentMode) === NoMode) {</span>
      <span class="s3">return </span><span class="s1">priorityLevel === ImmediatePriority ? Sync : Batched;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">((executionContext &amp; RenderContext) !== NoContext) {</span>
      <span class="s0">// Use whatever time we're already rendering</span>
      <span class="s0">// TODO: Should there be a way to opt out, like with `runWithPriority`?</span>
      <span class="s3">return </span><span class="s1">renderExpirationTime$1;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">expirationTime;</span>

    <span class="s3">if </span><span class="s1">(suspenseConfig !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Compute an expiration time based on the Suspense timeout.</span>
      <span class="s1">expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | </span><span class="s4">0 </span><span class="s1">|| LOW_PRIORITY_EXPIRATION);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Compute an expiration time based on the Scheduler priority.</span>
      <span class="s3">switch </span><span class="s1">(priorityLevel) {</span>
        <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
          <span class="s1">expirationTime = Sync;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">UserBlockingPriority$1:</span>
          <span class="s0">// TODO: Rename this to computeUserBlockingExpiration</span>
          <span class="s1">expirationTime = computeInteractiveExpiration(currentTime);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">NormalPriority:</span>
        <span class="s3">case </span><span class="s1">LowPriority:</span>
          <span class="s0">// TODO: Handle LowPriority</span>
          <span class="s0">// TODO: Rename this to... something better.</span>
          <span class="s1">expirationTime = computeAsyncExpiration(currentTime);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">IdlePriority:</span>
          <span class="s1">expirationTime = Idle;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Expected a valid priority level&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// If we're in the middle of rendering a tree, do not update at the same</span>
    <span class="s0">// expiration time that is already rendering.</span>
    <span class="s0">// TODO: We shouldn't have to do this if the update is on a different root.</span>
    <span class="s0">// Refactor computeExpirationForFiber + scheduleUpdate so we have access to</span>
    <span class="s0">// the root when we check for this condition.</span>


    <span class="s3">if </span><span class="s1">(workInProgressRoot !== </span><span class="s3">null </span><span class="s1">&amp;&amp; expirationTime === renderExpirationTime$1) {</span>
      <span class="s0">// This is a trick to move this update into a separate batch</span>
      <span class="s1">expirationTime -= </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">expirationTime;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">scheduleUpdateOnFiber(fiber, expirationTime) {</span>
    <span class="s1">checkForNestedUpdates();</span>
    <span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber);</span>
    <span class="s3">var </span><span class="s1">root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);</span>

    <span class="s3">if </span><span class="s1">(root === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">warnAboutUpdateOnUnmountedFiberInDEV(fiber);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">checkForInterruption(fiber, expirationTime);</span>
    <span class="s1">recordScheduleUpdate(); </span><span class="s0">// TODO: computeExpirationForFiber also reads the priority. Pass the</span>
    <span class="s0">// priority as an argument to that function and this one.</span>

    <span class="s3">var </span><span class="s1">priorityLevel = getCurrentPriorityLevel();</span>

    <span class="s3">if </span><span class="s1">(expirationTime === Sync) {</span>
      <span class="s3">if </span><span class="s1">( </span><span class="s0">// Check if we're inside unbatchedUpdates</span>
      <span class="s1">(executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; </span><span class="s0">// Check if we're not already rendering</span>
      <span class="s1">(executionContext &amp; (RenderContext | CommitContext)) === NoContext) {</span>
        <span class="s0">// Register pending interactions on the root to avoid losing traced interaction data.</span>
        <span class="s1">schedulePendingInteractions(root, expirationTime); </span><span class="s0">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span>
        <span class="s0">// root inside of batchedUpdates should be synchronous, but layout updates</span>
        <span class="s0">// should be deferred until the end of the batch.</span>

        <span class="s1">performSyncWorkOnRoot(root);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">ensureRootIsScheduled(root);</span>
        <span class="s1">schedulePendingInteractions(root, expirationTime);</span>

        <span class="s3">if </span><span class="s1">(executionContext === NoContext) {</span>
          <span class="s0">// Flush the synchronous work now, unless we're already working or inside</span>
          <span class="s0">// a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span>
          <span class="s0">// scheduleCallbackForFiber to preserve the ability to schedule a callback</span>
          <span class="s0">// without immediately flushing it. We only do this for user-initiated</span>
          <span class="s0">// updates, to preserve historical behavior of legacy mode.</span>
          <span class="s1">flushSyncCallbackQueue();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">ensureRootIsScheduled(root);</span>
      <span class="s1">schedulePendingInteractions(root, expirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">((executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; ( </span><span class="s0">// Only updates at user-blocking priority or greater are considered</span>
    <span class="s0">// discrete, even inside a discrete event.</span>
    <span class="s1">priorityLevel === UserBlockingPriority$1 || priorityLevel === ImmediatePriority)) {</span>
      <span class="s0">// This is the result of a discrete event. Track the lowest priority</span>
      <span class="s0">// discrete update per root so we can flush them early, if needed.</span>
      <span class="s3">if </span><span class="s1">(rootsWithPendingDiscreteUpdates === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">rootsWithPendingDiscreteUpdates = </span><span class="s3">new </span><span class="s1">Map([[root, expirationTime]]);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);</span>

        <span class="s3">if </span><span class="s1">(lastDiscreteTime === undefined || lastDiscreteTime &gt; expirationTime) {</span>
          <span class="s1">rootsWithPendingDiscreteUpdates.set(root, expirationTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">scheduleWork = scheduleUpdateOnFiber; </span><span class="s0">// This is split into a separate function so we can mark a fiber with pending</span>
  <span class="s0">// work without treating it as a typical update that originates from an event;</span>
  <span class="s0">// e.g. retrying a Suspense boundary isn't an update, but it does schedule work</span>
  <span class="s0">// on a fiber.</span>

  <span class="s3">function </span><span class="s1">markUpdateTimeFromFiberToRoot(fiber, expirationTime) {</span>
    <span class="s0">// Update the source fiber's expiration time</span>
    <span class="s3">if </span><span class="s1">(fiber.expirationTime &lt; expirationTime) {</span>
      <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.expirationTime &lt; expirationTime) {</span>
      <span class="s1">alternate.expirationTime = expirationTime;</span>
    <span class="s1">} </span><span class="s0">// Walk the parent path to the root and update the child expiration time.</span>


    <span class="s3">var </span><span class="s1">node = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">root = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(node === </span><span class="s3">null </span><span class="s1">&amp;&amp; fiber.tag === HostRoot) {</span>
      <span class="s1">root = fiber.stateNode;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">while </span><span class="s1">(node !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">alternate = node.alternate;</span>

        <span class="s3">if </span><span class="s1">(node.childExpirationTime &lt; expirationTime) {</span>
          <span class="s1">node.childExpirationTime = expirationTime;</span>

          <span class="s3">if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.childExpirationTime &lt; expirationTime) {</span>
            <span class="s1">alternate.childExpirationTime = expirationTime;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(alternate !== </span><span class="s3">null </span><span class="s1">&amp;&amp; alternate.childExpirationTime &lt; expirationTime) {</span>
          <span class="s1">alternate.childExpirationTime = expirationTime;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(node.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">&amp;&amp; node.tag === HostRoot) {</span>
          <span class="s1">root = node.stateNode;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">node = node.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(workInProgressRoot === root) {</span>
        <span class="s0">// Received an update to a tree that's in the middle of rendering. Mark</span>
        <span class="s0">// that's unprocessed work on this root.</span>
        <span class="s1">markUnprocessedUpdateTime(expirationTime);</span>

        <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootSuspendedWithDelay) {</span>
          <span class="s0">// The root already suspended with a delay, which means this render</span>
          <span class="s0">// definitely won't finish. Since we have a new update, let's mark it as</span>
          <span class="s0">// suspended now, right before marking the incoming update. This has the</span>
          <span class="s0">// effect of interrupting the current render and switching to the update.</span>
          <span class="s0">// TODO: This happens to work when receiving an update during the render</span>
          <span class="s0">// phase, because of the trick inside computeExpirationForFiber to</span>
          <span class="s0">// subtract 1 from `renderExpirationTime` to move it into a</span>
          <span class="s0">// separate bucket. But we should probably model it with an exception,</span>
          <span class="s0">// using the same mechanism we use to force hydration of a subtree.</span>
          <span class="s0">// TODO: This does not account for low pri updates that were already</span>
          <span class="s0">// scheduled before the root started rendering. Need to track the next</span>
          <span class="s0">// pending expiration time (perhaps by backtracking the return path) and</span>
          <span class="s0">// then trigger a restart in the `renderDidSuspendDelayIfPossible` path.</span>
          <span class="s1">markRootSuspendedAtTime(root, renderExpirationTime$1);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Mark that the root has a pending update.</span>


      <span class="s1">markRootUpdatedAtTime(root, expirationTime);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">root;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getNextRootExpirationTimeToWorkOn(root) {</span>
    <span class="s0">// Determines the next expiration time that the root should render, taking</span>
    <span class="s0">// into account levels that may be suspended, or levels that may have</span>
    <span class="s0">// received a ping.</span>
    <span class="s3">var </span><span class="s1">lastExpiredTime = root.lastExpiredTime;</span>

    <span class="s3">if </span><span class="s1">(lastExpiredTime !== NoWork) {</span>
      <span class="s3">return </span><span class="s1">lastExpiredTime;</span>
    <span class="s1">} </span><span class="s0">// &quot;Pending&quot; refers to any update that hasn't committed yet, including if it</span>
    <span class="s0">// suspended. The &quot;suspended&quot; range is therefore a subset.</span>


    <span class="s3">var </span><span class="s1">firstPendingTime = root.firstPendingTime;</span>

    <span class="s3">if </span><span class="s1">(!isRootSuspendedAtTime(root, firstPendingTime)) {</span>
      <span class="s0">// The highest priority pending time is not suspended. Let's work on that.</span>
      <span class="s3">return </span><span class="s1">firstPendingTime;</span>
    <span class="s1">} </span><span class="s0">// If the first pending time is suspended, check if there's a lower priority</span>
    <span class="s0">// pending level that we know about. Or check if we received a ping. Work</span>
    <span class="s0">// on whichever is higher priority.</span>


    <span class="s3">var </span><span class="s1">lastPingedTime = root.lastPingedTime;</span>
    <span class="s3">var </span><span class="s1">nextKnownPendingLevel = root.nextKnownPendingLevel;</span>
    <span class="s3">var </span><span class="s1">nextLevel = lastPingedTime &gt; nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;</span>

    <span class="s3">if </span><span class="s1">( nextLevel &lt;= Idle &amp;&amp; firstPendingTime !== nextLevel) {</span>
      <span class="s0">// Don't work on Idle/Never priority unless everything else is committed.</span>
      <span class="s3">return </span><span class="s1">NoWork;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">nextLevel;</span>
  <span class="s1">} </span><span class="s0">// Use this function to schedule a task for a root. There's only one task per</span>
  <span class="s0">// root; if a task was already scheduled, we'll check to make sure the</span>
  <span class="s0">// expiration time of the existing task is the same as the expiration time of</span>
  <span class="s0">// the next level that the root has work on. This function is called on every</span>
  <span class="s0">// update, and right before exiting a task.</span>


  <span class="s3">function </span><span class="s1">ensureRootIsScheduled(root) {</span>
    <span class="s3">var </span><span class="s1">lastExpiredTime = root.lastExpiredTime;</span>

    <span class="s3">if </span><span class="s1">(lastExpiredTime !== NoWork) {</span>
      <span class="s0">// Special case: Expired work should flush synchronously.</span>
      <span class="s1">root.callbackExpirationTime = Sync;</span>
      <span class="s1">root.callbackPriority = ImmediatePriority;</span>
      <span class="s1">root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root));</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">expirationTime = getNextRootExpirationTimeToWorkOn(root);</span>
    <span class="s3">var </span><span class="s1">existingCallbackNode = root.callbackNode;</span>

    <span class="s3">if </span><span class="s1">(expirationTime === NoWork) {</span>
      <span class="s0">// There's nothing to work on.</span>
      <span class="s3">if </span><span class="s1">(existingCallbackNode !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">root.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">root.callbackExpirationTime = NoWork;</span>
        <span class="s1">root.callbackPriority = NoPriority;</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// TODO: If this is an update, we already read the current time. Pass the</span>
    <span class="s0">// time as an argument.</span>


    <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
    <span class="s3">var </span><span class="s1">priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime); </span><span class="s0">// If there's an existing render task, confirm it has the correct priority and</span>
    <span class="s0">// expiration time. Otherwise, we'll cancel it and schedule a new one.</span>

    <span class="s3">if </span><span class="s1">(existingCallbackNode !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">existingCallbackPriority = root.callbackPriority;</span>
      <span class="s3">var </span><span class="s1">existingCallbackExpirationTime = root.callbackExpirationTime;</span>

      <span class="s3">if </span><span class="s1">( </span><span class="s0">// Callback must have the exact same expiration time.</span>
      <span class="s1">existingCallbackExpirationTime === expirationTime &amp;&amp; </span><span class="s0">// Callback must have greater or equal priority.</span>
      <span class="s1">existingCallbackPriority &gt;= priorityLevel) {</span>
        <span class="s0">// Existing callback is sufficient.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Need to schedule a new task.</span>
      <span class="s0">// TODO: Instead of scheduling a new task, we should be able to change the</span>
      <span class="s0">// priority of the existing one.</span>


      <span class="s1">cancelCallback(existingCallbackNode);</span>
    <span class="s1">}</span>

    <span class="s1">root.callbackExpirationTime = expirationTime;</span>
    <span class="s1">root.callbackPriority = priorityLevel;</span>
    <span class="s3">var </span><span class="s1">callbackNode;</span>

    <span class="s3">if </span><span class="s1">(expirationTime === Sync) {</span>
      <span class="s0">// Sync React callbacks are scheduled on a special internal queue</span>
      <span class="s1">callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root));</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root), </span><span class="s0">// Compute a task timeout based on the expiration time. This also affects</span>
      <span class="s0">// ordering because tasks are processed in timeout order.</span>
      <span class="s1">{</span>
        <span class="s1">timeout: expirationTimeToMs(expirationTime) - now()</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">root.callbackNode = callbackNode;</span>
  <span class="s1">} </span><span class="s0">// This is the entry point for every concurrent task, i.e. anything that</span>
  <span class="s0">// goes through Scheduler.</span>


  <span class="s3">function </span><span class="s1">performConcurrentWorkOnRoot(root, didTimeout) {</span>
    <span class="s0">// Since we know we're in a React event, we can clear the current</span>
    <span class="s0">// event time. The next update will compute a new event time.</span>
    <span class="s1">currentEventTime = NoWork;</span>

    <span class="s3">if </span><span class="s1">(didTimeout) {</span>
      <span class="s0">// The render task took too long to complete. Mark the current time as</span>
      <span class="s0">// expired to synchronously render all expired work in a single batch.</span>
      <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
      <span class="s1">markRootExpiredAtTime(root, currentTime); </span><span class="s0">// This will schedule a synchronous callback.</span>

      <span class="s1">ensureRootIsScheduled(root);</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Determine the next expiration time to work on, using the fields stored</span>
    <span class="s0">// on the root.</span>


    <span class="s3">var </span><span class="s1">expirationTime = getNextRootExpirationTimeToWorkOn(root);</span>

    <span class="s3">if </span><span class="s1">(expirationTime !== NoWork) {</span>
      <span class="s3">var </span><span class="s1">originalCallbackNode = root.callbackNode;</span>

      <span class="s3">if </span><span class="s1">(!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should not already be working.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">flushPassiveEffects(); </span><span class="s0">// If the root or expiration time have changed, throw out the existing stack</span>
      <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

      <span class="s3">if </span><span class="s1">(root !== workInProgressRoot || expirationTime !== renderExpirationTime$1) {</span>
        <span class="s1">prepareFreshStack(root, expirationTime);</span>
        <span class="s1">startWorkOnPendingInteractions(root, expirationTime);</span>
      <span class="s1">} </span><span class="s0">// If we have a work-in-progress fiber, it means there's still work to do</span>
      <span class="s0">// in this root.</span>


      <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
        <span class="s1">executionContext |= RenderContext;</span>
        <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher();</span>
        <span class="s3">var </span><span class="s1">prevInteractions = pushInteractions(root);</span>
        <span class="s1">startWorkLoopTimer(workInProgress);</span>

        <span class="s3">do </span><span class="s1">{</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">workLoopConcurrent();</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
            <span class="s1">handleError(root, thrownValue);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>

        <span class="s1">resetContextDependencies();</span>
        <span class="s1">executionContext = prevExecutionContext;</span>
        <span class="s1">popDispatcher(prevDispatcher);</span>

        <span class="s1">{</span>
          <span class="s1">popInteractions(prevInteractions);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootFatalErrored) {</span>
          <span class="s3">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
          <span class="s1">stopInterruptedWorkLoopTimer();</span>
          <span class="s1">prepareFreshStack(root, expirationTime);</span>
          <span class="s1">markRootSuspendedAtTime(root, expirationTime);</span>
          <span class="s1">ensureRootIsScheduled(root);</span>
          <span class="s3">throw </span><span class="s1">fatalError;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// There's still work left over. Exit without committing.</span>
          <span class="s1">stopInterruptedWorkLoopTimer();</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// We now have a consistent tree. The next step is either to commit it,</span>
          <span class="s0">// or, if something suspended, wait to commit it after a timeout.</span>
          <span class="s1">stopFinishedWorkLoopTimer();</span>
          <span class="s3">var </span><span class="s1">finishedWork = root.finishedWork = root.current.alternate;</span>
          <span class="s1">root.finishedExpirationTime = expirationTime;</span>
          <span class="s1">finishConcurrentRender(root, finishedWork, workInProgressRootExitStatus, expirationTime);</span>
        <span class="s1">}</span>

        <span class="s1">ensureRootIsScheduled(root);</span>

        <span class="s3">if </span><span class="s1">(root.callbackNode === originalCallbackNode) {</span>
          <span class="s0">// The task node scheduled for this root is the same one that's</span>
          <span class="s0">// currently executed. Need to return a continuation.</span>
          <span class="s3">return </span><span class="s1">performConcurrentWorkOnRoot.bind(</span><span class="s3">null</span><span class="s1">, root);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">finishConcurrentRender(root, finishedWork, exitStatus, expirationTime) {</span>
    <span class="s0">// Set this to null to indicate there's no in-progress render.</span>
    <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s1">(exitStatus) {</span>
      <span class="s3">case </span><span class="s1">RootIncomplete:</span>
      <span class="s3">case </span><span class="s1">RootFatalErrored:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Root did not complete. This is a bug in React.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s0">// Flow knows about invariant, so it complains if I add a break</span>
      <span class="s0">// statement, but eslint doesn't know about invariant, so it complains</span>
      <span class="s0">// if I do. eslint-disable-next-line no-fallthrough</span>

      <span class="s3">case </span><span class="s1">RootErrored:</span>
        <span class="s1">{</span>
          <span class="s0">// If this was an async render, the error may have happened due to</span>
          <span class="s0">// a mutation in a concurrent event. Try rendering one more time,</span>
          <span class="s0">// synchronously, to see if the error goes away. If there are</span>
          <span class="s0">// lower priority updates, let's include those, too, in case they</span>
          <span class="s0">// fix the inconsistency. Render at Idle to include all updates.</span>
          <span class="s0">// If it was Idle or Never or some not-yet-invented time, render</span>
          <span class="s0">// at that time.</span>
          <span class="s1">markRootExpiredAtTime(root, expirationTime &gt; Idle ? Idle : expirationTime); </span><span class="s0">// We assume that this second render pass will be synchronous</span>
          <span class="s0">// and therefore not hit this path again.</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">RootSuspended:</span>
        <span class="s1">{</span>
          <span class="s1">markRootSuspendedAtTime(root, expirationTime);</span>
          <span class="s3">var </span><span class="s1">lastSuspendedTime = root.lastSuspendedTime;</span>

          <span class="s3">if </span><span class="s1">(expirationTime === lastSuspendedTime) {</span>
            <span class="s1">root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);</span>
          <span class="s1">} </span><span class="s0">// We have an acceptable loading state. We need to figure out if we</span>
          <span class="s0">// should immediately commit it or wait a bit.</span>
          <span class="s0">// If we have processed new updates during this render, we may now</span>
          <span class="s0">// have a new loading state ready. We want to ensure that we commit</span>
          <span class="s0">// that as soon as possible.</span>


          <span class="s3">var </span><span class="s1">hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;</span>

          <span class="s3">if </span><span class="s1">(hasNotProcessedNewUpdates &amp;&amp; </span><span class="s0">// do not delay if we're inside an act() scope</span>
          <span class="s1">!( IsThisRendererActing.current)) {</span>
            <span class="s0">// If we have not processed any new updates during this pass, then</span>
            <span class="s0">// this is either a retry of an existing fallback state or a</span>
            <span class="s0">// hidden tree. Hidden trees shouldn't be batched with other work</span>
            <span class="s0">// and after that's fixed it can only be a retry. We're going to</span>
            <span class="s0">// throttle committing retries so that we don't show too many</span>
            <span class="s0">// loading states too quickly.</span>
            <span class="s3">var </span><span class="s1">msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); </span><span class="s0">// Don't bother with a very short suspense time.</span>

            <span class="s3">if </span><span class="s1">(msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
              <span class="s3">if </span><span class="s1">(workInProgressRootHasPendingPing) {</span>
                <span class="s3">var </span><span class="s1">lastPingedTime = root.lastPingedTime;</span>

                <span class="s3">if </span><span class="s1">(lastPingedTime === NoWork || lastPingedTime &gt;= expirationTime) {</span>
                  <span class="s0">// This render was pinged but we didn't get to restart</span>
                  <span class="s0">// earlier so try restarting now instead.</span>
                  <span class="s1">root.lastPingedTime = expirationTime;</span>
                  <span class="s1">prepareFreshStack(root, expirationTime);</span>
                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s3">var </span><span class="s1">nextTime = getNextRootExpirationTimeToWorkOn(root);</span>

              <span class="s3">if </span><span class="s1">(nextTime !== NoWork &amp;&amp; nextTime !== expirationTime) {</span>
                <span class="s0">// There's additional work on this root.</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s3">if </span><span class="s1">(lastSuspendedTime !== NoWork &amp;&amp; lastSuspendedTime !== expirationTime) {</span>
                <span class="s0">// We should prefer to render the fallback of at the last</span>
                <span class="s0">// suspended level. Ping the last suspended level to try</span>
                <span class="s0">// rendering it again.</span>
                <span class="s1">root.lastPingedTime = lastSuspendedTime;</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">} </span><span class="s0">// The render is suspended, it hasn't timed out, and there's no</span>
              <span class="s0">// lower priority work to do. Instead of committing the fallback</span>
              <span class="s0">// immediately, wait for more data to arrive.</span>


              <span class="s1">root.timeoutHandle = scheduleTimeout(commitRoot.bind(</span><span class="s3">null</span><span class="s1">, root), msUntilTimeout);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// The work expired. Commit immediately.</span>


          <span class="s1">commitRoot(root);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">RootSuspendedWithDelay:</span>
        <span class="s1">{</span>
          <span class="s1">markRootSuspendedAtTime(root, expirationTime);</span>
          <span class="s3">var </span><span class="s1">_lastSuspendedTime = root.lastSuspendedTime;</span>

          <span class="s3">if </span><span class="s1">(expirationTime === _lastSuspendedTime) {</span>
            <span class="s1">root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">( </span><span class="s0">// do not delay if we're inside an act() scope</span>
          <span class="s1">!( IsThisRendererActing.current)) {</span>
            <span class="s0">// We're suspended in a state that should be avoided. We'll try to</span>
            <span class="s0">// avoid committing it for as long as the timeouts let us.</span>
            <span class="s3">if </span><span class="s1">(workInProgressRootHasPendingPing) {</span>
              <span class="s3">var </span><span class="s1">_lastPingedTime = root.lastPingedTime;</span>

              <span class="s3">if </span><span class="s1">(_lastPingedTime === NoWork || _lastPingedTime &gt;= expirationTime) {</span>
                <span class="s0">// This render was pinged but we didn't get to restart earlier</span>
                <span class="s0">// so try restarting now instead.</span>
                <span class="s1">root.lastPingedTime = expirationTime;</span>
                <span class="s1">prepareFreshStack(root, expirationTime);</span>
                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_nextTime = getNextRootExpirationTimeToWorkOn(root);</span>

            <span class="s3">if </span><span class="s1">(_nextTime !== NoWork &amp;&amp; _nextTime !== expirationTime) {</span>
              <span class="s0">// There's additional work on this root.</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(_lastSuspendedTime !== NoWork &amp;&amp; _lastSuspendedTime !== expirationTime) {</span>
              <span class="s0">// We should prefer to render the fallback of at the last</span>
              <span class="s0">// suspended level. Ping the last suspended level to try</span>
              <span class="s0">// rendering it again.</span>
              <span class="s1">root.lastPingedTime = _lastSuspendedTime;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_msUntilTimeout;</span>

            <span class="s3">if </span><span class="s1">(workInProgressRootLatestSuspenseTimeout !== Sync) {</span>
              <span class="s0">// We have processed a suspense config whose expiration time we</span>
              <span class="s0">// can use as the timeout.</span>
              <span class="s1">_msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(workInProgressRootLatestProcessedExpirationTime === Sync) {</span>
              <span class="s0">// This should never normally happen because only new updates</span>
              <span class="s0">// cause delayed states, so we should have processed something.</span>
              <span class="s0">// However, this could also happen in an offscreen tree.</span>
              <span class="s1">_msUntilTimeout = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s0">// If we don't have a suspense config, we're going to use a</span>
              <span class="s0">// heuristic to determine how long we can suspend.</span>
              <span class="s3">var </span><span class="s1">eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);</span>
              <span class="s3">var </span><span class="s1">currentTimeMs = now();</span>
              <span class="s3">var </span><span class="s1">timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;</span>
              <span class="s3">var </span><span class="s1">timeElapsed = currentTimeMs - eventTimeMs;</span>

              <span class="s3">if </span><span class="s1">(timeElapsed &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">// We get this wrong some time since we estimate the time.</span>
                <span class="s1">timeElapsed = </span><span class="s4">0</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s1">_msUntilTimeout = jnd(timeElapsed) - timeElapsed; </span><span class="s0">// Clamp the timeout to the expiration time. TODO: Once the</span>
              <span class="s0">// event time is exact instead of inferred from expiration time</span>
              <span class="s0">// we don't need this.</span>

              <span class="s3">if </span><span class="s1">(timeUntilExpirationMs &lt; _msUntilTimeout) {</span>
                <span class="s1">_msUntilTimeout = timeUntilExpirationMs;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s0">// Don't bother with a very short suspense time.</span>


            <span class="s3">if </span><span class="s1">(_msUntilTimeout &gt; </span><span class="s4">10</span><span class="s1">) {</span>
              <span class="s0">// The render is suspended, it hasn't timed out, and there's no</span>
              <span class="s0">// lower priority work to do. Instead of committing the fallback</span>
              <span class="s0">// immediately, wait for more data to arrive.</span>
              <span class="s1">root.timeoutHandle = scheduleTimeout(commitRoot.bind(</span><span class="s3">null</span><span class="s1">, root), _msUntilTimeout);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// The work expired. Commit immediately.</span>


          <span class="s1">commitRoot(root);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s1">RootCompleted:</span>
        <span class="s1">{</span>
          <span class="s0">// The work completed. Ready to commit.</span>
          <span class="s3">if </span><span class="s1">( </span><span class="s0">// do not delay if we're inside an act() scope</span>
          <span class="s1">!( IsThisRendererActing.current) &amp;&amp; workInProgressRootLatestProcessedExpirationTime !== Sync &amp;&amp; workInProgressRootCanSuspendUsingConfig !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// If we have exceeded the minimum loading delay, which probably</span>
            <span class="s0">// means we have shown a spinner already, we might have to suspend</span>
            <span class="s0">// a bit longer to ensure that the spinner is shown for</span>
            <span class="s0">// enough time.</span>
            <span class="s3">var </span><span class="s1">_msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);</span>

            <span class="s3">if </span><span class="s1">(_msUntilTimeout2 &gt; </span><span class="s4">10</span><span class="s1">) {</span>
              <span class="s1">markRootSuspendedAtTime(root, expirationTime);</span>
              <span class="s1">root.timeoutHandle = scheduleTimeout(commitRoot.bind(</span><span class="s3">null</span><span class="s1">, root), _msUntilTimeout2);</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">commitRoot(root);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unknown root exit status.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This is the entry point for synchronous tasks that don't go</span>
  <span class="s0">// through Scheduler</span>


  <span class="s3">function </span><span class="s1">performSyncWorkOnRoot(root) {</span>
    <span class="s0">// Check if there's expired work on this root. Otherwise, render at Sync.</span>
    <span class="s3">var </span><span class="s1">lastExpiredTime = root.lastExpiredTime;</span>
    <span class="s3">var </span><span class="s1">expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;</span>

    <span class="s3">if </span><span class="s1">(!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should not already be working.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">flushPassiveEffects(); </span><span class="s0">// If the root or expiration time have changed, throw out the existing stack</span>
    <span class="s0">// and prepare a fresh one. Otherwise we'll continue where we left off.</span>

    <span class="s3">if </span><span class="s1">(root !== workInProgressRoot || expirationTime !== renderExpirationTime$1) {</span>
      <span class="s1">prepareFreshStack(root, expirationTime);</span>
      <span class="s1">startWorkOnPendingInteractions(root, expirationTime);</span>
    <span class="s1">} </span><span class="s0">// If we have a work-in-progress fiber, it means there's still work to do</span>
    <span class="s0">// in this root.</span>


    <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
      <span class="s1">executionContext |= RenderContext;</span>
      <span class="s3">var </span><span class="s1">prevDispatcher = pushDispatcher();</span>
      <span class="s3">var </span><span class="s1">prevInteractions = pushInteractions(root);</span>
      <span class="s1">startWorkLoopTimer(workInProgress);</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">workLoopSync();</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(thrownValue) {</span>
          <span class="s1">handleError(root, thrownValue);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>

      <span class="s1">resetContextDependencies();</span>
      <span class="s1">executionContext = prevExecutionContext;</span>
      <span class="s1">popDispatcher(prevDispatcher);</span>

      <span class="s1">{</span>
        <span class="s1">popInteractions(prevInteractions);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootFatalErrored) {</span>
        <span class="s3">var </span><span class="s1">fatalError = workInProgressRootFatalError;</span>
        <span class="s1">stopInterruptedWorkLoopTimer();</span>
        <span class="s1">prepareFreshStack(root, expirationTime);</span>
        <span class="s1">markRootSuspendedAtTime(root, expirationTime);</span>
        <span class="s1">ensureRootIsScheduled(root);</span>
        <span class="s3">throw </span><span class="s1">fatalError;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// This is a sync render, so we should have finished the whole tree.</span>
        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// We now have a consistent tree. Because this is a sync render, we</span>
        <span class="s0">// will commit it even if something suspended.</span>
        <span class="s1">stopFinishedWorkLoopTimer();</span>
        <span class="s1">root.finishedWork = root.current.alternate;</span>
        <span class="s1">root.finishedExpirationTime = expirationTime;</span>
        <span class="s1">finishSyncRender(root);</span>
      <span class="s1">} </span><span class="s0">// Before exiting, make sure there's a callback scheduled for the next</span>
      <span class="s0">// pending level.</span>


      <span class="s1">ensureRootIsScheduled(root);</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">finishSyncRender(root) {</span>
    <span class="s0">// Set this to null to indicate there's no in-progress render.</span>
    <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">commitRoot(root);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">flushDiscreteUpdates() {</span>
    <span class="s0">// TODO: Should be able to flush inside batchedUpdates, but not inside `act`.</span>
    <span class="s0">// However, `act` uses `batchedUpdates`, so there's no way to distinguish</span>
    <span class="s0">// those two cases. Need to fix this before exposing flushDiscreteUpdates</span>
    <span class="s0">// as a public API.</span>
    <span class="s3">if </span><span class="s1">((executionContext &amp; (BatchedContext | RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">((executionContext &amp; RenderContext) !== NoContext) {</span>
          <span class="s1">error(</span><span class="s2">'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' </span><span class="s1">+ </span><span class="s2">'already rendering.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// We're already rendering, so we can't synchronously flush pending work.</span>
      <span class="s0">// This is probably a nested event dispatch triggered by a lifecycle/effect,</span>
      <span class="s0">// like `el.focus()`. Exit.</span>


      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">flushPendingDiscreteUpdates(); </span><span class="s0">// If the discrete updates scheduled passive effects, flush them now so that</span>
    <span class="s0">// they fire before the next serial event.</span>

    <span class="s1">flushPassiveEffects();</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">syncUpdates(fn, a, b, c) {</span>
    <span class="s3">return </span><span class="s1">runWithPriority$1(ImmediatePriority, fn.bind(</span><span class="s3">null</span><span class="s1">, a, b, c));</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushPendingDiscreteUpdates() {</span>
    <span class="s3">if </span><span class="s1">(rootsWithPendingDiscreteUpdates !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// For each root with pending discrete updates, schedule a callback to</span>
      <span class="s0">// immediately flush them.</span>
      <span class="s3">var </span><span class="s1">roots = rootsWithPendingDiscreteUpdates;</span>
      <span class="s1">rootsWithPendingDiscreteUpdates = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">roots.forEach(</span><span class="s3">function </span><span class="s1">(expirationTime, root) {</span>
        <span class="s1">markRootExpiredAtTime(root, expirationTime);</span>
        <span class="s1">ensureRootIsScheduled(root);</span>
      <span class="s1">}); </span><span class="s0">// Now flush the immediate queue.</span>

      <span class="s1">flushSyncCallbackQueue();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">batchedUpdates$1(fn, a) {</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= BatchedContext;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">fn(a);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext;</span>

      <span class="s3">if </span><span class="s1">(executionContext === NoContext) {</span>
        <span class="s0">// Flush the immediate callbacks that were scheduled during this batch</span>
        <span class="s1">flushSyncCallbackQueue();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">batchedEventUpdates$1(fn, a) {</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= EventContext;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">fn(a);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext;</span>

      <span class="s3">if </span><span class="s1">(executionContext === NoContext) {</span>
        <span class="s0">// Flush the immediate callbacks that were scheduled during this batch</span>
        <span class="s1">flushSyncCallbackQueue();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">discreteUpdates$1(fn, a, b, c, d) {</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= DiscreteEventContext;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s0">// Should this</span>
      <span class="s3">return </span><span class="s1">runWithPriority$1(UserBlockingPriority$1, fn.bind(</span><span class="s3">null</span><span class="s1">, a, b, c, d));</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext;</span>

      <span class="s3">if </span><span class="s1">(executionContext === NoContext) {</span>
        <span class="s0">// Flush the immediate callbacks that were scheduled during this batch</span>
        <span class="s1">flushSyncCallbackQueue();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unbatchedUpdates(fn, a) {</span>
    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext &amp;= ~BatchedContext;</span>
    <span class="s1">executionContext |= LegacyUnbatchedContext;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">fn(a);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext;</span>

      <span class="s3">if </span><span class="s1">(executionContext === NoContext) {</span>
        <span class="s0">// Flush the immediate callbacks that were scheduled during this batch</span>
        <span class="s1">flushSyncCallbackQueue();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">flushSync(fn, a) {</span>
    <span class="s3">if </span><span class="s1">((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) {</span>
      <span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= BatchedContext;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">runWithPriority$1(ImmediatePriority, fn.bind(</span><span class="s3">null</span><span class="s1">, a));</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">executionContext = prevExecutionContext; </span><span class="s0">// Flush the immediate callbacks that were scheduled during this batch.</span>
      <span class="s0">// Note that this will happen even if batchedUpdates is higher up</span>
      <span class="s0">// the stack.</span>

      <span class="s1">flushSyncCallbackQueue();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">prepareFreshStack(root, expirationTime) {</span>
    <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">root.finishedExpirationTime = NoWork;</span>
    <span class="s3">var </span><span class="s1">timeoutHandle = root.timeoutHandle;</span>

    <span class="s3">if </span><span class="s1">(timeoutHandle !== noTimeout) {</span>
      <span class="s0">// The root previous suspended and scheduled a timeout to commit a fallback</span>
      <span class="s0">// state. Now that we have additional work, cancel the timeout.</span>
      <span class="s1">root.timeoutHandle = noTimeout; </span><span class="s0">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>

      <span class="s1">cancelTimeout(timeoutHandle);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">interruptedWork = workInProgress.</span><span class="s3">return</span><span class="s1">;</span>

      <span class="s3">while </span><span class="s1">(interruptedWork !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">unwindInterruptedWork(interruptedWork);</span>
        <span class="s1">interruptedWork = interruptedWork.</span><span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgressRoot = root;</span>
    <span class="s1">workInProgress = createWorkInProgress(root.current, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">renderExpirationTime$1 = expirationTime;</span>
    <span class="s1">workInProgressRootExitStatus = RootIncomplete;</span>
    <span class="s1">workInProgressRootFatalError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootLatestProcessedExpirationTime = Sync;</span>
    <span class="s1">workInProgressRootLatestSuspenseTimeout = Sync;</span>
    <span class="s1">workInProgressRootCanSuspendUsingConfig = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgressRootNextUnprocessedUpdateTime = NoWork;</span>
    <span class="s1">workInProgressRootHasPendingPing = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">spawnedWorkDuringRender = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.discardPendingWarnings();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">handleError(root, thrownValue) {</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s0">// Reset module-level state that was set during the render phase.</span>
        <span class="s1">resetContextDependencies();</span>
        <span class="s1">resetHooksAfterThrow();</span>
        <span class="s1">resetCurrentFiber();</span>

        <span class="s3">if </span><span class="s1">(workInProgress === </span><span class="s3">null </span><span class="s1">|| workInProgress.</span><span class="s3">return </span><span class="s1">=== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Expected to be working on a non-root fiber. This is a fatal error</span>
          <span class="s0">// because there's no ancestor that can handle it; the root is</span>
          <span class="s0">// supposed to capture all errors that weren't caught by an error</span>
          <span class="s0">// boundary.</span>
          <span class="s1">workInProgressRootExitStatus = RootFatalErrored;</span>
          <span class="s1">workInProgressRootFatalError = thrownValue; </span><span class="s0">// Set `workInProgress` to null. This represents advancing to the next</span>
          <span class="s0">// sibling, or the parent if there are no siblings. But since the root</span>
          <span class="s0">// has no siblings nor a parent, we set it to null. Usually this is</span>
          <span class="s0">// handled by `completeUnitOfWork` or `unwindWork`, but since we're</span>
          <span class="s0">// interntionally not calling those, we need set it here.</span>
          <span class="s0">// TODO: Consider calling `unwindWork` to pop the contexts.</span>

          <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(enableProfilerTimer &amp;&amp; workInProgress.mode &amp; ProfileMode) {</span>
          <span class="s0">// Record the time spent rendering before an error was thrown. This</span>
          <span class="s0">// avoids inaccurate Profiler durations in the case of a</span>
          <span class="s0">// suspended render.</span>
          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(workInProgress, </span><span class="s3">true</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">throwException(root, workInProgress.</span><span class="s3">return</span><span class="s1">, workInProgress, thrownValue, renderExpirationTime$1);</span>
        <span class="s1">workInProgress = completeUnitOfWork(workInProgress);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(yetAnotherThrownValue) {</span>
        <span class="s0">// Something in the return path also threw.</span>
        <span class="s1">thrownValue = yetAnotherThrownValue;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Return to the normal work loop.</span>


      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushDispatcher(root) {</span>
    <span class="s3">var </span><span class="s1">prevDispatcher = ReactCurrentDispatcher$1.current;</span>
    <span class="s1">ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;</span>

    <span class="s3">if </span><span class="s1">(prevDispatcher === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// The React isomorphic package does not include a default dispatcher.</span>
      <span class="s0">// Instead the first renderer will lazily attach one, in order to give</span>
      <span class="s0">// nicer error messages.</span>
      <span class="s3">return </span><span class="s1">ContextOnlyDispatcher;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">prevDispatcher;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popDispatcher(prevDispatcher) {</span>
    <span class="s1">ReactCurrentDispatcher$1.current = prevDispatcher;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">pushInteractions(root) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">prevInteractions = __interactionsRef.current;</span>
      <span class="s1">__interactionsRef.current = root.memoizedInteractions;</span>
      <span class="s3">return </span><span class="s1">prevInteractions;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">popInteractions(prevInteractions) {</span>
    <span class="s1">{</span>
      <span class="s1">__interactionsRef.current = prevInteractions;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markCommitTimeOfFallback() {</span>
    <span class="s1">globalMostRecentFallbackTime = now();</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {</span>
    <span class="s3">if </span><span class="s1">(expirationTime &lt; workInProgressRootLatestProcessedExpirationTime &amp;&amp; expirationTime &gt; Idle) {</span>
      <span class="s1">workInProgressRootLatestProcessedExpirationTime = expirationTime;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(suspenseConfig !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(expirationTime &lt; workInProgressRootLatestSuspenseTimeout &amp;&amp; expirationTime &gt; Idle) {</span>
        <span class="s1">workInProgressRootLatestSuspenseTimeout = expirationTime; </span><span class="s0">// Most of the time we only have one config and getting wrong is not bad.</span>

        <span class="s1">workInProgressRootCanSuspendUsingConfig = suspenseConfig;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markUnprocessedUpdateTime(expirationTime) {</span>
    <span class="s3">if </span><span class="s1">(expirationTime &gt; workInProgressRootNextUnprocessedUpdateTime) {</span>
      <span class="s1">workInProgressRootNextUnprocessedUpdateTime = expirationTime;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">renderDidSuspend() {</span>
    <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootIncomplete) {</span>
      <span class="s1">workInProgressRootExitStatus = RootSuspended;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">renderDidSuspendDelayIfPossible() {</span>
    <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {</span>
      <span class="s1">workInProgressRootExitStatus = RootSuspendedWithDelay;</span>
    <span class="s1">} </span><span class="s0">// Check if there's a lower priority update somewhere else in the tree.</span>


    <span class="s3">if </span><span class="s1">(workInProgressRootNextUnprocessedUpdateTime !== NoWork &amp;&amp; workInProgressRoot !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Mark the current render as suspended, and then mark that there's a</span>
      <span class="s0">// pending update.</span>
      <span class="s0">// TODO: This should immediately interrupt the current render, instead</span>
      <span class="s0">// of waiting until the next time we yield.</span>
      <span class="s1">markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$1);</span>
      <span class="s1">markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">renderDidError() {</span>
    <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus !== RootCompleted) {</span>
      <span class="s1">workInProgressRootExitStatus = RootErrored;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Called during render to determine if anything has suspended.</span>
  <span class="s0">// Returns false if we're not sure.</span>

  <span class="s3">function </span><span class="s1">renderHasNotSuspendedYet() {</span>
    <span class="s0">// If something errored or completed, we can't really be sure,</span>
    <span class="s0">// so those are false.</span>
    <span class="s3">return </span><span class="s1">workInProgressRootExitStatus === RootIncomplete;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">inferTimeFromExpirationTime(expirationTime) {</span>
    <span class="s0">// We don't know exactly when the update was scheduled, but we can infer an</span>
    <span class="s0">// approximate start time from the expiration time.</span>
    <span class="s3">var </span><span class="s1">earliestExpirationTimeMs = expirationTimeToMs(expirationTime);</span>
    <span class="s3">return </span><span class="s1">earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime, suspenseConfig) {</span>
    <span class="s0">// We don't know exactly when the update was scheduled, but we can infer an</span>
    <span class="s0">// approximate start time from the expiration time by subtracting the timeout</span>
    <span class="s0">// that was added to the event time.</span>
    <span class="s3">var </span><span class="s1">earliestExpirationTimeMs = expirationTimeToMs(expirationTime);</span>
    <span class="s3">return </span><span class="s1">earliestExpirationTimeMs - (suspenseConfig.timeoutMs | </span><span class="s4">0 </span><span class="s1">|| LOW_PRIORITY_EXPIRATION);</span>
  <span class="s1">} </span><span class="s0">// The work loop is an extremely hot path. Tell Closure not to inline it.</span>

  <span class="s0">/** @noinline */</span>


  <span class="s3">function </span><span class="s1">workLoopSync() {</span>
    <span class="s0">// Already timed out, so perform work without checking if we need to yield.</span>
    <span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">workInProgress = performUnitOfWork(workInProgress);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** @noinline */</span>


  <span class="s3">function </span><span class="s1">workLoopConcurrent() {</span>
    <span class="s0">// Perform work until Scheduler asks us to yield</span>
    <span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !shouldYield()) {</span>
      <span class="s1">workInProgress = performUnitOfWork(workInProgress);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">performUnitOfWork(unitOfWork) {</span>
    <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
    <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
    <span class="s0">// need an additional field on the work in progress.</span>
    <span class="s3">var </span><span class="s1">current = unitOfWork.alternate;</span>
    <span class="s1">startWorkTimer(unitOfWork);</span>
    <span class="s1">setCurrentFiber(unitOfWork);</span>
    <span class="s3">var </span><span class="s1">next;</span>

    <span class="s3">if </span><span class="s1">( (unitOfWork.mode &amp; ProfileMode) !== NoMode) {</span>
      <span class="s1">startProfilerTimer(unitOfWork);</span>
      <span class="s1">next = beginWork$1(current, unitOfWork, renderExpirationTime$1);</span>
      <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">next = beginWork$1(current, unitOfWork, renderExpirationTime$1);</span>
    <span class="s1">}</span>

    <span class="s1">resetCurrentFiber();</span>
    <span class="s1">unitOfWork.memoizedProps = unitOfWork.pendingProps;</span>

    <span class="s3">if </span><span class="s1">(next === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// If this doesn't spawn new work, complete the current work.</span>
      <span class="s1">next = completeUnitOfWork(unitOfWork);</span>
    <span class="s1">}</span>

    <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">next;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">completeUnitOfWork(unitOfWork) {</span>
    <span class="s0">// Attempt to complete the current unit of work, then move to the next</span>
    <span class="s0">// sibling. If there are no more siblings, return to the parent fiber.</span>
    <span class="s1">workInProgress = unitOfWork;</span>

    <span class="s3">do </span><span class="s1">{</span>
      <span class="s0">// The current, flushed, state of this fiber is the alternate. Ideally</span>
      <span class="s0">// nothing should rely on this, but relying on it here means that we don't</span>
      <span class="s0">// need an additional field on the work in progress.</span>
      <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>
      <span class="s3">var </span><span class="s1">returnFiber = workInProgress.</span><span class="s3">return</span><span class="s1">; </span><span class="s0">// Check if the work completed or if something threw.</span>

      <span class="s3">if </span><span class="s1">((workInProgress.effectTag &amp; Incomplete) === NoEffect) {</span>
        <span class="s1">setCurrentFiber(workInProgress);</span>
        <span class="s3">var </span><span class="s1">next = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">( (workInProgress.mode &amp; ProfileMode) === NoMode) {</span>
          <span class="s1">next = completeWork(current, workInProgress, renderExpirationTime$1);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">startProfilerTimer(workInProgress);</span>
          <span class="s1">next = completeWork(current, workInProgress, renderExpirationTime$1); </span><span class="s0">// Update render duration assuming we didn't error.</span>

          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(workInProgress, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">stopWorkTimer(workInProgress);</span>
        <span class="s1">resetCurrentFiber();</span>
        <span class="s1">resetChildExpirationTime(workInProgress);</span>

        <span class="s3">if </span><span class="s1">(next !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Completing this fiber spawned new work. Work on that next.</span>
          <span class="s3">return </span><span class="s1">next;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(returnFiber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s0">// Do not append effects to parents if a sibling failed to complete</span>
        <span class="s1">(returnFiber.effectTag &amp; Incomplete) === NoEffect) {</span>
          <span class="s0">// Append all the effects of the subtree and this fiber onto the effect</span>
          <span class="s0">// list of the parent. The completion order of the children affects the</span>
          <span class="s0">// side-effect order.</span>
          <span class="s3">if </span><span class="s1">(returnFiber.firstEffect === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">returnFiber.firstEffect = workInProgress.firstEffect;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(workInProgress.lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(returnFiber.lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span>
            <span class="s1">}</span>

            <span class="s1">returnFiber.lastEffect = workInProgress.lastEffect;</span>
          <span class="s1">} </span><span class="s0">// If this fiber had side-effects, we append it AFTER the children's</span>
          <span class="s0">// side-effects. We can perform certain side-effects earlier if needed,</span>
          <span class="s0">// by doing multiple passes over the effect list. We don't want to</span>
          <span class="s0">// schedule our own side-effect on our own list because if end up</span>
          <span class="s0">// reusing children we'll schedule this effect onto itself since we're</span>
          <span class="s0">// at the end.</span>


          <span class="s3">var </span><span class="s1">effectTag = workInProgress.effectTag; </span><span class="s0">// Skip both NoWork and PerformedWork tags when creating the effect</span>
          <span class="s0">// list. PerformedWork effect is read by React DevTools but shouldn't be</span>
          <span class="s0">// committed.</span>

          <span class="s3">if </span><span class="s1">(effectTag &gt; PerformedWork) {</span>
            <span class="s3">if </span><span class="s1">(returnFiber.lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">returnFiber.lastEffect.nextEffect = workInProgress;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">returnFiber.firstEffect = workInProgress;</span>
            <span class="s1">}</span>

            <span class="s1">returnFiber.lastEffect = workInProgress;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// This fiber did not complete because something threw. Pop values off</span>
        <span class="s0">// the stack without entering the complete phase. If this is a boundary,</span>
        <span class="s0">// capture values if possible.</span>
        <span class="s3">var </span><span class="s1">_next = unwindWork(workInProgress); </span><span class="s0">// Because this fiber did not complete, don't reset its expiration time.</span>


        <span class="s3">if </span><span class="s1">( (workInProgress.mode &amp; ProfileMode) !== NoMode) {</span>
          <span class="s0">// Record the render duration for the fiber that errored.</span>
          <span class="s1">stopProfilerTimerIfRunningAndRecordDelta(workInProgress, </span><span class="s3">false</span><span class="s1">); </span><span class="s0">// Include the time spent working on failed children before continuing.</span>

          <span class="s3">var </span><span class="s1">actualDuration = workInProgress.actualDuration;</span>
          <span class="s3">var </span><span class="s1">child = workInProgress.child;</span>

          <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">actualDuration += child.actualDuration;</span>
            <span class="s1">child = child.sibling;</span>
          <span class="s1">}</span>

          <span class="s1">workInProgress.actualDuration = actualDuration;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(_next !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// If completing this work spawned new work, do that next. We'll come</span>
          <span class="s0">// back here again.</span>
          <span class="s0">// Since we're restarting, remove anything that is not a host effect</span>
          <span class="s0">// from the effect tag.</span>
          <span class="s0">// TODO: The name stopFailedWorkTimer is misleading because Suspense</span>
          <span class="s0">// also captures and restarts.</span>
          <span class="s1">stopFailedWorkTimer(workInProgress);</span>
          <span class="s1">_next.effectTag &amp;= HostEffectMask;</span>
          <span class="s3">return </span><span class="s1">_next;</span>
        <span class="s1">}</span>

        <span class="s1">stopWorkTimer(workInProgress);</span>

        <span class="s3">if </span><span class="s1">(returnFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// Mark the parent fiber as incomplete and clear its effect list.</span>
          <span class="s1">returnFiber.firstEffect = returnFiber.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">returnFiber.effectTag |= Incomplete;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">siblingFiber = workInProgress.sibling;</span>

      <span class="s3">if </span><span class="s1">(siblingFiber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// If there is more work to do in this returnFiber, do that next.</span>
        <span class="s3">return </span><span class="s1">siblingFiber;</span>
      <span class="s1">} </span><span class="s0">// Otherwise, return to the parent</span>


      <span class="s1">workInProgress = returnFiber;</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(workInProgress !== </span><span class="s3">null</span><span class="s1">); </span><span class="s0">// We've reached the root.</span>


    <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootIncomplete) {</span>
      <span class="s1">workInProgressRootExitStatus = RootCompleted;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getRemainingExpirationTime(fiber) {</span>
    <span class="s3">var </span><span class="s1">updateExpirationTime = fiber.expirationTime;</span>
    <span class="s3">var </span><span class="s1">childExpirationTime = fiber.childExpirationTime;</span>
    <span class="s3">return </span><span class="s1">updateExpirationTime &gt; childExpirationTime ? updateExpirationTime : childExpirationTime;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resetChildExpirationTime(completedWork) {</span>
    <span class="s3">if </span><span class="s1">(renderExpirationTime$1 !== Never &amp;&amp; completedWork.childExpirationTime === Never) {</span>
      <span class="s0">// The children of this component are hidden. Don't bubble their</span>
      <span class="s0">// expiration times.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">newChildExpirationTime = NoWork; </span><span class="s0">// Bubble up the earliest expiration time.</span>

    <span class="s3">if </span><span class="s1">( (completedWork.mode &amp; ProfileMode) !== NoMode) {</span>
      <span class="s0">// In profiling mode, resetChildExpirationTime is also used to reset</span>
      <span class="s0">// profiler durations.</span>
      <span class="s3">var </span><span class="s1">actualDuration = completedWork.actualDuration;</span>
      <span class="s3">var </span><span class="s1">treeBaseDuration = completedWork.selfBaseDuration; </span><span class="s0">// When a fiber is cloned, its actualDuration is reset to 0. This value will</span>
      <span class="s0">// only be updated if work is done on the fiber (i.e. it doesn't bailout).</span>
      <span class="s0">// When work is done, it should bubble to the parent's actualDuration. If</span>
      <span class="s0">// the fiber has not been cloned though, (meaning no work was done), then</span>
      <span class="s0">// this value will reflect the amount of time spent working on a previous</span>
      <span class="s0">// render. In that case it should not bubble. We determine whether it was</span>
      <span class="s0">// cloned by comparing the child pointer.</span>

      <span class="s3">var </span><span class="s1">shouldBubbleActualDurations = completedWork.alternate === </span><span class="s3">null </span><span class="s1">|| completedWork.child !== completedWork.alternate.child;</span>
      <span class="s3">var </span><span class="s1">child = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">childUpdateExpirationTime = child.expirationTime;</span>
        <span class="s3">var </span><span class="s1">childChildExpirationTime = child.childExpirationTime;</span>

        <span class="s3">if </span><span class="s1">(childUpdateExpirationTime &gt; newChildExpirationTime) {</span>
          <span class="s1">newChildExpirationTime = childUpdateExpirationTime;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(childChildExpirationTime &gt; newChildExpirationTime) {</span>
          <span class="s1">newChildExpirationTime = childChildExpirationTime;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(shouldBubbleActualDurations) {</span>
          <span class="s1">actualDuration += child.actualDuration;</span>
        <span class="s1">}</span>

        <span class="s1">treeBaseDuration += child.treeBaseDuration;</span>
        <span class="s1">child = child.sibling;</span>
      <span class="s1">}</span>

      <span class="s1">completedWork.actualDuration = actualDuration;</span>
      <span class="s1">completedWork.treeBaseDuration = treeBaseDuration;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_child = completedWork.child;</span>

      <span class="s3">while </span><span class="s1">(_child !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_childUpdateExpirationTime = _child.expirationTime;</span>
        <span class="s3">var </span><span class="s1">_childChildExpirationTime = _child.childExpirationTime;</span>

        <span class="s3">if </span><span class="s1">(_childUpdateExpirationTime &gt; newChildExpirationTime) {</span>
          <span class="s1">newChildExpirationTime = _childUpdateExpirationTime;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(_childChildExpirationTime &gt; newChildExpirationTime) {</span>
          <span class="s1">newChildExpirationTime = _childChildExpirationTime;</span>
        <span class="s1">}</span>

        <span class="s1">_child = _child.sibling;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">completedWork.childExpirationTime = newChildExpirationTime;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitRoot(root) {</span>
    <span class="s3">var </span><span class="s1">renderPriorityLevel = getCurrentPriorityLevel();</span>
    <span class="s1">runWithPriority$1(ImmediatePriority, commitRootImpl.bind(</span><span class="s3">null</span><span class="s1">, root, renderPriorityLevel));</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitRootImpl(root, renderPriorityLevel) {</span>
    <span class="s3">do </span><span class="s1">{</span>
      <span class="s0">// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which</span>
      <span class="s0">// means `flushPassiveEffects` will sometimes result in additional</span>
      <span class="s0">// passive effects. So we need to keep flushing in a loop until there are</span>
      <span class="s0">// no more pending effects.</span>
      <span class="s0">// TODO: Might be better if `flushPassiveEffects` did not automatically</span>
      <span class="s0">// flush synchronous work at the end, to avoid factoring hazards like this.</span>
      <span class="s1">flushPassiveEffects();</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(rootWithPendingPassiveEffects !== </span><span class="s3">null</span><span class="s1">);</span>

    <span class="s1">flushRenderPhaseStrictModeWarningsInDEV();</span>

    <span class="s3">if </span><span class="s1">(!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should not already be working.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">finishedWork = root.finishedWork;</span>
    <span class="s3">var </span><span class="s1">expirationTime = root.finishedExpirationTime;</span>

    <span class="s3">if </span><span class="s1">(finishedWork === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">root.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">root.finishedExpirationTime = NoWork;</span>

    <span class="s3">if </span><span class="s1">(!(finishedWork !== root.current)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// commitRoot never returns a continuation; it always finishes synchronously.</span>
    <span class="s0">// So we can clear these now to allow a new callback to be scheduled.</span>


    <span class="s1">root.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">root.callbackExpirationTime = NoWork;</span>
    <span class="s1">root.callbackPriority = NoPriority;</span>
    <span class="s1">root.nextKnownPendingLevel = NoWork;</span>
    <span class="s1">startCommitTimer(); </span><span class="s0">// Update the first and last pending times on this root. The new first</span>
    <span class="s0">// pending time is whatever is left on the root fiber.</span>

    <span class="s3">var </span><span class="s1">remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork);</span>
    <span class="s1">markRootFinishedAtTime(root, expirationTime, remainingExpirationTimeBeforeCommit);</span>

    <span class="s3">if </span><span class="s1">(root === workInProgressRoot) {</span>
      <span class="s0">// We can reset these now that they are finished.</span>
      <span class="s1">workInProgressRoot = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">renderExpirationTime$1 = NoWork;</span>
    <span class="s1">} </span><span class="s0">// This indicates that the last root we worked on is not the same one that</span>
    <span class="s0">// we're committing now. This most commonly happens when a suspended root</span>
    <span class="s0">// times out.</span>
    <span class="s0">// Get the list of effects.</span>


    <span class="s3">var </span><span class="s1">firstEffect;</span>

    <span class="s3">if </span><span class="s1">(finishedWork.effectTag &gt; PerformedWork) {</span>
      <span class="s0">// A fiber's effect list consists only of its children, not itself. So if</span>
      <span class="s0">// the root has an effect, we need to add it to the end of the list. The</span>
      <span class="s0">// resulting list is the set that would belong to the root's parent, if it</span>
      <span class="s0">// had one; that is, all the effects in the tree including the root.</span>
      <span class="s3">if </span><span class="s1">(finishedWork.lastEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">finishedWork.lastEffect.nextEffect = finishedWork;</span>
        <span class="s1">firstEffect = finishedWork.firstEffect;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">firstEffect = finishedWork;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// There is no effect on the root.</span>
      <span class="s1">firstEffect = finishedWork.firstEffect;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(firstEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
      <span class="s1">executionContext |= CommitContext;</span>
      <span class="s3">var </span><span class="s1">prevInteractions = pushInteractions(root); </span><span class="s0">// Reset this to null before calling lifecycles</span>

      <span class="s1">ReactCurrentOwner$2.current = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// The commit phase is broken into several sub-phases. We do a separate pass</span>
      <span class="s0">// of the effect list for each phase: all mutation effects come before all</span>
      <span class="s0">// layout effects, and so on.</span>
      <span class="s0">// The first phase a &quot;before mutation&quot; phase. We use this phase to read the</span>
      <span class="s0">// state of the host tree right before we mutate it. This is where</span>
      <span class="s0">// getSnapshotBeforeUpdate is called.</span>

      <span class="s1">startCommitSnapshotEffectsTimer();</span>
      <span class="s1">prepareForCommit(root.containerInfo);</span>
      <span class="s1">nextEffect = firstEffect;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, commitBeforeMutationEffects, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
            <span class="s3">if </span><span class="s1">(!(nextEffect !== </span><span class="s3">null</span><span class="s1">)) {</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should be working on an effect.&quot; </span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">error = clearCaughtError();</span>
            <span class="s1">captureCommitPhaseError(nextEffect, error);</span>
            <span class="s1">nextEffect = nextEffect.nextEffect;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s1">stopCommitSnapshotEffectsTimer();</span>

      <span class="s1">{</span>
        <span class="s0">// Mark the current commit time to be shared by all Profilers in this</span>
        <span class="s0">// batch. This enables them to be grouped later.</span>
        <span class="s1">recordCommitTime();</span>
      <span class="s1">} </span><span class="s0">// The next phase is the mutation phase, where we mutate the host tree.</span>


      <span class="s1">startCommitHostEffectsTimer();</span>
      <span class="s1">nextEffect = firstEffect;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, commitMutationEffects, </span><span class="s3">null</span><span class="s1">, root, renderPriorityLevel);</span>

          <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
            <span class="s3">if </span><span class="s1">(!(nextEffect !== </span><span class="s3">null</span><span class="s1">)) {</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should be working on an effect.&quot; </span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_error = clearCaughtError();</span>

            <span class="s1">captureCommitPhaseError(nextEffect, _error);</span>
            <span class="s1">nextEffect = nextEffect.nextEffect;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s1">stopCommitHostEffectsTimer();</span>
      <span class="s1">resetAfterCommit(root.containerInfo); </span><span class="s0">// The work-in-progress tree is now the current tree. This must come after</span>
      <span class="s0">// the mutation phase, so that the previous tree is still current during</span>
      <span class="s0">// componentWillUnmount, but before the layout phase, so that the finished</span>
      <span class="s0">// work is current during componentDidMount/Update.</span>

      <span class="s1">root.current = finishedWork; </span><span class="s0">// The next phase is the layout phase, where we call effects that read</span>
      <span class="s0">// the host tree after it's been mutated. The idiomatic use case for this is</span>
      <span class="s0">// layout, but class component lifecycles also fire here for legacy reasons.</span>

      <span class="s1">startCommitLifeCyclesTimer();</span>
      <span class="s1">nextEffect = firstEffect;</span>

      <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, commitLayoutEffects, </span><span class="s3">null</span><span class="s1">, root, expirationTime);</span>

          <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
            <span class="s3">if </span><span class="s1">(!(nextEffect !== </span><span class="s3">null</span><span class="s1">)) {</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should be working on an effect.&quot; </span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_error2 = clearCaughtError();</span>

            <span class="s1">captureCommitPhaseError(nextEffect, _error2);</span>
            <span class="s1">nextEffect = nextEffect.nextEffect;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">);</span>

      <span class="s1">stopCommitLifeCyclesTimer();</span>
      <span class="s1">nextEffect = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Tell Scheduler to yield at the end of the frame, so the browser has an</span>
      <span class="s0">// opportunity to paint.</span>

      <span class="s1">requestPaint();</span>

      <span class="s1">{</span>
        <span class="s1">popInteractions(prevInteractions);</span>
      <span class="s1">}</span>

      <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// No effects.</span>
      <span class="s1">root.current = finishedWork; </span><span class="s0">// Measure these anyway so the flamegraph explicitly shows that there were</span>
      <span class="s0">// no effects.</span>
      <span class="s0">// TODO: Maybe there's a better way to report this.</span>

      <span class="s1">startCommitSnapshotEffectsTimer();</span>
      <span class="s1">stopCommitSnapshotEffectsTimer();</span>

      <span class="s1">{</span>
        <span class="s1">recordCommitTime();</span>
      <span class="s1">}</span>

      <span class="s1">startCommitHostEffectsTimer();</span>
      <span class="s1">stopCommitHostEffectsTimer();</span>
      <span class="s1">startCommitLifeCyclesTimer();</span>
      <span class="s1">stopCommitLifeCyclesTimer();</span>
    <span class="s1">}</span>

    <span class="s1">stopCommitTimer();</span>
    <span class="s3">var </span><span class="s1">rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span>

    <span class="s3">if </span><span class="s1">(rootDoesHavePassiveEffects) {</span>
      <span class="s0">// This commit has passive effects. Stash a reference to them. But don't</span>
      <span class="s0">// schedule a callback until after flushing layout work.</span>
      <span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">rootWithPendingPassiveEffects = root;</span>
      <span class="s1">pendingPassiveEffectsExpirationTime = expirationTime;</span>
      <span class="s1">pendingPassiveEffectsRenderPriority = renderPriorityLevel;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// We are done with the effect chain at this point so let's clear the</span>
      <span class="s0">// nextEffect pointers to assist with GC. If we have passive effects, we'll</span>
      <span class="s0">// clear this in flushPassiveEffects.</span>
      <span class="s1">nextEffect = firstEffect;</span>

      <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">nextNextEffect = nextEffect.nextEffect;</span>
        <span class="s1">nextEffect.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">nextEffect = nextNextEffect;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Check if there's remaining work on this root</span>


    <span class="s3">var </span><span class="s1">remainingExpirationTime = root.firstPendingTime;</span>

    <span class="s3">if </span><span class="s1">(remainingExpirationTime !== NoWork) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(spawnedWorkDuringRender !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">expirationTimes = spawnedWorkDuringRender;</span>
          <span class="s1">spawnedWorkDuringRender = </span><span class="s3">null</span><span class="s1">;</span>

          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; expirationTimes.length; i++) {</span>
            <span class="s1">scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">schedulePendingInteractions(root, remainingExpirationTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// If there's no remaining work, we can clear the set of already failed</span>
      <span class="s0">// error boundaries.</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!rootDidHavePassiveEffects) {</span>
        <span class="s0">// If there are no passive effects, then we can complete the pending interactions.</span>
        <span class="s0">// Otherwise, we'll wait until after the passive effects are flushed.</span>
        <span class="s0">// Wait to do this until after remaining work has been scheduled,</span>
        <span class="s0">// so that we don't prematurely signal complete for interactions when there's e.g. hidden work.</span>
        <span class="s1">finishPendingInteractions(root, expirationTime);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(remainingExpirationTime === Sync) {</span>
      <span class="s0">// Count the number of times the root synchronously re-renders without</span>
      <span class="s0">// finishing. If there are too many, it indicates an infinite update loop.</span>
      <span class="s3">if </span><span class="s1">(root === rootWithNestedUpdates) {</span>
        <span class="s1">nestedUpdateCount++;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">rootWithNestedUpdates = root;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">onCommitRoot(finishedWork.stateNode, expirationTime); </span><span class="s0">// Always call this before exiting `commitRoot`, to ensure that any</span>
    <span class="s0">// additional work on this root is scheduled.</span>

    <span class="s1">ensureRootIsScheduled(root);</span>

    <span class="s3">if </span><span class="s1">(hasUncaughtError) {</span>
      <span class="s1">hasUncaughtError = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">_error3 = firstUncaughtError;</span>
      <span class="s1">firstUncaughtError = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">throw </span><span class="s1">_error3;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">((executionContext &amp; LegacyUnbatchedContext) !== NoContext) {</span>
      <span class="s0">// This is a legacy edge case. We just committed the initial mount of</span>
      <span class="s0">// a ReactDOM.render-ed root inside of batchedUpdates. The commit fired</span>
      <span class="s0">// synchronously, but layout updates should be deferred until the end</span>
      <span class="s0">// of the batch.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// If layout work was scheduled, flush it now.</span>


    <span class="s1">flushSyncCallbackQueue();</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitBeforeMutationEffects() {</span>
    <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">effectTag = nextEffect.effectTag;</span>

      <span class="s3">if </span><span class="s1">((effectTag &amp; Snapshot) !== NoEffect) {</span>
        <span class="s1">setCurrentFiber(nextEffect);</span>
        <span class="s1">recordEffect();</span>
        <span class="s3">var </span><span class="s1">current = nextEffect.alternate;</span>
        <span class="s1">commitBeforeMutationLifeCycles(current, nextEffect);</span>
        <span class="s1">resetCurrentFiber();</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">((effectTag &amp; Passive) !== NoEffect) {</span>
        <span class="s0">// If there are passive effects, schedule a callback to flush at</span>
        <span class="s0">// the earliest opportunity.</span>
        <span class="s3">if </span><span class="s1">(!rootDoesHavePassiveEffects) {</span>
          <span class="s1">rootDoesHavePassiveEffects = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">scheduleCallback(NormalPriority, </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s1">flushPassiveEffects();</span>
            <span class="s3">return null</span><span class="s1">;</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">nextEffect = nextEffect.nextEffect;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitMutationEffects(root, renderPriorityLevel) {</span>
    <span class="s0">// TODO: Should probably move the bulk of this function to commitWork.</span>
    <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">setCurrentFiber(nextEffect);</span>
      <span class="s3">var </span><span class="s1">effectTag = nextEffect.effectTag;</span>

      <span class="s3">if </span><span class="s1">(effectTag &amp; ContentReset) {</span>
        <span class="s1">commitResetTextContent(nextEffect);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(effectTag &amp; Ref) {</span>
        <span class="s3">var </span><span class="s1">current = nextEffect.alternate;</span>

        <span class="s3">if </span><span class="s1">(current !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">commitDetachRef(current);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// The following switch statement is only concerned about placement,</span>
      <span class="s0">// updates, and deletions. To avoid needing to add a case for every possible</span>
      <span class="s0">// bitmap value, we remove the secondary effects from the effect tag and</span>
      <span class="s0">// switch on that value.</span>


      <span class="s3">var </span><span class="s1">primaryEffectTag = effectTag &amp; (Placement | Update | Deletion | Hydrating);</span>

      <span class="s3">switch </span><span class="s1">(primaryEffectTag) {</span>
        <span class="s3">case </span><span class="s1">Placement:</span>
          <span class="s1">{</span>
            <span class="s1">commitPlacement(nextEffect); </span><span class="s0">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span>
            <span class="s0">// inserted, before any life-cycles like componentDidMount gets called.</span>
            <span class="s0">// TODO: findDOMNode doesn't rely on this any more but isMounted does</span>
            <span class="s0">// and isMounted is deprecated anyway so we should be able to kill this.</span>

            <span class="s1">nextEffect.effectTag &amp;= ~Placement;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">PlacementAndUpdate:</span>
          <span class="s1">{</span>
            <span class="s0">// Placement</span>
            <span class="s1">commitPlacement(nextEffect); </span><span class="s0">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span>
            <span class="s0">// inserted, before any life-cycles like componentDidMount gets called.</span>

            <span class="s1">nextEffect.effectTag &amp;= ~Placement; </span><span class="s0">// Update</span>

            <span class="s3">var </span><span class="s1">_current = nextEffect.alternate;</span>
            <span class="s1">commitWork(_current, nextEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">Hydrating:</span>
          <span class="s1">{</span>
            <span class="s1">nextEffect.effectTag &amp;= ~Hydrating;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">HydratingAndUpdate:</span>
          <span class="s1">{</span>
            <span class="s1">nextEffect.effectTag &amp;= ~Hydrating; </span><span class="s0">// Update</span>

            <span class="s3">var </span><span class="s1">_current2 = nextEffect.alternate;</span>
            <span class="s1">commitWork(_current2, nextEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">Update:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">_current3 = nextEffect.alternate;</span>
            <span class="s1">commitWork(_current3, nextEffect);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

        <span class="s3">case </span><span class="s1">Deletion:</span>
          <span class="s1">{</span>
            <span class="s1">commitDeletion(root, nextEffect, renderPriorityLevel);</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// TODO: Only record a mutation effect if primaryEffectTag is non-zero.</span>


      <span class="s1">recordEffect();</span>
      <span class="s1">resetCurrentFiber();</span>
      <span class="s1">nextEffect = nextEffect.nextEffect;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">commitLayoutEffects(root, committedExpirationTime) {</span>
    <span class="s0">// TODO: Should probably move the bulk of this function to commitWork.</span>
    <span class="s3">while </span><span class="s1">(nextEffect !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">setCurrentFiber(nextEffect);</span>
      <span class="s3">var </span><span class="s1">effectTag = nextEffect.effectTag;</span>

      <span class="s3">if </span><span class="s1">(effectTag &amp; (Update | Callback)) {</span>
        <span class="s1">recordEffect();</span>
        <span class="s3">var </span><span class="s1">current = nextEffect.alternate;</span>
        <span class="s1">commitLifeCycles(root, current, nextEffect);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(effectTag &amp; Ref) {</span>
        <span class="s1">recordEffect();</span>
        <span class="s1">commitAttachRef(nextEffect);</span>
      <span class="s1">}</span>

      <span class="s1">resetCurrentFiber();</span>
      <span class="s1">nextEffect = nextEffect.nextEffect;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushPassiveEffects() {</span>
    <span class="s3">if </span><span class="s1">(pendingPassiveEffectsRenderPriority !== NoPriority) {</span>
      <span class="s3">var </span><span class="s1">priorityLevel = pendingPassiveEffectsRenderPriority &gt; NormalPriority ? NormalPriority : pendingPassiveEffectsRenderPriority;</span>
      <span class="s1">pendingPassiveEffectsRenderPriority = NoPriority;</span>
      <span class="s3">return </span><span class="s1">runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushPassiveEffectsImpl() {</span>
    <span class="s3">if </span><span class="s1">(rootWithPendingPassiveEffects === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = rootWithPendingPassiveEffects;</span>
    <span class="s3">var </span><span class="s1">expirationTime = pendingPassiveEffectsExpirationTime;</span>
    <span class="s1">rootWithPendingPassiveEffects = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">pendingPassiveEffectsExpirationTime = NoWork;</span>

    <span class="s3">if </span><span class="s1">(!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Cannot flush passive effects while already rendering.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">prevExecutionContext = executionContext;</span>
    <span class="s1">executionContext |= CommitContext;</span>
    <span class="s3">var </span><span class="s1">prevInteractions = pushInteractions(root);</span>

    <span class="s1">{</span>
      <span class="s0">// Note: This currently assumes there are no passive effects on the root fiber</span>
      <span class="s0">// because the root is not part of its own effect list.</span>
      <span class="s0">// This could change in the future.</span>
      <span class="s3">var </span><span class="s1">_effect2 = root.current.firstEffect;</span>

      <span class="s3">while </span><span class="s1">(_effect2 !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">{</span>
          <span class="s1">setCurrentFiber(_effect2);</span>
          <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, commitPassiveHookEffects, </span><span class="s3">null</span><span class="s1">, _effect2);</span>

          <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
            <span class="s3">if </span><span class="s1">(!(_effect2 !== </span><span class="s3">null</span><span class="s1">)) {</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Should be working on an effect.&quot; </span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">_error5 = clearCaughtError();</span>

            <span class="s1">captureCommitPhaseError(_effect2, _error5);</span>
          <span class="s1">}</span>

          <span class="s1">resetCurrentFiber();</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">nextNextEffect = _effect2.nextEffect; </span><span class="s0">// Remove nextEffect pointer to assist GC</span>

        <span class="s1">_effect2.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">_effect2 = nextNextEffect;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">popInteractions(prevInteractions);</span>
      <span class="s1">finishPendingInteractions(root, expirationTime);</span>
    <span class="s1">}</span>

    <span class="s1">executionContext = prevExecutionContext;</span>
    <span class="s1">flushSyncCallbackQueue(); </span><span class="s0">// If additional passive effects were scheduled, increment a counter. If this</span>
    <span class="s0">// exceeds the limit, we'll fire a warning.</span>

    <span class="s1">nestedPassiveUpdateCount = rootWithPendingPassiveEffects === </span><span class="s3">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: nestedPassiveUpdateCount + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isAlreadyFailedLegacyErrorBoundary(instance) {</span>
    <span class="s3">return </span><span class="s1">legacyErrorBoundariesThatAlreadyFailed !== </span><span class="s3">null </span><span class="s1">&amp;&amp; legacyErrorBoundariesThatAlreadyFailed.has(instance);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markLegacyErrorBoundaryAsFailed(instance) {</span>
    <span class="s3">if </span><span class="s1">(legacyErrorBoundariesThatAlreadyFailed === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed = </span><span class="s3">new </span><span class="s1">Set([instance]);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">legacyErrorBoundariesThatAlreadyFailed.add(instance);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">prepareToThrowUncaughtError(error) {</span>
    <span class="s3">if </span><span class="s1">(!hasUncaughtError) {</span>
      <span class="s1">hasUncaughtError = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">firstUncaughtError = error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">onUncaughtError = prepareToThrowUncaughtError;</span>

  <span class="s3">function </span><span class="s1">captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {</span>
    <span class="s3">var </span><span class="s1">errorInfo = createCapturedValue(error, sourceFiber);</span>
    <span class="s3">var </span><span class="s1">update = createRootErrorUpdate(rootFiber, errorInfo, Sync);</span>
    <span class="s1">enqueueUpdate(rootFiber, update);</span>
    <span class="s3">var </span><span class="s1">root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">ensureRootIsScheduled(root);</span>
      <span class="s1">schedulePendingInteractions(root, Sync);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">captureCommitPhaseError(sourceFiber, error) {</span>
    <span class="s3">if </span><span class="s1">(sourceFiber.tag === HostRoot) {</span>
      <span class="s0">// Error was thrown at the root. There is no parent, so the root</span>
      <span class="s0">// itself should capture it.</span>
      <span class="s1">captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = sourceFiber.</span><span class="s3">return</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s1">(fiber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(fiber.tag === HostRoot) {</span>
        <span class="s1">captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
        <span class="s3">var </span><span class="s1">ctor = fiber.type;</span>
        <span class="s3">var </span><span class="s1">instance = fiber.stateNode;</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">ctor.getDerivedStateFromError === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">instance.componentDidCatch === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !isAlreadyFailedLegacyErrorBoundary(instance)) {</span>
          <span class="s3">var </span><span class="s1">errorInfo = createCapturedValue(error, sourceFiber);</span>
          <span class="s3">var </span><span class="s1">update = createClassErrorUpdate(fiber, errorInfo, </span><span class="s0">// TODO: This is always sync</span>
          <span class="s1">Sync);</span>
          <span class="s1">enqueueUpdate(fiber, update);</span>
          <span class="s3">var </span><span class="s1">root = markUpdateTimeFromFiberToRoot(fiber, Sync);</span>

          <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">ensureRootIsScheduled(root);</span>
            <span class="s1">schedulePendingInteractions(root, Sync);</span>
          <span class="s1">}</span>

          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">fiber = fiber.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">pingSuspendedRoot(root, thenable, suspendedTime) {</span>
    <span class="s3">var </span><span class="s1">pingCache = root.pingCache;</span>

    <span class="s3">if </span><span class="s1">(pingCache !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// The thenable resolved, so we no longer need to memoize, because it will</span>
      <span class="s0">// never be thrown again.</span>
      <span class="s1">pingCache.</span><span class="s3">delete</span><span class="s1">(thenable);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(workInProgressRoot === root &amp;&amp; renderExpirationTime$1 === suspendedTime) {</span>
      <span class="s0">// Received a ping at the same priority level at which we're currently</span>
      <span class="s0">// rendering. We might want to restart this render. This should mirror</span>
      <span class="s0">// the logic of whether or not a root suspends once it completes.</span>
      <span class="s0">// TODO: If we're rendering sync either due to Sync, Batched or expired,</span>
      <span class="s0">// we should probably never restart.</span>
      <span class="s0">// If we're suspended with delay, we'll always suspend so we can always</span>
      <span class="s0">// restart. If we're suspended without any updates, it might be a retry.</span>
      <span class="s0">// If it's early in the retry we can restart. We can't know for sure</span>
      <span class="s0">// whether we'll eventually process an update during this render pass,</span>
      <span class="s0">// but it's somewhat unlikely that we get to a ping before that, since</span>
      <span class="s0">// getting to the root most update is usually very fast.</span>
      <span class="s3">if </span><span class="s1">(workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended &amp;&amp; workInProgressRootLatestProcessedExpirationTime === Sync &amp;&amp; now() - globalMostRecentFallbackTime &lt; FALLBACK_THROTTLE_MS) {</span>
        <span class="s0">// Restart from the root. Don't need to schedule a ping because</span>
        <span class="s0">// we're already working on this tree.</span>
        <span class="s1">prepareFreshStack(root, renderExpirationTime$1);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Even though we can't restart right now, we might get an</span>
        <span class="s0">// opportunity later. So we mark this render as having a ping.</span>
        <span class="s1">workInProgressRootHasPendingPing = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!isRootSuspendedAtTime(root, suspendedTime)) {</span>
      <span class="s0">// The root is no longer suspended at this time.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">lastPingedTime = root.lastPingedTime;</span>

    <span class="s3">if </span><span class="s1">(lastPingedTime !== NoWork &amp;&amp; lastPingedTime &lt; suspendedTime) {</span>
      <span class="s0">// There's already a lower priority ping scheduled.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// Mark the time at which this ping was scheduled.</span>


    <span class="s1">root.lastPingedTime = suspendedTime;</span>

    <span class="s1">ensureRootIsScheduled(root);</span>
    <span class="s1">schedulePendingInteractions(root, suspendedTime);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">retryTimedOutBoundary(boundaryFiber, retryTime) {</span>
    <span class="s0">// The boundary fiber (a Suspense component or SuspenseList component)</span>
    <span class="s0">// previously was rendered in its fallback state. One of the promises that</span>
    <span class="s0">// suspended it has resolved, which means at least part of the tree was</span>
    <span class="s0">// likely unblocked. Try rendering again, at a new expiration time.</span>
    <span class="s3">if </span><span class="s1">(retryTime === NoWork) {</span>
      <span class="s3">var </span><span class="s1">suspenseConfig = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Retries don't carry over the already committed update.</span>

      <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
      <span class="s1">retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);</span>
    <span class="s1">} </span><span class="s0">// TODO: Special case idle priority?</span>


    <span class="s3">var </span><span class="s1">root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);</span>

    <span class="s3">if </span><span class="s1">(root !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">ensureRootIsScheduled(root);</span>
      <span class="s1">schedulePendingInteractions(root, retryTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resolveRetryThenable(boundaryFiber, thenable) {</span>
    <span class="s3">var </span><span class="s1">retryTime = NoWork; </span><span class="s0">// Default</span>

    <span class="s3">var </span><span class="s1">retryCache;</span>

    <span class="s1">{</span>
      <span class="s1">retryCache = boundaryFiber.stateNode;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(retryCache !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// The thenable resolved, so we no longer need to memoize, because it will</span>
      <span class="s0">// never be thrown again.</span>
      <span class="s1">retryCache.</span><span class="s3">delete</span><span class="s1">(thenable);</span>
    <span class="s1">}</span>

    <span class="s1">retryTimedOutBoundary(boundaryFiber, retryTime);</span>
  <span class="s1">} </span><span class="s0">// Computes the next Just Noticeable Difference (JND) boundary.</span>
  <span class="s0">// The theory is that a person can't tell the difference between small differences in time.</span>
  <span class="s0">// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable</span>
  <span class="s0">// difference in the experience. However, waiting for longer might mean that we can avoid</span>
  <span class="s0">// showing an intermediate loading state. The longer we have already waited, the harder it</span>
  <span class="s0">// is to tell small differences in time. Therefore, the longer we've already waited,</span>
  <span class="s0">// the longer we can wait additionally. At some point we have to give up though.</span>
  <span class="s0">// We pick a train model where the next boundary commits at a consistent schedule.</span>
  <span class="s0">// These particular numbers are vague estimates. We expect to adjust them based on research.</span>

  <span class="s3">function </span><span class="s1">jnd(timeElapsed) {</span>
    <span class="s3">return </span><span class="s1">timeElapsed &lt; </span><span class="s4">120 </span><span class="s1">? </span><span class="s4">120 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">480 </span><span class="s1">? </span><span class="s4">480 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">1080 </span><span class="s1">? </span><span class="s4">1080 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">1920 </span><span class="s1">? </span><span class="s4">1920 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">3000 </span><span class="s1">? </span><span class="s4">3000 </span><span class="s1">: timeElapsed &lt; </span><span class="s4">4320 </span><span class="s1">? </span><span class="s4">4320 </span><span class="s1">: ceil(timeElapsed / </span><span class="s4">1960</span><span class="s1">) * </span><span class="s4">1960</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">computeMsUntilSuspenseLoadingDelay(mostRecentEventTime, committedExpirationTime, suspenseConfig) {</span>
    <span class="s3">var </span><span class="s1">busyMinDurationMs = suspenseConfig.busyMinDurationMs | </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(busyMinDurationMs &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">busyDelayMs = suspenseConfig.busyDelayMs | </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Compute the time until this render pass would expire.</span>

    <span class="s3">var </span><span class="s1">currentTimeMs = now();</span>
    <span class="s3">var </span><span class="s1">eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);</span>
    <span class="s3">var </span><span class="s1">timeElapsed = currentTimeMs - eventTimeMs;</span>

    <span class="s3">if </span><span class="s1">(timeElapsed &lt;= busyDelayMs) {</span>
      <span class="s0">// If we haven't yet waited longer than the initial delay, we don't</span>
      <span class="s0">// have to wait any additional time.</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; </span><span class="s0">// This is the value that is passed to `setTimeout`.</span>

    <span class="s3">return </span><span class="s1">msUntilTimeout;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">checkForNestedUpdates() {</span>
    <span class="s3">if </span><span class="s1">(nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {</span>
      <span class="s1">nestedUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">rootWithNestedUpdates = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.&quot; </span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(nestedPassiveUpdateCount &gt; NESTED_PASSIVE_UPDATE_LIMIT) {</span>
        <span class="s1">nestedPassiveUpdateCount = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'Maximum update depth exceeded. This can happen when a component ' </span><span class="s1">+ </span><span class="s2">&quot;calls setState inside useEffect, but useEffect either doesn't &quot; </span><span class="s1">+ </span><span class="s2">'have a dependency array, or one of the dependencies changes on ' </span><span class="s1">+ </span><span class="s2">'every render.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushRenderPhaseStrictModeWarningsInDEV() {</span>
    <span class="s1">{</span>
      <span class="s1">ReactStrictModeWarnings.flushLegacyContextWarning();</span>

      <span class="s1">{</span>
        <span class="s1">ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">stopFinishedWorkLoopTimer() {</span>
    <span class="s3">var </span><span class="s1">didCompleteRoot = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">stopWorkLoopTimer(interruptedBy, didCompleteRoot);</span>
    <span class="s1">interruptedBy = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">stopInterruptedWorkLoopTimer() {</span>
    <span class="s0">// TODO: Track which fiber caused the interruption.</span>
    <span class="s3">var </span><span class="s1">didCompleteRoot = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">stopWorkLoopTimer(interruptedBy, didCompleteRoot);</span>
    <span class="s1">interruptedBy = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {</span>
    <span class="s3">if </span><span class="s1">( workInProgressRoot !== </span><span class="s3">null </span><span class="s1">&amp;&amp; updateExpirationTime &gt; renderExpirationTime$1) {</span>
      <span class="s1">interruptedBy = fiberThatReceivedUpdate;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnStateUpdateForUnmountedComponent = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">warnAboutUpdateOnUnmountedFiberInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">tag = fiber.tag;</span>

      <span class="s3">if </span><span class="s1">(tag !== HostRoot &amp;&amp; tag !== ClassComponent &amp;&amp; tag !== FunctionComponent &amp;&amp; tag !== ForwardRef &amp;&amp; tag !== MemoComponent &amp;&amp; tag !== SimpleMemoComponent &amp;&amp; tag !== Block) {</span>
        <span class="s0">// Only warn for user-defined components, not internal ones like Suspense.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">// the problematic code almost always lies inside that component.</span>


      <span class="s3">var </span><span class="s1">componentName = getComponentName(fiber.type) || </span><span class="s2">'ReactComponent'</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(didWarnStateUpdateForUnmountedComponent !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(didWarnStateUpdateForUnmountedComponent.has(componentName)) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">didWarnStateUpdateForUnmountedComponent.add(componentName);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">didWarnStateUpdateForUnmountedComponent = </span><span class="s3">new </span><span class="s1">Set([componentName]);</span>
      <span class="s1">}</span>

      <span class="s1">error(</span><span class="s2">&quot;Can't perform a React state update on an unmounted component. This &quot; </span><span class="s1">+ </span><span class="s2">'is a no-op, but it indicates a memory leak in your application. To ' </span><span class="s1">+ </span><span class="s2">'fix, cancel all subscriptions and asynchronous tasks in %s.%s'</span><span class="s1">, tag === ClassComponent ? </span><span class="s2">'the componentWillUnmount method' </span><span class="s1">: </span><span class="s2">'a useEffect cleanup function'</span><span class="s1">, getStackByFiberInDevAndProd(fiber));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">beginWork$1;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">dummyFiber = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">beginWork$1 = </span><span class="s3">function </span><span class="s1">(current, unitOfWork, expirationTime) {</span>
      <span class="s0">// If a component throws an error, we replay it again in a synchronously</span>
      <span class="s0">// dispatched event, so that the debugger will treat it as an uncaught</span>
      <span class="s0">// error See ReactErrorUtils for more information.</span>
      <span class="s0">// Before entering the begin phase, copy the work-in-progress onto a dummy</span>
      <span class="s0">// fiber. If beginWork throws, we'll use this to reset the state.</span>
      <span class="s3">var </span><span class="s1">originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">beginWork(current, unitOfWork, expirationTime);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(originalError) {</span>
        <span class="s3">if </span><span class="s1">(originalError !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">originalError === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">originalError.then === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s0">// Don't replay promises. Treat everything else like an error.</span>
          <span class="s3">throw </span><span class="s1">originalError;</span>
        <span class="s1">} </span><span class="s0">// Keep this code in sync with handleError; any changes here must have</span>
        <span class="s0">// corresponding changes there.</span>


        <span class="s1">resetContextDependencies();</span>
        <span class="s1">resetHooksAfterThrow(); </span><span class="s0">// Don't reset current debug fiber, since we're about to work on the</span>
        <span class="s0">// same fiber again.</span>
        <span class="s0">// Unwind the failed stack frame</span>

        <span class="s1">unwindInterruptedWork(unitOfWork); </span><span class="s0">// Restore the original properties of the fiber.</span>

        <span class="s1">assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);</span>

        <span class="s3">if </span><span class="s1">( unitOfWork.mode &amp; ProfileMode) {</span>
          <span class="s0">// Reset the profiler timer.</span>
          <span class="s1">startProfilerTimer(unitOfWork);</span>
        <span class="s1">} </span><span class="s0">// Run beginWork again.</span>


        <span class="s1">invokeGuardedCallback(</span><span class="s3">null</span><span class="s1">, beginWork, </span><span class="s3">null</span><span class="s1">, current, unitOfWork, expirationTime);</span>

        <span class="s3">if </span><span class="s1">(hasCaughtError()) {</span>
          <span class="s3">var </span><span class="s1">replayError = clearCaughtError(); </span><span class="s0">// `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.</span>
          <span class="s0">// Rethrow this error instead of the original one.</span>

          <span class="s3">throw </span><span class="s1">replayError;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// This branch is reachable if the render phase is impure.</span>
          <span class="s3">throw </span><span class="s1">originalError;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnAboutUpdateInRender = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutUpdateInRenderForAnotherComponent;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnAboutRenderPhaseUpdatesInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isRendering &amp;&amp; (executionContext &amp; RenderContext) !== NoContext) {</span>
        <span class="s3">switch </span><span class="s1">(fiber.tag) {</span>
          <span class="s3">case </span><span class="s1">FunctionComponent:</span>
          <span class="s3">case </span><span class="s1">ForwardRef:</span>
          <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
            <span class="s1">{</span>
              <span class="s3">var </span><span class="s1">renderingComponentName = workInProgress &amp;&amp; getComponentName(workInProgress.type) || </span><span class="s2">'Unknown'</span><span class="s1">; </span><span class="s0">// Dedupe by the rendering component because it's the one that needs to be fixed.</span>

              <span class="s3">var </span><span class="s1">dedupeKey = renderingComponentName;</span>

              <span class="s3">if </span><span class="s1">(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {</span>
                <span class="s1">didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);</span>
                <span class="s3">var </span><span class="s1">setStateComponentName = getComponentName(fiber.type) || </span><span class="s2">'Unknown'</span><span class="s1">;</span>

                <span class="s1">error(</span><span class="s2">'Cannot update a component (`%s`) while rendering a ' </span><span class="s1">+ </span><span class="s2">'different component (`%s`). To locate the bad setState() call inside `%s`, ' </span><span class="s1">+ </span><span class="s2">'follow the stack trace as described in https://fb.me/setstate-in-render'</span><span class="s1">, setStateComponentName, renderingComponentName, renderingComponentName);</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>

          <span class="s3">case </span><span class="s1">ClassComponent:</span>
            <span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(!didWarnAboutUpdateInRender) {</span>
                <span class="s1">error(</span><span class="s2">'Cannot update during an existing state transition (such as ' </span><span class="s1">+ </span><span class="s2">'within `render`). Render methods should be a pure ' </span><span class="s1">+ </span><span class="s2">'function of props and state.'</span><span class="s1">);</span>

                <span class="s1">didWarnAboutUpdateInRender = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// a 'shared' variable that changes when act() opens/closes in tests.</span>


  <span class="s3">var </span><span class="s1">IsThisRendererActing = {</span>
    <span class="s1">current: </span><span class="s3">false</span>
  <span class="s1">};</span>
  <span class="s3">function </span><span class="s1">warnIfNotScopedWithMatchingAct(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">( IsSomeRendererActing.current === </span><span class="s3">true </span><span class="s1">&amp;&amp; IsThisRendererActing.current !== </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">&quot;It looks like you're using the wrong act() around your test interactions.</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'Be sure to use the matching version of act() corresponding to your renderer:</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'// for react-dom:</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;import {act} from 'react-dom/test-utils';</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'// ...</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'act(() =&gt; ...);</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'// for react-test-renderer:</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;import TestRenderer from 'react-test-renderer';</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'const {act} = TestRenderer;</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'// ...</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'act(() =&gt; ...);' </span><span class="s1">+ </span><span class="s2">'%s'</span><span class="s1">, getStackByFiberInDevAndProd(fiber));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">warnIfNotCurrentlyActingEffectsInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">( (fiber.mode &amp; StrictMode) !== NoMode &amp;&amp; IsSomeRendererActing.current === </span><span class="s3">false </span><span class="s1">&amp;&amp; IsThisRendererActing.current === </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'An update to %s ran an effect, but was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'When testing, code that causes React state updates should be ' </span><span class="s1">+ </span><span class="s2">'wrapped into act(...):</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'act(() =&gt; {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  /* fire events that update state */</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'});</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'/* assert on the output */</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+ </span><span class="s2">'in the browser.' </span><span class="s1">+ </span><span class="s2">' Learn more at https://fb.me/react-wrap-tests-with-act' </span><span class="s1">+ </span><span class="s2">'%s'</span><span class="s1">, getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnIfNotCurrentlyActingUpdatesInDEV(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">( executionContext === NoContext &amp;&amp; IsSomeRendererActing.current === </span><span class="s3">false </span><span class="s1">&amp;&amp; IsThisRendererActing.current === </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'An update to %s inside a test was not wrapped in act(...).</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'When testing, code that causes React state updates should be ' </span><span class="s1">+ </span><span class="s2">'wrapped into act(...):</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'act(() =&gt; {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  /* fire events that update state */</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'});</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'/* assert on the output */</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;This ensures that you're testing the behavior the user would see &quot; </span><span class="s1">+ </span><span class="s2">'in the browser.' </span><span class="s1">+ </span><span class="s2">' Learn more at https://fb.me/react-wrap-tests-with-act' </span><span class="s1">+ </span><span class="s2">'%s'</span><span class="s1">, getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; </span><span class="s0">// In tests, we want to enforce a mocked scheduler.</span>

  <span class="s3">var </span><span class="s1">didWarnAboutUnmockedScheduler = </span><span class="s3">false</span><span class="s1">; </span><span class="s0">// TODO Before we release concurrent mode, revisit this and decide whether a mocked</span>
  <span class="s0">// scheduler is the actual recommendation. The alternative could be a testing build,</span>
  <span class="s0">// a new lib, or whatever; we dunno just yet. This message is for early adopters</span>
  <span class="s0">// to get their tests right.</span>

  <span class="s3">function </span><span class="s1">warnIfUnmockedScheduler(fiber) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(didWarnAboutUnmockedScheduler === </span><span class="s3">false </span><span class="s1">&amp;&amp; unstable_flushAllWithoutAsserting === undefined) {</span>
        <span class="s3">if </span><span class="s1">(fiber.mode &amp; BlockingMode || fiber.mode &amp; ConcurrentMode) {</span>
          <span class="s1">didWarnAboutUnmockedScheduler = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'In Concurrent or Sync modes, the &quot;scheduler&quot; module needs to be mocked ' </span><span class="s1">+ </span><span class="s2">'to guarantee consistent behaviour across tests and browsers. ' </span><span class="s1">+ </span><span class="s2">'For example, with jest: </span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;jest.mock('scheduler', () =&gt; require('scheduler/unstable_mock'));</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'For more info, visit https://fb.me/react-mock-scheduler'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">computeThreadID(root, expirationTime) {</span>
    <span class="s0">// Interaction threads are unique per root and expiration time.</span>
    <span class="s3">return </span><span class="s1">expirationTime * </span><span class="s4">1000 </span><span class="s1">+ root.interactionThreadID;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markSpawnedWork(expirationTime) {</span>

    <span class="s3">if </span><span class="s1">(spawnedWorkDuringRender === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">spawnedWorkDuringRender = [expirationTime];</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">spawnedWorkDuringRender.push(expirationTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">scheduleInteractions(root, expirationTime, interactions) {</span>

    <span class="s3">if </span><span class="s1">(interactions.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">pendingInteractionMap = root.pendingInteractionMap;</span>
      <span class="s3">var </span><span class="s1">pendingInteractions = pendingInteractionMap.get(expirationTime);</span>

      <span class="s3">if </span><span class="s1">(pendingInteractions != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">interactions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
          <span class="s3">if </span><span class="s1">(!pendingInteractions.has(interaction)) {</span>
            <span class="s0">// Update the pending async work count for previously unscheduled interaction.</span>
            <span class="s1">interaction.__count++;</span>
          <span class="s1">}</span>

          <span class="s1">pendingInteractions.add(interaction);</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pendingInteractionMap.set(expirationTime, </span><span class="s3">new </span><span class="s1">Set(interactions)); </span><span class="s0">// Update the pending async work count for the current interactions.</span>

        <span class="s1">interactions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
          <span class="s1">interaction.__count++;</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">subscriber = __subscriberRef.current;</span>

      <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">threadID = computeThreadID(root, expirationTime);</span>
        <span class="s1">subscriber.onWorkScheduled(interactions, threadID);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">schedulePendingInteractions(root, expirationTime) {</span>

    <span class="s1">scheduleInteractions(root, expirationTime, __interactionsRef.current);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">startWorkOnPendingInteractions(root, expirationTime) {</span>
    <span class="s0">// we can accurately attribute time spent working on it, And so that cascading</span>
    <span class="s0">// work triggered during the render phase will be associated with it.</span>


    <span class="s3">var </span><span class="s1">interactions = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">root.pendingInteractionMap.forEach(</span><span class="s3">function </span><span class="s1">(scheduledInteractions, scheduledExpirationTime) {</span>
      <span class="s3">if </span><span class="s1">(scheduledExpirationTime &gt;= expirationTime) {</span>
        <span class="s1">scheduledInteractions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
          <span class="s3">return </span><span class="s1">interactions.add(interaction);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}); </span><span class="s0">// Store the current set of interactions on the FiberRoot for a few reasons:</span>
    <span class="s0">// We can re-use it in hot functions like performConcurrentWorkOnRoot()</span>
    <span class="s0">// without having to recalculate it. We will also use it in commitWork() to</span>
    <span class="s0">// pass to any Profiler onRender() hooks. This also provides DevTools with a</span>
    <span class="s0">// way to access it when the onCommitRoot() hook is called.</span>

    <span class="s1">root.memoizedInteractions = interactions;</span>

    <span class="s3">if </span><span class="s1">(interactions.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">subscriber = __subscriberRef.current;</span>

      <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">threadID = computeThreadID(root, expirationTime);</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">subscriber.onWorkStarted(interactions, threadID);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s0">// If the subscriber throws, rethrow it in a separate task</span>
          <span class="s1">scheduleCallback(ImmediatePriority, </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">throw </span><span class="s1">error;</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">finishPendingInteractions(root, committedExpirationTime) {</span>

    <span class="s3">var </span><span class="s1">earliestRemainingTimeAfterCommit = root.firstPendingTime;</span>
    <span class="s3">var </span><span class="s1">subscriber;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">subscriber = __subscriberRef.current;</span>

      <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; root.memoizedInteractions.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">threadID = computeThreadID(root, committedExpirationTime);</span>
        <span class="s1">subscriber.onWorkStopped(root.memoizedInteractions, threadID);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s0">// If the subscriber throws, rethrow it in a separate task</span>
      <span class="s1">scheduleCallback(ImmediatePriority, </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">throw </span><span class="s1">error;</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s0">// Clear completed interactions from the pending Map.</span>
      <span class="s0">// Unless the render was suspended or cascading work was scheduled,</span>
      <span class="s0">// In which case– leave pending interactions until the subsequent render.</span>
      <span class="s3">var </span><span class="s1">pendingInteractionMap = root.pendingInteractionMap;</span>
      <span class="s1">pendingInteractionMap.forEach(</span><span class="s3">function </span><span class="s1">(scheduledInteractions, scheduledExpirationTime) {</span>
        <span class="s0">// Only decrement the pending interaction count if we're done.</span>
        <span class="s0">// If there's still work at the current priority,</span>
        <span class="s0">// That indicates that we are waiting for suspense data.</span>
        <span class="s3">if </span><span class="s1">(scheduledExpirationTime &gt; earliestRemainingTimeAfterCommit) {</span>
          <span class="s1">pendingInteractionMap.</span><span class="s3">delete</span><span class="s1">(scheduledExpirationTime);</span>
          <span class="s1">scheduledInteractions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
            <span class="s1">interaction.__count--;</span>

            <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; interaction.__count === </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">subscriber.onInteractionScheduledWorkCompleted(interaction);</span>
              <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
                <span class="s0">// If the subscriber throws, rethrow it in a separate task</span>
                <span class="s1">scheduleCallback(ImmediatePriority, </span><span class="s3">function </span><span class="s1">() {</span>
                  <span class="s3">throw </span><span class="s1">error;</span>
                <span class="s1">});</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">onScheduleFiberRoot = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">onCommitFiberRoot = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">onCommitFiberUnmount = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasLoggedError = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isDevToolsPresent = </span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined'</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">injectInternals(internals) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">__REACT_DEVTOOLS_GLOBAL_HOOK__ === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s0">// No DevTools</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;</span>

    <span class="s3">if </span><span class="s1">(hook.isDisabled) {</span>
      <span class="s0">// This isn't a real property on the hook, but it can be set to opt out</span>
      <span class="s0">// of DevTools integration and associated warnings and logs.</span>
      <span class="s0">// https://github.com/facebook/react/issues/3877</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!hook.supportsFiber) {</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'The installed version of React DevTools is too old and will not work ' </span><span class="s1">+ </span><span class="s2">'with the current version of React. Please update React DevTools. ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-devtools'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// DevTools exists, even though it doesn't support Fiber.</span>


      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">rendererID = hook.inject(internals); </span><span class="s0">// We have successfully injected, so now it is safe to set up hooks.</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s0">// Only used by Fast Refresh</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">hook.onScheduleFiberRoot === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">onScheduleFiberRoot = </span><span class="s3">function </span><span class="s1">(root, children) {</span>
            <span class="s3">try </span><span class="s1">{</span>
              <span class="s1">hook.onScheduleFiberRoot(rendererID, root, children);</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s3">if </span><span class="s1">(</span><span class="s3">true </span><span class="s1">&amp;&amp; !hasLoggedError) {</span>
                <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

                <span class="s1">error(</span><span class="s2">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">};</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">onCommitFiberRoot = </span><span class="s3">function </span><span class="s1">(root, expirationTime) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">didError = (root.current.effectTag &amp; DidCapture) === DidCapture;</span>

          <span class="s3">if </span><span class="s1">(enableProfilerTimer) {</span>
            <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
            <span class="s3">var </span><span class="s1">priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime);</span>
            <span class="s1">hook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">hook.onCommitFiberRoot(rendererID, root, undefined, didError);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
              <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s2">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">};</span>

      <span class="s1">onCommitFiberUnmount = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">hook.onCommitFiberUnmount(rendererID, fiber);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(!hasLoggedError) {</span>
              <span class="s1">hasLoggedError = </span><span class="s3">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s2">'React instrumentation encountered an error: %s'</span><span class="s1">, err);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s0">// Catch all errors because it is unsafe to throw during initialization.</span>
      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'React instrumentation encountered an error: %s.'</span><span class="s1">, err);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// DevTools exists</span>


    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">onScheduleRoot(root, children) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onScheduleFiberRoot === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">onScheduleFiberRoot(root, children);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">onCommitRoot(root, expirationTime) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onCommitFiberRoot === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">onCommitFiberRoot(root, expirationTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">onCommitUnmount(fiber) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">onCommitFiberUnmount === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">onCommitFiberUnmount(fiber);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hasBadMapPolyfill;</span>

  <span class="s1">{</span>
    <span class="s1">hasBadMapPolyfill = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">nonExtensibleObject = Object.preventExtensions({});</span>
      <span class="s3">var </span><span class="s1">testMap = </span><span class="s3">new </span><span class="s1">Map([[nonExtensibleObject, </span><span class="s3">null</span><span class="s1">]]);</span>
      <span class="s3">var </span><span class="s1">testSet = </span><span class="s3">new </span><span class="s1">Set([nonExtensibleObject]); </span><span class="s0">// This is necessary for Rollup to not consider these unused.</span>
      <span class="s0">// https://github.com/rollup/rollup/issues/1771</span>
      <span class="s0">// TODO: we can remove these if Rollup fixes the bug.</span>

      <span class="s1">testMap.set(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">testSet.add(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
      <span class="s0">// TODO: Consider warning about bad polyfills</span>
      <span class="s1">hasBadMapPolyfill = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">debugCounter = </span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">FiberNode(tag, pendingProps, key, mode) {</span>
    <span class="s0">// Instance</span>
    <span class="s3">this</span><span class="s1">.tag = tag;</span>
    <span class="s3">this</span><span class="s1">.key = key;</span>
    <span class="s3">this</span><span class="s1">.elementType = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.type = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.stateNode = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Fiber</span>

    <span class="s3">this</span><span class="s1">.</span><span class="s3">return </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.child = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.sibling = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.index = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.ref = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.pendingProps = pendingProps;</span>
    <span class="s3">this</span><span class="s1">.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.dependencies = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.mode = mode; </span><span class="s0">// Effects</span>

    <span class="s3">this</span><span class="s1">.effectTag = NoEffect;</span>
    <span class="s3">this</span><span class="s1">.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.firstEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.expirationTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.childExpirationTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.alternate = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// Note: The following is done to avoid a v8 performance cliff.</span>
      <span class="s0">//</span>
      <span class="s0">// Initializing the fields below to smis and later updating them with</span>
      <span class="s0">// double values will cause Fibers to end up having separate shapes.</span>
      <span class="s0">// This behavior/bug has something to do with Object.preventExtension().</span>
      <span class="s0">// Fortunately this only impacts DEV builds.</span>
      <span class="s0">// Unfortunately it makes React unusably slow for some applications.</span>
      <span class="s0">// To work around this, initialize the fields below with doubles.</span>
      <span class="s0">//</span>
      <span class="s0">// Learn more about this here:</span>
      <span class="s0">// https://github.com/facebook/react/issues/14365</span>
      <span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span>
      <span class="s3">this</span><span class="s1">.actualDuration = Number.NaN;</span>
      <span class="s3">this</span><span class="s1">.actualStartTime = Number.NaN;</span>
      <span class="s3">this</span><span class="s1">.selfBaseDuration = Number.NaN;</span>
      <span class="s3">this</span><span class="s1">.treeBaseDuration = Number.NaN; </span><span class="s0">// It's okay to replace the initial doubles with smis after initialization.</span>
      <span class="s0">// This won't trigger the performance cliff mentioned above,</span>
      <span class="s0">// and it simplifies other profiler code (including DevTools).</span>

      <span class="s3">this</span><span class="s1">.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// This is normally DEV-only except www when it adds listeners.</span>
    <span class="s0">// TODO: remove the User Timing integration in favor of Root Events.</span>


    <span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._debugID = debugCounter++;</span>
      <span class="s3">this</span><span class="s1">._debugIsCurrentlyTiming = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._debugSource = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._debugOwner = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._debugNeedsRemount = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._debugHookTypes = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!hasBadMapPolyfill &amp;&amp; </span><span class="s3">typeof </span><span class="s1">Object.preventExtensions === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">Object.preventExtensions(</span><span class="s3">this</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// This is a constructor function, rather than a POJO constructor, still</span>
  <span class="s0">// please ensure we do the following:</span>
  <span class="s0">// 1) Nobody should add any instance methods on this. Instance methods can be</span>
  <span class="s0">//    more difficult to predict when they get optimized and they are almost</span>
  <span class="s0">//    never inlined properly in static compilers.</span>
  <span class="s0">// 2) Nobody should rely on `instanceof Fiber` for type testing. We should</span>
  <span class="s0">//    always know when it is a fiber.</span>
  <span class="s0">// 3) We might want to experiment with using numeric keys since they are easier</span>
  <span class="s0">//    to optimize in a non-JIT environment.</span>
  <span class="s0">// 4) We can easily go from a constructor to a createFiber object literal if that</span>
  <span class="s0">//    is faster.</span>
  <span class="s0">// 5) It should be easy to port this to a C struct and keep a C implementation</span>
  <span class="s0">//    compatible.</span>


  <span class="s3">var </span><span class="s1">createFiber = </span><span class="s3">function </span><span class="s1">(tag, pendingProps, key, mode) {</span>
    <span class="s0">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span>
    <span class="s3">return new </span><span class="s1">FiberNode(tag, pendingProps, key, mode);</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">shouldConstruct(Component) {</span>
    <span class="s3">var </span><span class="s1">prototype = Component.prototype;</span>
    <span class="s3">return </span><span class="s1">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isSimpleFunctionComponent(type) {</span>
    <span class="s3">return typeof </span><span class="s1">type === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !shouldConstruct(type) &amp;&amp; type.defaultProps === undefined;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">resolveLazyComponentTag(Component) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Component === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">shouldConstruct(Component) ? ClassComponent : FunctionComponent;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Component !== undefined &amp;&amp; Component !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">$$typeof = Component.$$typeof;</span>

      <span class="s3">if </span><span class="s1">($$typeof === REACT_FORWARD_REF_TYPE) {</span>
        <span class="s3">return </span><span class="s1">ForwardRef;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">($$typeof === REACT_MEMO_TYPE) {</span>
        <span class="s3">return </span><span class="s1">MemoComponent;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">IndeterminateComponent;</span>
  <span class="s1">} </span><span class="s0">// This is used to create an alternate fiber to do work on.</span>

  <span class="s3">function </span><span class="s1">createWorkInProgress(current, pendingProps) {</span>
    <span class="s3">var </span><span class="s1">workInProgress = current.alternate;</span>

    <span class="s3">if </span><span class="s1">(workInProgress === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// We use a double buffering pooling technique because we know that we'll</span>
      <span class="s0">// only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span>
      <span class="s0">// node that we're free to reuse. This is lazily created to avoid allocating</span>
      <span class="s0">// extra objects for things that are never updated. It also allow us to</span>
      <span class="s0">// reclaim the extra memory if needed.</span>
      <span class="s1">workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span>
      <span class="s1">workInProgress.elementType = current.elementType;</span>
      <span class="s1">workInProgress.type = current.type;</span>
      <span class="s1">workInProgress.stateNode = current.stateNode;</span>

      <span class="s1">{</span>
        <span class="s0">// DEV-only fields</span>
        <span class="s1">{</span>
          <span class="s1">workInProgress._debugID = current._debugID;</span>
        <span class="s1">}</span>

        <span class="s1">workInProgress._debugSource = current._debugSource;</span>
        <span class="s1">workInProgress._debugOwner = current._debugOwner;</span>
        <span class="s1">workInProgress._debugHookTypes = current._debugHookTypes;</span>
      <span class="s1">}</span>

      <span class="s1">workInProgress.alternate = current;</span>
      <span class="s1">current.alternate = workInProgress;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">workInProgress.pendingProps = pendingProps; </span><span class="s0">// We already have an alternate.</span>
      <span class="s0">// Reset the effect tag.</span>

      <span class="s1">workInProgress.effectTag = NoEffect; </span><span class="s0">// The effect list is no longer valid.</span>

      <span class="s1">workInProgress.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.firstEffect = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span>
        <span class="s0">// This prevents time from endlessly accumulating in new commits.</span>
        <span class="s0">// This has the downside of resetting values for different priority renders,</span>
        <span class="s0">// But works for yielding (the common case) and should support resuming.</span>
        <span class="s1">workInProgress.actualDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">workInProgress.actualStartTime = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">workInProgress.childExpirationTime = current.childExpirationTime;</span>
    <span class="s1">workInProgress.expirationTime = current.expirationTime;</span>
    <span class="s1">workInProgress.child = current.child;</span>
    <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
    <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
    <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
    <span class="s0">// it cannot be shared with the current fiber.</span>

    <span class="s3">var </span><span class="s1">currentDependencies = current.dependencies;</span>
    <span class="s1">workInProgress.dependencies = currentDependencies === </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: {</span>
      <span class="s1">expirationTime: currentDependencies.expirationTime,</span>
      <span class="s1">firstContext: currentDependencies.firstContext,</span>
      <span class="s1">responders: currentDependencies.responders</span>
    <span class="s1">}; </span><span class="s0">// These will be overridden during the parent's reconciliation</span>

    <span class="s1">workInProgress.sibling = current.sibling;</span>
    <span class="s1">workInProgress.index = current.index;</span>
    <span class="s1">workInProgress.ref = current.ref;</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
      <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">workInProgress._debugNeedsRemount = current._debugNeedsRemount;</span>

      <span class="s3">switch </span><span class="s1">(workInProgress.tag) {</span>
        <span class="s3">case </span><span class="s1">IndeterminateComponent:</span>
        <span class="s3">case </span><span class="s1">FunctionComponent:</span>
        <span class="s3">case </span><span class="s1">SimpleMemoComponent:</span>
          <span class="s1">workInProgress.type = resolveFunctionForHotReloading(current.type);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">ClassComponent:</span>
          <span class="s1">workInProgress.type = resolveClassForHotReloading(current.type);</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">ForwardRef:</span>
          <span class="s1">workInProgress.type = resolveForwardRefForHotReloading(current.type);</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress;</span>
  <span class="s1">} </span><span class="s0">// Used to reuse a Fiber for a second pass.</span>

  <span class="s3">function </span><span class="s1">resetWorkInProgress(workInProgress, renderExpirationTime) {</span>
    <span class="s0">// This resets the Fiber to what createFiber or createWorkInProgress would</span>
    <span class="s0">// have set the values to before during the first pass. Ideally this wouldn't</span>
    <span class="s0">// be necessary but unfortunately many code paths reads from the workInProgress</span>
    <span class="s0">// when they should be reading from current and writing to workInProgress.</span>
    <span class="s0">// We assume pendingProps, index, key, ref, return are still untouched to</span>
    <span class="s0">// avoid doing another reconciliation.</span>
    <span class="s0">// Reset the effect tag but keep any Placement tags, since that's something</span>
    <span class="s0">// that child fiber is setting, not the reconciliation.</span>
    <span class="s1">workInProgress.effectTag &amp;= Placement; </span><span class="s0">// The effect list is no longer valid.</span>

    <span class="s1">workInProgress.nextEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.firstEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">workInProgress.lastEffect = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">current = workInProgress.alternate;</span>

    <span class="s3">if </span><span class="s1">(current === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Reset to createFiber's initial values.</span>
      <span class="s1">workInProgress.childExpirationTime = NoWork;</span>
      <span class="s1">workInProgress.expirationTime = renderExpirationTime;</span>
      <span class="s1">workInProgress.child = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.memoizedProps = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.memoizedState = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.updateQueue = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">workInProgress.dependencies = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
        <span class="s0">// actual time across multiple render passes.</span>
        <span class="s1">workInProgress.selfBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">workInProgress.treeBaseDuration = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Reset to the cloned values that createWorkInProgress would've.</span>
      <span class="s1">workInProgress.childExpirationTime = current.childExpirationTime;</span>
      <span class="s1">workInProgress.expirationTime = current.expirationTime;</span>
      <span class="s1">workInProgress.child = current.child;</span>
      <span class="s1">workInProgress.memoizedProps = current.memoizedProps;</span>
      <span class="s1">workInProgress.memoizedState = current.memoizedState;</span>
      <span class="s1">workInProgress.updateQueue = current.updateQueue; </span><span class="s0">// Clone the dependencies object. This is mutated during the render phase, so</span>
      <span class="s0">// it cannot be shared with the current fiber.</span>

      <span class="s3">var </span><span class="s1">currentDependencies = current.dependencies;</span>
      <span class="s1">workInProgress.dependencies = currentDependencies === </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: {</span>
        <span class="s1">expirationTime: currentDependencies.expirationTime,</span>
        <span class="s1">firstContext: currentDependencies.firstContext,</span>
        <span class="s1">responders: currentDependencies.responders</span>
      <span class="s1">};</span>

      <span class="s1">{</span>
        <span class="s0">// Note: We don't reset the actualTime counts. It's useful to accumulate</span>
        <span class="s0">// actual time across multiple render passes.</span>
        <span class="s1">workInProgress.selfBaseDuration = current.selfBaseDuration;</span>
        <span class="s1">workInProgress.treeBaseDuration = current.treeBaseDuration;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">workInProgress;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createHostRootFiber(tag) {</span>
    <span class="s3">var </span><span class="s1">mode;</span>

    <span class="s3">if </span><span class="s1">(tag === ConcurrentRoot) {</span>
      <span class="s1">mode = ConcurrentMode | BlockingMode | StrictMode;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(tag === BlockingRoot) {</span>
      <span class="s1">mode = BlockingMode | StrictMode;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">mode = NoMode;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">( isDevToolsPresent) {</span>
      <span class="s0">// Always collect profile timings when DevTools are present.</span>
      <span class="s0">// This enables DevTools to start capturing timing at any point–</span>
      <span class="s0">// Without some nodes in the tree having empty base times.</span>
      <span class="s1">mode |= ProfileMode;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">createFiber(HostRoot, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, mode);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromTypeAndProps(type, </span><span class="s0">// React$ElementType</span>
  <span class="s1">key, pendingProps, owner, mode, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">fiber;</span>
    <span class="s3">var </span><span class="s1">fiberTag = IndeterminateComponent; </span><span class="s0">// The resolved type is set if we know what the final type will be. I.e. it's not lazy.</span>

    <span class="s3">var </span><span class="s1">resolvedType = type;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(shouldConstruct(type)) {</span>
        <span class="s1">fiberTag = ClassComponent;</span>

        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveClassForHotReloading(resolvedType);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">{</span>
          <span class="s1">resolvedType = resolveFunctionForHotReloading(resolvedType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s1">fiberTag = HostComponent;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">getTag: </span><span class="s3">switch </span><span class="s1">(type) {</span>
        <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
          <span class="s3">return </span><span class="s1">createFiberFromFragment(pendingProps.children, mode, expirationTime, key);</span>

        <span class="s3">case </span><span class="s1">REACT_CONCURRENT_MODE_TYPE:</span>
          <span class="s1">fiberTag = Mode;</span>
          <span class="s1">mode |= ConcurrentMode | BlockingMode | StrictMode;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
          <span class="s1">fiberTag = Mode;</span>
          <span class="s1">mode |= StrictMode;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
          <span class="s3">return </span><span class="s1">createFiberFromProfiler(pendingProps, mode, expirationTime, key);</span>

        <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
          <span class="s3">return </span><span class="s1">createFiberFromSuspense(pendingProps, mode, expirationTime, key);</span>

        <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
          <span class="s3">return </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, expirationTime, key);</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
                <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
                  <span class="s1">fiberTag = ContextProvider;</span>
                  <span class="s3">break </span><span class="s1">getTag;</span>

                <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
                  <span class="s0">// This is a consumer</span>
                  <span class="s1">fiberTag = ContextConsumer;</span>
                  <span class="s3">break </span><span class="s1">getTag;</span>

                <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
                  <span class="s1">fiberTag = ForwardRef;</span>

                  <span class="s1">{</span>
                    <span class="s1">resolvedType = resolveForwardRefForHotReloading(resolvedType);</span>
                  <span class="s1">}</span>

                  <span class="s3">break </span><span class="s1">getTag;</span>

                <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
                  <span class="s1">fiberTag = MemoComponent;</span>
                  <span class="s3">break </span><span class="s1">getTag;</span>

                <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
                  <span class="s1">fiberTag = LazyComponent;</span>
                  <span class="s1">resolvedType = </span><span class="s3">null</span><span class="s1">;</span>
                  <span class="s3">break </span><span class="s1">getTag;</span>

                <span class="s3">case </span><span class="s1">REACT_BLOCK_TYPE:</span>
                  <span class="s1">fiberTag = Block;</span>
                  <span class="s3">break </span><span class="s1">getTag;</span>

              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>

            <span class="s1">{</span>
              <span class="s3">if </span><span class="s1">(type === undefined || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Object.keys(type).length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">info += </span><span class="s2">' You likely forgot to export your component from the file ' </span><span class="s1">+ </span><span class="s2">&quot;it's defined in, or you might have mixed up default and &quot; </span><span class="s1">+ </span><span class="s2">'named imports.'</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s3">var </span><span class="s1">ownerName = owner ? getComponentName(owner.type) : </span><span class="s3">null</span><span class="s1">;</span>

              <span class="s3">if </span><span class="s1">(ownerName) {</span>
                <span class="s1">info += </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check the render method of `' </span><span class="s1">+ ownerName + </span><span class="s2">'`.'</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">{</span>
              <span class="s1">{</span>
                <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: &quot; </span><span class="s1">+ (type == </span><span class="s3">null </span><span class="s1">? type : </span><span class="s3">typeof </span><span class="s1">type) + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ info );</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">fiber = createFiber(fiberTag, pendingProps, key, mode);</span>
    <span class="s1">fiber.elementType = type;</span>
    <span class="s1">fiber.type = resolvedType;</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromElement(element, mode, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">owner = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s1">owner = element._owner;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">type = element.type;</span>
    <span class="s3">var </span><span class="s1">key = element.key;</span>
    <span class="s3">var </span><span class="s1">pendingProps = element.props;</span>
    <span class="s3">var </span><span class="s1">fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);</span>

    <span class="s1">{</span>
      <span class="s1">fiber._debugSource = element._source;</span>
      <span class="s1">fiber._debugOwner = element._owner;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromFragment(elements, mode, expirationTime, key) {</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(Fragment, elements, key, mode);</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createFiberFromProfiler(pendingProps, mode, expirationTime, key) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">pendingProps.id !== </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">pendingProps.onRender !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Profiler must specify an &quot;id&quot; string and &quot;onRender&quot; function as props'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); </span><span class="s0">// TODO: The Profiler fiber shouldn't have a type. It has a tag.</span>

    <span class="s1">fiber.elementType = REACT_PROFILER_TYPE;</span>
    <span class="s1">fiber.type = REACT_PROFILER_TYPE;</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createFiberFromSuspense(pendingProps, mode, expirationTime, key) {</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(SuspenseComponent, pendingProps, key, mode); </span><span class="s0">// TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.</span>
    <span class="s0">// This needs to be fixed in getComponentName so that it relies on the tag</span>
    <span class="s0">// instead.</span>

    <span class="s1">fiber.type = REACT_SUSPENSE_TYPE;</span>
    <span class="s1">fiber.elementType = REACT_SUSPENSE_TYPE;</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);</span>

    <span class="s1">{</span>
      <span class="s0">// TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.</span>
      <span class="s0">// This needs to be fixed in getComponentName so that it relies on the tag</span>
      <span class="s0">// instead.</span>
      <span class="s1">fiber.type = REACT_SUSPENSE_LIST_TYPE;</span>
    <span class="s1">}</span>

    <span class="s1">fiber.elementType = REACT_SUSPENSE_LIST_TYPE;</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromText(content, mode, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(HostText, content, </span><span class="s3">null</span><span class="s1">, mode);</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromHostInstanceForDeletion() {</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(HostComponent, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, NoMode); </span><span class="s0">// TODO: These should not need a type.</span>

    <span class="s1">fiber.elementType = </span><span class="s2">'DELETED'</span><span class="s1">;</span>
    <span class="s1">fiber.type = </span><span class="s2">'DELETED'</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createFiberFromPortal(portal, mode, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">pendingProps = portal.children !== </span><span class="s3">null </span><span class="s1">? portal.children : [];</span>
    <span class="s3">var </span><span class="s1">fiber = createFiber(HostPortal, pendingProps, portal.key, mode);</span>
    <span class="s1">fiber.expirationTime = expirationTime;</span>
    <span class="s1">fiber.stateNode = {</span>
      <span class="s1">containerInfo: portal.containerInfo,</span>
      <span class="s1">pendingChildren: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s0">// Used by persistent updates</span>
      <span class="s1">implementation: portal.implementation</span>
    <span class="s1">};</span>
    <span class="s3">return </span><span class="s1">fiber;</span>
  <span class="s1">} </span><span class="s0">// Used for stashing WIP properties to replay failed work in DEV.</span>

  <span class="s3">function </span><span class="s1">assignFiberPropertiesInDEV(target, source) {</span>
    <span class="s3">if </span><span class="s1">(target === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// This Fiber's initial properties will always be overwritten.</span>
      <span class="s0">// We only use a Fiber to ensure the same hidden class so DEV isn't slow.</span>
      <span class="s1">target = createFiber(IndeterminateComponent, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, NoMode);</span>
    <span class="s1">} </span><span class="s0">// This is intentionally written as a list of all properties.</span>
    <span class="s0">// We tried to use Object.assign() instead but this is called in</span>
    <span class="s0">// the hottest path, and Object.assign() was too slow:</span>
    <span class="s0">// https://github.com/facebook/react/issues/12502</span>
    <span class="s0">// This code is DEV-only so size is not a concern.</span>


    <span class="s1">target.tag = source.tag;</span>
    <span class="s1">target.key = source.key;</span>
    <span class="s1">target.elementType = source.elementType;</span>
    <span class="s1">target.type = source.type;</span>
    <span class="s1">target.stateNode = source.stateNode;</span>
    <span class="s1">target.</span><span class="s3">return </span><span class="s1">= source.</span><span class="s3">return</span><span class="s1">;</span>
    <span class="s1">target.child = source.child;</span>
    <span class="s1">target.sibling = source.sibling;</span>
    <span class="s1">target.index = source.index;</span>
    <span class="s1">target.ref = source.ref;</span>
    <span class="s1">target.pendingProps = source.pendingProps;</span>
    <span class="s1">target.memoizedProps = source.memoizedProps;</span>
    <span class="s1">target.updateQueue = source.updateQueue;</span>
    <span class="s1">target.memoizedState = source.memoizedState;</span>
    <span class="s1">target.dependencies = source.dependencies;</span>
    <span class="s1">target.mode = source.mode;</span>
    <span class="s1">target.effectTag = source.effectTag;</span>
    <span class="s1">target.nextEffect = source.nextEffect;</span>
    <span class="s1">target.firstEffect = source.firstEffect;</span>
    <span class="s1">target.lastEffect = source.lastEffect;</span>
    <span class="s1">target.expirationTime = source.expirationTime;</span>
    <span class="s1">target.childExpirationTime = source.childExpirationTime;</span>
    <span class="s1">target.alternate = source.alternate;</span>

    <span class="s1">{</span>
      <span class="s1">target.actualDuration = source.actualDuration;</span>
      <span class="s1">target.actualStartTime = source.actualStartTime;</span>
      <span class="s1">target.selfBaseDuration = source.selfBaseDuration;</span>
      <span class="s1">target.treeBaseDuration = source.treeBaseDuration;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">target._debugID = source._debugID;</span>
    <span class="s1">}</span>

    <span class="s1">target._debugSource = source._debugSource;</span>
    <span class="s1">target._debugOwner = source._debugOwner;</span>
    <span class="s1">target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;</span>
    <span class="s1">target._debugNeedsRemount = source._debugNeedsRemount;</span>
    <span class="s1">target._debugHookTypes = source._debugHookTypes;</span>
    <span class="s3">return </span><span class="s1">target;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">FiberRootNode(containerInfo, tag, hydrate) {</span>
    <span class="s3">this</span><span class="s1">.tag = tag;</span>
    <span class="s3">this</span><span class="s1">.current = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.containerInfo = containerInfo;</span>
    <span class="s3">this</span><span class="s1">.pendingChildren = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.pingCache = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.finishedExpirationTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.finishedWork = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.timeoutHandle = noTimeout;</span>
    <span class="s3">this</span><span class="s1">.context = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.pendingContext = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.hydrate = hydrate;</span>
    <span class="s3">this</span><span class="s1">.callbackNode = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.callbackPriority = NoPriority;</span>
    <span class="s3">this</span><span class="s1">.firstPendingTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.firstSuspendedTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.lastSuspendedTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.nextKnownPendingLevel = NoWork;</span>
    <span class="s3">this</span><span class="s1">.lastPingedTime = NoWork;</span>
    <span class="s3">this</span><span class="s1">.lastExpiredTime = NoWork;</span>

    <span class="s1">{</span>
      <span class="s3">this</span><span class="s1">.interactionThreadID = unstable_getThreadID();</span>
      <span class="s3">this</span><span class="s1">.memoizedInteractions = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s3">this</span><span class="s1">.pendingInteractionMap = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {</span>
    <span class="s3">var </span><span class="s1">root = </span><span class="s3">new </span><span class="s1">FiberRootNode(containerInfo, tag, hydrate);</span>
    <span class="s0">// stateNode is any.</span>


    <span class="s3">var </span><span class="s1">uninitializedFiber = createHostRootFiber(tag);</span>
    <span class="s1">root.current = uninitializedFiber;</span>
    <span class="s1">uninitializedFiber.stateNode = root;</span>
    <span class="s1">initializeUpdateQueue(uninitializedFiber);</span>
    <span class="s3">return </span><span class="s1">root;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isRootSuspendedAtTime(root, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">firstSuspendedTime = root.firstSuspendedTime;</span>
    <span class="s3">var </span><span class="s1">lastSuspendedTime = root.lastSuspendedTime;</span>
    <span class="s3">return </span><span class="s1">firstSuspendedTime !== NoWork &amp;&amp; firstSuspendedTime &gt;= expirationTime &amp;&amp; lastSuspendedTime &lt;= expirationTime;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markRootSuspendedAtTime(root, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">firstSuspendedTime = root.firstSuspendedTime;</span>
    <span class="s3">var </span><span class="s1">lastSuspendedTime = root.lastSuspendedTime;</span>

    <span class="s3">if </span><span class="s1">(firstSuspendedTime &lt; expirationTime) {</span>
      <span class="s1">root.firstSuspendedTime = expirationTime;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(lastSuspendedTime &gt; expirationTime || firstSuspendedTime === NoWork) {</span>
      <span class="s1">root.lastSuspendedTime = expirationTime;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(expirationTime &lt;= root.lastPingedTime) {</span>
      <span class="s1">root.lastPingedTime = NoWork;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(expirationTime &lt;= root.lastExpiredTime) {</span>
      <span class="s1">root.lastExpiredTime = NoWork;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markRootUpdatedAtTime(root, expirationTime) {</span>
    <span class="s0">// Update the range of pending times</span>
    <span class="s3">var </span><span class="s1">firstPendingTime = root.firstPendingTime;</span>

    <span class="s3">if </span><span class="s1">(expirationTime &gt; firstPendingTime) {</span>
      <span class="s1">root.firstPendingTime = expirationTime;</span>
    <span class="s1">} </span><span class="s0">// Update the range of suspended times. Treat everything lower priority or</span>
    <span class="s0">// equal to this update as unsuspended.</span>


    <span class="s3">var </span><span class="s1">firstSuspendedTime = root.firstSuspendedTime;</span>

    <span class="s3">if </span><span class="s1">(firstSuspendedTime !== NoWork) {</span>
      <span class="s3">if </span><span class="s1">(expirationTime &gt;= firstSuspendedTime) {</span>
        <span class="s0">// The entire suspended range is now unsuspended.</span>
        <span class="s1">root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expirationTime &gt;= root.lastSuspendedTime) {</span>
        <span class="s1">root.lastSuspendedTime = expirationTime + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// This is a pending level. Check if it's higher priority than the next</span>
      <span class="s0">// known pending level.</span>


      <span class="s3">if </span><span class="s1">(expirationTime &gt; root.nextKnownPendingLevel) {</span>
        <span class="s1">root.nextKnownPendingLevel = expirationTime;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markRootFinishedAtTime(root, finishedExpirationTime, remainingExpirationTime) {</span>
    <span class="s0">// Update the range of pending times</span>
    <span class="s1">root.firstPendingTime = remainingExpirationTime; </span><span class="s0">// Update the range of suspended times. Treat everything higher priority or</span>
    <span class="s0">// equal to this update as unsuspended.</span>

    <span class="s3">if </span><span class="s1">(finishedExpirationTime &lt;= root.lastSuspendedTime) {</span>
      <span class="s0">// The entire suspended range is now unsuspended.</span>
      <span class="s1">root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(finishedExpirationTime &lt;= root.firstSuspendedTime) {</span>
      <span class="s0">// Part of the suspended range is now unsuspended. Narrow the range to</span>
      <span class="s0">// include everything between the unsuspended time (non-inclusive) and the</span>
      <span class="s0">// last suspended time.</span>
      <span class="s1">root.firstSuspendedTime = finishedExpirationTime - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(finishedExpirationTime &lt;= root.lastPingedTime) {</span>
      <span class="s0">// Clear the pinged time</span>
      <span class="s1">root.lastPingedTime = NoWork;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(finishedExpirationTime &lt;= root.lastExpiredTime) {</span>
      <span class="s0">// Clear the expired time</span>
      <span class="s1">root.lastExpiredTime = NoWork;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markRootExpiredAtTime(root, expirationTime) {</span>
    <span class="s3">var </span><span class="s1">lastExpiredTime = root.lastExpiredTime;</span>

    <span class="s3">if </span><span class="s1">(lastExpiredTime === NoWork || lastExpiredTime &gt; expirationTime) {</span>
      <span class="s1">root.lastExpiredTime = expirationTime;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnAboutNestedUpdates;</span>
  <span class="s3">var </span><span class="s1">didWarnAboutFindNodeInStrictMode;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutNestedUpdates = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">didWarnAboutFindNodeInStrictMode = {};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getContextForSubtree(parentComponent) {</span>
    <span class="s3">if </span><span class="s1">(!parentComponent) {</span>
      <span class="s3">return </span><span class="s1">emptyContextObject;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">fiber = get(parentComponent);</span>
    <span class="s3">var </span><span class="s1">parentContext = findCurrentUnmaskedContext(fiber);</span>

    <span class="s3">if </span><span class="s1">(fiber.tag === ClassComponent) {</span>
      <span class="s3">var </span><span class="s1">Component = fiber.type;</span>

      <span class="s3">if </span><span class="s1">(isContextProvider(Component)) {</span>
        <span class="s3">return </span><span class="s1">processChildContext(fiber, Component, parentContext);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">parentContext;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findHostInstanceWithWarning(component, methodName) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">fiber = get(component);</span>

      <span class="s3">if </span><span class="s1">(fiber === undefined) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">component.render === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Unable to find node on an unmounted component.&quot; </span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Argument appears to not be a ReactComponent. Keys: &quot; </span><span class="s1">+ Object.keys(component) );</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>

      <span class="s3">if </span><span class="s1">(hostFiber === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(hostFiber.mode &amp; StrictMode) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(fiber.type) || </span><span class="s2">'Component'</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutFindNodeInStrictMode[componentName]) {</span>
          <span class="s1">didWarnAboutFindNodeInStrictMode[componentName] = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s1">(fiber.mode &amp; StrictMode) {</span>
            <span class="s1">error(</span><span class="s2">'%s is deprecated in StrictMode. ' </span><span class="s1">+ </span><span class="s2">'%s was passed an instance of %s which is inside StrictMode. ' </span><span class="s1">+ </span><span class="s2">'Instead, add a ref directly to the element you want to reference. ' </span><span class="s1">+ </span><span class="s2">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-strict-mode-find-node%s'</span><span class="s1">, methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">error(</span><span class="s2">'%s is deprecated in StrictMode. ' </span><span class="s1">+ </span><span class="s2">'%s was passed an instance of %s which renders StrictMode children. ' </span><span class="s1">+ </span><span class="s2">'Instead, add a ref directly to the element you want to reference. ' </span><span class="s1">+ </span><span class="s2">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-strict-mode-find-node%s'</span><span class="s1">, methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">hostFiber.stateNode;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {</span>
    <span class="s3">return </span><span class="s1">createFiberRoot(containerInfo, tag, hydrate);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">updateContainer(element, container, parentComponent, callback) {</span>
    <span class="s1">{</span>
      <span class="s1">onScheduleRoot(container, element);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">current$1 = container.current;</span>
    <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>

    <span class="s1">{</span>
      <span class="s0">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">'undefined' </span><span class="s1">!== </span><span class="s3">typeof </span><span class="s1">jest) {</span>
        <span class="s1">warnIfUnmockedScheduler(current$1);</span>
        <span class="s1">warnIfNotScopedWithMatchingAct(current$1);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">suspenseConfig = requestCurrentSuspenseConfig();</span>
    <span class="s3">var </span><span class="s1">expirationTime = computeExpirationForFiber(currentTime, current$1, suspenseConfig);</span>
    <span class="s3">var </span><span class="s1">context = getContextForSubtree(parentComponent);</span>

    <span class="s3">if </span><span class="s1">(container.context === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">container.context = context;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">container.pendingContext = context;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isRendering &amp;&amp; current !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !didWarnAboutNestedUpdates) {</span>
        <span class="s1">didWarnAboutNestedUpdates = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'Render methods should be a pure function of props and state; ' </span><span class="s1">+ </span><span class="s2">'triggering nested component updates from render is not allowed. ' </span><span class="s1">+ </span><span class="s2">'If necessary, trigger nested updates in componentDidUpdate.</span><span class="s5">\n\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'Check the render method of %s.'</span><span class="s1">, getComponentName(current.type) || </span><span class="s2">'Unknown'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">update = createUpdate(expirationTime, suspenseConfig); </span><span class="s0">// Caution: React DevTools currently depends on this property</span>
    <span class="s0">// being called &quot;element&quot;.</span>

    <span class="s1">update.payload = {</span>
      <span class="s1">element: element</span>
    <span class="s1">};</span>
    <span class="s1">callback = callback === undefined ? </span><span class="s3">null </span><span class="s1">: callback;</span>

    <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback !== </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'render(...): Expected the last optional `callback` argument to be a ' </span><span class="s1">+ </span><span class="s2">'function. Instead received: %s.'</span><span class="s1">, callback);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">update.callback = callback;</span>
    <span class="s1">}</span>

    <span class="s1">enqueueUpdate(current$1, update);</span>
    <span class="s1">scheduleWork(current$1, expirationTime);</span>
    <span class="s3">return </span><span class="s1">expirationTime;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">getPublicRootInstance(container) {</span>
    <span class="s3">var </span><span class="s1">containerFiber = container.current;</span>

    <span class="s3">if </span><span class="s1">(!containerFiber.child) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(containerFiber.child.tag) {</span>
      <span class="s3">case </span><span class="s1">HostComponent:</span>
        <span class="s3">return </span><span class="s1">getPublicInstance(containerFiber.child.stateNode);</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">containerFiber.child.stateNode;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markRetryTimeImpl(fiber, retryTime) {</span>
    <span class="s3">var </span><span class="s1">suspenseState = fiber.memoizedState;</span>

    <span class="s3">if </span><span class="s1">(suspenseState !== </span><span class="s3">null </span><span class="s1">&amp;&amp; suspenseState.dehydrated !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(suspenseState.retryTime &lt; retryTime) {</span>
        <span class="s1">suspenseState.retryTime = retryTime;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Increases the priority of thennables when they resolve within this boundary.</span>


  <span class="s3">function </span><span class="s1">markRetryTimeIfNotHydrated(fiber, retryTime) {</span>
    <span class="s1">markRetryTimeImpl(fiber, retryTime);</span>
    <span class="s3">var </span><span class="s1">alternate = fiber.alternate;</span>

    <span class="s3">if </span><span class="s1">(alternate) {</span>
      <span class="s1">markRetryTimeImpl(alternate, retryTime);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">attemptUserBlockingHydration$1(fiber) {</span>
    <span class="s3">if </span><span class="s1">(fiber.tag !== SuspenseComponent) {</span>
      <span class="s0">// We ignore HostRoots here because we can't increase</span>
      <span class="s0">// their priority and they should not suspend on I/O,</span>
      <span class="s0">// since you have to wrap anything that might suspend in</span>
      <span class="s0">// Suspense.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());</span>
    <span class="s1">scheduleWork(fiber, expTime);</span>
    <span class="s1">markRetryTimeIfNotHydrated(fiber, expTime);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">attemptContinuousHydration$1(fiber) {</span>
    <span class="s3">if </span><span class="s1">(fiber.tag !== SuspenseComponent) {</span>
      <span class="s0">// We ignore HostRoots here because we can't increase</span>
      <span class="s0">// their priority and they should not suspend on I/O,</span>
      <span class="s0">// since you have to wrap anything that might suspend in</span>
      <span class="s0">// Suspense.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">scheduleWork(fiber, ContinuousHydration);</span>
    <span class="s1">markRetryTimeIfNotHydrated(fiber, ContinuousHydration);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">attemptHydrationAtCurrentPriority$1(fiber) {</span>
    <span class="s3">if </span><span class="s1">(fiber.tag !== SuspenseComponent) {</span>
      <span class="s0">// We ignore HostRoots here because we can't increase</span>
      <span class="s0">// their priority other than synchronously flush it.</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">currentTime = requestCurrentTimeForUpdate();</span>
    <span class="s3">var </span><span class="s1">expTime = computeExpirationForFiber(currentTime, fiber, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">scheduleWork(fiber, expTime);</span>
    <span class="s1">markRetryTimeIfNotHydrated(fiber, expTime);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">findHostInstanceWithNoPortals(fiber) {</span>
    <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiberWithNoPortals(fiber);</span>

    <span class="s3">if </span><span class="s1">(hostFiber === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hostFiber.tag === FundamentalComponent) {</span>
      <span class="s3">return </span><span class="s1">hostFiber.stateNode.instance;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">hostFiber.stateNode;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">shouldSuspendImpl = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">shouldSuspend(fiber) {</span>
    <span class="s3">return </span><span class="s1">shouldSuspendImpl(fiber);</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">overrideHookState = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">overrideProps = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">scheduleUpdate = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">setSuspenseHandler = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">copyWithSetImpl = </span><span class="s3">function </span><span class="s1">(obj, path, idx, value) {</span>
      <span class="s3">if </span><span class="s1">(idx &gt;= path.length) {</span>
        <span class="s3">return </span><span class="s1">value;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">key = path[idx];</span>
      <span class="s3">var </span><span class="s1">updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); </span><span class="s0">// $FlowFixMe number or string is fine here</span>

      <span class="s1">updated[key] = copyWithSetImpl(obj[key], path, idx + </span><span class="s4">1</span><span class="s1">, value);</span>
      <span class="s3">return </span><span class="s1">updated;</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">copyWithSet = </span><span class="s3">function </span><span class="s1">(obj, path, value) {</span>
      <span class="s3">return </span><span class="s1">copyWithSetImpl(obj, path, </span><span class="s4">0</span><span class="s1">, value);</span>
    <span class="s1">}; </span><span class="s0">// Support DevTools editable values for useState and useReducer.</span>


    <span class="s1">overrideHookState = </span><span class="s3">function </span><span class="s1">(fiber, id, path, value) {</span>
      <span class="s0">// For now, the &quot;id&quot; of stateful hooks is just the stateful hook index.</span>
      <span class="s0">// This may change in the future with e.g. nested hooks.</span>
      <span class="s3">var </span><span class="s1">currentHook = fiber.memoizedState;</span>

      <span class="s3">while </span><span class="s1">(currentHook !== </span><span class="s3">null </span><span class="s1">&amp;&amp; id &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">currentHook = currentHook.next;</span>
        <span class="s1">id--;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(currentHook !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">newState = copyWithSet(currentHook.memoizedState, path, value);</span>
        <span class="s1">currentHook.memoizedState = newState;</span>
        <span class="s1">currentHook.baseState = newState; </span><span class="s0">// We aren't actually adding an update to the queue,</span>
        <span class="s0">// because there is no update we can add for useReducer hooks that won't trigger an error.</span>
        <span class="s0">// (There's no appropriate action type for DevTools overrides.)</span>
        <span class="s0">// As a result though, React will see the scheduled update as a noop and bailout.</span>
        <span class="s0">// Shallow cloning props works as a workaround for now to bypass the bailout check.</span>

        <span class="s1">fiber.memoizedProps = _assign({}, fiber.memoizedProps);</span>
        <span class="s1">scheduleWork(fiber, Sync);</span>
      <span class="s1">}</span>
    <span class="s1">}; </span><span class="s0">// Support DevTools props for function components, forwardRef, memo, host components, etc.</span>


    <span class="s1">overrideProps = </span><span class="s3">function </span><span class="s1">(fiber, path, value) {</span>
      <span class="s1">fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);</span>

      <span class="s3">if </span><span class="s1">(fiber.alternate) {</span>
        <span class="s1">fiber.alternate.pendingProps = fiber.pendingProps;</span>
      <span class="s1">}</span>

      <span class="s1">scheduleWork(fiber, Sync);</span>
    <span class="s1">};</span>

    <span class="s1">scheduleUpdate = </span><span class="s3">function </span><span class="s1">(fiber) {</span>
      <span class="s1">scheduleWork(fiber, Sync);</span>
    <span class="s1">};</span>

    <span class="s1">setSuspenseHandler = </span><span class="s3">function </span><span class="s1">(newShouldSuspendImpl) {</span>
      <span class="s1">shouldSuspendImpl = newShouldSuspendImpl;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">injectIntoDevTools(devToolsConfig) {</span>
    <span class="s3">var </span><span class="s1">findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;</span>
    <span class="s3">var </span><span class="s1">ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;</span>
    <span class="s3">return </span><span class="s1">injectInternals(_assign({}, devToolsConfig, {</span>
      <span class="s1">overrideHookState: overrideHookState,</span>
      <span class="s1">overrideProps: overrideProps,</span>
      <span class="s1">setSuspenseHandler: setSuspenseHandler,</span>
      <span class="s1">scheduleUpdate: scheduleUpdate,</span>
      <span class="s1">currentDispatcherRef: ReactCurrentDispatcher,</span>
      <span class="s1">findHostInstanceByFiber: </span><span class="s3">function </span><span class="s1">(fiber) {</span>
        <span class="s3">var </span><span class="s1">hostFiber = findCurrentHostFiber(fiber);</span>

        <span class="s3">if </span><span class="s1">(hostFiber === </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">hostFiber.stateNode;</span>
      <span class="s1">},</span>
      <span class="s1">findFiberByHostInstance: </span><span class="s3">function </span><span class="s1">(instance) {</span>
        <span class="s3">if </span><span class="s1">(!findFiberByHostInstance) {</span>
          <span class="s0">// Might not be implemented by the renderer.</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">findFiberByHostInstance(instance);</span>
      <span class="s1">},</span>
      <span class="s0">// React Refresh</span>
      <span class="s1">findHostInstancesForRefresh:  findHostInstancesForRefresh ,</span>
      <span class="s1">scheduleRefresh:  scheduleRefresh ,</span>
      <span class="s1">scheduleRoot:  scheduleRoot ,</span>
      <span class="s1">setRefreshHandler:  setRefreshHandler ,</span>
      <span class="s0">// Enables DevTools to append owner stacks to error messages in DEV mode.</span>
      <span class="s1">getCurrentFiber:  </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">current;</span>
      <span class="s1">}</span>
    <span class="s1">}));</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">IsSomeRendererActing$1 = ReactSharedInternals.IsSomeRendererActing;</span>

  <span class="s3">function </span><span class="s1">ReactDOMRoot(container, options) {</span>
    <span class="s3">this</span><span class="s1">._internalRoot = createRootImpl(container, ConcurrentRoot, options);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">ReactDOMBlockingRoot(container, tag, options) {</span>
    <span class="s3">this</span><span class="s1">._internalRoot = createRootImpl(container, tag, options);</span>
  <span class="s1">}</span>

  <span class="s1">ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = </span><span class="s3">function </span><span class="s1">(children) {</span>
    <span class="s3">var </span><span class="s1">root = </span><span class="s3">this</span><span class="s1">._internalRoot;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">arguments[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'render(...): does not support the second callback argument. ' </span><span class="s1">+ </span><span class="s2">'To execute a side effect after rendering, declare it in a component body with useEffect().'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">container = root.containerInfo;</span>

      <span class="s3">if </span><span class="s1">(container.nodeType !== COMMENT_NODE) {</span>
        <span class="s3">var </span><span class="s1">hostInstance = findHostInstanceWithNoPortals(root.current);</span>

        <span class="s3">if </span><span class="s1">(hostInstance) {</span>
          <span class="s3">if </span><span class="s1">(hostInstance.parentNode !== container) {</span>
            <span class="s1">error(</span><span class="s2">'render(...): It looks like the React-rendered content of the ' </span><span class="s1">+ </span><span class="s2">'root container was removed without using React. This is not ' </span><span class="s1">+ </span><span class="s2">'supported and will cause errors. Instead, call ' </span><span class="s1">+ </span><span class="s2">&quot;root.unmount() to empty a root's container.&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">updateContainer(children, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s1">ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = </span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">arguments[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'unmount(...): does not support a callback argument. ' </span><span class="s1">+ </span><span class="s2">'To execute a side effect after rendering, declare it in a component body with useEffect().'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">root = </span><span class="s3">this</span><span class="s1">._internalRoot;</span>
    <span class="s3">var </span><span class="s1">container = root.containerInfo;</span>
    <span class="s1">updateContainer(</span><span class="s3">null</span><span class="s1">, root, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">unmarkContainerAsRoot(container);</span>
    <span class="s1">});</span>
  <span class="s1">};</span>

  <span class="s3">function </span><span class="s1">createRootImpl(container, tag, options) {</span>
    <span class="s0">// Tag is either LegacyRoot or Concurrent Root</span>
    <span class="s3">var </span><span class="s1">hydrate = options != </span><span class="s3">null </span><span class="s1">&amp;&amp; options.hydrate === </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">hydrationCallbacks = options != </span><span class="s3">null </span><span class="s1">&amp;&amp; options.hydrationOptions || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">root = createContainer(container, tag, hydrate);</span>
    <span class="s1">markContainerAsRoot(root.current, container);</span>

    <span class="s3">if </span><span class="s1">(hydrate &amp;&amp; tag !== LegacyRoot) {</span>
      <span class="s3">var </span><span class="s1">doc = container.nodeType === DOCUMENT_NODE ? container : container.ownerDocument;</span>
      <span class="s1">eagerlyTrapReplayableEvents(container, doc);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">root;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createLegacyRoot(container, options) {</span>
    <span class="s3">return new </span><span class="s1">ReactDOMBlockingRoot(container, LegacyRoot, options);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">isValidContainer(node) {</span>
    <span class="s3">return </span><span class="s1">!!(node &amp;&amp; (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE &amp;&amp; node.nodeValue === </span><span class="s2">' react-mount-point-unstable '</span><span class="s1">));</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;</span>
  <span class="s3">var </span><span class="s1">topLevelUpdateWarnings;</span>
  <span class="s3">var </span><span class="s1">warnedAboutHydrateAPI = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">topLevelUpdateWarnings = </span><span class="s3">function </span><span class="s1">(container) {</span>
      <span class="s3">if </span><span class="s1">(container._reactRootContainer &amp;&amp; container.nodeType !== COMMENT_NODE) {</span>
        <span class="s3">var </span><span class="s1">hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);</span>

        <span class="s3">if </span><span class="s1">(hostInstance) {</span>
          <span class="s3">if </span><span class="s1">(hostInstance.parentNode !== container) {</span>
            <span class="s1">error(</span><span class="s2">'render(...): It looks like the React-rendered content of this ' </span><span class="s1">+ </span><span class="s2">'container was removed without using React. This is not ' </span><span class="s1">+ </span><span class="s2">'supported and will cause errors. Instead, call ' </span><span class="s1">+ </span><span class="s2">'ReactDOM.unmountComponentAtNode to empty a container.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">isRootRenderedBySomeReact = !!container._reactRootContainer;</span>
      <span class="s3">var </span><span class="s1">rootEl = getReactRootElementInContainer(container);</span>
      <span class="s3">var </span><span class="s1">hasNonRootReactChild = !!(rootEl &amp;&amp; getInstanceFromNode$1(rootEl));</span>

      <span class="s3">if </span><span class="s1">(hasNonRootReactChild &amp;&amp; !isRootRenderedBySomeReact) {</span>
        <span class="s1">error(</span><span class="s2">'render(...): Replacing React-rendered children with a new root ' </span><span class="s1">+ </span><span class="s2">'component. If you intended to update the children of this node, ' </span><span class="s1">+ </span><span class="s2">'you should instead have the existing children update their state ' </span><span class="s1">+ </span><span class="s2">'and render the new components instead of calling ReactDOM.render.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(container.nodeType === ELEMENT_NODE &amp;&amp; container.tagName &amp;&amp; container.tagName.toUpperCase() === </span><span class="s2">'BODY'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'render(): Rendering components directly into document.body is ' </span><span class="s1">+ </span><span class="s2">'discouraged, since its children are often manipulated by third-party ' </span><span class="s1">+ </span><span class="s2">'scripts and browser extensions. This may lead to subtle ' </span><span class="s1">+ </span><span class="s2">'reconciliation issues. Try rendering into a container element created ' </span><span class="s1">+ </span><span class="s2">'for your app.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getReactRootElementInContainer(container) {</span>
    <span class="s3">if </span><span class="s1">(!container) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(container.nodeType === DOCUMENT_NODE) {</span>
      <span class="s3">return </span><span class="s1">container.documentElement;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">container.firstChild;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">shouldHydrateDueToLegacyHeuristic(container) {</span>
    <span class="s3">var </span><span class="s1">rootElement = getReactRootElementInContainer(container);</span>
    <span class="s3">return </span><span class="s1">!!(rootElement &amp;&amp; rootElement.nodeType === ELEMENT_NODE &amp;&amp; rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">legacyCreateRootFromDOMContainer(container, forceHydrate) {</span>
    <span class="s3">var </span><span class="s1">shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); </span><span class="s0">// First clear any existing content.</span>

    <span class="s3">if </span><span class="s1">(!shouldHydrate) {</span>
      <span class="s3">var </span><span class="s1">warned = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">rootSibling;</span>

      <span class="s3">while </span><span class="s1">(rootSibling = container.lastChild) {</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(!warned &amp;&amp; rootSibling.nodeType === ELEMENT_NODE &amp;&amp; rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {</span>
            <span class="s1">warned = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s1">error(</span><span class="s2">'render(): Target node has markup rendered by React, but there ' </span><span class="s1">+ </span><span class="s2">'are unrelated nodes as well. This is most commonly caused by ' </span><span class="s1">+ </span><span class="s2">'white-space inserted around server-rendered markup.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">container.removeChild(rootSibling);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) {</span>
        <span class="s1">warnedAboutHydrateAPI = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">warn(</span><span class="s2">'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' </span><span class="s1">+ </span><span class="s2">'will stop working in React v17. Replace the ReactDOM.render() call ' </span><span class="s1">+ </span><span class="s2">'with ReactDOM.hydrate() if you want React to attach to the server HTML.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">createLegacyRoot(container, shouldHydrate ? {</span>
      <span class="s1">hydrate: </span><span class="s3">true</span>
    <span class="s1">} : undefined);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnOnInvalidCallback$1(callback, callerName) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">callback !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'%s(...): Expected the last optional `callback` argument to be a ' </span><span class="s1">+ </span><span class="s2">'function. Instead received: %s.'</span><span class="s1">, callerName, callback);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {</span>
    <span class="s1">{</span>
      <span class="s1">topLevelUpdateWarnings(container);</span>
      <span class="s1">warnOnInvalidCallback$1(callback === undefined ? </span><span class="s3">null </span><span class="s1">: callback, </span><span class="s2">'render'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s0">// TODO: Without `any` type, Flow says &quot;Property cannot be accessed on any</span>
    <span class="s0">// member of intersection type.&quot; Whyyyyyy.</span>


    <span class="s3">var </span><span class="s1">root = container._reactRootContainer;</span>
    <span class="s3">var </span><span class="s1">fiberRoot;</span>

    <span class="s3">if </span><span class="s1">(!root) {</span>
      <span class="s0">// Initial mount</span>
      <span class="s1">root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span>
      <span class="s1">fiberRoot = root._internalRoot;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">originalCallback = callback;</span>

        <span class="s1">callback = </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">var </span><span class="s1">instance = getPublicRootInstance(fiberRoot);</span>
          <span class="s1">originalCallback.call(instance);</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s0">// Initial mount should not be batched.</span>


      <span class="s1">unbatchedUpdates(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">updateContainer(children, fiberRoot, parentComponent, callback);</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">fiberRoot = root._internalRoot;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">callback === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">_originalCallback = callback;</span>

        <span class="s1">callback = </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">var </span><span class="s1">instance = getPublicRootInstance(fiberRoot);</span>

          <span class="s1">_originalCallback.call(instance);</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s0">// Update</span>


      <span class="s1">updateContainer(children, fiberRoot, parentComponent, callback);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">getPublicRootInstance(fiberRoot);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findDOMNode(componentOrElement) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">owner = ReactCurrentOwner$3.current;</span>

      <span class="s3">if </span><span class="s1">(owner !== </span><span class="s3">null </span><span class="s1">&amp;&amp; owner.stateNode !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;</span>

        <span class="s3">if </span><span class="s1">(!warnedAboutRefsInRender) {</span>
          <span class="s1">error(</span><span class="s2">'%s is accessing findDOMNode inside its render(). ' </span><span class="s1">+ </span><span class="s2">'render() should be a pure function of props and state. It should ' </span><span class="s1">+ </span><span class="s2">'never access something that requires stale data from the previous ' </span><span class="s1">+ </span><span class="s2">'render, such as refs. Move this logic to componentDidMount and ' </span><span class="s1">+ </span><span class="s2">'componentDidUpdate instead.'</span><span class="s1">, getComponentName(owner.type) || </span><span class="s2">'A component'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">owner.stateNode._warnedAboutRefsInRender = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(componentOrElement == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(componentOrElement.nodeType === ELEMENT_NODE) {</span>
      <span class="s3">return </span><span class="s1">componentOrElement;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">return </span><span class="s1">findHostInstanceWithWarning(componentOrElement, </span><span class="s2">'findDOMNode'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">hydrate(element, container, callback) {</span>
    <span class="s3">if </span><span class="s1">(!isValidContainer(container)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Target container is not a DOM element.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === undefined;</span>

      <span class="s3">if </span><span class="s1">(isModernRoot) {</span>
        <span class="s1">error(</span><span class="s2">'You are calling ReactDOM.hydrate() on a container that was previously ' </span><span class="s1">+ </span><span class="s2">'passed to ReactDOM.createRoot(). This is not supported. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to call createRoot(container, {hydrate: true}).render(element)?'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: throw or warn if we couldn't hydrate?</span>


    <span class="s3">return </span><span class="s1">legacyRenderSubtreeIntoContainer(</span><span class="s3">null</span><span class="s1">, element, container, </span><span class="s3">true</span><span class="s1">, callback);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">render(element, container, callback) {</span>
    <span class="s3">if </span><span class="s1">(!isValidContainer(container)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Target container is not a DOM element.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === undefined;</span>

      <span class="s3">if </span><span class="s1">(isModernRoot) {</span>
        <span class="s1">error(</span><span class="s2">'You are calling ReactDOM.render() on a container that was previously ' </span><span class="s1">+ </span><span class="s2">'passed to ReactDOM.createRoot(). This is not supported. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to call root.render(element)?'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">legacyRenderSubtreeIntoContainer(</span><span class="s3">null</span><span class="s1">, element, container, </span><span class="s3">false</span><span class="s1">, callback);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {</span>
    <span class="s3">if </span><span class="s1">(!isValidContainer(containerNode)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Target container is not a DOM element.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!(parentComponent != </span><span class="s3">null </span><span class="s1">&amp;&amp; has$1(parentComponent))) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;parentComponent must be a valid React Component&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, </span><span class="s3">false</span><span class="s1">, callback);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unmountComponentAtNode(container) {</span>
    <span class="s3">if </span><span class="s1">(!isValidContainer(container)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;unmountComponentAtNode(...): Target container is not a DOM element.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === undefined;</span>

      <span class="s3">if </span><span class="s1">(isModernRoot) {</span>
        <span class="s1">error(</span><span class="s2">'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' </span><span class="s1">+ </span><span class="s2">'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(container._reactRootContainer) {</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">rootEl = getReactRootElementInContainer(container);</span>
        <span class="s3">var </span><span class="s1">renderedByDifferentReact = rootEl &amp;&amp; !getInstanceFromNode$1(rootEl);</span>

        <span class="s3">if </span><span class="s1">(renderedByDifferentReact) {</span>
          <span class="s1">error(</span><span class="s2">&quot;unmountComponentAtNode(): The node you're attempting to unmount &quot; </span><span class="s1">+ </span><span class="s2">'was rendered by another copy of React.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Unmount should not be batched.</span>


      <span class="s1">unbatchedUpdates(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">legacyRenderSubtreeIntoContainer(</span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, container, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s0">// $FlowFixMe This should probably use `delete container._reactRootContainer`</span>
          <span class="s1">container._reactRootContainer = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">unmarkContainerAsRoot(container);</span>
        <span class="s1">});</span>
      <span class="s1">}); </span><span class="s0">// If you call unmountComponentAtNode twice in quick succession, you'll</span>
      <span class="s0">// get `true` twice. That's probably fine?</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_rootEl = getReactRootElementInContainer(container);</span>

        <span class="s3">var </span><span class="s1">hasNonRootReactChild = !!(_rootEl &amp;&amp; getInstanceFromNode$1(_rootEl)); </span><span class="s0">// Check if the container itself is a React root node.</span>

        <span class="s3">var </span><span class="s1">isContainerReactRoot = container.nodeType === ELEMENT_NODE &amp;&amp; isValidContainer(container.parentNode) &amp;&amp; !!container.parentNode._reactRootContainer;</span>

        <span class="s3">if </span><span class="s1">(hasNonRootReactChild) {</span>
          <span class="s1">error(</span><span class="s2">&quot;unmountComponentAtNode(): The node you're attempting to unmount &quot; </span><span class="s1">+ </span><span class="s2">'was rendered by React and is not a top-level container. %s'</span><span class="s1">, isContainerReactRoot ? </span><span class="s2">'You may have accidentally passed in a React root node instead ' </span><span class="s1">+ </span><span class="s2">'of its container.' </span><span class="s1">: </span><span class="s2">'Instead, have the parent component update its state and ' </span><span class="s1">+ </span><span class="s2">'rerender in order to remove this component.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createPortal(children, containerInfo, </span><span class="s0">// TODO: figure out the API for cross-renderer implementation.</span>
  <span class="s1">implementation) {</span>
    <span class="s3">var </span><span class="s1">key = arguments.length &gt; </span><span class="s4">3 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s0">// This tag allow us to uniquely identify this as a React Portal</span>
      <span class="s1">$$typeof: REACT_PORTAL_TYPE,</span>
      <span class="s1">key: key == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: </span><span class="s2">'' </span><span class="s1">+ key,</span>
      <span class="s1">children: children,</span>
      <span class="s1">containerInfo: containerInfo,</span>
      <span class="s1">implementation: implementation</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactVersion = </span><span class="s2">'16.14.0'</span><span class="s1">;</span>

  <span class="s1">setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);</span>
  <span class="s1">setAttemptContinuousHydration(attemptContinuousHydration$1);</span>
  <span class="s1">setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);</span>
  <span class="s3">var </span><span class="s1">didWarnAboutUnstableCreatePortal = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Map !== </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s0">// $FlowIssue Flow incorrectly thinks Map has no prototype</span>
    <span class="s1">Map.prototype == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">Map.prototype.forEach !== </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">Set !== </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s0">// $FlowIssue Flow incorrectly thinks Set has no prototype</span>
    <span class="s1">Set.prototype == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">Set.prototype.clear !== </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">Set.prototype.forEach !== </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">error(</span><span class="s2">'React depends on Map and Set built-in types. Make sure that you load a ' </span><span class="s1">+ </span><span class="s2">'polyfill in older browsers. https://fb.me/react-polyfills'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">setRestoreImplementation(restoreControlledState$3);</span>
  <span class="s1">setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);</span>

  <span class="s3">function </span><span class="s1">createPortal$1(children, container) {</span>
    <span class="s3">var </span><span class="s1">key = arguments.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!isValidContainer(container)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Target container is not a DOM element.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// TODO: pass ReactDOM portal implementation as third argument</span>
    <span class="s0">// $FlowFixMe The Flow type is opaque but there's no way to actually create it.</span>


    <span class="s3">return </span><span class="s1">createPortal(children, container, </span><span class="s3">null</span><span class="s1">, key);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {</span>

    <span class="s3">return </span><span class="s1">unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_createPortal(children, container) {</span>
    <span class="s3">var </span><span class="s1">key = arguments.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s1">] : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!didWarnAboutUnstableCreatePortal) {</span>
        <span class="s1">didWarnAboutUnstableCreatePortal = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">warn(</span><span class="s2">'The ReactDOM.unstable_createPortal() alias has been deprecated, ' </span><span class="s1">+ </span><span class="s2">'and will be removed in React 17+. Update your code to use ' </span><span class="s1">+ </span><span class="s2">'ReactDOM.createPortal() instead. It has the exact same API, ' </span><span class="s1">+ </span><span class="s2">'but without the &quot;unstable_&quot; prefix.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">createPortal$1(children, container, key);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">Internals = {</span>
    <span class="s0">// Keep in sync with ReactDOMUnstableNativeDependencies.js</span>
    <span class="s0">// ReactTestUtils.js, and ReactTestUtilsAct.js. This is an array for better minification.</span>
    <span class="s1">Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch, flushPassiveEffects, IsThisRendererActing]</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">foundDevTools = injectIntoDevTools({</span>
    <span class="s1">findFiberByHostInstance: getClosestInstanceFromNode,</span>
    <span class="s1">bundleType:  </span><span class="s4">1 </span><span class="s1">,</span>
    <span class="s1">version: ReactVersion,</span>
    <span class="s1">rendererPackageName: </span><span class="s2">'react-dom'</span>
  <span class="s1">});</span>

  <span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(!foundDevTools &amp;&amp; canUseDOM &amp;&amp; window.top === window.self) {</span>
      <span class="s0">// If we're in Chrome or Firefox, provide a download link if not installed.</span>
      <span class="s3">if </span><span class="s1">(navigator.userAgent.indexOf(</span><span class="s2">'Chrome'</span><span class="s1">) &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; navigator.userAgent.indexOf(</span><span class="s2">'Edge'</span><span class="s1">) === -</span><span class="s4">1 </span><span class="s1">|| navigator.userAgent.indexOf(</span><span class="s2">'Firefox'</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">protocol = window.location.protocol; </span><span class="s0">// Don't warn in exotic cases like chrome-extension://.</span>

        <span class="s3">if </span><span class="s1">(/^(https?|file):$/.test(protocol)) {</span>
          <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>
          <span class="s1">console.info(</span><span class="s2">'%cDownload the React DevTools ' </span><span class="s1">+ </span><span class="s2">'for a better development experience: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-devtools' </span><span class="s1">+ (protocol === </span><span class="s2">'file:' </span><span class="s1">? </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">You might need to use a local HTTP server (instead of file://): ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-devtools-faq' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">), </span><span class="s2">'font-weight:bold'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;</span>
  <span class="s1">exports.createPortal = createPortal$1;</span>
  <span class="s1">exports.findDOMNode = findDOMNode;</span>
  <span class="s1">exports.flushSync = flushSync;</span>
  <span class="s1">exports.hydrate = hydrate;</span>
  <span class="s1">exports.render = render;</span>
  <span class="s1">exports.unmountComponentAtNode = unmountComponentAtNode;</span>
  <span class="s1">exports.unstable_batchedUpdates = batchedUpdates$1;</span>
  <span class="s1">exports.unstable_createPortal = unstable_createPortal;</span>
  <span class="s1">exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;</span>
  <span class="s1">exports.version = ReactVersion;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>