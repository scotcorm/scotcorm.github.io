<html>
<head>
<title>test_series_apply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_series_apply.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Counter</span><span class="s0">,</span>
    <span class="s1">defaultdict</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">concat</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">timedelta_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.tests.apply.common </span><span class="s0">import </span><span class="s1">series_transform_kernels</span>


<span class="s0">def </span><span class="s1">test_series_map_box_timedelta():</span>
    <span class="s2"># GH#11349</span>
    <span class="s1">ser = Series(timedelta_range(</span><span class="s3">&quot;1 day 1 s&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;h&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x.total_seconds()</span>

    <span class="s1">ser.map(f)</span>
    <span class="s1">ser.apply(f)</span>
    <span class="s1">DataFrame(ser).applymap(f)</span>


<span class="s0">def </span><span class="s1">test_apply(datetime_series):</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">tm.assert_series_equal(datetime_series.apply(np.sqrt)</span><span class="s0">, </span><span class="s1">np.sqrt(datetime_series))</span>

        <span class="s2"># element-wise apply</span>
        <span class="s0">import </span><span class="s1">math</span>

        <span class="s1">tm.assert_series_equal(datetime_series.apply(math.exp)</span><span class="s0">, </span><span class="s1">np.exp(datetime_series))</span>

    <span class="s2"># empty series</span>
    <span class="s1">s = Series(dtype=object</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">index=Index([]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;bar&quot;</span><span class="s1">))</span>
    <span class="s1">rs = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x)</span>
    <span class="s1">tm.assert_series_equal(s</span><span class="s0">, </span><span class="s1">rs)</span>

    <span class="s2"># check all metadata (GH 9322)</span>
    <span class="s0">assert </span><span class="s1">s </span><span class="s0">is not </span><span class="s1">rs</span>
    <span class="s0">assert </span><span class="s1">s.index </span><span class="s0">is </span><span class="s1">rs.index</span>
    <span class="s0">assert </span><span class="s1">s.dtype == rs.dtype</span>
    <span class="s0">assert </span><span class="s1">s.name == rs.name</span>

    <span class="s2"># index but no data</span>
    <span class="s1">s = Series(index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">rs = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x)</span>
    <span class="s1">tm.assert_series_equal(s</span><span class="s0">, </span><span class="s1">rs)</span>


<span class="s0">def </span><span class="s1">test_apply_same_length_inference_bug():</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">x + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">result = s.apply(f)</span>
    <span class="s1">expected = s.map(f)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">result = s.apply(f)</span>
    <span class="s1">expected = s.map(f)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_dont_convert_dtype():</span>
    <span class="s1">s = Series(np.random.randn(</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s0">if </span><span class="s1">x &gt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">np.nan</span>

    <span class="s1">result = s.apply(f</span><span class="s0">, </span><span class="s1">convert_dtype=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result.dtype == object</span>


<span class="s0">def </span><span class="s1">test_apply_args():</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;foo,bar&quot;</span><span class="s1">])</span>

    <span class="s1">result = s.apply(str.split</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">&quot;,&quot;</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">result[</span><span class="s4">0</span><span class="s1">] == [</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;args, kwargs, increment&quot;</span><span class="s0">,</span>
    <span class="s1">[(()</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(()</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s4">201</span><span class="s1">)]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_agg_args(args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">increment):</span>
    <span class="s2"># GH 43357</span>
    <span class="s0">def </span><span class="s1">f(x</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">b=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">x + a + </span><span class="s4">10 </span><span class="s1">* b + </span><span class="s4">100 </span><span class="s1">* c</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">result = s.agg(f</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">expected = s + increment</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_map_box_timestamps():</span>
    <span class="s2"># GH#2689, GH#2627</span>
    <span class="s1">ser = Series(pd.date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">func(x):</span>
        <span class="s0">return </span><span class="s1">(x.hour</span><span class="s0">, </span><span class="s1">x.day</span><span class="s0">, </span><span class="s1">x.month)</span>

    <span class="s2"># it works!</span>
    <span class="s1">ser.map(func)</span>
    <span class="s1">ser.apply(func)</span>


<span class="s0">def </span><span class="s1">test_series_map_stringdtype(any_string_dtype):</span>
    <span class="s2"># map test on StringDType, GH#40823</span>
    <span class="s1">ser1 = Series(</span>
        <span class="s1">data=[</span><span class="s3">&quot;cat&quot;</span><span class="s0">, </span><span class="s3">&quot;dog&quot;</span><span class="s0">, </span><span class="s3">&quot;rabbit&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s3">&quot;id1&quot;</span><span class="s0">, </span><span class="s3">&quot;id2&quot;</span><span class="s0">, </span><span class="s3">&quot;id3&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=any_string_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ser2 = Series(data=[</span><span class="s3">&quot;id3&quot;</span><span class="s0">, </span><span class="s3">&quot;id2&quot;</span><span class="s0">, </span><span class="s3">&quot;id1&quot;</span><span class="s0">, </span><span class="s3">&quot;id7000&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>
    <span class="s1">result = ser2.map(ser1)</span>
    <span class="s1">expected = Series(data=[</span><span class="s3">&quot;rabbit&quot;</span><span class="s0">, </span><span class="s3">&quot;dog&quot;</span><span class="s0">, </span><span class="s3">&quot;cat&quot;</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s1">dtype=any_string_dtype)</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_box():</span>
    <span class="s2"># ufunc will not be boxed. Same test cases as the test_map_box</span>
    <span class="s1">vals = [pd.Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;datetime64[ns]&quot;</span>
    <span class="s2"># boxed value must be Timestamp instance</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timestamp_1_None&quot;</span><span class="s0">, </span><span class="s3">&quot;Timestamp_2_None&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">vals = [</span>
        <span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;datetime64[ns, US/Eastern]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timestamp_1_US/Eastern&quot;</span><span class="s0">, </span><span class="s3">&quot;Timestamp_2_US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># timedelta</span>
    <span class="s1">vals = [pd.Timedelta(</span><span class="s3">&quot;1 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s3">&quot;2 days&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;timedelta64[ns]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.days</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timedelta_1&quot;</span><span class="s0">, </span><span class="s3">&quot;Timedelta_2&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># period</span>
    <span class="s1">vals = [pd.Period(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Period(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;Period[M]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.freqstr</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Period_M&quot;</span><span class="s0">, </span><span class="s3">&quot;Period_M&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_apply_datetimetz():</span>
    <span class="s1">values = pd.date_range(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s3">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>

    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x + pd.offsets.Day())</span>
    <span class="s1">exp_values = pd.date_range(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s3">&quot;2011-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s3">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">exp = Series(exp_values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># change dtype</span>
    <span class="s2"># GH 14506 : Returned dtype changed from int32 to int64</span>
    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x.hour)</span>
    <span class="s1">exp = Series(list(range(</span><span class="s4">24</span><span class="s1">)) + [</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># not vectorized</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">if not </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">pd.Timestamp):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>
        <span class="s0">return </span><span class="s1">str(x.tz)</span>

    <span class="s1">result = s.map(f)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">] * </span><span class="s4">25</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_apply_categorical():</span>
    <span class="s1">values = pd.Categorical(list(</span><span class="s3">&quot;ABBABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s3">&quot;DCBA&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">ser = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">result = ser.apply(</span><span class="s0">lambda </span><span class="s1">x: x.lower())</span>

    <span class="s2"># should be categorical dtype when the number of categories are</span>
    <span class="s2"># the same</span>
    <span class="s1">values = pd.Categorical(list(</span><span class="s3">&quot;abbabcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s3">&quot;dcba&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">exp = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">tm.assert_categorical_equal(result.values</span><span class="s0">, </span><span class="s1">exp.values)</span>

    <span class="s1">result = ser.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;A&quot;</span><span class="s1">] * </span><span class="s4">7</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s0">assert </span><span class="s1">result.dtype == object</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;series&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">&quot;1-1&quot;</span><span class="s0">, </span><span class="s3">&quot;1-1&quot;</span><span class="s0">, </span><span class="s1">np.NaN]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;1-1&quot;</span><span class="s0">, </span><span class="s3">&quot;1-2&quot;</span><span class="s0">, </span><span class="s1">np.NaN]])</span>
<span class="s0">def </span><span class="s1">test_apply_categorical_with_nan_values(series):</span>
    <span class="s2"># GH 20714 bug fixed in: GH 24275</span>
    <span class="s1">s = Series(series</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x.split(</span><span class="s3">&quot;-&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">result = result.astype(object)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s1">np.NaN]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">expected = expected.astype(object)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_empty_integer_series_with_datetime_index():</span>
    <span class="s2"># GH 21245</span>
    <span class="s1">s = Series([]</span><span class="s0">, </span><span class="s1">index=pd.date_range(start=</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s0">def </span><span class="s1">test_transform(string_series):</span>
    <span class="s2"># transforming functions</span>

    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>

        <span class="s1">f_sqrt = np.sqrt(string_series)</span>
        <span class="s1">f_abs = np.abs(string_series)</span>

        <span class="s2"># ufunc</span>
        <span class="s1">result = string_series.apply(np.sqrt)</span>
        <span class="s1">expected = f_sqrt.copy()</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s2"># list-like</span>
        <span class="s1">result = string_series.apply([np.sqrt])</span>
        <span class="s1">expected = f_sqrt.to_frame().copy()</span>
        <span class="s1">expected.columns = [</span><span class="s3">&quot;sqrt&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = string_series.apply([</span><span class="s3">&quot;sqrt&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s2"># multiple items in list</span>
        <span class="s2"># these are in the order as if we are applying both functions per</span>
        <span class="s2"># series and then concatting</span>
        <span class="s1">expected = concat([f_sqrt</span><span class="s0">, </span><span class="s1">f_abs]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = [</span><span class="s3">&quot;sqrt&quot;</span><span class="s0">, </span><span class="s3">&quot;absolute&quot;</span><span class="s1">]</span>
        <span class="s1">result = string_series.apply([np.sqrt</span><span class="s0">, </span><span class="s1">np.abs])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s2"># dict, provide renaming</span>
        <span class="s1">expected = concat([f_sqrt</span><span class="s0">, </span><span class="s1">f_abs]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = [</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">]</span>
        <span class="s1">expected = expected.unstack().rename(</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>

        <span class="s1">result = string_series.apply({</span><span class="s3">&quot;foo&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">: np.abs})</span>
        <span class="s1">tm.assert_series_equal(result.reindex_like(expected)</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;op&quot;</span><span class="s0">, </span><span class="s1">series_transform_kernels)</span>
<span class="s0">def </span><span class="s1">test_transform_partial_failure(op</span><span class="s0">, </span><span class="s1">request):</span>
    <span class="s2"># GH 35964</span>
    <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;ffill&quot;</span><span class="s0">, </span><span class="s3">&quot;bfill&quot;</span><span class="s0">, </span><span class="s3">&quot;pad&quot;</span><span class="s0">, </span><span class="s3">&quot;backfill&quot;</span><span class="s0">, </span><span class="s3">&quot;shift&quot;</span><span class="s1">):</span>
        <span class="s1">request.node.add_marker(</span>
            <span class="s1">pytest.mark.xfail(</span>
                <span class="s1">raises=AssertionError</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s3">is successful on any dtype&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;rank&quot;</span><span class="s0">, </span><span class="s3">&quot;fillna&quot;</span><span class="s1">):</span>
        <span class="s1">pytest.skip(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s3">doesn't raise TypeError on object&quot;</span><span class="s1">)</span>

    <span class="s2"># Using object makes most transform kernels fail</span>
    <span class="s1">ser = Series(</span><span class="s4">3 </span><span class="s1">* [object])</span>

    <span class="s1">expected = ser.transform([</span><span class="s3">&quot;shift&quot;</span><span class="s1">])</span>
    <span class="s1">match = </span><span class="s3">rf&quot;\['</span><span class="s0">{</span><span class="s1">op</span><span class="s0">}</span><span class="s3">'\] did not transform successfully&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform([op</span><span class="s0">, </span><span class="s3">&quot;shift&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = ser.transform({</span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;shift&quot;</span><span class="s1">})</span>
    <span class="s1">match = </span><span class="s3">r&quot;\['A'\] did not transform successfully&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: op</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;shift&quot;</span><span class="s1">})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = ser.transform({</span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">&quot;shift&quot;</span><span class="s1">]})</span>
    <span class="s1">match = </span><span class="s3">r&quot;\['A'\] did not transform successfully&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [op]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">&quot;shift&quot;</span><span class="s1">]})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">match = </span><span class="s3">r&quot;\['B'\] did not transform successfully&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">expected = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">&quot;shift&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [op]})</span>
    <span class="s1">match = </span><span class="s3">rf&quot;\['</span><span class="s0">{</span><span class="s1">op</span><span class="s0">}</span><span class="s3">'\] did not transform successfully&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [op</span><span class="s0">, </span><span class="s3">&quot;shift&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [op]})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_transform_partial_failure_valueerror():</span>
    <span class="s2"># GH 40211</span>
    <span class="s1">match = </span><span class="s3">&quot;.*did not transform successfully&quot;</span>

    <span class="s0">def </span><span class="s1">noop(x):</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">raising_op(_):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s1">ser = Series(</span><span class="s4">3 </span><span class="s1">* [object])</span>

    <span class="s1">expected = ser.transform([noop])</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform([noop</span><span class="s0">, </span><span class="s1">raising_op])</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = ser.transform({</span><span class="s3">&quot;B&quot;</span><span class="s1">: noop})</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: raising_op</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: noop})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = ser.transform({</span><span class="s3">&quot;B&quot;</span><span class="s1">: [noop]})</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [raising_op]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [noop]})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [noop]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [noop]})</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">result = ser.transform({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [noop</span><span class="s0">, </span><span class="s1">raising_op]</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [noop]})</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_demo():</span>
    <span class="s2"># demonstration tests</span>
    <span class="s1">s = Series(range(</span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>

    <span class="s1">result = s.agg([</span><span class="s3">&quot;min&quot;</span><span class="s0">, </span><span class="s3">&quot;max&quot;</span><span class="s1">])</span>
    <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;min&quot;</span><span class="s0">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = s.agg({</span><span class="s3">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">&quot;min&quot;</span><span class="s1">})</span>
    <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_agg_apply_evaluate_lambdas_the_same(string_series):</span>
    <span class="s2"># test that we are evaluating row-by-row first</span>
    <span class="s2"># before vectorized evaluation</span>
    <span class="s1">result = string_series.apply(</span><span class="s0">lambda </span><span class="s1">x: str(x))</span>
    <span class="s1">expected = string_series.agg(</span><span class="s0">lambda </span><span class="s1">x: str(x))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = string_series.apply(str)</span>
    <span class="s1">expected = string_series.agg(str)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_with_nested_series(datetime_series):</span>
    <span class="s2"># GH 2316</span>
    <span class="s2"># .agg with a reducer and a transform, what to do</span>
    <span class="s1">result = datetime_series.apply(</span><span class="s0">lambda </span><span class="s1">x: Series([x</span><span class="s0">, </span><span class="s1">x ** </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s3">&quot;x^2&quot;</span><span class="s1">]))</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;x&quot;</span><span class="s1">: datetime_series</span><span class="s0">, </span><span class="s3">&quot;x^2&quot;</span><span class="s1">: datetime_series ** </span><span class="s4">2</span><span class="s1">})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = datetime_series.agg(</span><span class="s0">lambda </span><span class="s1">x: Series([x</span><span class="s0">, </span><span class="s1">x ** </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s3">&quot;x^2&quot;</span><span class="s1">]))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_replicate_describe(string_series):</span>
    <span class="s2"># this also tests a result set that is all scalars</span>
    <span class="s1">expected = string_series.describe()</span>
    <span class="s1">result = string_series.apply(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;count&quot;</span><span class="s1">: </span><span class="s3">&quot;count&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;mean&quot;</span><span class="s1">: </span><span class="s3">&quot;mean&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;std&quot;</span><span class="s1">: </span><span class="s3">&quot;std&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;min&quot;</span><span class="s1">: </span><span class="s3">&quot;min&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;25%&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x.quantile(</span><span class="s4">0.25</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s3">&quot;50%&quot;</span><span class="s1">: </span><span class="s3">&quot;median&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;75%&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x.quantile(</span><span class="s4">0.75</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s3">&quot;max&quot;</span><span class="s1">: </span><span class="s3">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_reduce(string_series):</span>
    <span class="s2"># reductions with named functions</span>
    <span class="s1">result = string_series.agg([</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">])</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[string_series.sum()</span><span class="s0">, </span><span class="s1">string_series.mean()]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">name=string_series.name</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;how&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;agg&quot;</span><span class="s0">, </span><span class="s3">&quot;apply&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_non_callable_aggregates(how):</span>
    <span class="s2"># test agg using non-callable series attributes</span>
    <span class="s2"># GH 39116 - expand to apply</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, None</span><span class="s1">])</span>

    <span class="s2"># Calling agg w/ just a string arg same as calling s.arg</span>
    <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">how)(</span><span class="s3">&quot;size&quot;</span><span class="s1">)</span>
    <span class="s1">expected = s.size</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s2"># test when mixed w/ callable reducers</span>
    <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">how)([</span><span class="s3">&quot;size&quot;</span><span class="s0">, </span><span class="s3">&quot;count&quot;</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">])</span>
    <span class="s1">expected = Series({</span><span class="s3">&quot;size&quot;</span><span class="s1">: </span><span class="s4">3.0</span><span class="s0">, </span><span class="s3">&quot;count&quot;</span><span class="s1">: </span><span class="s4">2.0</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">: </span><span class="s4">1.5</span><span class="s1">})</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_apply_no_suffix_index():</span>
    <span class="s2"># GH36189</span>
    <span class="s1">s = Series([</span><span class="s4">4</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">result = s.apply([</span><span class="s3">&quot;sum&quot;</span><span class="s0">, lambda </span><span class="s1">x: x.sum()</span><span class="s0">, lambda </span><span class="s1">x: x.sum()])</span>
    <span class="s1">expected = Series([</span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s3">&quot;&lt;lambda&gt;&quot;</span><span class="s0">, </span><span class="s3">&quot;&lt;lambda&gt;&quot;</span><span class="s1">])</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map(datetime_series):</span>
    <span class="s1">index</span><span class="s0">, </span><span class="s1">data = tm.getMixedTypeDict()</span>

    <span class="s1">source = Series(data[</span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=data[</span><span class="s3">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">target = Series(data[</span><span class="s3">&quot;C&quot;</span><span class="s1">][:</span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=data[</span><span class="s3">&quot;D&quot;</span><span class="s1">][:</span><span class="s4">4</span><span class="s1">])</span>

    <span class="s1">merged = target.map(source)</span>

    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">merged.items():</span>
        <span class="s0">assert </span><span class="s1">v == source[target[k]]</span>

    <span class="s2"># input could be a dict</span>
    <span class="s1">merged = target.map(source.to_dict())</span>

    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">merged.items():</span>
        <span class="s0">assert </span><span class="s1">v == source[target[k]]</span>

    <span class="s2"># function</span>
    <span class="s1">result = datetime_series.map(</span><span class="s0">lambda </span><span class="s1">x: x * </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">datetime_series * </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2"># GH 10324</span>
    <span class="s1">a = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">b = Series([</span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">c = Series([</span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s1">])</span>

    <span class="s1">exp = Series([</span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(a.map(b)</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s3">&quot;even&quot;</span><span class="s0">, </span><span class="s3">&quot;odd&quot;</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">tm.assert_series_equal(a.map(c)</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">a = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s1">b = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.CategoricalIndex([</span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]))</span>
    <span class="s1">c = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=Index([</span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]))</span>

    <span class="s1">exp = Series([np.nan</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(a.map(b)</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">exp = Series([np.nan</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(a.map(c)</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">a = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s1">b = Series(</span>
        <span class="s1">[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s0">, </span><span class="s3">&quot;E&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=</span><span class="s3">&quot;category&quot;</span><span class="s0">,</span>
        <span class="s1">index=pd.CategoricalIndex([</span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;e&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">c = Series([</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s0">, </span><span class="s3">&quot;E&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=Index([</span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s0">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]))</span>

    <span class="s1">exp = Series(</span>
        <span class="s1">pd.Categorical([np.nan</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s0">, </span><span class="s3">&quot;E&quot;</span><span class="s1">])</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(a.map(b)</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">exp = Series([np.nan</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(a.map(c)</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_map_empty(index):</span>
    <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;Initializing a Series from a MultiIndex is not supported&quot;</span><span class="s1">)</span>

    <span class="s1">s = Series(index)</span>
    <span class="s1">result = s.map({})</span>

    <span class="s1">expected = Series(np.nan</span><span class="s0">, </span><span class="s1">index=s.index)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_compat():</span>
    <span class="s2"># related GH 8024</span>
    <span class="s1">s = Series([</span><span class="s0">True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">result = s.map({</span><span class="s0">True</span><span class="s1">: </span><span class="s3">&quot;foo&quot;</span><span class="s0">, False</span><span class="s1">: </span><span class="s3">&quot;bar&quot;</span><span class="s1">})</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_int():</span>
    <span class="s1">left = Series({</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1.0</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s4">2.0</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s4">3.0</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s1">: </span><span class="s4">4</span><span class="s1">})</span>
    <span class="s1">right = Series({</span><span class="s4">1</span><span class="s1">: </span><span class="s4">11</span><span class="s0">, </span><span class="s4">2</span><span class="s1">: </span><span class="s4">22</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: </span><span class="s4">33</span><span class="s1">})</span>

    <span class="s0">assert </span><span class="s1">left.dtype == np.float_</span>
    <span class="s0">assert </span><span class="s1">issubclass(right.dtype.type</span><span class="s0">, </span><span class="s1">np.integer)</span>

    <span class="s1">merged = left.map(right)</span>
    <span class="s0">assert </span><span class="s1">merged.dtype == np.float_</span>
    <span class="s0">assert </span><span class="s1">isna(merged[</span><span class="s3">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s0">assert not </span><span class="s1">isna(merged[</span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_map_type_inference():</span>
    <span class="s1">s = Series(range(</span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">s2 = s.map(</span><span class="s0">lambda </span><span class="s1">x: np.where(x == </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">issubclass(s2.dtype.type</span><span class="s0">, </span><span class="s1">np.integer)</span>


<span class="s0">def </span><span class="s1">test_map_decimal(string_series):</span>
    <span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>

    <span class="s1">result = string_series.map(</span><span class="s0">lambda </span><span class="s1">x: Decimal(str(x)))</span>
    <span class="s0">assert </span><span class="s1">result.dtype == np.object_</span>
    <span class="s0">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Decimal)</span>


<span class="s0">def </span><span class="s1">test_map_na_exclusion():</span>
    <span class="s1">s = Series([</span><span class="s4">1.5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span>

    <span class="s1">result = s.map(</span><span class="s0">lambda </span><span class="s1">x: x * </span><span class="s4">2</span><span class="s0">, </span><span class="s1">na_action=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
    <span class="s1">exp = s * </span><span class="s4">2</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_map_dict_with_tuple_keys():</span>
    <span class="s5">&quot;&quot;&quot; 
    Due to new MultiIndex-ing behaviour in v0.14.0, 
    dicts with tuple keys passed to map were being 
    converted to a multi-index, preventing tuple values 
    from being mapped properly. 
    &quot;&quot;&quot;</span>
    <span class="s2"># GH 18496</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)]})</span>
    <span class="s1">label_mappings = {(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">): </span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">,</span><span class="s1">): </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">): </span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">): </span><span class="s3">&quot;B&quot;</span><span class="s1">}</span>

    <span class="s1">df[</span><span class="s3">&quot;labels&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;a&quot;</span><span class="s1">].map(label_mappings)</span>
    <span class="s1">df[</span><span class="s3">&quot;expected_labels&quot;</span><span class="s1">] = Series([</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=df.index)</span>
    <span class="s2"># All labels should be filled now</span>
    <span class="s1">tm.assert_series_equal(df[</span><span class="s3">&quot;labels&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">df[</span><span class="s3">&quot;expected_labels&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_map_counter():</span>
    <span class="s1">s = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">counter = Counter()</span>
    <span class="s1">counter[</span><span class="s3">&quot;b&quot;</span><span class="s1">] = </span><span class="s4">5</span>
    <span class="s1">counter[</span><span class="s3">&quot;c&quot;</span><span class="s1">] += </span><span class="s4">1</span>
    <span class="s1">result = s.map(counter)</span>
    <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_defaultdict():</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">default_dict = defaultdict(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s3">&quot;blank&quot;</span><span class="s1">)</span>
    <span class="s1">default_dict[</span><span class="s4">1</span><span class="s1">] = </span><span class="s3">&quot;stuff&quot;</span>
    <span class="s1">result = s.map(default_dict)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;stuff&quot;</span><span class="s0">, </span><span class="s3">&quot;blank&quot;</span><span class="s0">, </span><span class="s3">&quot;blank&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_dict_na_key():</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/17648</span>
    <span class="s2"># Checks that np.nan key is appropriately mapped</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">result = s.map({</span><span class="s4">1</span><span class="s1">: </span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s4">2</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan: </span><span class="s3">&quot;c&quot;</span><span class="s1">})</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_dict_subclass_with_missing():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test Series.map with a dictionary subclass that defines __missing__, 
    i.e. sets a default value (GH #15999). 
    &quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">DictWithMissing(dict):</span>
        <span class="s0">def </span><span class="s1">__missing__(self</span><span class="s0">, </span><span class="s1">key):</span>
            <span class="s0">return </span><span class="s3">&quot;missing&quot;</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">dictionary = DictWithMissing({</span><span class="s4">3</span><span class="s1">: </span><span class="s3">&quot;three&quot;</span><span class="s1">})</span>
    <span class="s1">result = s.map(dictionary)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;missing&quot;</span><span class="s0">, </span><span class="s3">&quot;missing&quot;</span><span class="s0">, </span><span class="s3">&quot;three&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_dict_subclass_without_missing():</span>
    <span class="s0">class </span><span class="s1">DictWithoutMissing(dict):</span>
        <span class="s0">pass</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">dictionary = DictWithoutMissing({</span><span class="s4">3</span><span class="s1">: </span><span class="s3">&quot;three&quot;</span><span class="s1">})</span>
    <span class="s1">result = s.map(dictionary)</span>
    <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;three&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_abc_mapping(non_dict_mapping_subclass):</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/29733</span>
    <span class="s2"># Check collections.abc.Mapping support as mapper for Series.map</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">not_a_dictionary = non_dict_mapping_subclass({</span><span class="s4">3</span><span class="s1">: </span><span class="s3">&quot;three&quot;</span><span class="s1">})</span>
    <span class="s1">result = s.map(not_a_dictionary)</span>
    <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;three&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_abc_mapping_with_missing(non_dict_mapping_subclass):</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/issues/29733</span>
    <span class="s2"># Check collections.abc.Mapping support as mapper for Series.map</span>
    <span class="s0">class </span><span class="s1">NonDictMappingWithMissing(non_dict_mapping_subclass):</span>
        <span class="s0">def </span><span class="s1">__missing__(key):</span>
            <span class="s0">return </span><span class="s3">&quot;missing&quot;</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">not_a_dictionary = NonDictMappingWithMissing({</span><span class="s4">3</span><span class="s1">: </span><span class="s3">&quot;three&quot;</span><span class="s1">})</span>
    <span class="s1">result = s.map(not_a_dictionary)</span>
    <span class="s2"># __missing__ is a dict concept, not a Mapping concept,</span>
    <span class="s2"># so it should not change the result!</span>
    <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">&quot;three&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_map_box():</span>
    <span class="s1">vals = [pd.Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;datetime64[ns]&quot;</span>
    <span class="s2"># boxed value must be Timestamp instance</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timestamp_1_None&quot;</span><span class="s0">, </span><span class="s3">&quot;Timestamp_2_None&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">vals = [</span>
        <span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.Timestamp(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;datetime64[ns, US/Eastern]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timestamp_1_US/Eastern&quot;</span><span class="s0">, </span><span class="s3">&quot;Timestamp_2_US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># timedelta</span>
    <span class="s1">vals = [pd.Timedelta(</span><span class="s3">&quot;1 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s3">&quot;2 days&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;timedelta64[ns]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.days</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Timedelta_1&quot;</span><span class="s0">, </span><span class="s3">&quot;Timedelta_2&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># period</span>
    <span class="s1">vals = [pd.Period(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Period(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s3">&quot;Period[M]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s3">_</span><span class="s0">{</span><span class="s1">x.freqstr</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Period_M&quot;</span><span class="s0">, </span><span class="s3">&quot;Period_M&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_map_categorical():</span>
    <span class="s1">values = pd.Categorical(list(</span><span class="s3">&quot;ABBABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s3">&quot;DCBA&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>

    <span class="s1">result = s.map(</span><span class="s0">lambda </span><span class="s1">x: x.lower())</span>
    <span class="s1">exp_values = pd.Categorical(list(</span><span class="s3">&quot;abbabcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s3">&quot;dcba&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">exp = Series(exp_values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">tm.assert_categorical_equal(result.values</span><span class="s0">, </span><span class="s1">exp_values)</span>

    <span class="s1">result = s.map(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;A&quot;</span><span class="s1">] * </span><span class="s4">7</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s0">assert </span><span class="s1">result.dtype == object</span>


<span class="s0">def </span><span class="s1">test_map_datetimetz():</span>
    <span class="s1">values = pd.date_range(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s3">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>

    <span class="s2"># keep tz</span>
    <span class="s1">result = s.map(</span><span class="s0">lambda </span><span class="s1">x: x + pd.offsets.Day())</span>
    <span class="s1">exp_values = pd.date_range(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s3">&quot;2011-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s3">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">exp = Series(exp_values</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># change dtype</span>
    <span class="s2"># GH 14506 : Returned dtype changed from int32 to int64</span>
    <span class="s1">result = s.map(</span><span class="s0">lambda </span><span class="s1">x: x.hour)</span>
    <span class="s1">exp = Series(list(range(</span><span class="s4">24</span><span class="s1">)) + [</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s2"># not vectorized</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">if not </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">pd.Timestamp):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>
        <span class="s0">return </span><span class="s1">str(x.tz)</span>

    <span class="s1">result = s.map(f)</span>
    <span class="s1">exp = Series([</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">] * </span><span class="s4">25</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;vals,mapping,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(list(</span><span class="s3">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{np.nan: </span><span class="s3">&quot;not NaN&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[np.nan] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s3">&quot;not NaN&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(list(</span><span class="s3">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s3">&quot;a letter&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;a letter&quot;</span><span class="s1">] + [np.nan] * </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(list(range(</span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">{</span><span class="s4">0</span><span class="s1">: </span><span class="s4">42</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s4">42</span><span class="s1">] + [np.nan] * </span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_map_missing_mixed(vals</span><span class="s0">, </span><span class="s1">mapping</span><span class="s0">, </span><span class="s1">exp):</span>
    <span class="s2"># GH20495</span>
    <span class="s1">s = Series(vals + [np.nan])</span>
    <span class="s1">result = s.map(mapping)</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">Series(exp))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;dti,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.DatetimeIndex([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">31536000000</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">DataFrame(np.repeat([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">tm.makeTimeSeries(nper=</span><span class="s4">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">DataFrame(np.repeat([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;aware&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_series_on_date_time_index_aware_series(dti</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">aware):</span>
    <span class="s2"># GH 25959</span>
    <span class="s2"># Calling apply on a localized time series should not cause an error</span>
    <span class="s0">if </span><span class="s1">aware:</span>
        <span class="s1">index = dti.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).index</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index = dti.index</span>
    <span class="s1">result = Series(index).apply(</span><span class="s0">lambda </span><span class="s1">x: Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_apply_scalar_on_date_time_index_aware_series():</span>
    <span class="s2"># GH 25959</span>
    <span class="s2"># Calling apply on a localized time series should not cause an error</span>
    <span class="s1">series = tm.makeTimeSeries(nper=</span><span class="s4">30</span><span class="s1">).tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
    <span class="s1">result = Series(series.index).apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">Series(np.ones(</span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_map_float_to_string_precision():</span>
    <span class="s2"># GH 13228</span>
    <span class="s1">ser = Series(</span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">result = ser.map(</span><span class="s0">lambda </span><span class="s1">val: str(val)).to_dict()</span>
    <span class="s1">expected = {</span><span class="s4">0</span><span class="s1">: </span><span class="s3">&quot;0.3333333333333333&quot;</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>


<span class="s0">def </span><span class="s1">test_apply_to_timedelta():</span>
    <span class="s1">list_of_valid_strings = [</span><span class="s3">&quot;00:00:01&quot;</span><span class="s0">, </span><span class="s3">&quot;00:00:02&quot;</span><span class="s1">]</span>
    <span class="s1">a = pd.to_timedelta(list_of_valid_strings)</span>
    <span class="s1">b = Series(list_of_valid_strings).apply(pd.to_timedelta)</span>
    <span class="s1">tm.assert_series_equal(Series(a)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">list_of_strings = [</span><span class="s3">&quot;00:00:01&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT]</span>

    <span class="s1">a = pd.to_timedelta(list_of_strings)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Inferring timedelta64&quot;</span><span class="s1">):</span>
        <span class="s1">ser = Series(list_of_strings)</span>
    <span class="s1">b = ser.apply(pd.to_timedelta)</span>
    <span class="s1">tm.assert_series_equal(Series(a)</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ops, names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([np.sum]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([np.sum</span><span class="s0">, </span><span class="s1">np.mean]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sum])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sum</span><span class="s0">, </span><span class="s1">np.mean])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;how&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;agg&quot;</span><span class="s0">, </span><span class="s3">&quot;apply&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_listlike_reducer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">how):</span>
    <span class="s2"># GH 39140</span>
    <span class="s1">expected = Series({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">zip(names</span><span class="s0">, </span><span class="s1">ops)})</span>
    <span class="s1">expected.name = </span><span class="s3">&quot;series&quot;</span>
    <span class="s1">result = getattr(string_series</span><span class="s0">, </span><span class="s1">how)(ops)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ops&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sum}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sum</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.mean}</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sum})</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sum</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.mean})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;how&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;agg&quot;</span><span class="s0">, </span><span class="s3">&quot;apply&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_dictlike_reducer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">how):</span>
    <span class="s2"># GH 39140</span>
    <span class="s1">expected = Series({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops.items()})</span>
    <span class="s1">expected.name = string_series.name</span>
    <span class="s1">result = getattr(string_series</span><span class="s0">, </span><span class="s1">how)(ops)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ops, names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([np.sqrt]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([np.abs</span><span class="s0">, </span><span class="s1">np.sqrt]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;absolute&quot;</span><span class="s0">, </span><span class="s3">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sqrt])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.abs</span><span class="s0">, </span><span class="s1">np.sqrt])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;absolute&quot;</span><span class="s0">, </span><span class="s3">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_listlike_transformer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">names):</span>
    <span class="s2"># GH 39140</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">expected = concat([op(string_series) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = names</span>
        <span class="s1">result = string_series.apply(ops)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ops&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sqrt}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.exp}</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sqrt})</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s3">&quot;A&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.exp})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_dictlike_transformer(string_series</span><span class="s0">, </span><span class="s1">ops):</span>
    <span class="s2"># GH 39140</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">expected = concat({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops.items()})</span>
        <span class="s1">expected.name = string_series.name</span>
        <span class="s1">result = string_series.apply(ops)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_retains_column_name():</span>
    <span class="s2"># GH 16380</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;x&quot;</span><span class="s1">: range(</span><span class="s4">3</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">))</span>
    <span class="s1">result = df.x.apply(</span><span class="s0">lambda </span><span class="s1">x: Series(range(x + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Index(range(x + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;y&quot;</span><span class="s1">)))</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">columns=Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;y&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">index=Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>