<html>
<head>
<title>tz.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tz.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
This module offers timezone implementations subclassing the abstract 
:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format 
files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`, 
etc), TZ environment string (in all known formats), given ranges (with help 
from relative deltas), local machine timezone, fixed offset timezone, and UTC 
timezone. 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">datetime</span>
<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">bisect</span>
<span class="s3">import </span><span class="s1">weakref</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">OrderedDict</span>

<span class="s3">import </span><span class="s1">six</span>
<span class="s3">from </span><span class="s1">six </span><span class="s3">import </span><span class="s1">string_types</span>
<span class="s3">from </span><span class="s1">six.moves </span><span class="s3">import </span><span class="s1">_thread</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">tzname_in_python2</span><span class="s3">, </span><span class="s1">_tzinfo</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">tzrangebase</span><span class="s3">, </span><span class="s1">enfold</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">_validate_fromutc_inputs</span>

<span class="s3">from </span><span class="s1">._factories </span><span class="s3">import </span><span class="s1">_TzSingleton</span><span class="s3">, </span><span class="s1">_TzOffsetFactory</span>
<span class="s3">from </span><span class="s1">._factories </span><span class="s3">import </span><span class="s1">_TzStrFactory</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">.win </span><span class="s3">import </span><span class="s1">tzwin</span><span class="s3">, </span><span class="s1">tzwinlocal</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">tzwin = tzwinlocal = </span><span class="s3">None</span>

<span class="s0"># For warning about rounding tzinfo</span>
<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>

<span class="s1">ZERO = datetime.timedelta(</span><span class="s4">0</span><span class="s1">)</span>
<span class="s1">EPOCH = datetime.datetime.utcfromtimestamp(</span><span class="s4">0</span><span class="s1">)</span>
<span class="s1">EPOCHORDINAL = EPOCH.toordinal()</span>


<span class="s1">@six.add_metaclass(_TzSingleton)</span>
<span class="s3">class </span><span class="s1">tzutc(datetime.tzinfo):</span>
    <span class="s2">&quot;&quot;&quot; 
    This is a tzinfo object that represents the UTC time zone. 
 
    **Examples:** 
 
    .. doctest:: 
 
        &gt;&gt;&gt; from datetime import * 
        &gt;&gt;&gt; from dateutil.tz import * 
 
        &gt;&gt;&gt; datetime.now() 
        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290) 
 
        &gt;&gt;&gt; datetime.now(tzutc()) 
        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc()) 
 
        &gt;&gt;&gt; datetime.now(tzutc()).tzname() 
        'UTC' 
 
    .. versionchanged:: 2.7.0 
        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will 
        always return the same object. 
 
        .. doctest:: 
 
            &gt;&gt;&gt; from dateutil.tz import tzutc, UTC 
            &gt;&gt;&gt; tzutc() is tzutc() 
            True 
            &gt;&gt;&gt; tzutc() is UTC 
            True 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">utcoffset(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">ZERO</span>

    <span class="s3">def </span><span class="s1">dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">ZERO</span>

    <span class="s1">@tzname_in_python2</span>
    <span class="s3">def </span><span class="s1">tzname(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s5">&quot;UTC&quot;</span>

    <span class="s3">def </span><span class="s1">is_ambiguous(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s2">&quot;&quot;&quot; 
        Whether or not the &quot;wall time&quot; of a given datetime is ambiguous in this 
        zone. 
 
        :param dt: 
            A :py:class:`datetime.datetime`, naive or time zone aware. 
 
 
        :return: 
            Returns ``True`` if ambiguous, ``False`` otherwise. 
 
        .. versionadded:: 2.6.0 
        &quot;&quot;&quot;</span>
        <span class="s3">return False</span>

    <span class="s1">@_validate_fromutc_inputs</span>
    <span class="s3">def </span><span class="s1">fromutc(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s2">&quot;&quot;&quot; 
        Fast track version of fromutc() returns the original ``dt`` object for 
        any valid :py:class:`datetime.datetime` object. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dt</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">(tzutc</span><span class="s3">, </span><span class="s1">tzoffset)):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">(isinstance(other</span><span class="s3">, </span><span class="s1">tzutc) </span><span class="s3">or</span>
                <span class="s1">(isinstance(other</span><span class="s3">, </span><span class="s1">tzoffset) </span><span class="s3">and </span><span class="s1">other._offset == ZERO))</span>

    <span class="s1">__hash__ = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s()&quot; </span><span class="s1">% self.__class__.__name__</span>

    <span class="s1">__reduce__ = object.__reduce__</span>


<span class="s0">#: Convenience constant providing a :class:`tzutc()` instance</span>
<span class="s0">#:</span>
<span class="s0">#: .. versionadded:: 2.7.0</span>
<span class="s1">UTC = tzutc()</span>


<span class="s1">@six.add_metaclass(_TzOffsetFactory)</span>
<span class="s3">class </span><span class="s1">tzoffset(datetime.tzinfo):</span>
    <span class="s2">&quot;&quot;&quot; 
    A simple class for representing a fixed offset from UTC. 
 
    :param name: 
        The timezone name, to be returned when ``tzname()`` is called. 
    :param offset: 
        The time zone offset in seconds, or (since version 2.6.0, represented 
        as a :py:class:`datetime.timedelta` object). 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">offset):</span>
        <span class="s1">self._name = name</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># Allow a timedelta</span>
            <span class="s1">offset = offset.total_seconds()</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
            <span class="s3">pass</span>

        <span class="s1">self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))</span>

    <span class="s3">def </span><span class="s1">utcoffset(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">self._offset</span>

    <span class="s3">def </span><span class="s1">dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">ZERO</span>

    <span class="s1">@tzname_in_python2</span>
    <span class="s3">def </span><span class="s1">tzname(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">self._name</span>

    <span class="s1">@_validate_fromutc_inputs</span>
    <span class="s3">def </span><span class="s1">fromutc(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">dt + self._offset</span>

    <span class="s3">def </span><span class="s1">is_ambiguous(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s2">&quot;&quot;&quot; 
        Whether or not the &quot;wall time&quot; of a given datetime is ambiguous in this 
        zone. 
 
        :param dt: 
            A :py:class:`datetime.datetime`, naive or time zone aware. 
        :return: 
            Returns ``True`` if ambiguous, ``False`` otherwise. 
 
        .. versionadded:: 2.6.0 
        &quot;&quot;&quot;</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzoffset):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self._offset == other._offset</span>

    <span class="s1">__hash__ = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%s, %s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">,</span>
                               <span class="s1">repr(self._name)</span><span class="s3">,</span>
                               <span class="s1">int(self._offset.total_seconds()))</span>

    <span class="s1">__reduce__ = object.__reduce__</span>


<span class="s3">class </span><span class="s1">tzlocal(_tzinfo):</span>
    <span class="s2">&quot;&quot;&quot; 
    A :class:`tzinfo` subclass built around the ``time`` timezone functions. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super(tzlocal</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s1">self._std_offset = datetime.timedelta(seconds=-time.timezone)</span>
        <span class="s3">if </span><span class="s1">time.daylight:</span>
            <span class="s1">self._dst_offset = datetime.timedelta(seconds=-time.altzone)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._dst_offset = self._std_offset</span>

        <span class="s1">self._dst_saved = self._dst_offset - self._std_offset</span>
        <span class="s1">self._hasdst = bool(self._dst_saved)</span>
        <span class="s1">self._tznames = tuple(time.tzname)</span>

    <span class="s3">def </span><span class="s1">utcoffset(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">dt </span><span class="s3">is None and </span><span class="s1">self._hasdst:</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">self._isdst(dt):</span>
            <span class="s3">return </span><span class="s1">self._dst_offset</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._std_offset</span>

    <span class="s3">def </span><span class="s1">dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">dt </span><span class="s3">is None and </span><span class="s1">self._hasdst:</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">self._isdst(dt):</span>
            <span class="s3">return </span><span class="s1">self._dst_offset - self._std_offset</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ZERO</span>

    <span class="s1">@tzname_in_python2</span>
    <span class="s3">def </span><span class="s1">tzname(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">self._tznames[self._isdst(dt)]</span>

    <span class="s3">def </span><span class="s1">is_ambiguous(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s2">&quot;&quot;&quot; 
        Whether or not the &quot;wall time&quot; of a given datetime is ambiguous in this 
        zone. 
 
        :param dt: 
            A :py:class:`datetime.datetime`, naive or time zone aware. 
 
 
        :return: 
            Returns ``True`` if ambiguous, ``False`` otherwise. 
 
        .. versionadded:: 2.6.0 
        &quot;&quot;&quot;</span>
        <span class="s1">naive_dst = self._naive_is_dst(dt)</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">not </span><span class="s1">naive_dst </span><span class="s3">and</span>
                <span class="s1">(naive_dst != self._naive_is_dst(dt - self._dst_saved)))</span>

    <span class="s3">def </span><span class="s1">_naive_is_dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s1">timestamp = _datetime_to_timestamp(dt)</span>
        <span class="s3">return </span><span class="s1">time.localtime(timestamp + time.timezone).tm_isdst</span>

    <span class="s3">def </span><span class="s1">_isdst(self</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">fold_naive=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0"># We can't use mktime here. It is unstable when deciding if</span>
        <span class="s0"># the hour near to a change is DST or not.</span>
        <span class="s0">#</span>
        <span class="s0"># timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,</span>
        <span class="s0">#                         dt.minute, dt.second, dt.weekday(), 0, -1))</span>
        <span class="s0"># return time.localtime(timestamp).tm_isdst</span>
        <span class="s0">#</span>
        <span class="s0"># The code above yields the following result:</span>
        <span class="s0">#</span>
        <span class="s0"># &gt;&gt;&gt; import tz, datetime</span>
        <span class="s0"># &gt;&gt;&gt; t = tz.tzlocal()</span>
        <span class="s0"># &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</span>
        <span class="s0"># 'BRDT'</span>
        <span class="s0"># &gt;&gt;&gt; datetime.datetime(2003,2,16,0,tzinfo=t).tzname()</span>
        <span class="s0"># 'BRST'</span>
        <span class="s0"># &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</span>
        <span class="s0"># 'BRST'</span>
        <span class="s0"># &gt;&gt;&gt; datetime.datetime(2003,2,15,22,tzinfo=t).tzname()</span>
        <span class="s0"># 'BRDT'</span>
        <span class="s0"># &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</span>
        <span class="s0"># 'BRDT'</span>
        <span class="s0">#</span>
        <span class="s0"># Here is a more stable implementation:</span>
        <span class="s0">#</span>
        <span class="s3">if not </span><span class="s1">self._hasdst:</span>
            <span class="s3">return False</span>

        <span class="s0"># Check for ambiguous times:</span>
        <span class="s1">dstval = self._naive_is_dst(dt)</span>
        <span class="s1">fold = getattr(dt</span><span class="s3">, </span><span class="s5">'fold'</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.is_ambiguous(dt):</span>
            <span class="s3">if </span><span class="s1">fold </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">return not </span><span class="s1">self._fold(dt)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return True</span>

        <span class="s3">return </span><span class="s1">dstval</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzlocal):</span>
            <span class="s3">return </span><span class="s1">(self._std_offset == other._std_offset </span><span class="s3">and</span>
                    <span class="s1">self._dst_offset == other._dst_offset)</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzutc):</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">not </span><span class="s1">self._hasdst </span><span class="s3">and</span>
                    <span class="s1">self._tznames[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">{</span><span class="s5">'UTC'</span><span class="s3">, </span><span class="s5">'GMT'</span><span class="s1">} </span><span class="s3">and</span>
                    <span class="s1">self._std_offset == ZERO)</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzoffset):</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s3">not </span><span class="s1">self._hasdst </span><span class="s3">and</span>
                    <span class="s1">self._tznames[</span><span class="s4">0</span><span class="s1">] == other._name </span><span class="s3">and</span>
                    <span class="s1">self._std_offset == other._offset)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s1">__hash__ = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s()&quot; </span><span class="s1">% self.__class__.__name__</span>

    <span class="s1">__reduce__ = object.__reduce__</span>


<span class="s3">class </span><span class="s1">_ttinfo(object):</span>
    <span class="s1">__slots__ = [</span><span class="s5">&quot;offset&quot;</span><span class="s3">, </span><span class="s5">&quot;delta&quot;</span><span class="s3">, </span><span class="s5">&quot;isdst&quot;</span><span class="s3">, </span><span class="s5">&quot;abbr&quot;</span><span class="s3">,</span>
                 <span class="s5">&quot;isstd&quot;</span><span class="s3">, </span><span class="s5">&quot;isgmt&quot;</span><span class="s3">, </span><span class="s5">&quot;dstoffset&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">self.__slots__:</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">l = []</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">self.__slots__:</span>
            <span class="s1">value = getattr(self</span><span class="s3">, </span><span class="s1">attr)</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">l.append(</span><span class="s5">&quot;%s=%s&quot; </span><span class="s1">% (attr</span><span class="s3">, </span><span class="s1">repr(value)))</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s5">&quot;, &quot;</span><span class="s1">.join(l))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_ttinfo):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">(self.offset == other.offset </span><span class="s3">and</span>
                <span class="s1">self.delta == other.delta </span><span class="s3">and</span>
                <span class="s1">self.isdst == other.isdst </span><span class="s3">and</span>
                <span class="s1">self.abbr == other.abbr </span><span class="s3">and</span>
                <span class="s1">self.isstd == other.isstd </span><span class="s3">and</span>
                <span class="s1">self.isgmt == other.isgmt </span><span class="s3">and</span>
                <span class="s1">self.dstoffset == other.dstoffset)</span>

    <span class="s1">__hash__ = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">state = {}</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.__slots__:</span>
            <span class="s1">state[name] = getattr(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">state</span>

    <span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">state):</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.__slots__:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">state:</span>
                <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">state[name])</span>


<span class="s3">class </span><span class="s1">_tzfile(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Lightweight class for holding the relevant transition and time zone 
    information read from binary tzfiles. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs = [</span><span class="s5">'trans_list'</span><span class="s3">, </span><span class="s5">'trans_list_utc'</span><span class="s3">, </span><span class="s5">'trans_idx'</span><span class="s3">, </span><span class="s5">'ttinfo_list'</span><span class="s3">,</span>
             <span class="s5">'ttinfo_std'</span><span class="s3">, </span><span class="s5">'ttinfo_dst'</span><span class="s3">, </span><span class="s5">'ttinfo_before'</span><span class="s3">, </span><span class="s5">'ttinfo_first'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">self.attrs:</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">kwargs.get(attr</span><span class="s3">, None</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">tzfile(_tzinfo):</span>
    <span class="s2">&quot;&quot;&quot; 
    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)`` 
    format timezone files to extract current and historical zone information. 
 
    :param fileobj: 
        This can be an opened file stream or a file name that the time zone 
        information can be read from. 
 
    :param filename: 
        This is an optional parameter specifying the source of the time zone 
        information in the event that ``fileobj`` is a file object. If omitted 
        and ``fileobj`` is a file stream, this parameter will be set either to 
        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``. 
 
    See `Sources for Time Zone and Daylight Saving Time Data 
    &lt;https://data.iana.org/time-zones/tz-link.html&gt;`_ for more information. 
    Time zone files can be compiled from the `IANA Time Zone database files 
    &lt;https://www.iana.org/time-zones&gt;`_ with the `zic time zone compiler 
    &lt;https://www.freebsd.org/cgi/man.cgi?query=zic&amp;sektion=8&gt;`_ 
 
    .. note:: 
 
        Only construct a ``tzfile`` directly if you have a specific timezone 
        file on disk that you want to read into a Python ``tzinfo`` object. 
        If you want to get a ``tzfile`` representing a specific IANA zone, 
        (e.g. ``'America/New_York'``), you should call 
        :func:`dateutil.tz.gettz` with the zone identifier. 
 
 
    **Examples:** 
 
    Using the US Eastern time zone as an example, we can see that a ``tzfile`` 
    provides time zone information for the standard Daylight Saving offsets: 
 
    .. testsetup:: tzfile 
 
        from dateutil.tz import gettz 
        from datetime import datetime 
 
    .. doctest:: tzfile 
 
        &gt;&gt;&gt; NYC = gettz('America/New_York') 
        &gt;&gt;&gt; NYC 
        tzfile('/usr/share/zoneinfo/America/New_York') 
 
        &gt;&gt;&gt; print(datetime(2016, 1, 3, tzinfo=NYC))     # EST 
        2016-01-03 00:00:00-05:00 
 
        &gt;&gt;&gt; print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT 
        2016-07-07 00:00:00-04:00 
 
 
    The ``tzfile`` structure contains a fully history of the time zone, 
    so historical dates will also have the right offsets. For example, before 
    the adoption of the UTC standards, New York used local solar  mean time: 
 
    .. doctest:: tzfile 
 
       &gt;&gt;&gt; print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT 
       1901-04-12 00:00:00-04:56 
 
    And during World War II, New York was on &quot;Eastern War Time&quot;, which was a 
    state of permanent daylight saving time: 
 
    .. doctest:: tzfile 
 
        &gt;&gt;&gt; print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT 
        1944-02-07 00:00:00-04:00 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fileobj</span><span class="s3">, </span><span class="s1">filename=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(tzfile</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s1">file_opened_here = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">isinstance(fileobj</span><span class="s3">, </span><span class="s1">string_types):</span>
            <span class="s1">self._filename = fileobj</span>
            <span class="s1">fileobj = open(fileobj</span><span class="s3">, </span><span class="s5">'rb'</span><span class="s1">)</span>
            <span class="s1">file_opened_here = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">filename </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._filename = filename</span>
        <span class="s3">elif </span><span class="s1">hasattr(fileobj</span><span class="s3">, </span><span class="s5">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s1">self._filename = fileobj.name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._filename = repr(fileobj)</span>

        <span class="s3">if </span><span class="s1">fileobj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">file_opened_here:</span>
                <span class="s1">fileobj = _nullcontext(fileobj)</span>

            <span class="s3">with </span><span class="s1">fileobj </span><span class="s3">as </span><span class="s1">file_stream:</span>
                <span class="s1">tzobj = self._read_tzfile(file_stream)</span>

            <span class="s1">self._set_tzdata(tzobj)</span>

    <span class="s3">def </span><span class="s1">_set_tzdata(self</span><span class="s3">, </span><span class="s1">tzobj):</span>
        <span class="s2">&quot;&quot;&quot; Set the time zone data of this object from a _tzfile object &quot;&quot;&quot;</span>
        <span class="s0"># Copy the relevant attributes over as private attributes</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">_tzfile.attrs:</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s5">'_' </span><span class="s1">+ attr</span><span class="s3">, </span><span class="s1">getattr(tzobj</span><span class="s3">, </span><span class="s1">attr))</span>

    <span class="s3">def </span><span class="s1">_read_tzfile(self</span><span class="s3">, </span><span class="s1">fileobj):</span>
        <span class="s1">out = _tzfile()</span>

        <span class="s0"># From tzfile(5):</span>
        <span class="s0">#</span>
        <span class="s0"># The time zone information files used by tzset(3)</span>
        <span class="s0"># begin with the magic characters &quot;TZif&quot; to identify</span>
        <span class="s0"># them as time zone information files, followed by</span>
        <span class="s0"># sixteen bytes reserved for future use, followed by</span>
        <span class="s0"># six four-byte values of type long, written in a</span>
        <span class="s0"># ``standard'' byte order (the high-order  byte</span>
        <span class="s0"># of the value is written first).</span>
        <span class="s3">if </span><span class="s1">fileobj.read(</span><span class="s4">4</span><span class="s1">).decode() != </span><span class="s5">&quot;TZif&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;magic not found&quot;</span><span class="s1">)</span>

        <span class="s1">fileobj.read(</span><span class="s4">16</span><span class="s1">)</span>

        <span class="s1">(</span>
            <span class="s0"># The number of UTC/local indicators stored in the file.</span>
            <span class="s1">ttisgmtcnt</span><span class="s3">,</span>

            <span class="s0"># The number of standard/wall indicators stored in the file.</span>
            <span class="s1">ttisstdcnt</span><span class="s3">,</span>

            <span class="s0"># The number of leap seconds for which data is</span>
            <span class="s0"># stored in the file.</span>
            <span class="s1">leapcnt</span><span class="s3">,</span>

            <span class="s0"># The number of &quot;transition times&quot; for which data</span>
            <span class="s0"># is stored in the file.</span>
            <span class="s1">timecnt</span><span class="s3">,</span>

            <span class="s0"># The number of &quot;local time types&quot; for which data</span>
            <span class="s0"># is stored in the file (must not be zero).</span>
            <span class="s1">typecnt</span><span class="s3">,</span>

            <span class="s0"># The  number  of  characters  of &quot;time zone</span>
            <span class="s0"># abbreviation strings&quot; stored in the file.</span>
            <span class="s1">charcnt</span><span class="s3">,</span>

        <span class="s1">) = struct.unpack(</span><span class="s5">&quot;&gt;6l&quot;</span><span class="s3">, </span><span class="s1">fileobj.read(</span><span class="s4">24</span><span class="s1">))</span>

        <span class="s0"># The above header is followed by tzh_timecnt four-byte</span>
        <span class="s0"># values  of  type long,  sorted  in ascending order.</span>
        <span class="s0"># These values are written in ``standard'' byte order.</span>
        <span class="s0"># Each is used as a transition time (as  returned  by</span>
        <span class="s0"># time(2)) at which the rules for computing local time</span>
        <span class="s0"># change.</span>

        <span class="s3">if </span><span class="s1">timecnt:</span>
            <span class="s1">out.trans_list_utc = list(struct.unpack(</span><span class="s5">&quot;&gt;%dl&quot; </span><span class="s1">% timecnt</span><span class="s3">,</span>
                                                    <span class="s1">fileobj.read(timecnt*</span><span class="s4">4</span><span class="s1">)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">out.trans_list_utc = []</span>

        <span class="s0"># Next come tzh_timecnt one-byte values of type unsigned</span>
        <span class="s0"># char; each one tells which of the different types of</span>
        <span class="s0"># ``local time'' types described in the file is associated</span>
        <span class="s0"># with the same-indexed transition time. These values</span>
        <span class="s0"># serve as indices into an array of ttinfo structures that</span>
        <span class="s0"># appears next in the file.</span>

        <span class="s3">if </span><span class="s1">timecnt:</span>
            <span class="s1">out.trans_idx = struct.unpack(</span><span class="s5">&quot;&gt;%dB&quot; </span><span class="s1">% timecnt</span><span class="s3">,</span>
                                          <span class="s1">fileobj.read(timecnt))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">out.trans_idx = []</span>

        <span class="s0"># Each ttinfo structure is written as a four-byte value</span>
        <span class="s0"># for tt_gmtoff  of  type long,  in  a  standard  byte</span>
        <span class="s0"># order, followed  by a one-byte value for tt_isdst</span>
        <span class="s0"># and a one-byte  value  for  tt_abbrind.   In  each</span>
        <span class="s0"># structure, tt_gmtoff  gives  the  number  of</span>
        <span class="s0"># seconds to be added to UTC, tt_isdst tells whether</span>
        <span class="s0"># tm_isdst should be set by  localtime(3),  and</span>
        <span class="s0"># tt_abbrind serves  as an index into the array of</span>
        <span class="s0"># time zone abbreviation characters that follow the</span>
        <span class="s0"># ttinfo structure(s) in the file.</span>

        <span class="s1">ttinfo = []</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(typecnt):</span>
            <span class="s1">ttinfo.append(struct.unpack(</span><span class="s5">&quot;&gt;lbb&quot;</span><span class="s3">, </span><span class="s1">fileobj.read(</span><span class="s4">6</span><span class="s1">)))</span>

        <span class="s1">abbr = fileobj.read(charcnt).decode()</span>

        <span class="s0"># Then there are tzh_leapcnt pairs of four-byte</span>
        <span class="s0"># values, written in  standard byte  order;  the</span>
        <span class="s0"># first  value  of  each pair gives the time (as</span>
        <span class="s0"># returned by time(2)) at which a leap second</span>
        <span class="s0"># occurs;  the  second  gives the  total  number of</span>
        <span class="s0"># leap seconds to be applied after the given time.</span>
        <span class="s0"># The pairs of values are sorted in ascending order</span>
        <span class="s0"># by time.</span>

        <span class="s0"># Not used, for now (but seek for correct file position)</span>
        <span class="s3">if </span><span class="s1">leapcnt:</span>
            <span class="s1">fileobj.seek(leapcnt * </span><span class="s4">8</span><span class="s3">, </span><span class="s1">os.SEEK_CUR)</span>

        <span class="s0"># Then there are tzh_ttisstdcnt standard/wall</span>
        <span class="s0"># indicators, each stored as a one-byte value;</span>
        <span class="s0"># they tell whether the transition times associated</span>
        <span class="s0"># with local time types were specified as standard</span>
        <span class="s0"># time or wall clock time, and are used when</span>
        <span class="s0"># a time zone file is used in handling POSIX-style</span>
        <span class="s0"># time zone environment variables.</span>

        <span class="s3">if </span><span class="s1">ttisstdcnt:</span>
            <span class="s1">isstd = struct.unpack(</span><span class="s5">&quot;&gt;%db&quot; </span><span class="s1">% ttisstdcnt</span><span class="s3">,</span>
                                  <span class="s1">fileobj.read(ttisstdcnt))</span>

        <span class="s0"># Finally, there are tzh_ttisgmtcnt UTC/local</span>
        <span class="s0"># indicators, each stored as a one-byte value;</span>
        <span class="s0"># they tell whether the transition times associated</span>
        <span class="s0"># with local time types were specified as UTC or</span>
        <span class="s0"># local time, and are used when a time zone file</span>
        <span class="s0"># is used in handling POSIX-style time zone envi-</span>
        <span class="s0"># ronment variables.</span>

        <span class="s3">if </span><span class="s1">ttisgmtcnt:</span>
            <span class="s1">isgmt = struct.unpack(</span><span class="s5">&quot;&gt;%db&quot; </span><span class="s1">% ttisgmtcnt</span><span class="s3">,</span>
                                  <span class="s1">fileobj.read(ttisgmtcnt))</span>

        <span class="s0"># Build ttinfo list</span>
        <span class="s1">out.ttinfo_list = []</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(typecnt):</span>
            <span class="s1">gmtoff</span><span class="s3">, </span><span class="s1">isdst</span><span class="s3">, </span><span class="s1">abbrind = ttinfo[i]</span>
            <span class="s1">gmtoff = _get_supported_offset(gmtoff)</span>
            <span class="s1">tti = _ttinfo()</span>
            <span class="s1">tti.offset = gmtoff</span>
            <span class="s1">tti.dstoffset = datetime.timedelta(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">tti.delta = datetime.timedelta(seconds=gmtoff)</span>
            <span class="s1">tti.isdst = isdst</span>
            <span class="s1">tti.abbr = abbr[abbrind:abbr.find(</span><span class="s5">'</span><span class="s3">\x00</span><span class="s5">'</span><span class="s3">, </span><span class="s1">abbrind)]</span>
            <span class="s1">tti.isstd = (ttisstdcnt &gt; i </span><span class="s3">and </span><span class="s1">isstd[i] != </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">tti.isgmt = (ttisgmtcnt &gt; i </span><span class="s3">and </span><span class="s1">isgmt[i] != </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">out.ttinfo_list.append(tti)</span>

        <span class="s0"># Replace ttinfo indexes for ttinfo objects.</span>
        <span class="s1">out.trans_idx = [out.ttinfo_list[idx] </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">out.trans_idx]</span>

        <span class="s0"># Set standard, dst, and before ttinfos. before will be</span>
        <span class="s0"># used when a given time is before any transitions,</span>
        <span class="s0"># and will be set to the first non-dst ttinfo, or to</span>
        <span class="s0"># the first dst, if all of them are dst.</span>
        <span class="s1">out.ttinfo_std = </span><span class="s3">None</span>
        <span class="s1">out.ttinfo_dst = </span><span class="s3">None</span>
        <span class="s1">out.ttinfo_before = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">out.ttinfo_list:</span>
            <span class="s3">if not </span><span class="s1">out.trans_list_utc:</span>
                <span class="s1">out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(timecnt-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s1">tti = out.trans_idx[i]</span>
                    <span class="s3">if not </span><span class="s1">out.ttinfo_std </span><span class="s3">and not </span><span class="s1">tti.isdst:</span>
                        <span class="s1">out.ttinfo_std = tti</span>
                    <span class="s3">elif not </span><span class="s1">out.ttinfo_dst </span><span class="s3">and </span><span class="s1">tti.isdst:</span>
                        <span class="s1">out.ttinfo_dst = tti</span>

                    <span class="s3">if </span><span class="s1">out.ttinfo_std </span><span class="s3">and </span><span class="s1">out.ttinfo_dst:</span>
                        <span class="s3">break</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">out.ttinfo_dst </span><span class="s3">and not </span><span class="s1">out.ttinfo_std:</span>
                        <span class="s1">out.ttinfo_std = out.ttinfo_dst</span>

                <span class="s3">for </span><span class="s1">tti </span><span class="s3">in </span><span class="s1">out.ttinfo_list:</span>
                    <span class="s3">if not </span><span class="s1">tti.isdst:</span>
                        <span class="s1">out.ttinfo_before = tti</span>
                        <span class="s3">break</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">out.ttinfo_before = out.ttinfo_list[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0"># Now fix transition times to become relative to wall time.</span>
        <span class="s0">#</span>
        <span class="s0"># I'm not sure about this. In my tests, the tz source file</span>
        <span class="s0"># is setup to wall time, and in the binary file isstd and</span>
        <span class="s0"># isgmt are off, so it should be in wall time. OTOH, it's</span>
        <span class="s0"># always in gmt time. Let me know if you have comments</span>
        <span class="s0"># about this.</span>
        <span class="s1">lastdst = </span><span class="s3">None</span>
        <span class="s1">lastoffset = </span><span class="s3">None</span>
        <span class="s1">lastdstoffset = </span><span class="s3">None</span>
        <span class="s1">lastbaseoffset = </span><span class="s3">None</span>
        <span class="s1">out.trans_list = []</span>

        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">tti </span><span class="s3">in </span><span class="s1">enumerate(out.trans_idx):</span>
            <span class="s1">offset = tti.offset</span>
            <span class="s1">dstoffset = </span><span class="s4">0</span>

            <span class="s3">if </span><span class="s1">lastdst </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">tti.isdst:</span>
                    <span class="s3">if not </span><span class="s1">lastdst:</span>
                        <span class="s1">dstoffset = offset - lastoffset</span>

                    <span class="s3">if not </span><span class="s1">dstoffset </span><span class="s3">and </span><span class="s1">lastdstoffset:</span>
                        <span class="s1">dstoffset = lastdstoffset</span>

                    <span class="s1">tti.dstoffset = datetime.timedelta(seconds=dstoffset)</span>
                    <span class="s1">lastdstoffset = dstoffset</span>

            <span class="s0"># If a time zone changes its base offset during a DST transition,</span>
            <span class="s0"># then you need to adjust by the previous base offset to get the</span>
            <span class="s0"># transition time in local time. Otherwise you use the current</span>
            <span class="s0"># base offset. Ideally, I would have some mathematical proof of</span>
            <span class="s0"># why this is true, but I haven't really thought about it enough.</span>
            <span class="s1">baseoffset = offset - dstoffset</span>
            <span class="s1">adjustment = baseoffset</span>
            <span class="s3">if </span><span class="s1">(lastbaseoffset </span><span class="s3">is not None and </span><span class="s1">baseoffset != lastbaseoffset</span>
                    <span class="s3">and </span><span class="s1">tti.isdst != lastdst):</span>
                <span class="s0"># The base DST has changed</span>
                <span class="s1">adjustment = lastbaseoffset</span>

            <span class="s1">lastdst = tti.isdst</span>
            <span class="s1">lastoffset = offset</span>
            <span class="s1">lastbaseoffset = baseoffset</span>

            <span class="s1">out.trans_list.append(out.trans_list_utc[i] + adjustment)</span>

        <span class="s1">out.trans_idx = tuple(out.trans_idx)</span>
        <span class="s1">out.trans_list = tuple(out.trans_list)</span>
        <span class="s1">out.trans_list_utc = tuple(out.trans_list_utc)</span>

        <span class="s3">return </span><span class="s1">out</span>

    <span class="s3">def </span><span class="s1">_find_last_transition(self</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">in_utc=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># If there's no list, there are no transitions to find</span>
        <span class="s3">if not </span><span class="s1">self._trans_list:</span>
            <span class="s3">return None</span>

        <span class="s1">timestamp = _datetime_to_timestamp(dt)</span>

        <span class="s0"># Find where the timestamp fits in the transition list - if the</span>
        <span class="s0"># timestamp is a transition time, it's part of the &quot;after&quot; period.</span>
        <span class="s1">trans_list = self._trans_list_utc </span><span class="s3">if </span><span class="s1">in_utc </span><span class="s3">else </span><span class="s1">self._trans_list</span>
        <span class="s1">idx = bisect.bisect_right(trans_list</span><span class="s3">, </span><span class="s1">timestamp)</span>

        <span class="s0"># We want to know when the previous transition was, so subtract off 1</span>
        <span class="s3">return </span><span class="s1">idx - </span><span class="s4">1</span>

    <span class="s3">def </span><span class="s1">_get_ttinfo(self</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s0"># For no list or after the last transition, default to _ttinfo_std</span>
        <span class="s3">if </span><span class="s1">idx </span><span class="s3">is None or </span><span class="s1">(idx + </span><span class="s4">1</span><span class="s1">) &gt;= len(self._trans_list):</span>
            <span class="s3">return </span><span class="s1">self._ttinfo_std</span>

        <span class="s0"># If there is a list and the time is before it, return _ttinfo_before</span>
        <span class="s3">if </span><span class="s1">idx &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._ttinfo_before</span>

        <span class="s3">return </span><span class="s1">self._trans_idx[idx]</span>

    <span class="s3">def </span><span class="s1">_find_ttinfo(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s1">idx = self._resolve_ambiguous_time(dt)</span>

        <span class="s3">return </span><span class="s1">self._get_ttinfo(idx)</span>

    <span class="s3">def </span><span class="s1">fromutc(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s2">&quot;&quot;&quot; 
        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`. 
 
        :param dt: 
            A :py:class:`datetime.datetime` object. 
 
        :raises TypeError: 
            Raised if ``dt`` is not a :py:class:`datetime.datetime` object. 
 
        :raises ValueError: 
            Raised if this is called with a ``dt`` which does not have this 
            ``tzinfo`` attached. 
 
        :return: 
            Returns a :py:class:`datetime.datetime` object representing the 
            wall time in ``self``'s time zone. 
        &quot;&quot;&quot;</span>
        <span class="s0"># These isinstance checks are in datetime.tzinfo, so we'll preserve</span>
        <span class="s0"># them, even if we don't care about duck typing.</span>
        <span class="s3">if not </span><span class="s1">isinstance(dt</span><span class="s3">, </span><span class="s1">datetime.datetime):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;fromutc() requires a datetime argument&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">dt.tzinfo </span><span class="s3">is not </span><span class="s1">self:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;dt.tzinfo is not self&quot;</span><span class="s1">)</span>

        <span class="s0"># First treat UTC as wall time and get the transition we're in.</span>
        <span class="s1">idx = self._find_last_transition(dt</span><span class="s3">, </span><span class="s1">in_utc=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">tti = self._get_ttinfo(idx)</span>

        <span class="s1">dt_out = dt + datetime.timedelta(seconds=tti.offset)</span>

        <span class="s1">fold = self.is_ambiguous(dt_out</span><span class="s3">, </span><span class="s1">idx=idx)</span>

        <span class="s3">return </span><span class="s1">enfold(dt_out</span><span class="s3">, </span><span class="s1">fold=int(fold))</span>

    <span class="s3">def </span><span class="s1">is_ambiguous(self</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">idx=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Whether or not the &quot;wall time&quot; of a given datetime is ambiguous in this 
        zone. 
 
        :param dt: 
            A :py:class:`datetime.datetime`, naive or time zone aware. 
 
 
        :return: 
            Returns ``True`` if ambiguous, ``False`` otherwise. 
 
        .. versionadded:: 2.6.0 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">idx </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">idx = self._find_last_transition(dt)</span>

        <span class="s0"># Calculate the difference in offsets from current to previous</span>
        <span class="s1">timestamp = _datetime_to_timestamp(dt)</span>
        <span class="s1">tti = self._get_ttinfo(idx)</span>

        <span class="s3">if </span><span class="s1">idx </span><span class="s3">is None or </span><span class="s1">idx &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return False</span>

        <span class="s1">od = self._get_ttinfo(idx - </span><span class="s4">1</span><span class="s1">).offset - tti.offset</span>
        <span class="s1">tt = self._trans_list[idx]          </span><span class="s0"># Transition time</span>

        <span class="s3">return </span><span class="s1">timestamp &lt; tt + od</span>

    <span class="s3">def </span><span class="s1">_resolve_ambiguous_time(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s1">idx = self._find_last_transition(dt)</span>

        <span class="s0"># If we have no transitions, return the index</span>
        <span class="s1">_fold = self._fold(dt)</span>
        <span class="s3">if </span><span class="s1">idx </span><span class="s3">is None or </span><span class="s1">idx == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">idx</span>

        <span class="s0"># If it's ambiguous and we're in a fold, shift to a different index.</span>
        <span class="s1">idx_offset = int(</span><span class="s3">not </span><span class="s1">_fold </span><span class="s3">and </span><span class="s1">self.is_ambiguous(dt</span><span class="s3">, </span><span class="s1">idx))</span>

        <span class="s3">return </span><span class="s1">idx - idx_offset</span>

    <span class="s3">def </span><span class="s1">utcoffset(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">dt </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s3">if not </span><span class="s1">self._ttinfo_std:</span>
            <span class="s3">return </span><span class="s1">ZERO</span>

        <span class="s3">return </span><span class="s1">self._find_ttinfo(dt).delta</span>

    <span class="s3">def </span><span class="s1">dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">dt </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s3">if not </span><span class="s1">self._ttinfo_dst:</span>
            <span class="s3">return </span><span class="s1">ZERO</span>

        <span class="s1">tti = self._find_ttinfo(dt)</span>

        <span class="s3">if not </span><span class="s1">tti.isdst:</span>
            <span class="s3">return </span><span class="s1">ZERO</span>

        <span class="s0"># The documentation says that utcoffset()-dst() must</span>
        <span class="s0"># be constant for every dt.</span>
        <span class="s3">return </span><span class="s1">tti.dstoffset</span>

    <span class="s1">@tzname_in_python2</span>
    <span class="s3">def </span><span class="s1">tzname(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if not </span><span class="s1">self._ttinfo_std </span><span class="s3">or </span><span class="s1">dt </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._find_ttinfo(dt).abbr</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzfile):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return </span><span class="s1">(self._trans_list == other._trans_list </span><span class="s3">and</span>
                <span class="s1">self._trans_idx == other._trans_idx </span><span class="s3">and</span>
                <span class="s1">self._ttinfo_list == other._ttinfo_list)</span>

    <span class="s1">__hash__ = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self == other)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">repr(self._filename))</span>

    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s3">return </span><span class="s1">self.__reduce_ex__(</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__reduce_ex__(self</span><span class="s3">, </span><span class="s1">protocol):</span>
        <span class="s3">return </span><span class="s1">(self.__class__</span><span class="s3">, </span><span class="s1">(</span><span class="s3">None, </span><span class="s1">self._filename)</span><span class="s3">, </span><span class="s1">self.__dict__)</span>


<span class="s3">class </span><span class="s1">tzrange(tzrangebase):</span>
    <span class="s2">&quot;&quot;&quot; 
    The ``tzrange`` object is a time zone specified by a set of offsets and 
    abbreviations, equivalent to the way the ``TZ`` variable can be specified 
    in POSIX-like systems, but using Python delta objects to specify DST 
    start, end and offsets. 
 
    :param stdabbr: 
        The abbreviation for standard time (e.g. ``'EST'``). 
 
    :param stdoffset: 
        An integer or :class:`datetime.timedelta` object or equivalent 
        specifying the base offset from UTC. 
 
        If unspecified, +00:00 is used. 
 
    :param dstabbr: 
        The abbreviation for DST / &quot;Summer&quot; time (e.g. ``'EDT'``). 
 
        If specified, with no other DST information, DST is assumed to occur 
        and the default behavior or ``dstoffset``, ``start`` and ``end`` is 
        used. If unspecified and no other DST information is specified, it 
        is assumed that this zone has no DST. 
 
        If this is unspecified and other DST information is *is* specified, 
        DST occurs in the zone but the time zone abbreviation is left 
        unchanged. 
 
    :param dstoffset: 
        A an integer or :class:`datetime.timedelta` object or equivalent 
        specifying the UTC offset during DST. If unspecified and any other DST 
        information is specified, it is assumed to be the STD offset +1 hour. 
 
    :param start: 
        A :class:`relativedelta.relativedelta` object or equivalent specifying 
        the time and time of year that daylight savings time starts. To 
        specify, for example, that DST starts at 2AM on the 2nd Sunday in 
        March, pass: 
 
            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))`` 
 
        If unspecified and any other DST information is specified, the default 
        value is 2 AM on the first Sunday in April. 
 
    :param end: 
        A :class:`relativedelta.relativedelta` object or equivalent 
        representing the time and time of year that daylight savings time 
        ends, with the same specification method as in ``start``. One note is 
        that this should point to the first time in the *standard* zone, so if 
        a transition occurs at 2AM in the DST zone and the clocks are set back 
        1 hour to 1AM, set the ``hours`` parameter to +1. 
 
 
    **Examples:** 
 
    .. testsetup:: tzrange 
 
        from dateutil.tz import tzrange, tzstr 
 
    .. doctest:: tzrange 
 
        &gt;&gt;&gt; tzstr('EST5EDT') == tzrange(&quot;EST&quot;, -18000, &quot;EDT&quot;) 
        True 
 
        &gt;&gt;&gt; from dateutil.relativedelta import * 
        &gt;&gt;&gt; range1 = tzrange(&quot;EST&quot;, -18000, &quot;EDT&quot;) 
        &gt;&gt;&gt; range2 = tzrange(&quot;EST&quot;, -18000, &quot;EDT&quot;, -14400, 
        ...                  relativedelta(hours=+2, month=4, day=1, 
        ...                                weekday=SU(+1)), 
        ...                  relativedelta(hours=+1, month=10, day=31, 
        ...                                weekday=SU(-1))) 
        &gt;&gt;&gt; tzstr('EST5EDT') == range1 == range2 
        True 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">stdabbr</span><span class="s3">, </span><span class="s1">stdoffset=</span><span class="s3">None,</span>
                 <span class="s1">dstabbr=</span><span class="s3">None, </span><span class="s1">dstoffset=</span><span class="s3">None,</span>
                 <span class="s1">start=</span><span class="s3">None, </span><span class="s1">end=</span><span class="s3">None</span><span class="s1">):</span>

        <span class="s3">global </span><span class="s1">relativedelta</span>
        <span class="s3">from </span><span class="s1">dateutil </span><span class="s3">import </span><span class="s1">relativedelta</span>

        <span class="s1">self._std_abbr = stdabbr</span>
        <span class="s1">self._dst_abbr = dstabbr</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">stdoffset = stdoffset.total_seconds()</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
            <span class="s3">pass</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">dstoffset = dstoffset.total_seconds()</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
            <span class="s3">pass</span>

        <span class="s3">if </span><span class="s1">stdoffset </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._std_offset = datetime.timedelta(seconds=stdoffset)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._std_offset = ZERO</span>

        <span class="s3">if </span><span class="s1">dstoffset </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._dst_offset = datetime.timedelta(seconds=dstoffset)</span>
        <span class="s3">elif </span><span class="s1">dstabbr </span><span class="s3">and </span><span class="s1">stdoffset </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._dst_offset = self._std_offset + datetime.timedelta(hours=+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._dst_offset = ZERO</span>

        <span class="s3">if </span><span class="s1">dstabbr </span><span class="s3">and </span><span class="s1">start </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self._start_delta = relativedelta.relativedelta(</span>
                <span class="s1">hours=+</span><span class="s4">2</span><span class="s3">, </span><span class="s1">month=</span><span class="s4">4</span><span class="s3">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">weekday=relativedelta.SU(+</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._start_delta = start</span>

        <span class="s3">if </span><span class="s1">dstabbr </span><span class="s3">and </span><span class="s1">end </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self._end_delta = relativedelta.relativedelta(</span>
                <span class="s1">hours=+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">month=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s3">, </span><span class="s1">weekday=relativedelta.SU(-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._end_delta = end</span>

        <span class="s1">self._dst_base_offset_ = self._dst_offset - self._std_offset</span>
        <span class="s1">self.hasdst = bool(self._start_delta)</span>

    <span class="s3">def </span><span class="s1">transitions(self</span><span class="s3">, </span><span class="s1">year):</span>
        <span class="s2">&quot;&quot;&quot; 
        For a given year, get the DST on and off transition times, expressed 
        always on the standard time side. For zones with no transitions, this 
        function returns ``None``. 
 
        :param year: 
            The year whose transitions you would like to query. 
 
        :return: 
            Returns a :class:`tuple` of :class:`datetime.datetime` objects, 
            ``(dston, dstoff)`` for zones with an annual DST transition, or 
            ``None`` for fixed offset zones. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self.hasdst:</span>
            <span class="s3">return None</span>

        <span class="s1">base_year = datetime.datetime(year</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">start = base_year + self._start_delta</span>
        <span class="s1">end = base_year + self._end_delta</span>

        <span class="s3">return </span><span class="s1">(start</span><span class="s3">, </span><span class="s1">end)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tzrange):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">(self._std_abbr == other._std_abbr </span><span class="s3">and</span>
                <span class="s1">self._dst_abbr == other._dst_abbr </span><span class="s3">and</span>
                <span class="s1">self._std_offset == other._std_offset </span><span class="s3">and</span>
                <span class="s1">self._dst_offset == other._dst_offset </span><span class="s3">and</span>
                <span class="s1">self._start_delta == other._start_delta </span><span class="s3">and</span>
                <span class="s1">self._end_delta == other._end_delta)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_dst_base_offset(self):</span>
        <span class="s3">return </span><span class="s1">self._dst_base_offset_</span>


<span class="s1">@six.add_metaclass(_TzStrFactory)</span>
<span class="s3">class </span><span class="s1">tzstr(tzrange):</span>
    <span class="s2">&quot;&quot;&quot; 
    ``tzstr`` objects are time zone objects specified by a time-zone string as 
    it would be passed to a ``TZ`` variable on POSIX-style systems (see 
    the `GNU C Library: TZ Variable`_ for more details). 
 
    There is one notable exception, which is that POSIX-style time zones use an 
    inverted offset format, so normally ``GMT+3`` would be parsed as an offset 
    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an 
    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX 
    behavior, pass a ``True`` value to ``posix_offset``. 
 
    The :class:`tzrange` object provides the same functionality, but is 
    specified using :class:`relativedelta.relativedelta` objects. rather than 
    strings. 
 
    :param s: 
        A time zone string in ``TZ`` variable format. This can be a 
        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x: 
        :class:`unicode`) or a stream emitting unicode characters 
        (e.g. :class:`StringIO`). 
 
    :param posix_offset: 
        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or 
        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the 
        POSIX standard. 
 
    .. caution:: 
 
        Prior to version 2.7.0, this function also supported time zones 
        in the format: 
 
            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600`` 
            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600`` 
 
        This format is non-standard and has been deprecated; this function 
        will raise a :class:`DeprecatedTZFormatWarning` until 
        support is removed in a future version. 
 
    .. _`GNU C Library: TZ Variable`: 
        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">posix_offset=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">global </span><span class="s1">parser</span>
        <span class="s3">from </span><span class="s1">dateutil.parser </span><span class="s3">import </span><span class="s1">_parser </span><span class="s3">as </span><span class="s1">parser</span>

        <span class="s1">self._s = s</span>

        <span class="s1">res = parser._parsetz(s)</span>
        <span class="s3">if </span><span class="s1">res </span><span class="s3">is None or </span><span class="s1">res.any_unused_tokens:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unknown string format&quot;</span><span class="s1">)</span>

        <span class="s0"># Here we break the compatibility with the TZ variable handling.</span>
        <span class="s0"># GMT-3 actually *means* the timezone -3.</span>
        <span class="s3">if </span><span class="s1">res.stdabbr </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;GMT&quot;</span><span class="s3">, </span><span class="s5">&quot;UTC&quot;</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">posix_offset:</span>
            <span class="s1">res.stdoffset *= -</span><span class="s4">1</span>

        <span class="s0"># We must initialize it first, since _delta() needs</span>
        <span class="s0"># _std_offset and _dst_offset set. Use False in start/end</span>
        <span class="s0"># to avoid building it two times.</span>
        <span class="s1">tzrange.__init__(self</span><span class="s3">, </span><span class="s1">res.stdabbr</span><span class="s3">, </span><span class="s1">res.stdoffset</span><span class="s3">,</span>
                         <span class="s1">res.dstabbr</span><span class="s3">, </span><span class="s1">res.dstoffset</span><span class="s3">,</span>
                         <span class="s1">start=</span><span class="s3">False, </span><span class="s1">end=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">res.dstabbr:</span>
            <span class="s1">self._start_delta = </span><span class="s3">None</span>
            <span class="s1">self._end_delta = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._start_delta = self._delta(res.start)</span>
            <span class="s3">if </span><span class="s1">self._start_delta:</span>
                <span class="s1">self._end_delta = self._delta(res.end</span><span class="s3">, </span><span class="s1">isend=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">self.hasdst = bool(self._start_delta)</span>

    <span class="s3">def </span><span class="s1">_delta(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">isend=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s3">from </span><span class="s1">dateutil </span><span class="s3">import </span><span class="s1">relativedelta</span>
        <span class="s1">kwargs = {}</span>
        <span class="s3">if </span><span class="s1">x.month </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;month&quot;</span><span class="s1">] = x.month</span>
            <span class="s3">if </span><span class="s1">x.weekday </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;weekday&quot;</span><span class="s1">] = relativedelta.weekday(x.weekday</span><span class="s3">, </span><span class="s1">x.week)</span>
                <span class="s3">if </span><span class="s1">x.week &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">kwargs[</span><span class="s5">&quot;day&quot;</span><span class="s1">] = </span><span class="s4">1</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">kwargs[</span><span class="s5">&quot;day&quot;</span><span class="s1">] = </span><span class="s4">31</span>
            <span class="s3">elif </span><span class="s1">x.day:</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;day&quot;</span><span class="s1">] = x.day</span>
        <span class="s3">elif </span><span class="s1">x.yday </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;yearday&quot;</span><span class="s1">] = x.yday</span>
        <span class="s3">elif </span><span class="s1">x.jyday </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;nlyearday&quot;</span><span class="s1">] = x.jyday</span>
        <span class="s3">if not </span><span class="s1">kwargs:</span>
            <span class="s0"># Default is to start on first sunday of april, and end</span>
            <span class="s0"># on last sunday of october.</span>
            <span class="s3">if not </span><span class="s1">isend:</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;month&quot;</span><span class="s1">] = </span><span class="s4">4</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;day&quot;</span><span class="s1">] = </span><span class="s4">1</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;weekday&quot;</span><span class="s1">] = relativedelta.SU(+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;month&quot;</span><span class="s1">] = </span><span class="s4">10</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;day&quot;</span><span class="s1">] = </span><span class="s4">31</span>
                <span class="s1">kwargs[</span><span class="s5">&quot;weekday&quot;</span><span class="s1">] = relativedelta.SU(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">x.time </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;seconds&quot;</span><span class="s1">] = x.time</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Default is 2AM.</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;seconds&quot;</span><span class="s1">] = </span><span class="s4">7200</span>
        <span class="s3">if </span><span class="s1">isend:</span>
            <span class="s0"># Convert to standard time, to follow the documented way</span>
            <span class="s0"># of working with the extra hour. See the documentation</span>
            <span class="s0"># of the tzinfo class.</span>
            <span class="s1">delta = self._dst_offset - self._std_offset</span>
            <span class="s1">kwargs[</span><span class="s5">&quot;seconds&quot;</span><span class="s1">] -= delta.seconds + delta.days * </span><span class="s4">86400</span>
        <span class="s3">return </span><span class="s1">relativedelta.relativedelta(**kwargs)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">repr(self._s))</span>


<span class="s3">class </span><span class="s1">_tzicalvtzcomp(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">tzoffsetfrom</span><span class="s3">, </span><span class="s1">tzoffsetto</span><span class="s3">, </span><span class="s1">isdst</span><span class="s3">,</span>
                 <span class="s1">tzname=</span><span class="s3">None, </span><span class="s1">rrule=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)</span>
        <span class="s1">self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)</span>
        <span class="s1">self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom</span>
        <span class="s1">self.isdst = isdst</span>
        <span class="s1">self.tzname = tzname</span>
        <span class="s1">self.rrule = rrule</span>


<span class="s3">class </span><span class="s1">_tzicalvtz(_tzinfo):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">tzid</span><span class="s3">, </span><span class="s1">comps=[]):</span>
        <span class="s1">super(_tzicalvtz</span><span class="s3">, </span><span class="s1">self).__init__()</span>

        <span class="s1">self._tzid = tzid</span>
        <span class="s1">self._comps = comps</span>
        <span class="s1">self._cachedate = []</span>
        <span class="s1">self._cachecomp = []</span>
        <span class="s1">self._cache_lock = _thread.allocate_lock()</span>

    <span class="s3">def </span><span class="s1">_find_comp(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">len(self._comps) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._comps[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">dt = dt.replace(tzinfo=</span><span class="s3">None</span><span class="s1">)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">self._cache_lock:</span>
                <span class="s3">return </span><span class="s1">self._cachecomp[self._cachedate.index(</span>
                    <span class="s1">(dt</span><span class="s3">, </span><span class="s1">self._fold(dt)))]</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">pass</span>

        <span class="s1">lastcompdt = </span><span class="s3">None</span>
        <span class="s1">lastcomp = </span><span class="s3">None</span>

        <span class="s3">for </span><span class="s1">comp </span><span class="s3">in </span><span class="s1">self._comps:</span>
            <span class="s1">compdt = self._find_compdt(comp</span><span class="s3">, </span><span class="s1">dt)</span>

            <span class="s3">if </span><span class="s1">compdt </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">lastcompdt </span><span class="s3">or </span><span class="s1">lastcompdt &lt; compdt):</span>
                <span class="s1">lastcompdt = compdt</span>
                <span class="s1">lastcomp = comp</span>

        <span class="s3">if not </span><span class="s1">lastcomp:</span>
            <span class="s0"># RFC says nothing about what to do when a given</span>
            <span class="s0"># time is before the first onset date. We'll look for the</span>
            <span class="s0"># first standard component, or the first component, if</span>
            <span class="s0"># none is found.</span>
            <span class="s3">for </span><span class="s1">comp </span><span class="s3">in </span><span class="s1">self._comps:</span>
                <span class="s3">if not </span><span class="s1">comp.isdst:</span>
                    <span class="s1">lastcomp = comp</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">lastcomp = comp[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s3">with </span><span class="s1">self._cache_lock:</span>
            <span class="s1">self._cachedate.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">(dt</span><span class="s3">, </span><span class="s1">self._fold(dt)))</span>
            <span class="s1">self._cachecomp.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">lastcomp)</span>

            <span class="s3">if </span><span class="s1">len(self._cachedate) &gt; </span><span class="s4">10</span><span class="s1">:</span>
                <span class="s1">self._cachedate.pop()</span>
                <span class="s1">self._cachecomp.pop()</span>

        <span class="s3">return </span><span class="s1">lastcomp</span>

    <span class="s3">def </span><span class="s1">_find_compdt(self</span><span class="s3">, </span><span class="s1">comp</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">comp.tzoffsetdiff &lt; ZERO </span><span class="s3">and </span><span class="s1">self._fold(dt):</span>
            <span class="s1">dt -= comp.tzoffsetdiff</span>

        <span class="s1">compdt = comp.rrule.before(dt</span><span class="s3">, </span><span class="s1">inc=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">compdt</span>

    <span class="s3">def </span><span class="s1">utcoffset(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">if </span><span class="s1">dt </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s3">return </span><span class="s1">self._find_comp(dt).tzoffsetto</span>

    <span class="s3">def </span><span class="s1">dst(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s1">comp = self._find_comp(dt)</span>
        <span class="s3">if </span><span class="s1">comp.isdst:</span>
            <span class="s3">return </span><span class="s1">comp.tzoffsetdiff</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ZERO</span>

    <span class="s1">@tzname_in_python2</span>
    <span class="s3">def </span><span class="s1">tzname(self</span><span class="s3">, </span><span class="s1">dt):</span>
        <span class="s3">return </span><span class="s1">self._find_comp(dt).tzname</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;&lt;tzicalvtz %s&gt;&quot; </span><span class="s1">% repr(self._tzid)</span>

    <span class="s1">__reduce__ = object.__reduce__</span>


<span class="s3">class </span><span class="s1">tzical(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure 
    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects. 
 
    :param `fileobj`: 
        A file or stream in iCalendar format, which should be UTF-8 encoded 
        with CRLF endings. 
 
    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fileobj):</span>
        <span class="s3">global </span><span class="s1">rrule</span>
        <span class="s3">from </span><span class="s1">dateutil </span><span class="s3">import </span><span class="s1">rrule</span>

        <span class="s3">if </span><span class="s1">isinstance(fileobj</span><span class="s3">, </span><span class="s1">string_types):</span>
            <span class="s1">self._s = fileobj</span>
            <span class="s0"># ical should be encoded in UTF-8 with CRLF</span>
            <span class="s1">fileobj = open(fileobj</span><span class="s3">, </span><span class="s5">'r'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._s = getattr(fileobj</span><span class="s3">, </span><span class="s5">'name'</span><span class="s3">, </span><span class="s1">repr(fileobj))</span>
            <span class="s1">fileobj = _nullcontext(fileobj)</span>

        <span class="s1">self._vtz = {}</span>

        <span class="s3">with </span><span class="s1">fileobj </span><span class="s3">as </span><span class="s1">fobj:</span>
            <span class="s1">self._parse_rfc(fobj.read())</span>

    <span class="s3">def </span><span class="s1">keys(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieves the available time zones as a list. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">list(self._vtz.keys())</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">tzid=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``. 
 
        :param tzid: 
            If there is exactly one time zone available, omitting ``tzid`` 
            or passing :py:const:`None` value returns it. Otherwise a valid 
            key (which can be retrieved from :func:`keys`) is required. 
 
        :raises ValueError: 
            Raised if ``tzid`` is not specified but there are either more 
            or fewer than 1 zone defined. 
 
        :returns: 
            Returns either a :py:class:`datetime.tzinfo` object representing 
            the relevant time zone or :py:const:`None` if the ``tzid`` was 
            not found. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">tzid </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">len(self._vtz) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;no timezones defined&quot;</span><span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">len(self._vtz) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;more than one timezone available&quot;</span><span class="s1">)</span>
            <span class="s1">tzid = next(iter(self._vtz))</span>

        <span class="s3">return </span><span class="s1">self._vtz.get(tzid)</span>

    <span class="s3">def </span><span class="s1">_parse_offset(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s1">s = s.strip()</span>
        <span class="s3">if not </span><span class="s1">s:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;empty offset&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">s[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'+'</span><span class="s3">, </span><span class="s5">'-'</span><span class="s1">):</span>
            <span class="s1">signal = (-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">+</span><span class="s4">1</span><span class="s1">)[s[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'+'</span><span class="s1">]</span>
            <span class="s1">s = s[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">signal = +</span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">len(s) == </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(int(s[:</span><span class="s4">2</span><span class="s1">]) * </span><span class="s4">3600 </span><span class="s1">+ int(s[</span><span class="s4">2</span><span class="s1">:]) * </span><span class="s4">60</span><span class="s1">) * signal</span>
        <span class="s3">elif </span><span class="s1">len(s) == </span><span class="s4">6</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(int(s[:</span><span class="s4">2</span><span class="s1">]) * </span><span class="s4">3600 </span><span class="s1">+ int(s[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">4</span><span class="s1">]) * </span><span class="s4">60 </span><span class="s1">+ int(s[</span><span class="s4">4</span><span class="s1">:])) * signal</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;invalid offset: &quot; </span><span class="s1">+ s)</span>

    <span class="s3">def </span><span class="s1">_parse_rfc(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s1">lines = s.splitlines()</span>
        <span class="s3">if not </span><span class="s1">lines:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;empty string&quot;</span><span class="s1">)</span>

        <span class="s0"># Unfold</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s3">while </span><span class="s1">i &lt; len(lines):</span>
            <span class="s1">line = lines[i].rstrip()</span>
            <span class="s3">if not </span><span class="s1">line:</span>
                <span class="s3">del </span><span class="s1">lines[i]</span>
            <span class="s3">elif </span><span class="s1">i &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">line[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">&quot; &quot;</span><span class="s1">:</span>
                <span class="s1">lines[i-</span><span class="s4">1</span><span class="s1">] += line[</span><span class="s4">1</span><span class="s1">:]</span>
                <span class="s3">del </span><span class="s1">lines[i]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">i += </span><span class="s4">1</span>

        <span class="s1">tzid = </span><span class="s3">None</span>
        <span class="s1">comps = []</span>
        <span class="s1">invtz = </span><span class="s3">False</span>
        <span class="s1">comptype = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines:</span>
            <span class="s3">if not </span><span class="s1">line:</span>
                <span class="s3">continue</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s5">':'</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">parms = name.split(</span><span class="s5">';'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">parms:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;empty property name&quot;</span><span class="s1">)</span>
            <span class="s1">name = parms[</span><span class="s4">0</span><span class="s1">].upper()</span>
            <span class="s1">parms = parms[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s3">if </span><span class="s1">invtz:</span>
                <span class="s3">if </span><span class="s1">name == </span><span class="s5">&quot;BEGIN&quot;</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;STANDARD&quot;</span><span class="s3">, </span><span class="s5">&quot;DAYLIGHT&quot;</span><span class="s1">):</span>
                        <span class="s0"># Process component</span>
                        <span class="s3">pass</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unknown component: &quot;</span><span class="s1">+value)</span>
                    <span class="s1">comptype = value</span>
                    <span class="s1">founddtstart = </span><span class="s3">False</span>
                    <span class="s1">tzoffsetfrom = </span><span class="s3">None</span>
                    <span class="s1">tzoffsetto = </span><span class="s3">None</span>
                    <span class="s1">rrulelines = []</span>
                    <span class="s1">tzname = </span><span class="s3">None</span>
                <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;END&quot;</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">value == </span><span class="s5">&quot;VTIMEZONE&quot;</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">comptype:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;component not closed: &quot;</span><span class="s1">+comptype)</span>
                        <span class="s3">if not </span><span class="s1">tzid:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;mandatory TZID not found&quot;</span><span class="s1">)</span>
                        <span class="s3">if not </span><span class="s1">comps:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;at least one component is needed&quot;</span><span class="s1">)</span>
                        <span class="s0"># Process vtimezone</span>
                        <span class="s1">self._vtz[tzid] = _tzicalvtz(tzid</span><span class="s3">, </span><span class="s1">comps)</span>
                        <span class="s1">invtz = </span><span class="s3">False</span>
                    <span class="s3">elif </span><span class="s1">value == comptype:</span>
                        <span class="s3">if not </span><span class="s1">founddtstart:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;mandatory DTSTART not found&quot;</span><span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">tzoffsetfrom </span><span class="s3">is None</span><span class="s1">:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;mandatory TZOFFSETFROM not found&quot;</span><span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">tzoffsetto </span><span class="s3">is None</span><span class="s1">:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;mandatory TZOFFSETFROM not found&quot;</span><span class="s1">)</span>
                        <span class="s0"># Process component</span>
                        <span class="s1">rr = </span><span class="s3">None</span>
                        <span class="s3">if </span><span class="s1">rrulelines:</span>
                            <span class="s1">rr = rrule.rrulestr(</span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join(rrulelines)</span><span class="s3">,</span>
                                                <span class="s1">compatible=</span><span class="s3">True,</span>
                                                <span class="s1">ignoretz=</span><span class="s3">True,</span>
                                                <span class="s1">cache=</span><span class="s3">True</span><span class="s1">)</span>
                        <span class="s1">comp = _tzicalvtzcomp(tzoffsetfrom</span><span class="s3">, </span><span class="s1">tzoffsetto</span><span class="s3">,</span>
                                              <span class="s1">(comptype == </span><span class="s5">&quot;DAYLIGHT&quot;</span><span class="s1">)</span><span class="s3">,</span>
                                              <span class="s1">tzname</span><span class="s3">, </span><span class="s1">rr)</span>
                        <span class="s1">comps.append(comp)</span>
                        <span class="s1">comptype = </span><span class="s3">None</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;invalid component end: &quot;</span><span class="s1">+value)</span>
                <span class="s3">elif </span><span class="s1">comptype:</span>
                    <span class="s3">if </span><span class="s1">name == </span><span class="s5">&quot;DTSTART&quot;</span><span class="s1">:</span>
                        <span class="s0"># DTSTART in VTIMEZONE takes a subset of valid RRULE</span>
                        <span class="s0"># values under RFC 5545.</span>
                        <span class="s3">for </span><span class="s1">parm </span><span class="s3">in </span><span class="s1">parms:</span>
                            <span class="s3">if </span><span class="s1">parm != </span><span class="s5">'VALUE=DATE-TIME'</span><span class="s1">:</span>
                                <span class="s1">msg = (</span><span class="s5">'Unsupported DTSTART param in ' </span><span class="s1">+</span>
                                       <span class="s5">'VTIMEZONE: ' </span><span class="s1">+ parm)</span>
                                <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
                        <span class="s1">rrulelines.append(line)</span>
                        <span class="s1">founddtstart = </span><span class="s3">True</span>
                    <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;RRULE&quot;</span><span class="s3">, </span><span class="s5">&quot;RDATE&quot;</span><span class="s3">, </span><span class="s5">&quot;EXRULE&quot;</span><span class="s3">, </span><span class="s5">&quot;EXDATE&quot;</span><span class="s1">):</span>
                        <span class="s1">rrulelines.append(line)</span>
                    <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;TZOFFSETFROM&quot;</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">parms:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;unsupported %s parm: %s &quot; </span><span class="s1">% (name</span><span class="s3">, </span><span class="s1">parms[</span><span class="s4">0</span><span class="s1">]))</span>
                        <span class="s1">tzoffsetfrom = self._parse_offset(value)</span>
                    <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;TZOFFSETTO&quot;</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">parms:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;unsupported TZOFFSETTO parm: &quot;</span><span class="s1">+parms[</span><span class="s4">0</span><span class="s1">])</span>
                        <span class="s1">tzoffsetto = self._parse_offset(value)</span>
                    <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;TZNAME&quot;</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">parms:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;unsupported TZNAME parm: &quot;</span><span class="s1">+parms[</span><span class="s4">0</span><span class="s1">])</span>
                        <span class="s1">tzname = value</span>
                    <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;COMMENT&quot;</span><span class="s1">:</span>
                        <span class="s3">pass</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unsupported property: &quot;</span><span class="s1">+name)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">name == </span><span class="s5">&quot;TZID&quot;</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">parms:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;unsupported TZID parm: &quot;</span><span class="s1">+parms[</span><span class="s4">0</span><span class="s1">])</span>
                        <span class="s1">tzid = value</span>
                    <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;TZURL&quot;</span><span class="s3">, </span><span class="s5">&quot;LAST-MODIFIED&quot;</span><span class="s3">, </span><span class="s5">&quot;COMMENT&quot;</span><span class="s1">):</span>
                        <span class="s3">pass</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unsupported property: &quot;</span><span class="s1">+name)</span>
            <span class="s3">elif </span><span class="s1">name == </span><span class="s5">&quot;BEGIN&quot; </span><span class="s3">and </span><span class="s1">value == </span><span class="s5">&quot;VTIMEZONE&quot;</span><span class="s1">:</span>
                <span class="s1">tzid = </span><span class="s3">None</span>
                <span class="s1">comps = []</span>
                <span class="s1">invtz = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">repr(self._s))</span>


<span class="s3">if </span><span class="s1">sys.platform != </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
    <span class="s1">TZFILES = [</span><span class="s5">&quot;/etc/localtime&quot;</span><span class="s3">, </span><span class="s5">&quot;localtime&quot;</span><span class="s1">]</span>
    <span class="s1">TZPATHS = [</span><span class="s5">&quot;/usr/share/zoneinfo&quot;</span><span class="s3">,</span>
               <span class="s5">&quot;/usr/lib/zoneinfo&quot;</span><span class="s3">,</span>
               <span class="s5">&quot;/usr/share/lib/zoneinfo&quot;</span><span class="s3">,</span>
               <span class="s5">&quot;/etc/zoneinfo&quot;</span><span class="s1">]</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">TZFILES = []</span>
    <span class="s1">TZPATHS = []</span>


<span class="s3">def </span><span class="s1">__get_gettz():</span>
    <span class="s1">tzlocal_classes = (tzlocal</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">tzwinlocal </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">tzlocal_classes += (tzwinlocal</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">class </span><span class="s1">GettzFunc(object):</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieve a time zone object from a string representation 
 
        This function is intended to retrieve the :py:class:`tzinfo` subclass 
        that best represents the time zone that would be used if a POSIX 
        `TZ variable`_ were set to the same value. 
 
        If no argument or an empty string is passed to ``gettz``, local time 
        is returned: 
 
        .. code-block:: python3 
 
            &gt;&gt;&gt; gettz() 
            tzfile('/etc/localtime') 
 
        This function is also the preferred way to map IANA tz database keys 
        to :class:`tzfile` objects: 
 
        .. code-block:: python3 
 
            &gt;&gt;&gt; gettz('Pacific/Kiritimati') 
            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati') 
 
        On Windows, the standard is extended to include the Windows-specific 
        zone names provided by the operating system: 
 
        .. code-block:: python3 
 
            &gt;&gt;&gt; gettz('Egypt Standard Time') 
            tzwin('Egypt Standard Time') 
 
        Passing a GNU ``TZ`` style string time zone specification returns a 
        :class:`tzstr` object: 
 
        .. code-block:: python3 
 
            &gt;&gt;&gt; gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3') 
            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3') 
 
        :param name: 
            A time zone name (IANA, or, on Windows, Windows keys), location of 
            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone 
            specifier. An empty string, no argument or ``None`` is interpreted 
            as local time. 
 
        :return: 
            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo` 
            subclasses. 
 
        .. versionchanged:: 2.7.0 
 
            After version 2.7.0, any two calls to ``gettz`` using the same 
            input strings will return the same object: 
 
            .. code-block:: python3 
 
                &gt;&gt;&gt; tz.gettz('America/Chicago') is tz.gettz('America/Chicago') 
                True 
 
            In addition to improving performance, this ensures that 
            `&quot;same zone&quot; semantics`_ are used for datetimes in the same zone. 
 
 
        .. _`TZ variable`: 
            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html 
 
        .. _`&quot;same zone&quot; semantics`: 
            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">__init__(self):</span>

            <span class="s1">self.__instances = weakref.WeakValueDictionary()</span>
            <span class="s1">self.__strong_cache_size = </span><span class="s4">8</span>
            <span class="s1">self.__strong_cache = OrderedDict()</span>
            <span class="s1">self._cache_lock = _thread.allocate_lock()</span>

        <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">self._cache_lock:</span>
                <span class="s1">rv = self.__instances.get(name</span><span class="s3">, None</span><span class="s1">)</span>

                <span class="s3">if </span><span class="s1">rv </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">rv = self.nocache(name=name)</span>
                    <span class="s3">if not </span><span class="s1">(name </span><span class="s3">is None</span>
                            <span class="s3">or </span><span class="s1">isinstance(rv</span><span class="s3">, </span><span class="s1">tzlocal_classes)</span>
                            <span class="s3">or </span><span class="s1">rv </span><span class="s3">is None</span><span class="s1">):</span>
                        <span class="s0"># tzlocal is slightly more complicated than the other</span>
                        <span class="s0"># time zone providers because it depends on environment</span>
                        <span class="s0"># at construction time, so don't cache that.</span>
                        <span class="s0">#</span>
                        <span class="s0"># We also cannot store weak references to None, so we</span>
                        <span class="s0"># will also not store that.</span>
                        <span class="s1">self.__instances[name] = rv</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s0"># No need for strong caching, return immediately</span>
                        <span class="s3">return </span><span class="s1">rv</span>

                <span class="s1">self.__strong_cache[name] = self.__strong_cache.pop(name</span><span class="s3">, </span><span class="s1">rv)</span>

                <span class="s3">if </span><span class="s1">len(self.__strong_cache) &gt; self.__strong_cache_size:</span>
                    <span class="s1">self.__strong_cache.popitem(last=</span><span class="s3">False</span><span class="s1">)</span>

            <span class="s3">return </span><span class="s1">rv</span>

        <span class="s3">def </span><span class="s1">set_cache_size(self</span><span class="s3">, </span><span class="s1">size):</span>
            <span class="s3">with </span><span class="s1">self._cache_lock:</span>
                <span class="s1">self.__strong_cache_size = size</span>
                <span class="s3">while </span><span class="s1">len(self.__strong_cache) &gt; size:</span>
                    <span class="s1">self.__strong_cache.popitem(last=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">def </span><span class="s1">cache_clear(self):</span>
            <span class="s3">with </span><span class="s1">self._cache_lock:</span>
                <span class="s1">self.__instances = weakref.WeakValueDictionary()</span>
                <span class="s1">self.__strong_cache.clear()</span>

        <span class="s1">@staticmethod</span>
        <span class="s3">def </span><span class="s1">nocache(name=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s2">&quot;&quot;&quot;A non-cached version of gettz&quot;&quot;&quot;</span>
            <span class="s1">tz = </span><span class="s3">None</span>
            <span class="s3">if not </span><span class="s1">name:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">name = os.environ[</span><span class="s5">&quot;TZ&quot;</span><span class="s1">]</span>
                <span class="s3">except </span><span class="s1">KeyError:</span>
                    <span class="s3">pass</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">is None or </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;&quot;</span><span class="s3">, </span><span class="s5">&quot;:&quot;</span><span class="s1">):</span>
                <span class="s3">for </span><span class="s1">filepath </span><span class="s3">in </span><span class="s1">TZFILES:</span>
                    <span class="s3">if not </span><span class="s1">os.path.isabs(filepath):</span>
                        <span class="s1">filename = filepath</span>
                        <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">TZPATHS:</span>
                            <span class="s1">filepath = os.path.join(path</span><span class="s3">, </span><span class="s1">filename)</span>
                            <span class="s3">if </span><span class="s1">os.path.isfile(filepath):</span>
                                <span class="s3">break</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s3">continue</span>
                    <span class="s3">if </span><span class="s1">os.path.isfile(filepath):</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">tz = tzfile(filepath)</span>
                            <span class="s3">break</span>
                        <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">ValueError):</span>
                            <span class="s3">pass</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">tz = tzlocal()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">name.startswith(</span><span class="s5">&quot;:&quot;</span><span class="s1">):</span>
                        <span class="s1">name = name[</span><span class="s4">1</span><span class="s1">:]</span>
                <span class="s3">except </span><span class="s1">TypeError </span><span class="s3">as </span><span class="s1">e:</span>
                    <span class="s3">if </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">bytes):</span>
                        <span class="s1">new_msg = </span><span class="s5">&quot;gettz argument should be str, not bytes&quot;</span>
                        <span class="s1">six.raise_from(TypeError(new_msg)</span><span class="s3">, </span><span class="s1">e)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                <span class="s3">if </span><span class="s1">os.path.isabs(name):</span>
                    <span class="s3">if </span><span class="s1">os.path.isfile(name):</span>
                        <span class="s1">tz = tzfile(name)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">tz = </span><span class="s3">None</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">TZPATHS:</span>
                        <span class="s1">filepath = os.path.join(path</span><span class="s3">, </span><span class="s1">name)</span>
                        <span class="s3">if not </span><span class="s1">os.path.isfile(filepath):</span>
                            <span class="s1">filepath = filepath.replace(</span><span class="s5">' '</span><span class="s3">, </span><span class="s5">'_'</span><span class="s1">)</span>
                            <span class="s3">if not </span><span class="s1">os.path.isfile(filepath):</span>
                                <span class="s3">continue</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">tz = tzfile(filepath)</span>
                            <span class="s3">break</span>
                        <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">ValueError):</span>
                            <span class="s3">pass</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">tz = </span><span class="s3">None</span>
                        <span class="s3">if </span><span class="s1">tzwin </span><span class="s3">is not None</span><span class="s1">:</span>
                            <span class="s3">try</span><span class="s1">:</span>
                                <span class="s1">tz = tzwin(name)</span>
                            <span class="s3">except </span><span class="s1">(WindowsError</span><span class="s3">, </span><span class="s1">UnicodeEncodeError):</span>
                                <span class="s0"># UnicodeEncodeError is for Python 2.7 compat</span>
                                <span class="s1">tz = </span><span class="s3">None</span>

                        <span class="s3">if not </span><span class="s1">tz:</span>
                            <span class="s3">from </span><span class="s1">dateutil.zoneinfo </span><span class="s3">import </span><span class="s1">get_zonefile_instance</span>
                            <span class="s1">tz = get_zonefile_instance().get(name)</span>

                        <span class="s3">if not </span><span class="s1">tz:</span>
                            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">name:</span>
                                <span class="s0"># name is not a tzstr unless it has at least</span>
                                <span class="s0"># one offset. For short values of &quot;name&quot;, an</span>
                                <span class="s0"># explicit for loop seems to be the fastest way</span>
                                <span class="s0"># To determine if a string contains a digit</span>
                                <span class="s3">if </span><span class="s1">c </span><span class="s3">in </span><span class="s5">&quot;0123456789&quot;</span><span class="s1">:</span>
                                    <span class="s3">try</span><span class="s1">:</span>
                                        <span class="s1">tz = tzstr(name)</span>
                                    <span class="s3">except </span><span class="s1">ValueError:</span>
                                        <span class="s3">pass</span>
                                    <span class="s3">break</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;GMT&quot;</span><span class="s3">, </span><span class="s5">&quot;UTC&quot;</span><span class="s1">):</span>
                                    <span class="s1">tz = UTC</span>
                                <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">time.tzname:</span>
                                    <span class="s1">tz = tzlocal()</span>
            <span class="s3">return </span><span class="s1">tz</span>

    <span class="s3">return </span><span class="s1">GettzFunc()</span>


<span class="s1">gettz = __get_gettz()</span>
<span class="s3">del </span><span class="s1">__get_gettz</span>


<span class="s3">def </span><span class="s1">datetime_exists(dt</span><span class="s3">, </span><span class="s1">tz=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Given a datetime and a time zone, determine whether or not a given datetime 
    would fall in a gap. 
 
    :param dt: 
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz`` 
        is provided.) 
 
    :param tz: 
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If 
        ``None`` or not provided, the datetime's own time zone will be used. 
 
    :return: 
        Returns a boolean value whether or not the &quot;wall time&quot; exists in 
        ``tz``. 
 
    .. versionadded:: 2.7.0 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">tz </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">dt.tzinfo </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Datetime is naive and no time zone provided.'</span><span class="s1">)</span>
        <span class="s1">tz = dt.tzinfo</span>

    <span class="s1">dt = dt.replace(tzinfo=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s0"># This is essentially a test of whether or not the datetime can survive</span>
    <span class="s0"># a round trip to UTC.</span>
    <span class="s1">dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)</span>
    <span class="s1">dt_rt = dt_rt.replace(tzinfo=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">dt == dt_rt</span>


<span class="s3">def </span><span class="s1">datetime_ambiguous(dt</span><span class="s3">, </span><span class="s1">tz=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Given a datetime and a time zone, determine whether or not a given datetime 
    is ambiguous (i.e if there are two times differentiated only by their DST 
    status). 
 
    :param dt: 
        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz`` 
        is provided.) 
 
    :param tz: 
        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If 
        ``None`` or not provided, the datetime's own time zone will be used. 
 
    :return: 
        Returns a boolean value whether or not the &quot;wall time&quot; is ambiguous in 
        ``tz``. 
 
    .. versionadded:: 2.6.0 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">tz </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">dt.tzinfo </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Datetime is naive and no time zone provided.'</span><span class="s1">)</span>

        <span class="s1">tz = dt.tzinfo</span>

    <span class="s0"># If a time zone defines its own &quot;is_ambiguous&quot; function, we'll use that.</span>
    <span class="s1">is_ambiguous_fn = getattr(tz</span><span class="s3">, </span><span class="s5">'is_ambiguous'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">is_ambiguous_fn </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tz.is_ambiguous(dt)</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>

    <span class="s0"># If it doesn't come out and tell us it's ambiguous, we'll just check if</span>
    <span class="s0"># the fold attribute has any effect on this particular date and time.</span>
    <span class="s1">dt = dt.replace(tzinfo=tz)</span>
    <span class="s1">wall_0 = enfold(dt</span><span class="s3">, </span><span class="s1">fold=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">wall_1 = enfold(dt</span><span class="s3">, </span><span class="s1">fold=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">same_offset = wall_0.utcoffset() == wall_1.utcoffset()</span>
    <span class="s1">same_dst = wall_0.dst() == wall_1.dst()</span>

    <span class="s3">return not </span><span class="s1">(same_offset </span><span class="s3">and </span><span class="s1">same_dst)</span>


<span class="s3">def </span><span class="s1">resolve_imaginary(dt):</span>
    <span class="s2">&quot;&quot;&quot; 
    Given a datetime that may be imaginary, return an existing datetime. 
 
    This function assumes that an imaginary datetime represents what the 
    wall time would be in a zone had the offset transition not occurred, so 
    it will always fall forward by the transition's change in offset. 
 
    .. doctest:: 
 
        &gt;&gt;&gt; from dateutil import tz 
        &gt;&gt;&gt; from datetime import datetime 
        &gt;&gt;&gt; NYC = tz.gettz('America/New_York') 
        &gt;&gt;&gt; print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC))) 
        2017-03-12 03:30:00-04:00 
 
        &gt;&gt;&gt; KIR = tz.gettz('Pacific/Kiritimati') 
        &gt;&gt;&gt; print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR))) 
        1995-01-02 12:30:00+14:00 
 
    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid, 
    existing datetime, so a round-trip to and from UTC is sufficient to get 
    an extant datetime, however, this generally &quot;falls back&quot; to an earlier time 
    rather than falling forward to the STD side (though no guarantees are made 
    about this behavior). 
 
    :param dt: 
        A :class:`datetime.datetime` which may or may not exist. 
 
    :return: 
        Returns an existing :class:`datetime.datetime`. If ``dt`` was not 
        imaginary, the datetime returned is guaranteed to be the same object 
        passed to the function. 
 
    .. versionadded:: 2.7.0 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">dt.tzinfo </span><span class="s3">is not None and not </span><span class="s1">datetime_exists(dt):</span>

        <span class="s1">curr_offset = (dt + datetime.timedelta(hours=</span><span class="s4">24</span><span class="s1">)).utcoffset()</span>
        <span class="s1">old_offset = (dt - datetime.timedelta(hours=</span><span class="s4">24</span><span class="s1">)).utcoffset()</span>

        <span class="s1">dt += curr_offset - old_offset</span>

    <span class="s3">return </span><span class="s1">dt</span>


<span class="s3">def </span><span class="s1">_datetime_to_timestamp(dt):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a :class:`datetime.datetime` object to an epoch timestamp in 
    seconds since January 1, 1970, ignoring the time zone. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">(dt.replace(tzinfo=</span><span class="s3">None</span><span class="s1">) - EPOCH).total_seconds()</span>


<span class="s3">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">6</span><span class="s1">):</span>
    <span class="s3">def </span><span class="s1">_get_supported_offset(second_offset):</span>
        <span class="s3">return </span><span class="s1">second_offset</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">_get_supported_offset(second_offset):</span>
        <span class="s0"># For python pre-3.6, round to full-minutes if that's not the case.</span>
        <span class="s0"># Python's datetime doesn't accept sub-minute timezones. Check</span>
        <span class="s0"># http://python.org/sf/1447945 or https://bugs.python.org/issue5288</span>
        <span class="s0"># for some information.</span>
        <span class="s1">old_offset = second_offset</span>
        <span class="s1">calculated_offset = </span><span class="s4">60 </span><span class="s1">* ((second_offset + </span><span class="s4">30</span><span class="s1">) // </span><span class="s4">60</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">calculated_offset</span>


<span class="s3">try</span><span class="s1">:</span>
    <span class="s0"># Python 3.7 feature</span>
    <span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">nullcontext </span><span class="s3">as </span><span class="s1">_nullcontext</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">class </span><span class="s1">_nullcontext(object):</span>
        <span class="s2">&quot;&quot;&quot; 
        Class for wrapping contexts so that they are passed through in a 
        with statement. 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">context):</span>
            <span class="s1">self.context = context</span>

        <span class="s3">def </span><span class="s1">__enter__(self):</span>
            <span class="s3">return </span><span class="s1">self.context</span>

        <span class="s3">def </span><span class="s1">__exit__(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s3">pass</span>

<span class="s0"># vim:ts=4:sw=4:et</span>
</pre>
</body>
</html>