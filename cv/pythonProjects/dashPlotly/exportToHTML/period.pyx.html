<html>
<head>
<title>period.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
period.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import warnings</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">Py_NE,</span>
    <span class="s0">PyObject_RichCompare,</span>
    <span class="s0">PyObject_RichCompareBool,</span>
<span class="s0">)</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">import numpy as np</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from libc.stdlib cimport (</span>
    <span class="s0">free,</span>
    <span class="s0">malloc,</span>
<span class="s0">)</span>
<span class="s0">from libc.string cimport (</span>
    <span class="s0">memset,</span>
    <span class="s0">strlen,</span>
<span class="s0">)</span>
<span class="s0">from libc.time cimport (</span>
    <span class="s0">strftime,</span>
    <span class="s0">tm,</span>
<span class="s0">)</span>

<span class="s0">import cython</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">datetime,</span>
<span class="s0">)</span>

<span class="s0"># import datetime C API</span>
<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">NPY_DATETIMEUNIT,</span>
    <span class="s0">NPY_FR_D,</span>
    <span class="s0">NPY_FR_us,</span>
    <span class="s0">check_dts_bounds,</span>
    <span class="s0">dt64_to_dtstruct,</span>
    <span class="s0">dtstruct_to_dt64,</span>
    <span class="s0">npy_datetimestruct,</span>
    <span class="s0">pandas_datetime_to_datetimestruct,</span>
<span class="s0">)</span>


<span class="s0">cdef extern from &quot;src/datetime/np_datetime.h&quot;:</span>
    <span class="s0">int64_t npy_datetimestruct_to_datetime(NPY_DATETIMEUNIT fr,</span>
                                           <span class="s0">npy_datetimestruct *d) nogil</span>

<span class="s0">cimport pandas._libs.tslibs.util as util</span>

<span class="s0">from pandas._libs.tslibs.timedeltas import Timedelta</span>
<span class="s0">from pandas._libs.tslibs.timestamps import Timestamp</span>

<span class="s0">from pandas._libs.tslibs.ccalendar cimport (</span>
    <span class="s0">c_MONTH_NUMBERS,</span>
    <span class="s0">dayofweek,</span>
    <span class="s0">get_day_of_year,</span>
    <span class="s0">get_days_in_month,</span>
    <span class="s0">get_week_of_year,</span>
    <span class="s0">is_leapyear,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.timedeltas cimport (</span>
    <span class="s0">delta_to_nanoseconds,</span>
    <span class="s0">is_any_td_scalar,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.conversion import ensure_datetime64ns</span>

<span class="s0">from pandas._libs.tslibs.dtypes cimport (</span>
    <span class="s0">FR_ANN,</span>
    <span class="s0">FR_BUS,</span>
    <span class="s0">FR_DAY,</span>
    <span class="s0">FR_HR,</span>
    <span class="s0">FR_MIN,</span>
    <span class="s0">FR_MS,</span>
    <span class="s0">FR_MTH,</span>
    <span class="s0">FR_NS,</span>
    <span class="s0">FR_QTR,</span>
    <span class="s0">FR_SEC,</span>
    <span class="s0">FR_UND,</span>
    <span class="s0">FR_US,</span>
    <span class="s0">FR_WK,</span>
    <span class="s0">PeriodDtypeBase,</span>
    <span class="s0">attrname_to_abbrevs,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.parsing cimport quarter_to_myear</span>

<span class="s0">from pandas._libs.tslibs.parsing import parse_time_string</span>

<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">_nat_scalar_rules,</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">c_nat_strings as nat_strings,</span>
    <span class="s0">checknull_with_nat,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.offsets cimport (</span>
    <span class="s0">BaseOffset,</span>
    <span class="s0">is_offset_object,</span>
    <span class="s0">is_tick_object,</span>
    <span class="s0">to_offset,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.offsets import INVALID_FREQ_ERR_MSG</span>

<span class="s0">cdef:</span>
    <span class="s0">enum:</span>
        <span class="s0">INT32_MIN = -2_147_483_648LL</span>


<span class="s0">ctypedef struct asfreq_info:</span>
    <span class="s0">int64_t intraday_conversion_factor</span>
    <span class="s0">int is_end</span>
    <span class="s0">int to_end</span>
    <span class="s0">int from_end</span>

<span class="s0">ctypedef int64_t (*freq_conv_func)(int64_t, asfreq_info*) nogil</span>


<span class="s0">cdef extern from *:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">// must use npy typedef b/c int64_t is aliased in cython-generated c</span>
    <span class="s0">// unclear why we need LL for that row.</span>
    <span class="s0">// see https://github.com/pandas-dev/pandas/pull/34416/</span>
    <span class="s0">static npy_int64 daytime_conversion_factor_matrix[7][7] = {</span>
        <span class="s0">{1, 24, 1440, 86400, 86400000, 86400000000, 86400000000000},</span>
        <span class="s0">{0LL,  1LL,   60LL,  3600LL,  3600000LL,  3600000000LL,  3600000000000LL},</span>
        <span class="s0">{0,  0,   1,     60,    60000,    60000000,    60000000000},</span>
        <span class="s0">{0,  0,   0,      1,     1000,     1000000,     1000000000},</span>
        <span class="s0">{0,  0,   0,      0,        1,        1000,        1000000},</span>
        <span class="s0">{0,  0,   0,      0,        0,           1,           1000},</span>
        <span class="s0">{0,  0,   0,      0,        0,           0,              1}};</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">int64_t daytime_conversion_factor_matrix[7][7]</span>


<span class="s0">cdef int max_value(int left, int right) nogil:</span>
    <span class="s0">if left &gt; right:</span>
        <span class="s0">return left</span>
    <span class="s0">return right</span>


<span class="s0">cdef int min_value(int left, int right) nogil:</span>
    <span class="s0">if left &lt; right:</span>
        <span class="s0">return left</span>
    <span class="s0">return right</span>


<span class="s0">cdef int64_t get_daytime_conversion_factor(int from_index, int to_index) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int row = min_value(from_index, to_index)</span>
        <span class="s0">int col = max_value(from_index, to_index)</span>
    <span class="s0"># row or col &lt; 6 means frequency strictly lower than Daily, which</span>
    <span class="s0"># do not use daytime_conversion_factors</span>
    <span class="s0">if row &lt; 6:</span>
        <span class="s0">return 0</span>
    <span class="s0">elif col &lt; 6:</span>
        <span class="s0">return 0</span>
    <span class="s0">return daytime_conversion_factor_matrix[row - 6][col - 6]</span>


<span class="s0">cdef int64_t nofunc(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return INT32_MIN</span>


<span class="s0">cdef int64_t no_op(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return ordinal</span>


<span class="s0">cdef freq_conv_func get_asfreq_func(int from_freq, int to_freq) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int from_group = get_freq_group(from_freq)</span>
        <span class="s0">int to_group = get_freq_group(to_freq)</span>

    <span class="s0">if from_group == FR_UND:</span>
        <span class="s0">from_group = FR_DAY</span>

    <span class="s0">if from_group == FR_BUS:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_BtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_BtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_BtoM</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_BtoW</span>
        <span class="s0">elif to_group == FR_BUS:</span>
            <span class="s0">return &lt;freq_conv_func&gt;no_op</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_BtoDT</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif to_group == FR_BUS:</span>
        <span class="s0">if from_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoB</span>
        <span class="s0">elif from_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoB</span>
        <span class="s0">elif from_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_MtoB</span>
        <span class="s0">elif from_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoB</span>
        <span class="s0">elif from_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_DTtoB</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif from_group == FR_ANN:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoM</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoW</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_AtoDT</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif from_group == FR_QTR:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoM</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoW</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_QtoDT</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif from_group == FR_MTH:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_MtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_MtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;no_op</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_MtoW</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_MtoDT</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif from_group == FR_WK:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoM</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoW</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_WtoDT</span>
        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">elif from_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
        <span class="s0">if to_group == FR_ANN:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_DTtoA</span>
        <span class="s0">elif to_group == FR_QTR:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_DTtoQ</span>
        <span class="s0">elif to_group == FR_MTH:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_DTtoM</span>
        <span class="s0">elif to_group == FR_WK:</span>
            <span class="s0">return &lt;freq_conv_func&gt;asfreq_DTtoW</span>
        <span class="s0">elif to_group in [FR_DAY, FR_HR, FR_MIN, FR_SEC, FR_MS, FR_US, FR_NS]:</span>
            <span class="s0">if from_group &gt; to_group:</span>
                <span class="s0">return &lt;freq_conv_func&gt;downsample_daytime</span>
            <span class="s0">else:</span>
                <span class="s0">return &lt;freq_conv_func&gt;upsample_daytime</span>

        <span class="s0">else:</span>
            <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>

    <span class="s0">else:</span>
        <span class="s0">return &lt;freq_conv_func&gt;nofunc</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Frequency Conversion Helpers</span>

<span class="s0">cdef int64_t DtoB_weekday(int64_t unix_date) nogil:</span>
    <span class="s0">return ((unix_date + 4) // 7) * 5 + ((unix_date + 4) % 7) - 4</span>


<span class="s0">cdef int64_t DtoB(npy_datetimestruct *dts, int roll_back,</span>
                  <span class="s0">int64_t unix_date) nogil:</span>
    <span class="s0"># calculate the current week (counting from 1970-01-01) treating</span>
    <span class="s0"># sunday as last day of a week</span>
    <span class="s0">cdef:</span>
        <span class="s0">int day_of_week = dayofweek(dts.year, dts.month, dts.day)</span>

    <span class="s0">if roll_back == 1:</span>
        <span class="s0">if day_of_week &gt; 4:</span>
            <span class="s0"># change to friday before weekend</span>
            <span class="s0">unix_date -= (day_of_week - 4)</span>
    <span class="s0">else:</span>
        <span class="s0">if day_of_week &gt; 4:</span>
            <span class="s0"># change to Monday after weekend</span>
            <span class="s0">unix_date += (7 - day_of_week)</span>

    <span class="s0">return DtoB_weekday(unix_date)</span>


<span class="s0">cdef inline int64_t upsample_daytime(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">if af_info.is_end:</span>
        <span class="s0">return (ordinal + 1) * af_info.intraday_conversion_factor - 1</span>
    <span class="s0">else:</span>
        <span class="s0">return ordinal * af_info.intraday_conversion_factor</span>


<span class="s0">cdef inline int64_t downsample_daytime(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return ordinal // af_info.intraday_conversion_factor</span>


<span class="s0">cdef inline int64_t transform_via_day(int64_t ordinal,</span>
                                      <span class="s0">asfreq_info *af_info,</span>
                                      <span class="s0">freq_conv_func first_func,</span>
                                      <span class="s0">freq_conv_func second_func) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t result</span>

    <span class="s0">result = first_func(ordinal, af_info)</span>
    <span class="s0">result = second_func(result, af_info)</span>
    <span class="s0">return result</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Conversion _to_ Daily Freq</span>

<span class="s0">cdef int64_t asfreq_AtoDT(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unix_date</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">ordinal += af_info.is_end</span>

    <span class="s0">dts.year = ordinal + 1970</span>
    <span class="s0">dts.month = 1</span>
    <span class="s0">adjust_dts_for_month(&amp;dts, af_info.from_end)</span>

    <span class="s0">unix_date = unix_date_from_ymd(dts.year, dts.month, 1)</span>
    <span class="s0">unix_date -= af_info.is_end</span>
    <span class="s0">return upsample_daytime(unix_date, af_info)</span>


<span class="s0">cdef int64_t asfreq_QtoDT(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unix_date</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">ordinal += af_info.is_end</span>

    <span class="s0">dts.year = ordinal // 4 + 1970</span>
    <span class="s0">dts.month = (ordinal % 4) * 3 + 1</span>
    <span class="s0">adjust_dts_for_month(&amp;dts, af_info.from_end)</span>

    <span class="s0">unix_date = unix_date_from_ymd(dts.year, dts.month, 1)</span>
    <span class="s0">unix_date -= af_info.is_end</span>
    <span class="s0">return upsample_daytime(unix_date, af_info)</span>


<span class="s0">cdef int64_t asfreq_MtoDT(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unix_date</span>
        <span class="s0">int year, month</span>

    <span class="s0">ordinal += af_info.is_end</span>

    <span class="s0">year = ordinal // 12 + 1970</span>
    <span class="s0">month = ordinal % 12 + 1</span>

    <span class="s0">unix_date = unix_date_from_ymd(year, month, 1)</span>
    <span class="s0">unix_date -= af_info.is_end</span>
    <span class="s0">return upsample_daytime(unix_date, af_info)</span>


<span class="s0">cdef int64_t asfreq_WtoDT(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">ordinal = (ordinal * 7 + af_info.from_end - 4 +</span>
               <span class="s0">(7 - 1) * (af_info.is_end - 1))</span>
    <span class="s0">return upsample_daytime(ordinal, af_info)</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Conversion _to_ BusinessDay Freq</span>

<span class="s0">cdef int64_t asfreq_AtoB(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int roll_back</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date = asfreq_AtoDT(ordinal, af_info)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, &amp;dts)</span>
    <span class="s0">roll_back = af_info.is_end</span>
    <span class="s0">return DtoB(&amp;dts, roll_back, unix_date)</span>


<span class="s0">cdef int64_t asfreq_QtoB(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int roll_back</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date = asfreq_QtoDT(ordinal, af_info)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, &amp;dts)</span>
    <span class="s0">roll_back = af_info.is_end</span>
    <span class="s0">return DtoB(&amp;dts, roll_back, unix_date)</span>


<span class="s0">cdef int64_t asfreq_MtoB(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int roll_back</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date = asfreq_MtoDT(ordinal, af_info)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, &amp;dts)</span>
    <span class="s0">roll_back = af_info.is_end</span>
    <span class="s0">return DtoB(&amp;dts, roll_back, unix_date)</span>


<span class="s0">cdef int64_t asfreq_WtoB(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int roll_back</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date = asfreq_WtoDT(ordinal, af_info)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, &amp;dts)</span>
    <span class="s0">roll_back = af_info.is_end</span>
    <span class="s0">return DtoB(&amp;dts, roll_back, unix_date)</span>


<span class="s0">cdef int64_t asfreq_DTtoB(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int roll_back</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date = downsample_daytime(ordinal, af_info)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, &amp;dts)</span>
    <span class="s0"># This usage defines roll_back the opposite way from the others</span>
    <span class="s0">roll_back = 1 - af_info.is_end</span>
    <span class="s0">return DtoB(&amp;dts, roll_back, unix_date)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ Daily Freq</span>

<span class="s0">cdef int64_t asfreq_DTtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">ordinal = downsample_daytime(ordinal, af_info)</span>
    <span class="s0">pandas_datetime_to_datetimestruct(ordinal, NPY_FR_D, &amp;dts)</span>
    <span class="s0">return dts_to_year_ordinal(&amp;dts, af_info.to_end)</span>


<span class="s0">cdef int DtoQ_yq(int64_t ordinal, asfreq_info *af_info, npy_datetimestruct* dts) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int quarter</span>

    <span class="s0">pandas_datetime_to_datetimestruct(ordinal, NPY_FR_D, dts)</span>
    <span class="s0">adjust_dts_for_qtr(dts, af_info.to_end)</span>

    <span class="s0">quarter = month_to_quarter(dts.month)</span>
    <span class="s0">return quarter</span>


<span class="s0">cdef int64_t asfreq_DTtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int quarter</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">ordinal = downsample_daytime(ordinal, af_info)</span>

    <span class="s0">quarter = DtoQ_yq(ordinal, af_info, &amp;dts)</span>
    <span class="s0">return &lt;int64_t&gt;((dts.year - 1970) * 4 + quarter - 1)</span>


<span class="s0">cdef int64_t asfreq_DTtoM(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">ordinal = downsample_daytime(ordinal, af_info)</span>
    <span class="s0">pandas_datetime_to_datetimestruct(ordinal, NPY_FR_D, &amp;dts)</span>
    <span class="s0">return dts_to_month_ordinal(&amp;dts)</span>


<span class="s0">cdef int64_t asfreq_DTtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">ordinal = downsample_daytime(ordinal, af_info)</span>
    <span class="s0">return unix_date_to_week(ordinal, af_info.to_end)</span>


<span class="s0">cdef int64_t unix_date_to_week(int64_t unix_date, int to_end) nogil:</span>
    <span class="s0">return (unix_date + 3 - to_end) // 7 + 1</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ BusinessDay Freq</span>

<span class="s0">cdef int64_t asfreq_BtoDT(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">ordinal = ((ordinal + 3) // 5) * 7 + (ordinal + 3) % 5 - 3</span>
    <span class="s0">return upsample_daytime(ordinal, af_info)</span>


<span class="s0">cdef int64_t asfreq_BtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_BtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoA)</span>


<span class="s0">cdef int64_t asfreq_BtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_BtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoQ)</span>


<span class="s0">cdef int64_t asfreq_BtoM(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_BtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoM)</span>


<span class="s0">cdef int64_t asfreq_BtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_BtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoW)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ Annual Freq</span>

<span class="s0">cdef int64_t asfreq_AtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_AtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoA)</span>


<span class="s0">cdef int64_t asfreq_AtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_AtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoQ)</span>


<span class="s0">cdef int64_t asfreq_AtoM(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_AtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoM)</span>


<span class="s0">cdef int64_t asfreq_AtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_AtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoW)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ Quarterly Freq</span>

<span class="s0">cdef int64_t asfreq_QtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_QtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoQ)</span>


<span class="s0">cdef int64_t asfreq_QtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_QtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoA)</span>


<span class="s0">cdef int64_t asfreq_QtoM(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_QtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoM)</span>


<span class="s0">cdef int64_t asfreq_QtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_QtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoW)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ Monthly Freq</span>

<span class="s0">cdef int64_t asfreq_MtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_MtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoA)</span>


<span class="s0">cdef int64_t asfreq_MtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_MtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoQ)</span>


<span class="s0">cdef int64_t asfreq_MtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_MtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoW)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion _from_ Weekly Freq</span>

<span class="s0">cdef int64_t asfreq_WtoA(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_WtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoA)</span>


<span class="s0">cdef int64_t asfreq_WtoQ(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_WtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoQ)</span>


<span class="s0">cdef int64_t asfreq_WtoM(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_WtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoM)</span>


<span class="s0">cdef int64_t asfreq_WtoW(int64_t ordinal, asfreq_info *af_info) nogil:</span>
    <span class="s0">return transform_via_day(ordinal, af_info,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_WtoDT,</span>
                             <span class="s0">&lt;freq_conv_func&gt;asfreq_DTtoW)</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">@cython.cdivision</span>
<span class="s0">cdef char* c_strftime(npy_datetimestruct *dts, char *fmt):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Generate a nice string representation of the period</span>
    <span class="s0">object, originally from DateObject_strftime</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">dts : npy_datetimestruct*</span>
    <span class="s0">fmt : char*</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">result : char*</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">tm c_date</span>
        <span class="s0">char *result</span>
        <span class="s0">int result_len = strlen(fmt) + 50</span>

    <span class="s0">c_date.tm_sec = dts.sec</span>
    <span class="s0">c_date.tm_min = dts.min</span>
    <span class="s0">c_date.tm_hour = dts.hour</span>
    <span class="s0">c_date.tm_mday = dts.day</span>
    <span class="s0">c_date.tm_mon = dts.month - 1</span>
    <span class="s0">c_date.tm_year = dts.year - 1900</span>
    <span class="s0">c_date.tm_wday = (dayofweek(dts.year, dts.month, dts.day) + 1) % 7</span>
    <span class="s0">c_date.tm_yday = get_day_of_year(dts.year, dts.month, dts.day) - 1</span>
    <span class="s0">c_date.tm_isdst = -1</span>

    <span class="s0">result = &lt;char*&gt;malloc(result_len * sizeof(char))</span>

    <span class="s0">strftime(result, result_len, fmt, &amp;c_date)</span>

    <span class="s0">return result</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Conversion between date_info and npy_datetimestruct</span>

<span class="s0">cdef inline int get_freq_group(int freq) nogil:</span>
    <span class="s0"># Note: this is equivalent to libfrequencies.get_freq_group, specialized</span>
    <span class="s0">#  to integer argument.</span>
    <span class="s0">return (freq // 1000) * 1000</span>


<span class="s0">cdef inline int get_freq_group_index(int freq) nogil:</span>
    <span class="s0">return freq // 1000</span>


<span class="s0">cdef void adjust_dts_for_month(npy_datetimestruct* dts, int from_end) nogil:</span>
    <span class="s0">if from_end != 12:</span>
        <span class="s0">dts.month += from_end</span>
        <span class="s0">if dts.month &gt; 12:</span>
            <span class="s0">dts.month -= 12</span>
        <span class="s0">else:</span>
            <span class="s0">dts.year -= 1</span>


<span class="s0">cdef void adjust_dts_for_qtr(npy_datetimestruct* dts, int to_end) nogil:</span>
    <span class="s0">if to_end != 12:</span>
        <span class="s0">dts.month -= to_end</span>
        <span class="s0">if dts.month &lt;= 0:</span>
            <span class="s0">dts.month += 12</span>
        <span class="s0">else:</span>
            <span class="s0">dts.year += 1</span>


<span class="s0"># Find the unix_date (days elapsed since datetime(1970, 1, 1)</span>
<span class="s0"># for the given year/month/day.</span>
<span class="s0"># Assumes GREGORIAN_CALENDAR */</span>
<span class="s0">cdef int64_t unix_date_from_ymd(int year, int month, int day) nogil:</span>
    <span class="s0"># Calculate the absolute date</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int64_t unix_date</span>

    <span class="s0">memset(&amp;dts, 0, sizeof(npy_datetimestruct))</span>
    <span class="s0">dts.year = year</span>
    <span class="s0">dts.month = month</span>
    <span class="s0">dts.day = day</span>
    <span class="s0">unix_date = npy_datetimestruct_to_datetime(NPY_FR_D, &amp;dts)</span>
    <span class="s0">return unix_date</span>


<span class="s0">cdef inline int64_t dts_to_month_ordinal(npy_datetimestruct* dts) nogil:</span>
    <span class="s0"># AKA: use npy_datetimestruct_to_datetime(NPY_FR_M, &amp;dts)</span>
    <span class="s0">return &lt;int64_t&gt;((dts.year - 1970) * 12 + dts.month - 1)</span>


<span class="s0">cdef inline int64_t dts_to_year_ordinal(npy_datetimestruct *dts, int to_end) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t result</span>

    <span class="s0">result = npy_datetimestruct_to_datetime(NPY_DATETIMEUNIT.NPY_FR_Y, dts)</span>
    <span class="s0">if dts.month &gt; to_end:</span>
        <span class="s0">return result + 1</span>
    <span class="s0">else:</span>
        <span class="s0">return result</span>


<span class="s0">cdef inline int64_t dts_to_qtr_ordinal(npy_datetimestruct* dts, int to_end) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int quarter</span>

    <span class="s0">adjust_dts_for_qtr(dts, to_end)</span>
    <span class="s0">quarter = month_to_quarter(dts.month)</span>
    <span class="s0">return &lt;int64_t&gt;((dts.year - 1970) * 4 + quarter - 1)</span>


<span class="s0">cdef inline int get_anchor_month(int freq, int freq_group) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int fmonth</span>
    <span class="s0">fmonth = freq - freq_group</span>
    <span class="s0">if fmonth == 0:</span>
        <span class="s0">fmonth = 12</span>
    <span class="s0">return fmonth</span>


<span class="s0"># specifically _dont_ use cdvision or else ordinals near -1 are assigned to</span>
<span class="s0"># incorrect dates GH#19643</span>
<span class="s0">@cython.cdivision(False)</span>
<span class="s0">cdef int64_t get_period_ordinal(npy_datetimestruct *dts, int freq) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Generate an ordinal in period space</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">dts: npy_datetimestruct*</span>
    <span class="s0">freq : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">period_ordinal : int64_t</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unix_date</span>
        <span class="s0">int freq_group, fmonth, mdiff</span>
        <span class="s0">NPY_DATETIMEUNIT unit</span>

    <span class="s0">freq_group = get_freq_group(freq)</span>

    <span class="s0">if freq_group == FR_ANN:</span>
        <span class="s0">fmonth = get_anchor_month(freq, freq_group)</span>
        <span class="s0">return dts_to_year_ordinal(dts, fmonth)</span>

    <span class="s0">elif freq_group == FR_QTR:</span>
        <span class="s0">fmonth = get_anchor_month(freq, freq_group)</span>
        <span class="s0">return dts_to_qtr_ordinal(dts, fmonth)</span>

    <span class="s0">elif freq_group == FR_WK:</span>
        <span class="s0">unix_date = npy_datetimestruct_to_datetime(NPY_FR_D, dts)</span>
        <span class="s0">return unix_date_to_week(unix_date, freq - FR_WK)</span>

    <span class="s0">elif freq == FR_BUS:</span>
        <span class="s0">unix_date = npy_datetimestruct_to_datetime(NPY_FR_D, dts)</span>
        <span class="s0">return DtoB(dts, 0, unix_date)</span>

    <span class="s0">unit = get_unit(freq)</span>
    <span class="s0">return npy_datetimestruct_to_datetime(unit, dts)</span>


<span class="s0">cdef NPY_DATETIMEUNIT get_unit(int freq) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert the freq to the corresponding NPY_DATETIMEUNIT to pass</span>
    <span class="s0">to npy_datetimestruct_to_datetime.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if freq == FR_MTH:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_M</span>
    <span class="s0">elif freq == FR_DAY:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_D</span>
    <span class="s0">elif freq == FR_HR:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_h</span>
    <span class="s0">elif freq == FR_MIN:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_m</span>
    <span class="s0">elif freq == FR_SEC:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_s</span>
    <span class="s0">elif freq == FR_MS:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_ms</span>
    <span class="s0">elif freq == FR_US:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_us</span>
    <span class="s0">elif freq == FR_NS:</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_ns</span>
    <span class="s0">elif freq == FR_UND:</span>
        <span class="s0"># Default to Day</span>
        <span class="s0">return NPY_DATETIMEUNIT.NPY_FR_D</span>


<span class="s0">cdef void get_date_info(int64_t ordinal, int freq, npy_datetimestruct *dts) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unix_date, nanos</span>
        <span class="s0">npy_datetimestruct dts2</span>

    <span class="s0">unix_date = get_unix_date(ordinal, freq)</span>
    <span class="s0">nanos = get_time_nanos(freq, unix_date, ordinal)</span>

    <span class="s0">pandas_datetime_to_datetimestruct(unix_date, NPY_FR_D, dts)</span>

    <span class="s0">dt64_to_dtstruct(nanos, &amp;dts2)</span>
    <span class="s0">dts.hour = dts2.hour</span>
    <span class="s0">dts.min = dts2.min</span>
    <span class="s0">dts.sec = dts2.sec</span>
    <span class="s0">dts.us = dts2.us</span>
    <span class="s0">dts.ps = dts2.ps</span>


<span class="s0">cdef int64_t get_unix_date(int64_t period_ordinal, int freq) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Returns the proleptic Gregorian ordinal of the date, as an integer.</span>
    <span class="s0">This corresponds to the number of days since Jan., 1st, 1970 AD.</span>
    <span class="s0">When the instance has a frequency less than daily, the proleptic date</span>
    <span class="s0">is calculated for the last day of the period.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">period_ordinal : int64_t</span>
    <span class="s0">freq : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">unix_date : int64_t number of days since datetime(1970, 1, 1)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">asfreq_info af_info</span>
        <span class="s0">freq_conv_func toDaily = NULL</span>

    <span class="s0">if freq == FR_DAY:</span>
        <span class="s0">return period_ordinal</span>

    <span class="s0">toDaily = get_asfreq_func(freq, FR_DAY)</span>
    <span class="s0">get_asfreq_info(freq, FR_DAY, True, &amp;af_info)</span>
    <span class="s0">return toDaily(period_ordinal, &amp;af_info)</span>


<span class="s0">@cython.cdivision</span>
<span class="s0">cdef int64_t get_time_nanos(int freq, int64_t unix_date, int64_t ordinal) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Find the number of nanoseconds after midnight on the given unix_date</span>
    <span class="s0">that the ordinal represents in the given frequency.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">freq : int</span>
    <span class="s0">unix_date : int64_t</span>
    <span class="s0">ordinal : int64_t</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">int64_t</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t sub, factor</span>
        <span class="s0">int64_t nanos_in_day = 24 * 3600 * 10**9</span>

    <span class="s0">freq = get_freq_group(freq)</span>

    <span class="s0">if freq &lt;= FR_DAY:</span>
        <span class="s0">return 0</span>

    <span class="s0">elif freq == FR_NS:</span>
        <span class="s0">factor = 1</span>

    <span class="s0">elif freq == FR_US:</span>
        <span class="s0">factor = 10**3</span>

    <span class="s0">elif freq == FR_MS:</span>
        <span class="s0">factor = 10**6</span>

    <span class="s0">elif freq == FR_SEC:</span>
        <span class="s0">factor = 10 **9</span>

    <span class="s0">elif freq == FR_MIN:</span>
        <span class="s0">factor = 10**9 * 60</span>

    <span class="s0">else:</span>
        <span class="s0"># We must have freq == FR_HR</span>
        <span class="s0">factor = 10**9 * 3600</span>

    <span class="s0">sub = ordinal - unix_date * (nanos_in_day / factor)</span>
    <span class="s0">return sub * factor</span>


<span class="s0">cdef int get_yq(int64_t ordinal, int freq, npy_datetimestruct* dts):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Find the year and quarter of a Period with the given ordinal and frequency</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">ordinal : int64_t</span>
    <span class="s0">freq : int</span>
    <span class="s0">dts : *npy_datetimestruct</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">quarter : int</span>
        <span class="s0">describes the implied quarterly frequency associated with `freq`</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">Sets dts.year in-place.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">asfreq_info af_info</span>
        <span class="s0">int qtr_freq</span>
        <span class="s0">int64_t unix_date</span>
        <span class="s0">int quarter</span>

    <span class="s0">unix_date = get_unix_date(ordinal, freq)</span>

    <span class="s0">if get_freq_group(freq) == FR_QTR:</span>
        <span class="s0">qtr_freq = freq</span>
    <span class="s0">else:</span>
        <span class="s0">qtr_freq = FR_QTR</span>

    <span class="s0">get_asfreq_info(FR_DAY, qtr_freq, True, &amp;af_info)</span>

    <span class="s0">quarter = DtoQ_yq(unix_date, &amp;af_info, dts)</span>
    <span class="s0">return quarter</span>


<span class="s0">cdef inline int month_to_quarter(int month) nogil:</span>
    <span class="s0">return (month - 1) // 3 + 1</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Period logic</span>

<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def periodarr_to_dt64arr(const int64_t[:] periodarr, int freq):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert array to datetime64 values from a set of ordinals corresponding to</span>
    <span class="s0">periods per period convention.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t[:] out</span>
        <span class="s0">Py_ssize_t i, N</span>

    <span class="s0">if freq &lt; 6000:  # i.e. FR_DAY, hard-code to avoid need to cast</span>
        <span class="s0">N = len(periodarr)</span>
        <span class="s0">out = np.empty(N, dtype=&quot;i8&quot;)</span>

        <span class="s0"># We get here with freqs that do not correspond to a datetime64 unit</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">out[i] = period_ordinal_to_dt64(periodarr[i], freq)</span>

        <span class="s0">return out.base  # .base to access underlying np.ndarray</span>

    <span class="s0">else:</span>
        <span class="s0"># Short-circuit for performance</span>
        <span class="s0">if freq == FR_NS:</span>
            <span class="s0">return periodarr.base</span>

        <span class="s0">if freq == FR_US:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[us]&quot;)</span>
        <span class="s0">elif freq == FR_MS:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[ms]&quot;)</span>
        <span class="s0">elif freq == FR_SEC:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[s]&quot;)</span>
        <span class="s0">elif freq == FR_MIN:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[m]&quot;)</span>
        <span class="s0">elif freq == FR_HR:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[h]&quot;)</span>
        <span class="s0">elif freq == FR_DAY:</span>
            <span class="s0">dta = periodarr.base.view(&quot;M8[D]&quot;)</span>
        <span class="s0">return ensure_datetime64ns(dta)</span>


<span class="s0">cdef void get_asfreq_info(int from_freq, int to_freq,</span>
                          <span class="s0">bint is_end, asfreq_info *af_info) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Construct the `asfreq_info` object used to convert an ordinal from</span>
    <span class="s0">`from_freq` to `to_freq`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">from_freq : int</span>
    <span class="s0">to_freq int</span>
    <span class="s0">is_end : bool</span>
    <span class="s0">af_info : *asfreq_info</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int from_group = get_freq_group(from_freq)</span>
        <span class="s0">int to_group = get_freq_group(to_freq)</span>

    <span class="s0">af_info.is_end = is_end</span>

    <span class="s0">af_info.intraday_conversion_factor = get_daytime_conversion_factor(</span>
        <span class="s0">get_freq_group_index(max_value(from_group, FR_DAY)),</span>
        <span class="s0">get_freq_group_index(max_value(to_group, FR_DAY)))</span>

    <span class="s0">if from_group == FR_WK:</span>
        <span class="s0">af_info.from_end = calc_week_end(from_freq, from_group)</span>
    <span class="s0">elif from_group == FR_ANN:</span>
        <span class="s0">af_info.from_end = calc_a_year_end(from_freq, from_group)</span>
    <span class="s0">elif from_group == FR_QTR:</span>
        <span class="s0">af_info.from_end = calc_a_year_end(from_freq, from_group)</span>

    <span class="s0">if to_group == FR_WK:</span>
        <span class="s0">af_info.to_end = calc_week_end(to_freq, to_group)</span>
    <span class="s0">elif to_group == FR_ANN:</span>
        <span class="s0">af_info.to_end = calc_a_year_end(to_freq, to_group)</span>
    <span class="s0">elif to_group == FR_QTR:</span>
        <span class="s0">af_info.to_end = calc_a_year_end(to_freq, to_group)</span>


<span class="s0">@cython.cdivision</span>
<span class="s0">cdef int calc_a_year_end(int freq, int group) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int result = (freq - group) % 12</span>
    <span class="s0">if result == 0:</span>
        <span class="s0">return 12</span>
    <span class="s0">else:</span>
        <span class="s0">return result</span>


<span class="s0">cdef inline int calc_week_end(int freq, int group) nogil:</span>
    <span class="s0">return freq - group</span>


<span class="s0">cpdef int64_t period_asfreq(int64_t ordinal, int freq1, int freq2, bint end):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert period ordinal from one frequency to another, and if upsampling,</span>
    <span class="s0">choose to use start ('S') or end ('E') of period.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t retval</span>

    <span class="s0">_period_asfreq(&amp;ordinal, &amp;retval, 1, freq1, freq2, end)</span>
    <span class="s0">return retval</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def period_asfreq_arr(ndarray[int64_t] arr, int freq1, int freq2, bint end):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert int64-array of period ordinals from one frequency to another, and</span>
    <span class="s0">if upsampling, choose to use start ('S') or end ('E') of period.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t n = len(arr)</span>
        <span class="s0">Py_ssize_t increment = arr.strides[0] // 8</span>
        <span class="s0">ndarray[int64_t] result = np.empty(n, dtype=np.int64)</span>

    <span class="s0">_period_asfreq(</span>
        <span class="s0">&lt;int64_t*&gt;cnp.PyArray_DATA(arr),</span>
        <span class="s0">&lt;int64_t*&gt;cnp.PyArray_DATA(result),</span>
        <span class="s0">n,</span>
        <span class="s0">freq1,</span>
        <span class="s0">freq2,</span>
        <span class="s0">end,</span>
        <span class="s0">increment,</span>
    <span class="s0">)</span>
    <span class="s0">return result</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef void _period_asfreq(</span>
    <span class="s0">int64_t* ordinals,</span>
    <span class="s0">int64_t* out,</span>
    <span class="s0">Py_ssize_t length,</span>
    <span class="s0">int freq1,</span>
    <span class="s0">int freq2,</span>
    <span class="s0">bint end,</span>
    <span class="s0">Py_ssize_t increment=1,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;See period_asfreq.__doc__&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">freq_conv_func func</span>
        <span class="s0">asfreq_info af_info</span>
        <span class="s0">int64_t val</span>

    <span class="s0">if length == 1 and ordinals[0] == NPY_NAT:</span>
        <span class="s0"># fastpath avoid calling get_asfreq_func</span>
        <span class="s0">out[0] = NPY_NAT</span>
        <span class="s0">return</span>

    <span class="s0">func = get_asfreq_func(freq1, freq2)</span>
    <span class="s0">get_asfreq_info(freq1, freq2, end, &amp;af_info)</span>

    <span class="s0">for i in range(length):</span>
        <span class="s0">val = ordinals[i * increment]</span>
        <span class="s0">if val != NPY_NAT:</span>
            <span class="s0">val = func(val, &amp;af_info)</span>
        <span class="s0">out[i] = val</span>


<span class="s0">cpdef int64_t period_ordinal(int y, int m, int d, int h, int min,</span>
                             <span class="s0">int s, int us, int ps, int freq):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Find the ordinal representation of the given datetime components at the</span>
    <span class="s0">frequency `freq`.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">y : int</span>
    <span class="s0">m : int</span>
    <span class="s0">d : int</span>
    <span class="s0">h : int</span>
    <span class="s0">min : int</span>
    <span class="s0">s : int</span>
    <span class="s0">us : int</span>
    <span class="s0">ps : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ordinal : int64_t</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">dts.year = y</span>
    <span class="s0">dts.month = m</span>
    <span class="s0">dts.day = d</span>
    <span class="s0">dts.hour = h</span>
    <span class="s0">dts.min = min</span>
    <span class="s0">dts.sec = s</span>
    <span class="s0">dts.us = us</span>
    <span class="s0">dts.ps = ps</span>
    <span class="s0">return get_period_ordinal(&amp;dts, freq)</span>


<span class="s0">cdef int64_t period_ordinal_to_dt64(int64_t ordinal, int freq) except? -1:</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">if ordinal == NPY_NAT:</span>
        <span class="s0">return NPY_NAT</span>

    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>

    <span class="s0">check_dts_bounds(&amp;dts)</span>
    <span class="s0">return dtstruct_to_dt64(&amp;dts)</span>


<span class="s0">cdef str period_format(int64_t value, int freq, object fmt=None):</span>
    <span class="s0">cdef:</span>
        <span class="s0">int freq_group</span>

    <span class="s0">if value == NPY_NAT:</span>
        <span class="s0">return &quot;NaT&quot;</span>

    <span class="s0">if isinstance(fmt, str):</span>
        <span class="s0">fmt = fmt.encode(&quot;utf-8&quot;)</span>

    <span class="s0">if fmt is None:</span>
        <span class="s0">freq_group = get_freq_group(freq)</span>
        <span class="s0">if freq_group == FR_ANN:</span>
            <span class="s0">fmt = b'%Y'</span>
        <span class="s0">elif freq_group == FR_QTR:</span>
            <span class="s0">fmt = b'%FQ%q'</span>
        <span class="s0">elif freq_group == FR_MTH:</span>
            <span class="s0">fmt = b'%Y-%m'</span>
        <span class="s0">elif freq_group == FR_WK:</span>
            <span class="s0">left = period_asfreq(value, freq, FR_DAY, 0)</span>
            <span class="s0">right = period_asfreq(value, freq, FR_DAY, 1)</span>
            <span class="s0">return f&quot;{period_format(left, FR_DAY)}/{period_format(right, FR_DAY)}&quot;</span>
        <span class="s0">elif freq_group == FR_BUS or freq_group == FR_DAY:</span>
            <span class="s0">fmt = b'%Y-%m-%d'</span>
        <span class="s0">elif freq_group == FR_HR:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:00'</span>
        <span class="s0">elif freq_group == FR_MIN:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:%M'</span>
        <span class="s0">elif freq_group == FR_SEC:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:%M:%S'</span>
        <span class="s0">elif freq_group == FR_MS:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:%M:%S.%l'</span>
        <span class="s0">elif freq_group == FR_US:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:%M:%S.%u'</span>
        <span class="s0">elif freq_group == FR_NS:</span>
            <span class="s0">fmt = b'%Y-%m-%d %H:%M:%S.%n'</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(f&quot;Unknown freq: {freq}&quot;)</span>

    <span class="s0">return _period_strftime(value, freq, fmt)</span>


<span class="s0">cdef list extra_fmts = [(b&quot;%q&quot;, b&quot;^`AB`^&quot;),</span>
                        <span class="s0">(b&quot;%f&quot;, b&quot;^`CD`^&quot;),</span>
                        <span class="s0">(b&quot;%F&quot;, b&quot;^`EF`^&quot;),</span>
                        <span class="s0">(b&quot;%l&quot;, b&quot;^`GH`^&quot;),</span>
                        <span class="s0">(b&quot;%u&quot;, b&quot;^`IJ`^&quot;),</span>
                        <span class="s0">(b&quot;%n&quot;, b&quot;^`KL`^&quot;)]</span>

<span class="s0">cdef list str_extra_fmts = [&quot;^`AB`^&quot;, &quot;^`CD`^&quot;, &quot;^`EF`^&quot;,</span>
                            <span class="s0">&quot;^`GH`^&quot;, &quot;^`IJ`^&quot;, &quot;^`KL`^&quot;]</span>

<span class="s0">cdef str _period_strftime(int64_t value, int freq, bytes fmt):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">char *formatted</span>
        <span class="s0">bytes pat, brepl</span>
        <span class="s0">list found_pat = [False] * len(extra_fmts)</span>
        <span class="s0">int year, quarter</span>
        <span class="s0">str result, repl</span>

    <span class="s0">get_date_info(value, freq, &amp;dts)</span>
    <span class="s0">for i in range(len(extra_fmts)):</span>
        <span class="s0">pat = extra_fmts[i][0]</span>
        <span class="s0">brepl = extra_fmts[i][1]</span>
        <span class="s0">if pat in fmt:</span>
            <span class="s0">fmt = fmt.replace(pat, brepl)</span>
            <span class="s0">found_pat[i] = True</span>

    <span class="s0">formatted = c_strftime(&amp;dts, &lt;char*&gt;fmt)</span>

    <span class="s0">result = util.char_to_string(formatted)</span>
    <span class="s0">free(formatted)</span>

    <span class="s0">for i in range(len(extra_fmts)):</span>
        <span class="s0">if found_pat[i]:</span>

            <span class="s0">quarter = get_yq(value, freq, &amp;dts)</span>

            <span class="s0">if i == 0:</span>
                <span class="s0">repl = str(quarter)</span>
            <span class="s0">elif i == 1:  # %f, 2-digit year</span>
                <span class="s0">repl = f&quot;{(dts.year % 100):02d}&quot;</span>
            <span class="s0">elif i == 2:</span>
                <span class="s0">repl = str(dts.year)</span>
            <span class="s0">elif i == 3:</span>
                <span class="s0">repl = f&quot;{(value % 1_000):03d}&quot;</span>
            <span class="s0">elif i == 4:</span>
                <span class="s0">repl = f&quot;{(value % 1_000_000):06d}&quot;</span>
            <span class="s0">elif i == 5:</span>
                <span class="s0">repl = f&quot;{(value % 1_000_000_000):09d}&quot;</span>

            <span class="s0">result = result.replace(str_extra_fmts[i], repl)</span>

    <span class="s0">return result</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># period accessors</span>

<span class="s0">ctypedef int (*accessor)(int64_t ordinal, int freq) except INT32_MIN</span>


<span class="s0">cdef int pyear(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.year</span>


<span class="s0">cdef int pqyear(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">get_yq(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.year</span>


<span class="s0">cdef int pquarter(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">int quarter</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">quarter = get_yq(ordinal, freq, &amp;dts)</span>
    <span class="s0">return quarter</span>


<span class="s0">cdef int pmonth(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.month</span>


<span class="s0">cdef int pday(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.day</span>


<span class="s0">cdef int pweekday(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dayofweek(dts.year, dts.month, dts.day)</span>


<span class="s0">cdef int pday_of_year(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return get_day_of_year(dts.year, dts.month, dts.day)</span>


<span class="s0">cdef int pweek(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return get_week_of_year(dts.year, dts.month, dts.day)</span>


<span class="s0">cdef int phour(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.hour</span>


<span class="s0">cdef int pminute(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return dts.min</span>


<span class="s0">cdef int psecond(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return &lt;int&gt;dts.sec</span>


<span class="s0">cdef int pdays_in_month(int64_t ordinal, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">npy_datetimestruct dts</span>
    <span class="s0">get_date_info(ordinal, freq, &amp;dts)</span>
    <span class="s0">return get_days_in_month(dts.year, dts.month)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def get_period_field_arr(str field, const int64_t[:] arr, int freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, sz</span>
        <span class="s0">int64_t[:] out</span>
        <span class="s0">accessor f</span>

    <span class="s0">func = _get_accessor_func(field)</span>
    <span class="s0">if func is NULL:</span>
        <span class="s0">raise ValueError(f&quot;Unrecognized field name: {field}&quot;)</span>

    <span class="s0">sz = len(arr)</span>
    <span class="s0">out = np.empty(sz, dtype=np.int64)</span>

    <span class="s0">for i in range(sz):</span>
        <span class="s0">if arr[i] == NPY_NAT:</span>
            <span class="s0">out[i] = -1</span>
            <span class="s0">continue</span>
        <span class="s0">out[i] = func(arr[i], freq)</span>

    <span class="s0">return out.base  # .base to access underlying np.ndarray</span>


<span class="s0">cdef accessor _get_accessor_func(str field):</span>
    <span class="s0">if field == &quot;year&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pyear</span>
    <span class="s0">elif field == &quot;qyear&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pqyear</span>
    <span class="s0">elif field == &quot;quarter&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pquarter</span>
    <span class="s0">elif field == &quot;month&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pmonth</span>
    <span class="s0">elif field == &quot;day&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pday</span>
    <span class="s0">elif field == &quot;hour&quot;:</span>
        <span class="s0">return &lt;accessor&gt;phour</span>
    <span class="s0">elif field == &quot;minute&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pminute</span>
    <span class="s0">elif field == &quot;second&quot;:</span>
        <span class="s0">return &lt;accessor&gt;psecond</span>
    <span class="s0">elif field == &quot;week&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pweek</span>
    <span class="s0">elif field == &quot;day_of_year&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pday_of_year</span>
    <span class="s0">elif field == &quot;weekday&quot; or field == &quot;day_of_week&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pweekday</span>
    <span class="s0">elif field == &quot;days_in_month&quot;:</span>
        <span class="s0">return &lt;accessor&gt;pdays_in_month</span>
    <span class="s0">return NULL</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def from_ordinals(const int64_t[:] values, freq):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">int64_t[:] result = np.empty(len(values), dtype=&quot;i8&quot;)</span>
        <span class="s0">int64_t val</span>

    <span class="s0">freq = to_offset(freq)</span>
    <span class="s0">if not isinstance(freq, BaseOffset):</span>
        <span class="s0">raise ValueError(&quot;freq not specified and cannot be inferred&quot;)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if val == NPY_NAT:</span>
            <span class="s0">result[i] = NPY_NAT</span>
        <span class="s0">else:</span>
            <span class="s0">result[i] = Period(val, freq=freq).ordinal</span>

    <span class="s0">return result.base</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def extract_ordinals(ndarray[object] values, freq) -&gt; np.ndarray:</span>
    <span class="s0"># TODO: Change type to const object[:] when Cython supports that.</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">int64_t[:] ordinals = np.empty(n, dtype=np.int64)</span>
        <span class="s0">object p</span>

    <span class="s0">freqstr = Period._maybe_convert_freq(freq).freqstr</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">p = values[i]</span>

        <span class="s0">if checknull_with_nat(p):</span>
            <span class="s0">ordinals[i] = NPY_NAT</span>
        <span class="s0">elif util.is_integer_object(p):</span>
            <span class="s0">if p == NPY_NAT:</span>
                <span class="s0">ordinals[i] = NPY_NAT</span>
            <span class="s0">else:</span>
                <span class="s0">raise TypeError(p)</span>
        <span class="s0">else:</span>
            <span class="s0">try:</span>
                <span class="s0">ordinals[i] = p.ordinal</span>

                <span class="s0">if p.freqstr != freqstr:</span>
                    <span class="s0">msg = DIFFERENT_FREQ.format(cls=&quot;PeriodIndex&quot;,</span>
                                                <span class="s0">own_freq=freqstr,</span>
                                                <span class="s0">other_freq=p.freqstr)</span>
                    <span class="s0">raise IncompatibleFrequency(msg)</span>

            <span class="s0">except AttributeError:</span>
                <span class="s0">p = Period(p, freq=freq)</span>
                <span class="s0">if p is NaT:</span>
                    <span class="s0"># input may contain NaT-like string</span>
                    <span class="s0">ordinals[i] = NPY_NAT</span>
                <span class="s0">else:</span>
                    <span class="s0">ordinals[i] = p.ordinal</span>

    <span class="s0">return ordinals.base  # .base to access underlying np.ndarray</span>


<span class="s0">def extract_freq(ndarray[object] values) -&gt; BaseOffset:</span>
    <span class="s0"># TODO: Change type to const object[:] when Cython supports that.</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">object value</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">value = values[i]</span>

        <span class="s0">if is_period_object(value):</span>
            <span class="s0">return value.freq</span>

    <span class="s0">raise ValueError('freq not specified and cannot be inferred')</span>

<span class="s0"># -----------------------------------------------------------------------</span>
<span class="s0"># period helpers</span>


<span class="s0">DIFFERENT_FREQ = (&quot;Input has different freq={other_freq} &quot;</span>
                  <span class="s0">&quot;from {cls}(freq={own_freq})&quot;)</span>


<span class="s0">class IncompatibleFrequency(ValueError):</span>
    <span class="s0">pass</span>


<span class="s0">cdef class PeriodMixin:</span>
    <span class="s0"># Methods shared between Period and PeriodArray</span>

    <span class="s0">cpdef int _get_to_timestamp_base(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return frequency code group used for base of to_timestamp against</span>
        <span class="s0">frequency code.</span>

        <span class="s0">Return day freq code against longer freq than day.</span>
        <span class="s0">Return second freq code against hour between second.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">if base &lt; FR_BUS:</span>
            <span class="s0">return FR_DAY</span>
        <span class="s0">elif FR_HR &lt;= base &lt;= FR_SEC:</span>
            <span class="s0">return FR_SEC</span>
        <span class="s0">return base</span>

    <span class="s0">@property</span>
    <span class="s0">def start_time(self) -&gt; Timestamp:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the Timestamp for the start of the period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">Timestamp</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.end_time : Return the end Timestamp.</span>
        <span class="s0">Period.dayofyear : Return the day of year.</span>
        <span class="s0">Period.daysinmonth : Return the days in that month.</span>
        <span class="s0">Period.dayofweek : Return the day of the week.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; period = pd.Period('2012-1-1', freq='D')</span>
        <span class="s0">&gt;&gt;&gt; period</span>
        <span class="s0">Period('2012-01-01', 'D')</span>

        <span class="s0">&gt;&gt;&gt; period.start_time</span>
        <span class="s0">Timestamp('2012-01-01 00:00:00')</span>

        <span class="s0">&gt;&gt;&gt; period.end_time</span>
        <span class="s0">Timestamp('2012-01-01 23:59:59.999999999')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.to_timestamp(how=&quot;start&quot;)</span>

    <span class="s0">@property</span>
    <span class="s0">def end_time(self) -&gt; Timestamp:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the Timestamp for the end of the period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">Timestamp</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.start_time : Return the start Timestamp.</span>
        <span class="s0">Period.dayofyear : Return the day of year.</span>
        <span class="s0">Period.daysinmonth : Return the days in that month.</span>
        <span class="s0">Period.dayofweek : Return the day of the week.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.to_timestamp(how=&quot;end&quot;)</span>

    <span class="s0">def _require_matching_freq(self, other, base=False):</span>
        <span class="s0"># See also arrays.period.raise_on_incompatible</span>
        <span class="s0">if is_offset_object(other):</span>
            <span class="s0">other_freq = other</span>
        <span class="s0">else:</span>
            <span class="s0">other_freq = other.freq</span>

        <span class="s0">if base:</span>
            <span class="s0">condition = self.freq.base != other_freq.base</span>
        <span class="s0">else:</span>
            <span class="s0">condition = self.freq != other_freq</span>

        <span class="s0">if condition:</span>
            <span class="s0">msg = DIFFERENT_FREQ.format(</span>
                <span class="s0">cls=type(self).__name__,</span>
                <span class="s0">own_freq=self.freqstr,</span>
                <span class="s0">other_freq=other_freq.freqstr,</span>
            <span class="s0">)</span>
            <span class="s0">raise IncompatibleFrequency(msg)</span>


<span class="s0">cdef class _Period(PeriodMixin):</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int64_t ordinal</span>
        <span class="s0">PeriodDtypeBase _dtype</span>
        <span class="s0">BaseOffset freq</span>

    <span class="s0"># higher than np.ndarray, np.matrix, np.timedelta64</span>
    <span class="s0">__array_priority__ = 100</span>

    <span class="s0">dayofweek = _Period.day_of_week</span>
    <span class="s0">dayofyear = _Period.day_of_year</span>

    <span class="s0">def __cinit__(self, int64_t ordinal, BaseOffset freq):</span>
        <span class="s0">self.ordinal = ordinal</span>
        <span class="s0">self.freq = freq</span>
        <span class="s0"># Note: this is more performant than PeriodDtype.from_date_offset(freq)</span>
        <span class="s0">#  because from_date_offset cannot be made a cdef method (until cython</span>
        <span class="s0">#  supported cdef classmethods)</span>
        <span class="s0">self._dtype = PeriodDtypeBase(freq._period_dtype_code)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _maybe_convert_freq(cls, object freq) -&gt; BaseOffset:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Internally we allow integer and tuple representations (for now) that</span>
        <span class="s0">are not recognized by to_offset, so we convert them here.  Also, a</span>
        <span class="s0">Period's freq attribute must have `freq.n &gt; 0`, which we check for here.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">DateOffset</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(freq, int):</span>
            <span class="s0"># We already have a dtype code</span>
            <span class="s0">dtype = PeriodDtypeBase(freq)</span>
            <span class="s0">freq = dtype.date_offset</span>

        <span class="s0">freq = to_offset(freq)</span>

        <span class="s0">if freq.n &lt;= 0:</span>
            <span class="s0">raise ValueError(&quot;Frequency must be positive, because it &quot;</span>
                             <span class="s0">f&quot;represents span: {freq.freqstr}&quot;)</span>

        <span class="s0">return freq</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_ordinal(cls, ordinal: int, freq) -&gt; &quot;Period&quot;:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Fast creation from an ordinal and freq that are already validated!</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if ordinal == NPY_NAT:</span>
            <span class="s0">return NaT</span>
        <span class="s0">else:</span>
            <span class="s0">freq = cls._maybe_convert_freq(freq)</span>
            <span class="s0">self = _Period.__new__(cls, ordinal, freq)</span>
            <span class="s0">return self</span>

    <span class="s0">def __richcmp__(self, other, op):</span>
        <span class="s0">if is_period_object(other):</span>
            <span class="s0">if other.freq != self.freq:</span>
                <span class="s0">if op == Py_EQ:</span>
                    <span class="s0">return False</span>
                <span class="s0">elif op == Py_NE:</span>
                    <span class="s0">return True</span>
                <span class="s0">self._require_matching_freq(other)</span>
            <span class="s0">return PyObject_RichCompareBool(self.ordinal, other.ordinal, op)</span>
        <span class="s0">elif other is NaT:</span>
            <span class="s0">return _nat_scalar_rules[op]</span>
        <span class="s0">elif util.is_array(other):</span>
            <span class="s0"># GH#44285</span>
            <span class="s0">if cnp.PyArray_IsZeroDim(other):</span>
                <span class="s0">return PyObject_RichCompare(self, other.item(), op)</span>
            <span class="s0">else:</span>
                <span class="s0"># in particular ndarray[object]; see test_pi_cmp_period</span>
                <span class="s0">return np.array([PyObject_RichCompare(self, x, op) for x in other])</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __hash__(self):</span>
        <span class="s0">return hash((self.ordinal, self.freqstr))</span>

    <span class="s0">def _add_timedeltalike_scalar(self, other) -&gt; &quot;Period&quot;:</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t nanos, base_nanos</span>

        <span class="s0">if is_tick_object(self.freq):</span>
            <span class="s0">nanos = delta_to_nanoseconds(other)</span>
            <span class="s0">base_nanos = self.freq.base.nanos</span>
            <span class="s0">if nanos % base_nanos == 0:</span>
                <span class="s0">ordinal = self.ordinal + (nanos // base_nanos)</span>
                <span class="s0">return Period(ordinal=ordinal, freq=self.freq)</span>
        <span class="s0">raise IncompatibleFrequency(&quot;Input cannot be converted to &quot;</span>
                                    <span class="s0">f&quot;Period(freq={self.freqstr})&quot;)</span>

    <span class="s0">def _add_offset(self, other) -&gt; &quot;Period&quot;:</span>
        <span class="s0"># Non-Tick DateOffset other</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t ordinal</span>

        <span class="s0">self._require_matching_freq(other, base=True)</span>

        <span class="s0">ordinal = self.ordinal + other.n</span>
        <span class="s0">return Period(ordinal=ordinal, freq=self.freq)</span>

    <span class="s0">def __add__(self, other):</span>
        <span class="s0">if not is_period_object(self):</span>
            <span class="s0"># cython semantics; this is analogous to a call to __radd__</span>
            <span class="s0">if self is NaT:</span>
                <span class="s0">return NaT</span>
            <span class="s0">return other.__add__(self)</span>

        <span class="s0">if is_any_td_scalar(other):</span>
            <span class="s0">return self._add_timedeltalike_scalar(other)</span>
        <span class="s0">elif is_offset_object(other):</span>
            <span class="s0">return self._add_offset(other)</span>
        <span class="s0">elif other is NaT:</span>
            <span class="s0">return NaT</span>
        <span class="s0">elif util.is_integer_object(other):</span>
            <span class="s0">ordinal = self.ordinal + other * self.freq.n</span>
            <span class="s0">return Period(ordinal=ordinal, freq=self.freq)</span>
        <span class="s0">elif (PyDateTime_Check(other) or</span>
              <span class="s0">is_period_object(other) or util.is_datetime64_object(other)):</span>
            <span class="s0"># can't add datetime-like</span>
            <span class="s0"># GH#17983</span>
            <span class="s0">sname = type(self).__name__</span>
            <span class="s0">oname = type(other).__name__</span>
            <span class="s0">raise TypeError(f&quot;unsupported operand type(s) for +: '{sname}' &quot;</span>
                            <span class="s0">f&quot;and '{oname}'&quot;)</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __sub__(self, other):</span>
        <span class="s0">if not is_period_object(self):</span>
            <span class="s0"># cython semantics; this is like a call to __rsub__</span>
            <span class="s0">if self is NaT:</span>
                <span class="s0">return NaT</span>
            <span class="s0">return NotImplemented</span>

        <span class="s0">elif is_any_td_scalar(other):</span>
            <span class="s0">neg_other = -other</span>
            <span class="s0">return self + neg_other</span>
        <span class="s0">elif is_offset_object(other):</span>
            <span class="s0"># Non-Tick DateOffset</span>
            <span class="s0">neg_other = -other</span>
            <span class="s0">return self + neg_other</span>
        <span class="s0">elif util.is_integer_object(other):</span>
            <span class="s0">ordinal = self.ordinal - other * self.freq.n</span>
            <span class="s0">return Period(ordinal=ordinal, freq=self.freq)</span>
        <span class="s0">elif is_period_object(other):</span>
            <span class="s0">self._require_matching_freq(other)</span>
            <span class="s0"># GH 23915 - mul by base freq since __add__ is agnostic of n</span>
            <span class="s0">return (self.ordinal - other.ordinal) * self.freq.base</span>
        <span class="s0">elif other is NaT:</span>
            <span class="s0">return NaT</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def asfreq(self, freq, how='E') -&gt; &quot;Period&quot;:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert Period to desired frequency, at the start or end of the interval.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">The desired frequency.</span>
        <span class="s0">how : {'E', 'S', 'end', 'start'}, default 'end'</span>
            <span class="s0">Start or end of the timespan.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">resampled : Period</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">freq = self._maybe_convert_freq(freq)</span>
        <span class="s0">how = validate_end_alias(how)</span>
        <span class="s0">base1 = self._dtype._dtype_code</span>
        <span class="s0">base2 = freq_to_dtype_code(freq)</span>

        <span class="s0"># self.n can't be negative or 0</span>
        <span class="s0">end = how == 'E'</span>
        <span class="s0">if end:</span>
            <span class="s0">ordinal = self.ordinal + self.freq.n - 1</span>
        <span class="s0">else:</span>
            <span class="s0">ordinal = self.ordinal</span>
        <span class="s0">ordinal = period_asfreq(ordinal, base1, base2, end)</span>

        <span class="s0">return Period(ordinal=ordinal, freq=freq)</span>

    <span class="s0">def to_timestamp(self, freq=None, how='start', tz=None) -&gt; Timestamp:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the Timestamp representation of the Period.</span>

        <span class="s0">Uses the target frequency specified at the part of the period specified</span>
        <span class="s0">by `how`, which is either `Start` or `Finish`.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str or DateOffset</span>
            <span class="s0">Target frequency. Default is 'D' if self.freq is week or</span>
            <span class="s0">longer and 'S' otherwise.</span>
        <span class="s0">how : str, default 'S' (start)</span>
            <span class="s0">One of 'S', 'E'. Can be aliased as case insensitive</span>
            <span class="s0">'Start', 'Finish', 'Begin', 'End'.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">Timestamp</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if tz is not None:</span>
            <span class="s0"># GH#34522</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;Period.to_timestamp `tz` argument is deprecated and will &quot;</span>
                <span class="s0">&quot;be removed in a future version.  Use &quot;</span>
                <span class="s0">&quot;`per.to_timestamp(...).tz_localize(tz)` instead.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>

        <span class="s0">how = validate_end_alias(how)</span>

        <span class="s0">end = how == 'E'</span>
        <span class="s0">if end:</span>
            <span class="s0">if freq == &quot;B&quot; or self.freq == &quot;B&quot;:</span>
                <span class="s0"># roll forward to ensure we land on B date</span>
                <span class="s0">adjust = Timedelta(1, &quot;D&quot;) - Timedelta(1, &quot;ns&quot;)</span>
                <span class="s0">return self.to_timestamp(how=&quot;start&quot;) + adjust</span>
            <span class="s0">endpoint = (self + self.freq).to_timestamp(how='start')</span>
            <span class="s0">return endpoint - Timedelta(1, 'ns')</span>

        <span class="s0">if freq is None:</span>
            <span class="s0">freq = self._get_to_timestamp_base()</span>
            <span class="s0">base = freq</span>
        <span class="s0">else:</span>
            <span class="s0">freq = self._maybe_convert_freq(freq)</span>
            <span class="s0">base = freq._period_dtype_code</span>

        <span class="s0">val = self.asfreq(freq, how)</span>

        <span class="s0">dt64 = period_ordinal_to_dt64(val.ordinal, base)</span>
        <span class="s0">return Timestamp(dt64, tz=tz)</span>

    <span class="s0">@property</span>
    <span class="s0">def year(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the year this Period falls on.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pyear(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def month(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the month this Period falls on.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pmonth(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def day(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get day of the month that a Period falls on.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.dayofweek : Get the day of the week.</span>
        <span class="s0">Period.dayofyear : Get the day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11&quot;, freq='H')</span>
        <span class="s0">&gt;&gt;&gt; p.day</span>
        <span class="s0">11</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pday(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def hour(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the hour of the day component of the Period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">The hour as an integer, between 0 and 23.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.second : Get the second component of the Period.</span>
        <span class="s0">Period.minute : Get the minute component of the Period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11 13:03:12.050000&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.hour</span>
        <span class="s0">13</span>

        <span class="s0">Period longer than a day</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11&quot;, freq=&quot;M&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.hour</span>
        <span class="s0">0</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return phour(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def minute(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get minute of the hour component of the Period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">The minute as an integer, between 0 and 59.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.hour : Get the hour component of the Period.</span>
        <span class="s0">Period.second : Get the second component of the Period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11 13:03:12.050000&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.minute</span>
        <span class="s0">3</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pminute(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def second(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the second component of the Period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">The second of the Period (ranges from 0 to 59).</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.hour : Get the hour component of the Period.</span>
        <span class="s0">Period.minute : Get the minute component of the Period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11 13:03:12.050000&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.second</span>
        <span class="s0">12</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return psecond(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def weekofyear(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the week of the year on the given Period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.dayofweek : Get the day component of the Period.</span>
        <span class="s0">Period.weekday : Get the day component of the Period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11&quot;, &quot;H&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.weekofyear</span>
        <span class="s0">10</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-02-01&quot;, &quot;D&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.weekofyear</span>
        <span class="s0">5</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-01-06&quot;, &quot;D&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.weekofyear</span>
        <span class="s0">1</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pweek(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def week(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the week of the year on the given Period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.dayofweek : Get the day component of the Period.</span>
        <span class="s0">Period.weekday : Get the day component of the Period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11&quot;, &quot;H&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.week</span>
        <span class="s0">10</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-02-01&quot;, &quot;D&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.week</span>
        <span class="s0">5</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-01-06&quot;, &quot;D&quot;)</span>
        <span class="s0">&gt;&gt;&gt; p.week</span>
        <span class="s0">1</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.weekofyear</span>

    <span class="s0">@property</span>
    <span class="s0">def day_of_week(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Day of the week the period lies in, with Monday=0 and Sunday=6.</span>

        <span class="s0">If the period frequency is lower than daily (e.g. hourly), and the</span>
        <span class="s0">period spans over multiple days, the day at the start of the period is</span>
        <span class="s0">used.</span>

        <span class="s0">If the frequency is higher than daily (e.g. monthly), the last day</span>
        <span class="s0">of the period is used.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">Day of the week.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.day_of_week : Day of the week the period lies in.</span>
        <span class="s0">Period.weekday : Alias of Period.day_of_week.</span>
        <span class="s0">Period.day : Day of the month.</span>
        <span class="s0">Period.dayofyear : Day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; per = pd.Period('2017-12-31 22:00', 'H')</span>
        <span class="s0">&gt;&gt;&gt; per.day_of_week</span>
        <span class="s0">6</span>

        <span class="s0">For periods that span over multiple days, the day at the beginning of</span>
        <span class="s0">the period is returned.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2017-12-31 22:00', '4H')</span>
        <span class="s0">&gt;&gt;&gt; per.day_of_week</span>
        <span class="s0">6</span>
        <span class="s0">&gt;&gt;&gt; per.start_time.day_of_week</span>
        <span class="s0">6</span>

        <span class="s0">For periods with a frequency higher than days, the last day of the</span>
        <span class="s0">period is returned.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2018-01', 'M')</span>
        <span class="s0">&gt;&gt;&gt; per.day_of_week</span>
        <span class="s0">2</span>
        <span class="s0">&gt;&gt;&gt; per.end_time.day_of_week</span>
        <span class="s0">2</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pweekday(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def weekday(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Day of the week the period lies in, with Monday=0 and Sunday=6.</span>

        <span class="s0">If the period frequency is lower than daily (e.g. hourly), and the</span>
        <span class="s0">period spans over multiple days, the day at the start of the period is</span>
        <span class="s0">used.</span>

        <span class="s0">If the frequency is higher than daily (e.g. monthly), the last day</span>
        <span class="s0">of the period is used.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">Day of the week.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.dayofweek : Day of the week the period lies in.</span>
        <span class="s0">Period.weekday : Alias of Period.dayofweek.</span>
        <span class="s0">Period.day : Day of the month.</span>
        <span class="s0">Period.dayofyear : Day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; per = pd.Period('2017-12-31 22:00', 'H')</span>
        <span class="s0">&gt;&gt;&gt; per.dayofweek</span>
        <span class="s0">6</span>

        <span class="s0">For periods that span over multiple days, the day at the beginning of</span>
        <span class="s0">the period is returned.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2017-12-31 22:00', '4H')</span>
        <span class="s0">&gt;&gt;&gt; per.dayofweek</span>
        <span class="s0">6</span>
        <span class="s0">&gt;&gt;&gt; per.start_time.dayofweek</span>
        <span class="s0">6</span>

        <span class="s0">For periods with a frequency higher than days, the last day of the</span>
        <span class="s0">period is returned.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2018-01', 'M')</span>
        <span class="s0">&gt;&gt;&gt; per.dayofweek</span>
        <span class="s0">2</span>
        <span class="s0">&gt;&gt;&gt; per.end_time.dayofweek</span>
        <span class="s0">2</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># Docstring is a duplicate from dayofweek. Reusing docstrings with</span>
        <span class="s0"># Appender doesn't work for properties in Cython files, and setting</span>
        <span class="s0"># the __doc__ attribute is also not possible.</span>
        <span class="s0">return self.dayofweek</span>

    <span class="s0">@property</span>
    <span class="s0">def day_of_year(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the year.</span>

        <span class="s0">This attribute returns the day of the year on which the particular</span>
        <span class="s0">date occurs. The return value ranges between 1 to 365 for regular</span>
        <span class="s0">years and 1 to 366 for leap years.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">The day of year.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.day : Return the day of the month.</span>
        <span class="s0">Period.day_of_week : Return the day of week.</span>
        <span class="s0">PeriodIndex.day_of_year : Return the day of year of all indexes.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; period = pd.Period(&quot;2015-10-23&quot;, freq='H')</span>
        <span class="s0">&gt;&gt;&gt; period.day_of_year</span>
        <span class="s0">296</span>
        <span class="s0">&gt;&gt;&gt; period = pd.Period(&quot;2012-12-31&quot;, freq='D')</span>
        <span class="s0">&gt;&gt;&gt; period.day_of_year</span>
        <span class="s0">366</span>
        <span class="s0">&gt;&gt;&gt; period = pd.Period(&quot;2013-01-01&quot;, freq='D')</span>
        <span class="s0">&gt;&gt;&gt; period.day_of_year</span>
        <span class="s0">1</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pday_of_year(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def quarter(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the quarter this Period falls on.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pquarter(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def qyear(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Fiscal year the Period lies in according to its starting-quarter.</span>

        <span class="s0">The `year` and the `qyear` of the period will be the same if the fiscal</span>
        <span class="s0">and calendar years are the same. When they are not, the fiscal year</span>
        <span class="s0">can be different from the calendar year of the period.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>
            <span class="s0">The fiscal year of the period.</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.year : Return the calendar year of the period.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">If the natural and fiscal year are the same, `qyear` and `year` will</span>
        <span class="s0">be the same.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2018Q1', freq='Q')</span>
        <span class="s0">&gt;&gt;&gt; per.qyear</span>
        <span class="s0">2018</span>
        <span class="s0">&gt;&gt;&gt; per.year</span>
        <span class="s0">2018</span>

        <span class="s0">If the fiscal year starts in April (`Q-MAR`), the first quarter of</span>
        <span class="s0">2018 will start in April 2017. `year` will then be 2018, but `qyear`</span>
        <span class="s0">will be the fiscal year, 2018.</span>

        <span class="s0">&gt;&gt;&gt; per = pd.Period('2018Q1', freq='Q-MAR')</span>
        <span class="s0">&gt;&gt;&gt; per.start_time</span>
        <span class="s0">Timestamp('2017-04-01 00:00:00')</span>
        <span class="s0">&gt;&gt;&gt; per.qyear</span>
        <span class="s0">2018</span>
        <span class="s0">&gt;&gt;&gt; per.year</span>
        <span class="s0">2017</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pqyear(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def days_in_month(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the total number of days in the month that this period falls on.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.daysinmonth : Gets the number of days in the month.</span>
        <span class="s0">DatetimeIndex.daysinmonth : Gets the number of days in the month.</span>
        <span class="s0">calendar.monthrange : Returns a tuple containing weekday</span>
            <span class="s0">(0-6 ~ Mon-Sun) and number of days (28-31).</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period('2018-2-17')</span>
        <span class="s0">&gt;&gt;&gt; p.days_in_month</span>
        <span class="s0">28</span>

        <span class="s0">&gt;&gt;&gt; pd.Period('2018-03-01').days_in_month</span>
        <span class="s0">31</span>

        <span class="s0">Handles the leap year case as well:</span>

        <span class="s0">&gt;&gt;&gt; p = pd.Period('2016-2-17')</span>
        <span class="s0">&gt;&gt;&gt; p.days_in_month</span>
        <span class="s0">29</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return pdays_in_month(self.ordinal, base)</span>

    <span class="s0">@property</span>
    <span class="s0">def daysinmonth(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the total number of days of the month that the Period falls in.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">int</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">Period.days_in_month : Return the days of the month.</span>
        <span class="s0">Period.dayofyear : Return the day of the year.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; p = pd.Period(&quot;2018-03-11&quot;, freq='H')</span>
        <span class="s0">&gt;&gt;&gt; p.daysinmonth</span>
        <span class="s0">31</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.days_in_month</span>

    <span class="s0">@property</span>
    <span class="s0">def is_leap_year(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if the period's year is in a leap year.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return bool(is_leapyear(self.year))</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def now(cls, freq=None):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the period of now's date.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return Period(datetime.now(), freq=freq)</span>

    <span class="s0">@property</span>
    <span class="s0">def freqstr(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a string representation of the frequency.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.freq.freqstr</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">formatted = period_format(self.ordinal, base)</span>
        <span class="s0">return f&quot;Period('{formatted}', '{self.freqstr}')&quot;</span>

    <span class="s0">def __str__(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a string representation for a particular DataFrame</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">formatted = period_format(self.ordinal, base)</span>
        <span class="s0">value = str(formatted)</span>
        <span class="s0">return value</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">self.freq = state[1]</span>
        <span class="s0">self.ordinal = state[2]</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">object_state = None, self.freq, self.ordinal</span>
        <span class="s0">return (Period, object_state)</span>

    <span class="s0">def strftime(self, fmt: str) -&gt; str:</span>
        <span class="s0">r&quot;&quot;&quot;</span>
        <span class="s0">Returns the string representation of the :class:`Period`, depending</span>
        <span class="s0">on the selected ``fmt``. ``fmt`` must be a string</span>
        <span class="s0">containing one or several directives.  The method recognizes the same</span>
        <span class="s0">directives as the :func:`time.strftime` function of the standard Python</span>
        <span class="s0">distribution, as well as the specific additional directives ``%f``,</span>
        <span class="s0">``%F``, ``%q``. (formatting &amp; docs originally from scikits.timeries).</span>

        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| Directive | Meaning                        | Notes |</span>
        <span class="s0">+===========+================================+=======+</span>
        <span class="s0">| ``%a``    | Locale's abbreviated weekday   |       |</span>
        <span class="s0">|           | name.                          |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%A``    | Locale's full weekday name.    |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%b``    | Locale's abbreviated month     |       |</span>
        <span class="s0">|           | name.                          |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%B``    | Locale's full month name.      |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%c``    | Locale's appropriate date and  |       |</span>
        <span class="s0">|           | time representation.           |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%d``    | Day of the month as a decimal  |       |</span>
        <span class="s0">|           | number [01,31].                |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%f``    | 'Fiscal' year without a        | \(1)  |</span>
        <span class="s0">|           | century  as a decimal number   |       |</span>
        <span class="s0">|           | [00,99]                        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%F``    | 'Fiscal' year with a century   | \(2)  |</span>
        <span class="s0">|           | as a decimal number            |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%H``    | Hour (24-hour clock) as a      |       |</span>
        <span class="s0">|           | decimal number [00,23].        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%I``    | Hour (12-hour clock) as a      |       |</span>
        <span class="s0">|           | decimal number [01,12].        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%j``    | Day of the year as a decimal   |       |</span>
        <span class="s0">|           | number [001,366].              |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%m``    | Month as a decimal number      |       |</span>
        <span class="s0">|           | [01,12].                       |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%M``    | Minute as a decimal number     |       |</span>
        <span class="s0">|           | [00,59].                       |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%p``    | Locale's equivalent of either  | \(3)  |</span>
        <span class="s0">|           | AM or PM.                      |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%q``    | Quarter as a decimal number    |       |</span>
        <span class="s0">|           | [01,04]                        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%S``    | Second as a decimal number     | \(4)  |</span>
        <span class="s0">|           | [00,61].                       |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%U``    | Week number of the year        | \(5)  |</span>
        <span class="s0">|           | (Sunday as the first day of    |       |</span>
        <span class="s0">|           | the week) as a decimal number  |       |</span>
        <span class="s0">|           | [00,53].  All days in a new    |       |</span>
        <span class="s0">|           | year preceding the first       |       |</span>
        <span class="s0">|           | Sunday are considered to be in |       |</span>
        <span class="s0">|           | week 0.                        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%w``    | Weekday as a decimal number    |       |</span>
        <span class="s0">|           | [0(Sunday),6].                 |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%W``    | Week number of the year        | \(5)  |</span>
        <span class="s0">|           | (Monday as the first day of    |       |</span>
        <span class="s0">|           | the week) as a decimal number  |       |</span>
        <span class="s0">|           | [00,53].  All days in a new    |       |</span>
        <span class="s0">|           | year preceding the first       |       |</span>
        <span class="s0">|           | Monday are considered to be in |       |</span>
        <span class="s0">|           | week 0.                        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%x``    | Locale's appropriate date      |       |</span>
        <span class="s0">|           | representation.                |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%X``    | Locale's appropriate time      |       |</span>
        <span class="s0">|           | representation.                |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%y``    | Year without century as a      |       |</span>
        <span class="s0">|           | decimal number [00,99].        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%Y``    | Year with century as a decimal |       |</span>
        <span class="s0">|           | number.                        |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%Z``    | Time zone name (no characters  |       |</span>
        <span class="s0">|           | if no time zone exists).       |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>
        <span class="s0">| ``%%``    | A literal ``'%'`` character.   |       |</span>
        <span class="s0">+-----------+--------------------------------+-------+</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>

        <span class="s0">(1)</span>
            <span class="s0">The ``%f`` directive is the same as ``%y`` if the frequency is</span>
            <span class="s0">not quarterly.</span>
            <span class="s0">Otherwise, it corresponds to the 'fiscal' year, as defined by</span>
            <span class="s0">the :attr:`qyear` attribute.</span>

        <span class="s0">(2)</span>
            <span class="s0">The ``%F`` directive is the same as ``%Y`` if the frequency is</span>
            <span class="s0">not quarterly.</span>
            <span class="s0">Otherwise, it corresponds to the 'fiscal' year, as defined by</span>
            <span class="s0">the :attr:`qyear` attribute.</span>

        <span class="s0">(3)</span>
            <span class="s0">The ``%p`` directive only affects the output hour field</span>
            <span class="s0">if the ``%I`` directive is used to parse the hour.</span>

        <span class="s0">(4)</span>
            <span class="s0">The range really is ``0`` to ``61``; this accounts for leap</span>
            <span class="s0">seconds and the (very rare) double leap seconds.</span>

        <span class="s0">(5)</span>
            <span class="s0">The ``%U`` and ``%W`` directives are only used in calculations</span>
            <span class="s0">when the day of the week and the year are specified.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>

        <span class="s0">&gt;&gt;&gt; a = Period(freq='Q-JUL', year=2006, quarter=1)</span>
        <span class="s0">&gt;&gt;&gt; a.strftime('%F-Q%q')</span>
        <span class="s0">'2006-Q1'</span>
        <span class="s0">&gt;&gt;&gt; # Output the last month in the quarter of this date</span>
        <span class="s0">&gt;&gt;&gt; a.strftime('%b-%Y')</span>
        <span class="s0">'Oct-2005'</span>
        <span class="s0">&gt;&gt;&gt;</span>
        <span class="s0">&gt;&gt;&gt; a = Period(freq='D', year=2001, month=1, day=1)</span>
        <span class="s0">&gt;&gt;&gt; a.strftime('%d-%b-%Y')</span>
        <span class="s0">'01-Jan-2001'</span>
        <span class="s0">&gt;&gt;&gt; a.strftime('%b. %d, %Y was a %A')</span>
        <span class="s0">'Jan. 01, 2001 was a Monday'</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">base = self._dtype._dtype_code</span>
        <span class="s0">return period_format(self.ordinal, base, fmt)</span>


<span class="s0">class Period(_Period):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Represents a period of time.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">value : Period or str, default None</span>
        <span class="s0">The time period represented (e.g., '4Q2005').</span>
    <span class="s0">freq : str, default None</span>
        <span class="s0">One of pandas period strings or corresponding objects.</span>
    <span class="s0">ordinal : int, default None</span>
        <span class="s0">The period offset from the proleptic Gregorian epoch.</span>
    <span class="s0">year : int, default None</span>
        <span class="s0">Year value of the period.</span>
    <span class="s0">month : int, default 1</span>
        <span class="s0">Month value of the period.</span>
    <span class="s0">quarter : int, default None</span>
        <span class="s0">Quarter value of the period.</span>
    <span class="s0">day : int, default 1</span>
        <span class="s0">Day value of the period.</span>
    <span class="s0">hour : int, default 0</span>
        <span class="s0">Hour value of the period.</span>
    <span class="s0">minute : int, default 0</span>
        <span class="s0">Minute value of the period.</span>
    <span class="s0">second : int, default 0</span>
        <span class="s0">Second value of the period.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __new__(cls, value=None, freq=None, ordinal=None,</span>
                <span class="s0">year=None, month=None, quarter=None, day=None,</span>
                <span class="s0">hour=None, minute=None, second=None):</span>
        <span class="s0"># freq points to a tuple (base, mult);  base is one of the defined</span>
        <span class="s0"># periods such as A, Q, etc. Every five minutes would be, e.g.,</span>
        <span class="s0"># ('T', 5) but may be passed in as a string like '5T'</span>

        <span class="s0"># ordinal is the period offset from the gregorian proleptic epoch</span>
        <span class="s0">cdef _Period self</span>

        <span class="s0">if freq is not None:</span>
            <span class="s0">freq = cls._maybe_convert_freq(freq)</span>
        <span class="s0">nanosecond = 0</span>

        <span class="s0">if ordinal is not None and value is not None:</span>
            <span class="s0">raise ValueError(&quot;Only value or ordinal but not both should be &quot;</span>
                             <span class="s0">&quot;given but not both&quot;)</span>
        <span class="s0">elif ordinal is not None:</span>
            <span class="s0">if not util.is_integer_object(ordinal):</span>
                <span class="s0">raise ValueError(&quot;Ordinal must be an integer&quot;)</span>
            <span class="s0">if freq is None:</span>
                <span class="s0">raise ValueError('Must supply freq for ordinal value')</span>

        <span class="s0">elif value is None:</span>
            <span class="s0">if (year is None and month is None and</span>
                    <span class="s0">quarter is None and day is None and</span>
                    <span class="s0">hour is None and minute is None and second is None):</span>
                <span class="s0">ordinal = NPY_NAT</span>
            <span class="s0">else:</span>
                <span class="s0">if freq is None:</span>
                    <span class="s0">raise ValueError(&quot;If value is None, freq cannot be None&quot;)</span>

                <span class="s0"># set defaults</span>
                <span class="s0">month = 1 if month is None else month</span>
                <span class="s0">day = 1 if day is None else day</span>
                <span class="s0">hour = 0 if hour is None else hour</span>
                <span class="s0">minute = 0 if minute is None else minute</span>
                <span class="s0">second = 0 if second is None else second</span>

                <span class="s0">ordinal = _ordinal_from_fields(year, month, quarter, day,</span>
                                               <span class="s0">hour, minute, second, freq)</span>

        <span class="s0">elif is_period_object(value):</span>
            <span class="s0">other = value</span>
            <span class="s0">if freq is None or freq._period_dtype_code == other.freq._period_dtype_code:</span>
                <span class="s0">ordinal = other.ordinal</span>
                <span class="s0">freq = other.freq</span>
            <span class="s0">else:</span>
                <span class="s0">converted = other.asfreq(freq)</span>
                <span class="s0">ordinal = converted.ordinal</span>

        <span class="s0">elif checknull_with_nat(value) or (isinstance(value, str) and</span>
                                           <span class="s0">value in nat_strings):</span>
            <span class="s0"># explicit str check is necessary to avoid raising incorrectly</span>
            <span class="s0">#  if we have a non-hashable value.</span>
            <span class="s0">ordinal = NPY_NAT</span>

        <span class="s0">elif isinstance(value, str) or util.is_integer_object(value):</span>
            <span class="s0">if util.is_integer_object(value):</span>
                <span class="s0">if value == NPY_NAT:</span>
                    <span class="s0">value = &quot;NaT&quot;</span>

                <span class="s0">value = str(value)</span>
            <span class="s0">value = value.upper()</span>
            <span class="s0">dt, reso = parse_time_string(value, freq)</span>
            <span class="s0">try:</span>
                <span class="s0">ts = Timestamp(value)</span>
            <span class="s0">except ValueError:</span>
                <span class="s0">nanosecond = 0</span>
            <span class="s0">else:</span>
                <span class="s0">nanosecond = ts.nanosecond</span>
                <span class="s0">if nanosecond != 0:</span>
                    <span class="s0">reso = 'nanosecond'</span>
            <span class="s0">if dt is NaT:</span>
                <span class="s0">ordinal = NPY_NAT</span>

            <span class="s0">if freq is None:</span>
                <span class="s0">try:</span>
                    <span class="s0">freq = attrname_to_abbrevs[reso]</span>
                <span class="s0">except KeyError:</span>
                    <span class="s0">raise ValueError(f&quot;Invalid frequency or could not &quot;</span>
                                     <span class="s0">f&quot;infer: {reso}&quot;)</span>
                <span class="s0">freq = to_offset(freq)</span>

        <span class="s0">elif PyDateTime_Check(value):</span>
            <span class="s0">dt = value</span>
            <span class="s0">if freq is None:</span>
                <span class="s0">raise ValueError('Must supply freq for datetime value')</span>
        <span class="s0">elif util.is_datetime64_object(value):</span>
            <span class="s0">dt = Timestamp(value)</span>
            <span class="s0">if freq is None:</span>
                <span class="s0">raise ValueError('Must supply freq for datetime value')</span>
        <span class="s0">elif PyDate_Check(value):</span>
            <span class="s0">dt = datetime(year=value.year, month=value.month, day=value.day)</span>
            <span class="s0">if freq is None:</span>
                <span class="s0">raise ValueError('Must supply freq for datetime value')</span>
        <span class="s0">else:</span>
            <span class="s0">msg = &quot;Value must be Period, string, integer, or datetime&quot;</span>
            <span class="s0">raise ValueError(msg)</span>

        <span class="s0">if ordinal is None:</span>
            <span class="s0">base = freq_to_dtype_code(freq)</span>
            <span class="s0">ordinal = period_ordinal(dt.year, dt.month, dt.day,</span>
                                     <span class="s0">dt.hour, dt.minute, dt.second,</span>
                                     <span class="s0">dt.microsecond, 1000*nanosecond, base)</span>

        <span class="s0">return cls._from_ordinal(ordinal, freq)</span>


<span class="s0">cdef bint is_period_object(object obj):</span>
    <span class="s0">return isinstance(obj, _Period)</span>


<span class="s0">cpdef int freq_to_dtype_code(BaseOffset freq) except? -1:</span>
    <span class="s0">try:</span>
        <span class="s0">return freq._period_dtype_code</span>
    <span class="s0">except AttributeError as err:</span>
        <span class="s0">raise ValueError(INVALID_FREQ_ERR_MSG.format(freq)) from err</span>


<span class="s0">cdef int64_t _ordinal_from_fields(int year, int month, quarter, int day,</span>
                                  <span class="s0">int hour, int minute, int second,</span>
                                  <span class="s0">BaseOffset freq):</span>
    <span class="s0">base = freq_to_dtype_code(freq)</span>
    <span class="s0">if quarter is not None:</span>
        <span class="s0">year, month = quarter_to_myear(year, quarter, freq.freqstr)</span>

    <span class="s0">return period_ordinal(year, month, day, hour,</span>
                          <span class="s0">minute, second, 0, 0, base)</span>


<span class="s0">def validate_end_alias(how: str) -&gt; str:  # Literal[&quot;E&quot;, &quot;S&quot;]</span>
    <span class="s0">how_dict = {'S': 'S', 'E': 'E',</span>
                <span class="s0">'START': 'S', 'FINISH': 'E',</span>
                <span class="s0">'BEGIN': 'S', 'END': 'E'}</span>
    <span class="s0">how = how_dict.get(str(how).upper())</span>
    <span class="s0">if how not in {'S', 'E'}:</span>
        <span class="s0">raise ValueError('How must be one of S or E')</span>
    <span class="s0">return how</span>
</pre>
</body>
</html>