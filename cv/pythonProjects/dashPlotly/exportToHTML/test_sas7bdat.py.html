<html>
<head>
<title>test_sas7bdat.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sas7bdat.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>

<span class="s0">import </span><span class="s1">dateutil.parser</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">EmptyDataError</span>
<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>


<span class="s2"># https://github.com/cython/cython/issues/1720</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:can't resolve package:ImportWarning&quot;</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestSAS7BDAT:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">setup_method(self</span><span class="s0">, </span><span class="s1">datapath):</span>
        <span class="s1">self.dirpath = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s1">self.data = []</span>
        <span class="s1">self.test_ix = [list(range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">16</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s4">16</span><span class="s1">]]</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test_sas7bdat_</span><span class="s0">{</span><span class="s1">j</span><span class="s0">}</span><span class="s3">.csv&quot;</span><span class="s1">)</span>
            <span class="s1">df = pd.read_csv(fname)</span>
            <span class="s1">epoch = datetime(</span><span class="s4">1960</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">t1 = pd.to_timedelta(df[</span><span class="s3">&quot;Column4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">unit=</span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
            <span class="s1">df[</span><span class="s3">&quot;Column4&quot;</span><span class="s1">] = epoch + t1</span>
            <span class="s1">t2 = pd.to_timedelta(df[</span><span class="s3">&quot;Column12&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">unit=</span><span class="s3">&quot;d&quot;</span><span class="s1">)</span>
            <span class="s1">df[</span><span class="s3">&quot;Column12&quot;</span><span class="s1">] = epoch + t2</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(df.shape[</span><span class="s4">1</span><span class="s1">]):</span>
                <span class="s1">col = df.iloc[:</span><span class="s0">, </span><span class="s1">k]</span>
                <span class="s0">if </span><span class="s1">col.dtype == np.int64:</span>
                    <span class="s1">df.iloc[:</span><span class="s0">, </span><span class="s1">k] = df.iloc[:</span><span class="s0">, </span><span class="s1">k].astype(np.float64)</span>
            <span class="s1">self.data.append(df)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_from_file(self):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df0 = self.data[j]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">)</span>
                <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
                <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_from_buffer(self):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df0 = self.data[j]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">open(fname</span><span class="s0">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                    <span class="s1">byts = f.read()</span>
                <span class="s1">buf = io.BytesIO(byts)</span>
                <span class="s0">with </span><span class="s1">pd.read_sas(</span>
                    <span class="s1">buf</span><span class="s0">, </span><span class="s1">format=</span><span class="s3">&quot;sas7bdat&quot;</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span>
                <span class="s1">) </span><span class="s0">as </span><span class="s1">rdr:</span>
                    <span class="s1">df = rdr.read()</span>
                <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_from_iterator(self):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df0 = self.data[j]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">pd.read_sas(fname</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">rdr:</span>
                    <span class="s1">df = rdr.read(</span><span class="s4">2</span><span class="s1">)</span>
                    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0.iloc[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">2</span><span class="s0">, </span><span class="s1">:])</span>
                    <span class="s1">df = rdr.read(</span><span class="s4">3</span><span class="s1">)</span>
                    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0.iloc[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">5</span><span class="s0">, </span><span class="s1">:])</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_path_pathlib(self):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df0 = self.data[j]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s1">fname = Path(os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">))</span>
                <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
                <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>

    <span class="s1">@td.skip_if_no(</span><span class="s3">&quot;py.path&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_path_localpath(self):</span>
        <span class="s0">from </span><span class="s1">py.path </span><span class="s0">import </span><span class="s1">local </span><span class="s0">as </span><span class="s1">LocalPath</span>

        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df0 = self.data[j]</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s1">fname = LocalPath(os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">))</span>
                <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
                <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_iterator_loop(self):</span>
        <span class="s2"># github #13654</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.test_ix[j]:</span>
                <span class="s0">for </span><span class="s1">chunksize </span><span class="s0">in </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">11</span><span class="s1">):</span>
                    <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">)</span>
                    <span class="s0">with </span><span class="s1">pd.read_sas(</span>
                        <span class="s1">fname</span><span class="s0">, </span><span class="s1">chunksize=chunksize</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span>
                    <span class="s1">) </span><span class="s0">as </span><span class="s1">rdr:</span>
                        <span class="s1">y = </span><span class="s4">0</span>
                        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">rdr:</span>
                            <span class="s1">y += x.shape[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s0">assert </span><span class="s1">y == rdr.row_count</span>

    <span class="s0">def </span><span class="s1">test_iterator_read_too_much(self):</span>
        <span class="s2"># github #14734</span>
        <span class="s1">k = self.test_ix[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">fname = os.path.join(self.dirpath</span><span class="s0">, </span><span class="s3">f&quot;test</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">.sas7bdat&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pd.read_sas(</span>
            <span class="s1">fname</span><span class="s0">, </span><span class="s1">format=</span><span class="s3">&quot;sas7bdat&quot;</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">rdr:</span>
            <span class="s1">d1 = rdr.read(rdr.row_count + </span><span class="s4">20</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pd.read_sas(fname</span><span class="s0">, </span><span class="s1">iterator=</span><span class="s0">True, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">rdr:</span>
            <span class="s1">d2 = rdr.read(rdr.row_count + </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(d1</span><span class="s0">, </span><span class="s1">d2)</span>


<span class="s0">def </span><span class="s1">test_encoding_options(datapath):</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;test1.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df1 = pd.read_sas(fname)</span>
    <span class="s1">df2 = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">df1.columns:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df1[col] = df1[col].str.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">pass</span>
    <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df2)</span>

    <span class="s0">from </span><span class="s1">pandas.io.sas.sas7bdat </span><span class="s0">import </span><span class="s1">SAS7BDATReader</span>

    <span class="s1">rdr = SAS7BDATReader(fname</span><span class="s0">, </span><span class="s1">convert_header_text=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">df3 = rdr.read()</span>
    <span class="s1">rdr.close()</span>
    <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip(df1.columns</span><span class="s0">, </span><span class="s1">df3.columns):</span>
        <span class="s0">assert </span><span class="s1">x == y.decode()</span>


<span class="s0">def </span><span class="s1">test_productsales(datapath):</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;productsales.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;productsales.csv&quot;</span><span class="s1">)</span>
    <span class="s1">df0 = pd.read_csv(fname</span><span class="s0">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;MONTH&quot;</span><span class="s1">])</span>
    <span class="s1">vn = [</span><span class="s3">&quot;ACTUAL&quot;</span><span class="s0">, </span><span class="s3">&quot;PREDICT&quot;</span><span class="s0">, </span><span class="s3">&quot;QUARTER&quot;</span><span class="s0">, </span><span class="s3">&quot;YEAR&quot;</span><span class="s1">]</span>
    <span class="s1">df0[vn] = df0[vn].astype(np.float64)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>


<span class="s0">def </span><span class="s1">test_12659(datapath):</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;test_12659.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;test_12659.csv&quot;</span><span class="s1">)</span>
    <span class="s1">df0 = pd.read_csv(fname)</span>
    <span class="s1">df0 = df0.astype(np.float64)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>


<span class="s0">def </span><span class="s1">test_airline(datapath):</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;airline.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;airline.csv&quot;</span><span class="s1">)</span>
    <span class="s1">df0 = pd.read_csv(fname)</span>
    <span class="s1">df0 = df0.astype(np.float64)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_date_time(datapath):</span>
    <span class="s2"># Support of different SAS date/datetime formats (PR #15871)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;datetime.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;datetime.csv&quot;</span><span class="s1">)</span>
    <span class="s1">df0 = pd.read_csv(</span>
        <span class="s1">fname</span><span class="s0">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;Date1&quot;</span><span class="s0">, </span><span class="s3">&quot;Date2&quot;</span><span class="s0">, </span><span class="s3">&quot;DateTime&quot;</span><span class="s0">, </span><span class="s3">&quot;DateTimeHi&quot;</span><span class="s0">, </span><span class="s3">&quot;Taiw&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2"># GH 19732: Timestamps imported from sas will incur floating point errors</span>
    <span class="s1">df.iloc[:</span><span class="s0">, </span><span class="s4">3</span><span class="s1">] = df.iloc[:</span><span class="s0">, </span><span class="s4">3</span><span class="s1">].dt.round(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>


<span class="s0">def </span><span class="s1">test_compact_numerical_values(datapath):</span>
    <span class="s2"># Regression test for #21616</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;cars.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;latin-1&quot;</span><span class="s1">)</span>
    <span class="s2"># The two columns CYL and WGT in cars.sas7bdat have column</span>
    <span class="s2"># width &lt; 8 and only contain integral values.</span>
    <span class="s2"># Test that pandas doesn't corrupt the numbers by adding</span>
    <span class="s2"># decimals.</span>
    <span class="s1">result = df[</span><span class="s3">&quot;WGT&quot;</span><span class="s1">]</span>
    <span class="s1">expected = df[</span><span class="s3">&quot;WGT&quot;</span><span class="s1">].round()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">result = df[</span><span class="s3">&quot;CYL&quot;</span><span class="s1">]</span>
    <span class="s1">expected = df[</span><span class="s3">&quot;CYL&quot;</span><span class="s1">].round()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_many_columns(datapath):</span>
    <span class="s2"># Test for looking for column information in more places (PR #22628)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;many_columns.sas7bdat&quot;</span><span class="s1">)</span>

    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;latin-1&quot;</span><span class="s1">)</span>

    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;many_columns.csv&quot;</span><span class="s1">)</span>
    <span class="s1">df0 = pd.read_csv(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;latin-1&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df0)</span>


<span class="s0">def </span><span class="s1">test_inconsistent_number_of_rows(datapath):</span>
    <span class="s2"># Regression test for issue #16615. (PR #22628)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;load_log.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;latin-1&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(df) == </span><span class="s4">2097</span>


<span class="s0">def </span><span class="s1">test_zero_variables(datapath):</span>
    <span class="s2"># Check if the SAS file has zero variables (PR #18184)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;zero_variables.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(EmptyDataError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;No columns to parse from file&quot;</span><span class="s1">):</span>
        <span class="s1">pd.read_sas(fname)</span>


<span class="s0">def </span><span class="s1">test_corrupt_read(datapath):</span>
    <span class="s2"># We don't really care about the exact failure, the important thing is</span>
    <span class="s2"># that the resource should be cleaned up afterwards (BUG #35566)</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;corrupt.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;'SAS7BDATReader' object has no attribute 'row_count'&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">pd.read_sas(fname)</span>


<span class="s0">def </span><span class="s1">round_datetime_to_ms(ts):</span>
    <span class="s0">if </span><span class="s1">isinstance(ts</span><span class="s0">, </span><span class="s1">datetime):</span>
        <span class="s0">return </span><span class="s1">ts.replace(microsecond=int(round(ts.microsecond</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">) / </span><span class="s4">1000</span><span class="s1">) * </span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(ts</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">_ts = dateutil.parser.parse(timestr=ts)</span>
        <span class="s0">return </span><span class="s1">_ts.replace(microsecond=int(round(_ts.microsecond</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">) / </span><span class="s4">1000</span><span class="s1">) * </span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">ts</span>


<span class="s0">def </span><span class="s1">test_max_sas_date(datapath):</span>
    <span class="s2"># GH 20927</span>
    <span class="s2"># NB. max datetime in SAS dataset is 31DEC9999:23:59:59.999</span>
    <span class="s2">#    but this is read as 29DEC9999:23:59:59.998993 by a buggy</span>
    <span class="s2">#    sas7bdat module</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;max_sas_date.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;iso-8859-1&quot;</span><span class="s1">)</span>

    <span class="s2"># SAS likes to left pad strings with spaces - lstrip before comparing</span>
    <span class="s1">df = df.applymap(</span><span class="s0">lambda </span><span class="s1">x: x.lstrip() </span><span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">else </span><span class="s1">x)</span>
    <span class="s2"># GH 19732: Timestamps imported from sas will incur floating point errors</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">].dt.round(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">pd._libs.tslibs.np_datetime.OutOfBoundsDatetime:</span>
        <span class="s1">df = df.applymap(round_datetime_to_ms)</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">].apply(round_datetime_to_ms)</span>
    <span class="s2"># if there are any date/times &gt; pandas.Timestamp.max then ALL in that chunk</span>
    <span class="s2"># are returned as datetime.datetime</span>
    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;text&quot;</span><span class="s1">: [</span><span class="s3">&quot;max&quot;</span><span class="s0">, </span><span class="s3">&quot;normal&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">&quot;dt_as_float&quot;</span><span class="s1">: [</span><span class="s4">253717747199.999</span><span class="s0">, </span><span class="s4">1880323199.999</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">: [</span>
                <span class="s1">datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s0">, </span><span class="s4">23</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">999000</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">datetime(</span><span class="s4">2019</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">23</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">999000</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s3">&quot;date_as_float&quot;</span><span class="s1">: [</span><span class="s4">2936547.0</span><span class="s0">, </span><span class="s4">21762.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3">&quot;date_as_date&quot;</span><span class="s1">: [datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s4">2019</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;text&quot;</span><span class="s0">, </span><span class="s3">&quot;dt_as_float&quot;</span><span class="s0">, </span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s0">, </span><span class="s3">&quot;date_as_float&quot;</span><span class="s0">, </span><span class="s3">&quot;date_as_date&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_max_sas_date_iterator(datapath):</span>
    <span class="s2"># GH 20927</span>
    <span class="s2"># when called as an iterator, only those chunks with a date &gt; pd.Timestamp.max</span>
    <span class="s2"># are returned as datetime.datetime, if this happens that whole chunk is returned</span>
    <span class="s2"># as datetime.datetime</span>
    <span class="s1">col_order = [</span><span class="s3">&quot;text&quot;</span><span class="s0">, </span><span class="s3">&quot;dt_as_float&quot;</span><span class="s0">, </span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s0">, </span><span class="s3">&quot;date_as_float&quot;</span><span class="s0">, </span><span class="s3">&quot;date_as_date&quot;</span><span class="s1">]</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;max_sas_date.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">results = []</span>
    <span class="s0">for </span><span class="s1">df </span><span class="s0">in </span><span class="s1">pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;iso-8859-1&quot;</span><span class="s0">, </span><span class="s1">chunksize=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2"># SAS likes to left pad strings with spaces - lstrip before comparing</span>
        <span class="s1">df = df.applymap(</span><span class="s0">lambda </span><span class="s1">x: x.lstrip() </span><span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">else </span><span class="s1">x)</span>
        <span class="s2"># GH 19732: Timestamps imported from sas will incur floating point errors</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">].dt.round(</span><span class="s3">&quot;us&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">pd._libs.tslibs.np_datetime.OutOfBoundsDatetime:</span>
            <span class="s1">df = df.applymap(round_datetime_to_ms)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">].apply(round_datetime_to_ms)</span>
        <span class="s1">df.reset_index(inplace=</span><span class="s0">True, </span><span class="s1">drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">results.append(df)</span>
    <span class="s1">expected = [</span>
        <span class="s1">pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;text&quot;</span><span class="s1">: [</span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;dt_as_float&quot;</span><span class="s1">: [</span><span class="s4">253717747199.999</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">: [datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s0">, </span><span class="s4">23</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">999000</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s3">&quot;date_as_float&quot;</span><span class="s1">: [</span><span class="s4">2936547.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;date_as_date&quot;</span><span class="s1">: [datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">columns=col_order</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;text&quot;</span><span class="s1">: [</span><span class="s3">&quot;normal&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;dt_as_float&quot;</span><span class="s1">: [</span><span class="s4">1880323199.999</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;dt_as_dt&quot;</span><span class="s1">: [np.datetime64(</span><span class="s3">&quot;2019-08-01 23:59:59.999&quot;</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s3">&quot;date_as_float&quot;</span><span class="s1">: [</span><span class="s4">21762.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3">&quot;date_as_date&quot;</span><span class="s1">: [np.datetime64(</span><span class="s3">&quot;2019-08-01&quot;</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">columns=col_order</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">result</span><span class="s0">, </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">zip(results</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_null_date(datapath):</span>
    <span class="s1">fname = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s0">, </span><span class="s3">&quot;sas&quot;</span><span class="s0">, </span><span class="s3">&quot;data&quot;</span><span class="s0">, </span><span class="s3">&quot;dates_null.sas7bdat&quot;</span><span class="s1">)</span>
    <span class="s1">df = pd.read_sas(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;datecol&quot;</span><span class="s1">: [</span>
                <span class="s1">datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">pd.NaT</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s3">&quot;datetimecol&quot;</span><span class="s1">: [</span>
                <span class="s1">datetime(</span><span class="s4">9999</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">29</span><span class="s0">, </span><span class="s4">23</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">59</span><span class="s0">, </span><span class="s4">998993</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">pd.NaT</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>