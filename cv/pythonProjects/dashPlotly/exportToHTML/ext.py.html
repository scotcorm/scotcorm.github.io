<html>
<head>
<title>ext.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ext.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Extension API for adding custom tags and behavior.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">pprint</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">Markup</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">defaults</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateAssertionError</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateSyntaxError</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">concat  </span><span class="s3"># type: ignore</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Context</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Undefined</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">import_string</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pass_context</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">Token</span>
    <span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">TokenStream</span>
    <span class="s2">from </span><span class="s1">.parser </span><span class="s2">import </span><span class="s1">Parser</span>

    <span class="s2">class </span><span class="s1">_TranslationsBasic(te.Protocol):</span>
        <span class="s2">def </span><span class="s1">gettext(self</span><span class="s2">, </span><span class="s1">message: str) -&gt; str:</span>
            <span class="s1">...</span>

        <span class="s2">def </span><span class="s1">ngettext(self</span><span class="s2">, </span><span class="s1">singular: str</span><span class="s2">, </span><span class="s1">plural: str</span><span class="s2">, </span><span class="s1">n: int) -&gt; str:</span>
            <span class="s2">pass</span>

    <span class="s2">class </span><span class="s1">_TranslationsContext(_TranslationsBasic):</span>
        <span class="s2">def </span><span class="s1">pgettext(self</span><span class="s2">, </span><span class="s1">context: str</span><span class="s2">, </span><span class="s1">message: str) -&gt; str:</span>
            <span class="s1">...</span>

        <span class="s2">def </span><span class="s1">npgettext(self</span><span class="s2">, </span><span class="s1">context: str</span><span class="s2">, </span><span class="s1">singular: str</span><span class="s2">, </span><span class="s1">plural: str</span><span class="s2">, </span><span class="s1">n: int) -&gt; str:</span>
            <span class="s1">...</span>

    <span class="s1">_SupportedTranslations = t.Union[_TranslationsBasic</span><span class="s2">, </span><span class="s1">_TranslationsContext]</span>


<span class="s3"># I18N functions available in Jinja templates. If the I18N library</span>
<span class="s3"># provides ugettext, it will be assigned to gettext.</span>
<span class="s1">GETTEXT_FUNCTIONS: t.Tuple[str</span><span class="s2">, </span><span class="s1">...] = (</span>
    <span class="s4">&quot;_&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;gettext&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;ngettext&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;pgettext&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;npgettext&quot;</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">_ws_re = re.compile(</span><span class="s4">r&quot;\s*\n\s*&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Extension:</span>
    <span class="s0">&quot;&quot;&quot;Extensions can be used to add extra functionality to the Jinja template 
    system at the parser level.  Custom extensions are bound to an environment 
    but may not store environment specific data on `self`.  The reason for 
    this is that an extension can be bound to another environment (for 
    overlays) by creating a copy and reassigning the `environment` attribute. 
 
    As extensions are created by the environment they cannot accept any 
    arguments for configuration.  One may want to work around that by using 
    a factory function, but that is not possible as extensions are identified 
    by their import name.  The correct way to configure the extension is 
    storing the configuration values on the environment.  Because this way the 
    environment ends up acting as central configuration storage the 
    attributes may clash which is why extensions have to ensure that the names 
    they choose for configuration are not too generic.  ``prefix`` for example 
    is a terrible name, ``fragment_cache_prefix`` on the other hand is a good 
    name as includes the name of the extension (fragment cache). 
    &quot;&quot;&quot;</span>

    <span class="s1">identifier: t.ClassVar[str]</span>

    <span class="s2">def </span><span class="s1">__init_subclass__(cls) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">cls.identifier = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls.__module__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cls.__name__</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s3">#: if this extension parses this is the list of tags it's listening to.</span>
    <span class="s1">tags: t.Set[str] = set()</span>

    <span class="s3">#: the priority of that extension.  This is especially useful for</span>
    <span class="s3">#: extensions that preprocess values.  A lower value means higher</span>
    <span class="s3">#: priority.</span>
    <span class="s3">#:</span>
    <span class="s3">#: .. versionadded:: 2.4</span>
    <span class="s1">priority = </span><span class="s5">100</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">environment: Environment) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.environment = environment</span>

    <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">environment: Environment) -&gt; </span><span class="s4">&quot;Extension&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Create a copy of this extension bound to another environment.&quot;&quot;&quot;</span>
        <span class="s1">rv = t.cast(Extension</span><span class="s2">, </span><span class="s1">object.__new__(self.__class__))</span>
        <span class="s1">rv.__dict__.update(self.__dict__)</span>
        <span class="s1">rv.environment = environment</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">preprocess(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">source: str</span><span class="s2">, </span><span class="s1">name: t.Optional[str]</span><span class="s2">, </span><span class="s1">filename: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;This method is called before the actual lexing and can be used to 
        preprocess the source.  The `filename` is optional.  The return value 
        must be the preprocessed source. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">source</span>

    <span class="s2">def </span><span class="s1">filter_stream(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">stream: </span><span class="s4">&quot;TokenStream&quot;</span>
    <span class="s1">) -&gt; t.Union[</span><span class="s4">&quot;TokenStream&quot;</span><span class="s2">, </span><span class="s1">t.Iterable[</span><span class="s4">&quot;Token&quot;</span><span class="s1">]]:</span>
        <span class="s0">&quot;&quot;&quot;It's passed a :class:`~jinja2.lexer.TokenStream` that can be used 
        to filter tokens returned.  This method has to return an iterable of 
        :class:`~jinja2.lexer.Token`\\s, but it doesn't have to return a 
        :class:`~jinja2.lexer.TokenStream`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">stream</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s1">) -&gt; t.Union[nodes.Node</span><span class="s2">, </span><span class="s1">t.List[nodes.Node]]:</span>
        <span class="s0">&quot;&quot;&quot;If any of the :attr:`tags` matched this method is called with the 
        parser as first argument.  The token the parser stream is pointing at 
        is the name token that matched.  This method has to return one or a 
        list of multiple nodes. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">attr(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">lineno: t.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; nodes.ExtensionAttribute:</span>
        <span class="s0">&quot;&quot;&quot;Return an attribute node for the current extension.  This is useful 
        to pass constants on extensions to generated template code. 
 
        :: 
 
            self.attr('_my_attribute', lineno=lineno) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">nodes.ExtensionAttribute(self.identifier</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">call_method(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">args: t.Optional[t.List[nodes.Expr]] = </span><span class="s2">None,</span>
        <span class="s1">kwargs: t.Optional[t.List[nodes.Keyword]] = </span><span class="s2">None,</span>
        <span class="s1">dyn_args: t.Optional[nodes.Expr] = </span><span class="s2">None,</span>
        <span class="s1">dyn_kwargs: t.Optional[nodes.Expr] = </span><span class="s2">None,</span>
        <span class="s1">lineno: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; nodes.Call:</span>
        <span class="s0">&quot;&quot;&quot;Call a method of the extension.  This is a shortcut for 
        :meth:`attr` + :class:`jinja2.nodes.Call`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">args = []</span>
        <span class="s2">if </span><span class="s1">kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">kwargs = []</span>
        <span class="s2">return </span><span class="s1">nodes.Call(</span>
            <span class="s1">self.attr(name</span><span class="s2">, </span><span class="s1">lineno=lineno)</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">,</span>
            <span class="s1">dyn_args</span><span class="s2">,</span>
            <span class="s1">dyn_kwargs</span><span class="s2">,</span>
            <span class="s1">lineno=lineno</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">_gettext_alias(</span>
    <span class="s1">__context: Context</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s1">Undefined]:</span>
    <span class="s2">return </span><span class="s1">__context.call(__context.resolve(</span><span class="s4">&quot;gettext&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">_make_new_gettext(func: t.Callable[[str]</span><span class="s2">, </span><span class="s1">str]) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">@pass_context</span>
    <span class="s2">def </span><span class="s1">gettext(__context: Context</span><span class="s2">, </span><span class="s1">__string: str</span><span class="s2">, </span><span class="s1">**variables: t.Any) -&gt; str:</span>
        <span class="s1">rv = __context.call(func</span><span class="s2">, </span><span class="s1">__string)</span>
        <span class="s2">if </span><span class="s1">__context.eval_ctx.autoescape:</span>
            <span class="s1">rv = Markup(rv)</span>
        <span class="s3"># Always treat as a format string, even if there are no</span>
        <span class="s3"># variables. This makes translation strings more consistent</span>
        <span class="s3"># and predictable. This requires escaping</span>
        <span class="s2">return </span><span class="s1">rv % variables  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">gettext</span>


<span class="s2">def </span><span class="s1">_make_new_ngettext(func: t.Callable[[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">str]) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">@pass_context</span>
    <span class="s2">def </span><span class="s1">ngettext(</span>
        <span class="s1">__context: Context</span><span class="s2">,</span>
        <span class="s1">__singular: str</span><span class="s2">,</span>
        <span class="s1">__plural: str</span><span class="s2">,</span>
        <span class="s1">__num: int</span><span class="s2">,</span>
        <span class="s1">**variables: t.Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">variables.setdefault(</span><span class="s4">&quot;num&quot;</span><span class="s2">, </span><span class="s1">__num)</span>
        <span class="s1">rv = __context.call(func</span><span class="s2">, </span><span class="s1">__singular</span><span class="s2">, </span><span class="s1">__plural</span><span class="s2">, </span><span class="s1">__num)</span>
        <span class="s2">if </span><span class="s1">__context.eval_ctx.autoescape:</span>
            <span class="s1">rv = Markup(rv)</span>
        <span class="s3"># Always treat as a format string, see gettext comment above.</span>
        <span class="s2">return </span><span class="s1">rv % variables  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">ngettext</span>


<span class="s2">def </span><span class="s1">_make_new_pgettext(func: t.Callable[[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">str]) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">@pass_context</span>
    <span class="s2">def </span><span class="s1">pgettext(</span>
        <span class="s1">__context: Context</span><span class="s2">, </span><span class="s1">__string_ctx: str</span><span class="s2">, </span><span class="s1">__string: str</span><span class="s2">, </span><span class="s1">**variables: t.Any</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">variables.setdefault(</span><span class="s4">&quot;context&quot;</span><span class="s2">, </span><span class="s1">__string_ctx)</span>
        <span class="s1">rv = __context.call(func</span><span class="s2">, </span><span class="s1">__string_ctx</span><span class="s2">, </span><span class="s1">__string)</span>

        <span class="s2">if </span><span class="s1">__context.eval_ctx.autoescape:</span>
            <span class="s1">rv = Markup(rv)</span>

        <span class="s3"># Always treat as a format string, see gettext comment above.</span>
        <span class="s2">return </span><span class="s1">rv % variables  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">pgettext</span>


<span class="s2">def </span><span class="s1">_make_new_npgettext(</span>
    <span class="s1">func: t.Callable[[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">str]</span>
<span class="s1">) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s1">@pass_context</span>
    <span class="s2">def </span><span class="s1">npgettext(</span>
        <span class="s1">__context: Context</span><span class="s2">,</span>
        <span class="s1">__string_ctx: str</span><span class="s2">,</span>
        <span class="s1">__singular: str</span><span class="s2">,</span>
        <span class="s1">__plural: str</span><span class="s2">,</span>
        <span class="s1">__num: int</span><span class="s2">,</span>
        <span class="s1">**variables: t.Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">variables.setdefault(</span><span class="s4">&quot;context&quot;</span><span class="s2">, </span><span class="s1">__string_ctx)</span>
        <span class="s1">variables.setdefault(</span><span class="s4">&quot;num&quot;</span><span class="s2">, </span><span class="s1">__num)</span>
        <span class="s1">rv = __context.call(func</span><span class="s2">, </span><span class="s1">__string_ctx</span><span class="s2">, </span><span class="s1">__singular</span><span class="s2">, </span><span class="s1">__plural</span><span class="s2">, </span><span class="s1">__num)</span>

        <span class="s2">if </span><span class="s1">__context.eval_ctx.autoescape:</span>
            <span class="s1">rv = Markup(rv)</span>

        <span class="s3"># Always treat as a format string, see gettext comment above.</span>
        <span class="s2">return </span><span class="s1">rv % variables  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">npgettext</span>


<span class="s2">class </span><span class="s1">InternationalizationExtension(Extension):</span>
    <span class="s0">&quot;&quot;&quot;This extension adds gettext support to Jinja.&quot;&quot;&quot;</span>

    <span class="s1">tags = {</span><span class="s4">&quot;trans&quot;</span><span class="s1">}</span>

    <span class="s3"># TODO: the i18n extension is currently reevaluating values in a few</span>
    <span class="s3"># situations.  Take this example:</span>
    <span class="s3">#   {% trans count=something() %}{{ count }} foo{% pluralize</span>
    <span class="s3">#     %}{{ count }} fooss{% endtrans %}</span>
    <span class="s3"># something is called twice here.  One time for the gettext value and</span>
    <span class="s3"># the other time for the n-parameter of the ngettext function.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">environment: Environment) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(environment)</span>
        <span class="s1">environment.globals[</span><span class="s4">&quot;_&quot;</span><span class="s1">] = _gettext_alias</span>
        <span class="s1">environment.extend(</span>
            <span class="s1">install_gettext_translations=self._install</span><span class="s2">,</span>
            <span class="s1">install_null_translations=self._install_null</span><span class="s2">,</span>
            <span class="s1">install_gettext_callables=self._install_callables</span><span class="s2">,</span>
            <span class="s1">uninstall_gettext_translations=self._uninstall</span><span class="s2">,</span>
            <span class="s1">extract_translations=self._extract</span><span class="s2">,</span>
            <span class="s1">newstyle_gettext=</span><span class="s2">False,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_install(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">translations: </span><span class="s4">&quot;_SupportedTranslations&quot;</span><span class="s2">, </span><span class="s1">newstyle: t.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># ugettext and ungettext are preferred in case the I18N library</span>
        <span class="s3"># is providing compatibility with older Python versions.</span>
        <span class="s1">gettext = getattr(translations</span><span class="s2">, </span><span class="s4">&quot;ugettext&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">gettext </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">gettext = translations.gettext</span>
        <span class="s1">ngettext = getattr(translations</span><span class="s2">, </span><span class="s4">&quot;ungettext&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ngettext </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ngettext = translations.ngettext</span>

        <span class="s1">pgettext = getattr(translations</span><span class="s2">, </span><span class="s4">&quot;pgettext&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">npgettext = getattr(translations</span><span class="s2">, </span><span class="s4">&quot;npgettext&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self._install_callables(</span>
            <span class="s1">gettext</span><span class="s2">, </span><span class="s1">ngettext</span><span class="s2">, </span><span class="s1">newstyle=newstyle</span><span class="s2">, </span><span class="s1">pgettext=pgettext</span><span class="s2">, </span><span class="s1">npgettext=npgettext</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_install_null(self</span><span class="s2">, </span><span class="s1">newstyle: t.Optional[bool] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">gettext</span>

        <span class="s1">translations = gettext.NullTranslations()</span>

        <span class="s2">if </span><span class="s1">hasattr(translations</span><span class="s2">, </span><span class="s4">&quot;pgettext&quot;</span><span class="s1">):</span>
            <span class="s3"># Python &lt; 3.8</span>
            <span class="s1">pgettext = translations.pgettext  </span><span class="s3"># type: ignore</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">pgettext(c: str</span><span class="s2">, </span><span class="s1">s: str) -&gt; str:</span>
                <span class="s2">return </span><span class="s1">s</span>

        <span class="s2">if </span><span class="s1">hasattr(translations</span><span class="s2">, </span><span class="s4">&quot;npgettext&quot;</span><span class="s1">):</span>
            <span class="s1">npgettext = translations.npgettext  </span><span class="s3"># type: ignore</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">npgettext(c: str</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">p: str</span><span class="s2">, </span><span class="s1">n: int) -&gt; str:</span>
                <span class="s2">return </span><span class="s1">s </span><span class="s2">if </span><span class="s1">n == </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">p</span>

        <span class="s1">self._install_callables(</span>
            <span class="s1">gettext=translations.gettext</span><span class="s2">,</span>
            <span class="s1">ngettext=translations.ngettext</span><span class="s2">,</span>
            <span class="s1">newstyle=newstyle</span><span class="s2">,</span>
            <span class="s1">pgettext=pgettext</span><span class="s2">,</span>
            <span class="s1">npgettext=npgettext</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_install_callables(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">gettext: t.Callable[[str]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">ngettext: t.Callable[[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">newstyle: t.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">pgettext: t.Optional[t.Callable[[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">npgettext: t.Optional[t.Callable[[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">newstyle </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.environment.newstyle_gettext = newstyle  </span><span class="s3"># type: ignore</span>
        <span class="s2">if </span><span class="s1">self.environment.newstyle_gettext:  </span><span class="s3"># type: ignore</span>
            <span class="s1">gettext = _make_new_gettext(gettext)</span>
            <span class="s1">ngettext = _make_new_ngettext(ngettext)</span>

            <span class="s2">if </span><span class="s1">pgettext </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">pgettext = _make_new_pgettext(pgettext)</span>

            <span class="s2">if </span><span class="s1">npgettext </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">npgettext = _make_new_npgettext(npgettext)</span>

        <span class="s1">self.environment.globals.update(</span>
            <span class="s1">gettext=gettext</span><span class="s2">, </span><span class="s1">ngettext=ngettext</span><span class="s2">, </span><span class="s1">pgettext=pgettext</span><span class="s2">, </span><span class="s1">npgettext=npgettext</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_uninstall(self</span><span class="s2">, </span><span class="s1">translations: </span><span class="s4">&quot;_SupportedTranslations&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;gettext&quot;</span><span class="s2">, </span><span class="s4">&quot;ngettext&quot;</span><span class="s2">, </span><span class="s4">&quot;pgettext&quot;</span><span class="s2">, </span><span class="s4">&quot;npgettext&quot;</span><span class="s1">):</span>
            <span class="s1">self.environment.globals.pop(key</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_extract(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS</span><span class="s2">,</span>
    <span class="s1">) -&gt; t.Iterator[</span>
        <span class="s1">t.Tuple[int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">t.Union[t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Tuple[t.Optional[str]</span><span class="s2">, </span><span class="s1">...]]]</span>
    <span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">isinstance(source</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">source = self.environment.parse(source)</span>
        <span class="s2">return </span><span class="s1">extract_from_ast(source</span><span class="s2">, </span><span class="s1">gettext_functions)</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s1">) -&gt; t.Union[nodes.Node</span><span class="s2">, </span><span class="s1">t.List[nodes.Node]]:</span>
        <span class="s0">&quot;&quot;&quot;Parse a translatable tag.&quot;&quot;&quot;</span>
        <span class="s1">lineno = next(parser.stream).lineno</span>
        <span class="s1">num_called_num = </span><span class="s2">False</span>

        <span class="s3"># find all the variables referenced.  Additionally a variable can be</span>
        <span class="s3"># defined in the body of the trans block too, but this is checked at</span>
        <span class="s3"># a later state.</span>
        <span class="s1">plural_expr: t.Optional[nodes.Expr] = </span><span class="s2">None</span>
        <span class="s1">plural_expr_assignment: t.Optional[nodes.Assign] = </span><span class="s2">None</span>
        <span class="s1">variables: t.Dict[str</span><span class="s2">, </span><span class="s1">nodes.Expr] = {}</span>
        <span class="s1">trimmed = </span><span class="s2">None</span>
        <span class="s2">while </span><span class="s1">parser.stream.current.type != </span><span class="s4">&quot;block_end&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">variables:</span>
                <span class="s1">parser.stream.expect(</span><span class="s4">&quot;comma&quot;</span><span class="s1">)</span>

            <span class="s3"># skip colon for python compatibility</span>
            <span class="s2">if </span><span class="s1">parser.stream.skip_if(</span><span class="s4">&quot;colon&quot;</span><span class="s1">):</span>
                <span class="s2">break</span>

            <span class="s1">token = parser.stream.expect(</span><span class="s4">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">token.value </span><span class="s2">in </span><span class="s1">variables:</span>
                <span class="s1">parser.fail(</span>
                    <span class="s4">f&quot;translatable variable </span><span class="s2">{</span><span class="s1">token.value</span><span class="s2">!r} </span><span class="s4">defined twice.&quot;</span><span class="s2">,</span>
                    <span class="s1">token.lineno</span><span class="s2">,</span>
                    <span class="s1">exc=TemplateAssertionError</span><span class="s2">,</span>
                <span class="s1">)</span>

            <span class="s3"># expressions</span>
            <span class="s2">if </span><span class="s1">parser.stream.current.type == </span><span class="s4">&quot;assign&quot;</span><span class="s1">:</span>
                <span class="s1">next(parser.stream)</span>
                <span class="s1">variables[token.value] = var = parser.parse_expression()</span>
            <span class="s2">elif </span><span class="s1">trimmed </span><span class="s2">is None and </span><span class="s1">token.value </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;trimmed&quot;</span><span class="s2">, </span><span class="s4">&quot;notrimmed&quot;</span><span class="s1">):</span>
                <span class="s1">trimmed = token.value == </span><span class="s4">&quot;trimmed&quot;</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">variables[token.value] = var = nodes.Name(token.value</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">plural_expr </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">nodes.Call):</span>
                    <span class="s1">plural_expr = nodes.Name(</span><span class="s4">&quot;_trans&quot;</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>
                    <span class="s1">variables[token.value] = plural_expr</span>
                    <span class="s1">plural_expr_assignment = nodes.Assign(</span>
                        <span class="s1">nodes.Name(</span><span class="s4">&quot;_trans&quot;</span><span class="s2">, </span><span class="s4">&quot;store&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">var</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">plural_expr = var</span>
                <span class="s1">num_called_num = token.value == </span><span class="s4">&quot;num&quot;</span>

        <span class="s1">parser.stream.expect(</span><span class="s4">&quot;block_end&quot;</span><span class="s1">)</span>

        <span class="s1">plural = </span><span class="s2">None</span>
        <span class="s1">have_plural = </span><span class="s2">False</span>
        <span class="s1">referenced = set()</span>

        <span class="s3"># now parse until endtrans or pluralize</span>
        <span class="s1">singular_names</span><span class="s2">, </span><span class="s1">singular = self._parse_block(parser</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">singular_names:</span>
            <span class="s1">referenced.update(singular_names)</span>
            <span class="s2">if </span><span class="s1">plural_expr </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">plural_expr = nodes.Name(singular_names[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>
                <span class="s1">num_called_num = singular_names[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;num&quot;</span>

        <span class="s3"># if we have a pluralize block, we parse that too</span>
        <span class="s2">if </span><span class="s1">parser.stream.current.test(</span><span class="s4">&quot;name:pluralize&quot;</span><span class="s1">):</span>
            <span class="s1">have_plural = </span><span class="s2">True</span>
            <span class="s1">next(parser.stream)</span>
            <span class="s2">if </span><span class="s1">parser.stream.current.type != </span><span class="s4">&quot;block_end&quot;</span><span class="s1">:</span>
                <span class="s1">token = parser.stream.expect(</span><span class="s4">&quot;name&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">token.value </span><span class="s2">not in </span><span class="s1">variables:</span>
                    <span class="s1">parser.fail(</span>
                        <span class="s4">f&quot;unknown variable </span><span class="s2">{</span><span class="s1">token.value</span><span class="s2">!r} </span><span class="s4">for pluralization&quot;</span><span class="s2">,</span>
                        <span class="s1">token.lineno</span><span class="s2">,</span>
                        <span class="s1">exc=TemplateAssertionError</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">plural_expr = variables[token.value]</span>
                <span class="s1">num_called_num = token.value == </span><span class="s4">&quot;num&quot;</span>
            <span class="s1">parser.stream.expect(</span><span class="s4">&quot;block_end&quot;</span><span class="s1">)</span>
            <span class="s1">plural_names</span><span class="s2">, </span><span class="s1">plural = self._parse_block(parser</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">next(parser.stream)</span>
            <span class="s1">referenced.update(plural_names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">next(parser.stream)</span>

        <span class="s3"># register free names as simple name expressions</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">referenced:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">variables:</span>
                <span class="s1">variables[name] = nodes.Name(name</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">have_plural:</span>
            <span class="s1">plural_expr = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">plural_expr </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">parser.fail(</span><span class="s4">&quot;pluralize without variables&quot;</span><span class="s2">, </span><span class="s1">lineno)</span>

        <span class="s2">if </span><span class="s1">trimmed </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">trimmed = self.environment.policies[</span><span class="s4">&quot;ext.i18n.trimmed&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">trimmed:</span>
            <span class="s1">singular = self._trim_whitespace(singular)</span>
            <span class="s2">if </span><span class="s1">plural:</span>
                <span class="s1">plural = self._trim_whitespace(plural)</span>

        <span class="s1">node = self._make_node(</span>
            <span class="s1">singular</span><span class="s2">,</span>
            <span class="s1">plural</span><span class="s2">,</span>
            <span class="s1">variables</span><span class="s2">,</span>
            <span class="s1">plural_expr</span><span class="s2">,</span>
            <span class="s1">bool(referenced)</span><span class="s2">,</span>
            <span class="s1">num_called_num </span><span class="s2">and </span><span class="s1">have_plural</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">node.set_lineno(lineno)</span>
        <span class="s2">if </span><span class="s1">plural_expr_assignment </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[plural_expr_assignment</span><span class="s2">, </span><span class="s1">node]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">_trim_whitespace(self</span><span class="s2">, </span><span class="s1">string: str</span><span class="s2">, </span><span class="s1">_ws_re: t.Pattern[str] = _ws_re) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">_ws_re.sub(</span><span class="s4">&quot; &quot;</span><span class="s2">, </span><span class="s1">string.strip())</span>

    <span class="s2">def </span><span class="s1">_parse_block(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s2">, </span><span class="s1">allow_pluralize: bool</span>
    <span class="s1">) -&gt; t.Tuple[t.List[str]</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s0">&quot;&quot;&quot;Parse until the next block tag with a given name.&quot;&quot;&quot;</span>
        <span class="s1">referenced = []</span>
        <span class="s1">buf = []</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">parser.stream.current.type == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s1">buf.append(parser.stream.current.value.replace(</span><span class="s4">&quot;%&quot;</span><span class="s2">, </span><span class="s4">&quot;%%&quot;</span><span class="s1">))</span>
                <span class="s1">next(parser.stream)</span>
            <span class="s2">elif </span><span class="s1">parser.stream.current.type == </span><span class="s4">&quot;variable_begin&quot;</span><span class="s1">:</span>
                <span class="s1">next(parser.stream)</span>
                <span class="s1">name = parser.stream.expect(</span><span class="s4">&quot;name&quot;</span><span class="s1">).value</span>
                <span class="s1">referenced.append(name)</span>
                <span class="s1">buf.append(</span><span class="s4">f&quot;%(</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">)s&quot;</span><span class="s1">)</span>
                <span class="s1">parser.stream.expect(</span><span class="s4">&quot;variable_end&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">parser.stream.current.type == </span><span class="s4">&quot;block_begin&quot;</span><span class="s1">:</span>
                <span class="s1">next(parser.stream)</span>
                <span class="s2">if </span><span class="s1">parser.stream.current.test(</span><span class="s4">&quot;name:endtrans&quot;</span><span class="s1">):</span>
                    <span class="s2">break</span>
                <span class="s2">elif </span><span class="s1">parser.stream.current.test(</span><span class="s4">&quot;name:pluralize&quot;</span><span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">allow_pluralize:</span>
                        <span class="s2">break</span>
                    <span class="s1">parser.fail(</span>
                        <span class="s4">&quot;a translatable section can have only one pluralize section&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">parser.fail(</span>
                    <span class="s4">&quot;control structures in translatable sections are not allowed&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">parser.stream.eos:</span>
                <span class="s1">parser.fail(</span><span class="s4">&quot;unclosed translation block&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;internal parser error&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">referenced</span><span class="s2">, </span><span class="s1">concat(buf)</span>

    <span class="s2">def </span><span class="s1">_make_node(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">singular: str</span><span class="s2">,</span>
        <span class="s1">plural: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">variables: t.Dict[str</span><span class="s2">, </span><span class="s1">nodes.Expr]</span><span class="s2">,</span>
        <span class="s1">plural_expr: t.Optional[nodes.Expr]</span><span class="s2">,</span>
        <span class="s1">vars_referenced: bool</span><span class="s2">,</span>
        <span class="s1">num_called_num: bool</span><span class="s2">,</span>
    <span class="s1">) -&gt; nodes.Output:</span>
        <span class="s0">&quot;&quot;&quot;Generates a useful node from the data provided.&quot;&quot;&quot;</span>
        <span class="s1">newstyle = self.environment.newstyle_gettext  </span><span class="s3"># type: ignore</span>
        <span class="s1">node: nodes.Expr</span>

        <span class="s3"># no variables referenced?  no need to escape for old style</span>
        <span class="s3"># gettext invocations only if there are vars.</span>
        <span class="s2">if not </span><span class="s1">vars_referenced </span><span class="s2">and not </span><span class="s1">newstyle:</span>
            <span class="s1">singular = singular.replace(</span><span class="s4">&quot;%%&quot;</span><span class="s2">, </span><span class="s4">&quot;%&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">plural:</span>
                <span class="s1">plural = plural.replace(</span><span class="s4">&quot;%%&quot;</span><span class="s2">, </span><span class="s4">&quot;%&quot;</span><span class="s1">)</span>

        <span class="s3"># singular only:</span>
        <span class="s2">if </span><span class="s1">plural_expr </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">gettext = nodes.Name(</span><span class="s4">&quot;gettext&quot;</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>
            <span class="s1">node = nodes.Call(gettext</span><span class="s2">, </span><span class="s1">[nodes.Const(singular)]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, None, None</span><span class="s1">)</span>

        <span class="s3"># singular and plural</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ngettext = nodes.Name(</span><span class="s4">&quot;ngettext&quot;</span><span class="s2">, </span><span class="s4">&quot;load&quot;</span><span class="s1">)</span>
            <span class="s1">node = nodes.Call(</span>
                <span class="s1">ngettext</span><span class="s2">,</span>
                <span class="s1">[nodes.Const(singular)</span><span class="s2">, </span><span class="s1">nodes.Const(plural)</span><span class="s2">, </span><span class="s1">plural_expr]</span><span class="s2">,</span>
                <span class="s1">[]</span><span class="s2">,</span>
                <span class="s2">None,</span>
                <span class="s2">None,</span>
            <span class="s1">)</span>

        <span class="s3"># in case newstyle gettext is used, the method is powerful</span>
        <span class="s3"># enough to handle the variable expansion and autoescape</span>
        <span class="s3"># handling itself</span>
        <span class="s2">if </span><span class="s1">newstyle:</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">variables.items():</span>
                <span class="s3"># the function adds that later anyways in case num was</span>
                <span class="s3"># called num, so just skip it.</span>
                <span class="s2">if </span><span class="s1">num_called_num </span><span class="s2">and </span><span class="s1">key == </span><span class="s4">&quot;num&quot;</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">node.kwargs.append(nodes.Keyword(key</span><span class="s2">, </span><span class="s1">value))</span>

        <span class="s3"># otherwise do that here</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># mark the return value as safe if we are in an</span>
            <span class="s3"># environment with autoescaping turned on</span>
            <span class="s1">node = nodes.MarkSafeIfAutoescape(node)</span>
            <span class="s2">if </span><span class="s1">variables:</span>
                <span class="s1">node = nodes.Mod(</span>
                    <span class="s1">node</span><span class="s2">,</span>
                    <span class="s1">nodes.Dict(</span>
                        <span class="s1">[</span>
                            <span class="s1">nodes.Pair(nodes.Const(key)</span><span class="s2">, </span><span class="s1">value)</span>
                            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">variables.items()</span>
                        <span class="s1">]</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.Output([node])</span>


<span class="s2">class </span><span class="s1">ExprStmtExtension(Extension):</span>
    <span class="s0">&quot;&quot;&quot;Adds a `do` tag to Jinja that works like the print statement just 
    that it doesn't print the return value. 
    &quot;&quot;&quot;</span>

    <span class="s1">tags = {</span><span class="s4">&quot;do&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s1">) -&gt; nodes.ExprStmt:</span>
        <span class="s1">node = nodes.ExprStmt(lineno=next(parser.stream).lineno)</span>
        <span class="s1">node.node = parser.parse_tuple()</span>
        <span class="s2">return </span><span class="s1">node</span>


<span class="s2">class </span><span class="s1">LoopControlExtension(Extension):</span>
    <span class="s0">&quot;&quot;&quot;Adds break and continue to the template engine.&quot;&quot;&quot;</span>

    <span class="s1">tags = {</span><span class="s4">&quot;break&quot;</span><span class="s2">, </span><span class="s4">&quot;continue&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s1">) -&gt; t.Union[nodes.Break</span><span class="s2">, </span><span class="s1">nodes.Continue]:</span>
        <span class="s1">token = next(parser.stream)</span>
        <span class="s2">if </span><span class="s1">token.value == </span><span class="s4">&quot;break&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">nodes.Break(lineno=token.lineno)</span>
        <span class="s2">return </span><span class="s1">nodes.Continue(lineno=token.lineno)</span>


<span class="s2">class </span><span class="s1">WithExtension(Extension):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">environment: Environment) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(environment)</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'with' extension is deprecated and will be removed in&quot;</span>
            <span class="s4">&quot; Jinja 3.1. This is built in now.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s5">3</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">AutoEscapeExtension(Extension):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">environment: Environment) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(environment)</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;The 'autoescape' extension is deprecated and will be&quot;</span>
            <span class="s4">&quot; removed in Jinja 3.1. This is built in now.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s5">3</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">DebugExtension(Extension):</span>
    <span class="s0">&quot;&quot;&quot;A ``{% debug %}`` tag that dumps the available variables, 
    filters, and tests. 
 
    .. code-block:: html+jinja 
 
        &lt;pre&gt;{% debug %}&lt;/pre&gt; 
 
    .. code-block:: text 
 
        {'context': {'cycler': &lt;class 'jinja2.utils.Cycler'&gt;, 
                     ..., 
                     'namespace': &lt;class 'jinja2.utils.Namespace'&gt;}, 
         'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd', 
                     ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'], 
         'tests': ['!=', '&lt;', '&lt;=', '==', '&gt;', '&gt;=', 'callable', 'defined', 
                   ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']} 
 
    .. versionadded:: 2.11.0 
    &quot;&quot;&quot;</span>

    <span class="s1">tags = {</span><span class="s4">&quot;debug&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">parser: </span><span class="s4">&quot;Parser&quot;</span><span class="s1">) -&gt; nodes.Output:</span>
        <span class="s1">lineno = parser.stream.expect(</span><span class="s4">&quot;name:debug&quot;</span><span class="s1">).lineno</span>
        <span class="s1">context = nodes.ContextReference()</span>
        <span class="s1">result = self.call_method(</span><span class="s4">&quot;_render&quot;</span><span class="s2">, </span><span class="s1">[context]</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">return </span><span class="s1">nodes.Output([result]</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">_render(self</span><span class="s2">, </span><span class="s1">context: Context) -&gt; str:</span>
        <span class="s1">result = {</span>
            <span class="s4">&quot;context&quot;</span><span class="s1">: context.get_all()</span><span class="s2">,</span>
            <span class="s4">&quot;filters&quot;</span><span class="s1">: sorted(self.environment.filters.keys())</span><span class="s2">,</span>
            <span class="s4">&quot;tests&quot;</span><span class="s1">: sorted(self.environment.tests.keys())</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s3"># Set the depth since the intent is to show the top few names.</span>
        <span class="s2">return </span><span class="s1">pprint.pformat(result</span><span class="s2">, </span><span class="s1">depth=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">compact=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">extract_from_ast(</span>
    <span class="s1">ast: nodes.Template</span><span class="s2">,</span>
    <span class="s1">gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS</span><span class="s2">,</span>
    <span class="s1">babel_style: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; t.Iterator[</span>
    <span class="s1">t.Tuple[int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">t.Union[t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Tuple[t.Optional[str]</span><span class="s2">, </span><span class="s1">...]]]</span>
<span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Extract localizable strings from the given template node.  Per 
    default this function returns matches in babel style that means non string 
    parameters as well as keyword arguments are returned as `None`.  This 
    allows Babel to figure out what you really meant if you are using 
    gettext functions that allow keyword arguments for placeholder expansion. 
    If you don't want that behavior set the `babel_style` parameter to `False` 
    which causes only strings to be returned and parameters are always stored 
    in tuples.  As a consequence invalid gettext calls (calls without a single 
    string parameter or string parameters after non-string parameters) are 
    skipped. 
 
    This example explains the behavior: 
 
    &gt;&gt;&gt; from jinja2 import Environment 
    &gt;&gt;&gt; env = Environment() 
    &gt;&gt;&gt; node = env.parse('{{ (_(&quot;foo&quot;), _(), ngettext(&quot;foo&quot;, &quot;bar&quot;, 42)) }}') 
    &gt;&gt;&gt; list(extract_from_ast(node)) 
    [(1, '_', 'foo'), (1, '_', ()), (1, 'ngettext', ('foo', 'bar', None))] 
    &gt;&gt;&gt; list(extract_from_ast(node, babel_style=False)) 
    [(1, '_', ('foo',)), (1, 'ngettext', ('foo', 'bar'))] 
 
    For every string found this function yields a ``(lineno, function, 
    message)`` tuple, where: 
 
    * ``lineno`` is the number of the line on which the string was found, 
    * ``function`` is the name of the ``gettext`` function used (if the 
      string was extracted from embedded Python code), and 
    *   ``message`` is the string, or a tuple of strings for functions 
         with multiple string arguments. 
 
    This extraction function operates on the AST and is because of that unable 
    to extract any comments.  For comment support you have to use the babel 
    extraction interface or extract comments yourself. 
    &quot;&quot;&quot;</span>
    <span class="s1">out: t.Union[t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Tuple[t.Optional[str]</span><span class="s2">, </span><span class="s1">...]]</span>

    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">ast.find_all(nodes.Call):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(node.node</span><span class="s2">, </span><span class="s1">nodes.Name)</span>
            <span class="s2">or </span><span class="s1">node.node.name </span><span class="s2">not in </span><span class="s1">gettext_functions</span>
        <span class="s1">):</span>
            <span class="s2">continue</span>

        <span class="s1">strings: t.List[t.Optional[str]] = []</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">node.args:</span>
            <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">nodes.Const) </span><span class="s2">and </span><span class="s1">isinstance(arg.value</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">strings.append(arg.value)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">strings.append(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">node.kwargs:</span>
            <span class="s1">strings.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">node.dyn_args </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">strings.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">node.dyn_kwargs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">strings.append(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">babel_style:</span>
            <span class="s1">out = tuple(x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">strings </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">out:</span>
                <span class="s2">continue</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(strings) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">out = strings[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">out = tuple(strings)</span>

        <span class="s2">yield </span><span class="s1">node.lineno</span><span class="s2">, </span><span class="s1">node.node.name</span><span class="s2">, </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">_CommentFinder:</span>
    <span class="s0">&quot;&quot;&quot;Helper class to find comments in a token stream.  Can only 
    find comments for gettext calls forwards.  Once the comment 
    from line 4 is found, a comment for line 1 will not return a 
    usable value. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tokens: t.Sequence[t.Tuple[int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]]</span><span class="s2">, </span><span class="s1">comment_tags: t.Sequence[str]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.tokens = tokens</span>
        <span class="s1">self.comment_tags = comment_tags</span>
        <span class="s1">self.offset = </span><span class="s5">0</span>
        <span class="s1">self.last_lineno = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">find_backwards(self</span><span class="s2">, </span><span class="s1">offset: int) -&gt; t.List[str]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">token_type</span><span class="s2">, </span><span class="s1">token_value </span><span class="s2">in </span><span class="s1">reversed(</span>
                <span class="s1">self.tokens[self.offset : offset]</span>
            <span class="s1">):</span>
                <span class="s2">if </span><span class="s1">token_type </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;comment&quot;</span><span class="s2">, </span><span class="s4">&quot;linecomment&quot;</span><span class="s1">):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">comment = token_value.split(</span><span class="s2">None, </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s2">except </span><span class="s1">ValueError:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">self.comment_tags:</span>
                        <span class="s2">return </span><span class="s1">[comment.rstrip()]</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.offset = offset</span>

    <span class="s2">def </span><span class="s1">find_comments(self</span><span class="s2">, </span><span class="s1">lineno: int) -&gt; t.List[str]:</span>
        <span class="s2">if not </span><span class="s1">self.comment_tags </span><span class="s2">or </span><span class="s1">self.last_lineno &gt; lineno:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">(token_lineno</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_) </span><span class="s2">in </span><span class="s1">enumerate(self.tokens[self.offset :]):</span>
            <span class="s2">if </span><span class="s1">token_lineno &gt; lineno:</span>
                <span class="s2">return </span><span class="s1">self.find_backwards(self.offset + idx)</span>
        <span class="s2">return </span><span class="s1">self.find_backwards(len(self.tokens))</span>


<span class="s2">def </span><span class="s1">babel_extract(</span>
    <span class="s1">fileobj: t.BinaryIO</span><span class="s2">,</span>
    <span class="s1">keywords: t.Sequence[str]</span><span class="s2">,</span>
    <span class="s1">comment_tags: t.Sequence[str]</span><span class="s2">,</span>
    <span class="s1">options: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Iterator[</span>
    <span class="s1">t.Tuple[</span>
        <span class="s1">int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">t.Union[t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Tuple[t.Optional[str]</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">, </span><span class="s1">t.List[str]</span>
    <span class="s1">]</span>
<span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Babel extraction method for Jinja templates. 
 
    .. versionchanged:: 2.3 
       Basic support for translation comments was added.  If `comment_tags` 
       is now set to a list of keywords for extraction, the extractor will 
       try to find the best preceding comment that begins with one of the 
       keywords.  For best results, make sure to not have more than one 
       gettext call in one line of code and the matching comment in the 
       same line or the line before. 
 
    .. versionchanged:: 2.5.1 
       The `newstyle_gettext` flag can be set to `True` to enable newstyle 
       gettext calls. 
 
    .. versionchanged:: 2.7 
       A `silent` option can now be provided.  If set to `False` template 
       syntax errors are propagated instead of being ignored. 
 
    :param fileobj: the file-like object the messages should be extracted from 
    :param keywords: a list of keywords (i.e. function names) that should be 
                     recognized as translation functions 
    :param comment_tags: a list of translator tags to search for and include 
                         in the results. 
    :param options: a dictionary of additional options (optional) 
    :return: an iterator over ``(lineno, funcname, message, comments)`` tuples. 
             (comments will be empty currently) 
    &quot;&quot;&quot;</span>
    <span class="s1">extensions: t.Dict[t.Type[Extension]</span><span class="s2">, None</span><span class="s1">] = {}</span>

    <span class="s2">for </span><span class="s1">extension_name </span><span class="s2">in </span><span class="s1">options.get(</span><span class="s4">&quot;extensions&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">).split(</span><span class="s4">&quot;,&quot;</span><span class="s1">):</span>
        <span class="s1">extension_name = extension_name.strip()</span>

        <span class="s2">if not </span><span class="s1">extension_name:</span>
            <span class="s2">continue</span>

        <span class="s1">extensions[import_string(extension_name)] = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">InternationalizationExtension </span><span class="s2">not in </span><span class="s1">extensions:</span>
        <span class="s1">extensions[InternationalizationExtension] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">getbool(options: t.Mapping[str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">key: str</span><span class="s2">, </span><span class="s1">default: bool = </span><span class="s2">False</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">options.get(key</span><span class="s2">, </span><span class="s1">str(default)).lower() </span><span class="s2">in </span><span class="s1">{</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;on&quot;</span><span class="s2">, </span><span class="s4">&quot;yes&quot;</span><span class="s2">, </span><span class="s4">&quot;true&quot;</span><span class="s1">}</span>

    <span class="s1">silent = getbool(options</span><span class="s2">, </span><span class="s4">&quot;silent&quot;</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">environment = Environment(</span>
        <span class="s1">options.get(</span><span class="s4">&quot;block_start_string&quot;</span><span class="s2">, </span><span class="s1">defaults.BLOCK_START_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;block_end_string&quot;</span><span class="s2">, </span><span class="s1">defaults.BLOCK_END_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;variable_start_string&quot;</span><span class="s2">, </span><span class="s1">defaults.VARIABLE_START_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;variable_end_string&quot;</span><span class="s2">, </span><span class="s1">defaults.VARIABLE_END_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;comment_start_string&quot;</span><span class="s2">, </span><span class="s1">defaults.COMMENT_START_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;comment_end_string&quot;</span><span class="s2">, </span><span class="s1">defaults.COMMENT_END_STRING)</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;line_statement_prefix&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">defaults.LINE_STATEMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">options.get(</span><span class="s4">&quot;line_comment_prefix&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">defaults.LINE_COMMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">getbool(options</span><span class="s2">, </span><span class="s4">&quot;trim_blocks&quot;</span><span class="s2">, </span><span class="s1">defaults.TRIM_BLOCKS)</span><span class="s2">,</span>
        <span class="s1">getbool(options</span><span class="s2">, </span><span class="s4">&quot;lstrip_blocks&quot;</span><span class="s2">, </span><span class="s1">defaults.LSTRIP_BLOCKS)</span><span class="s2">,</span>
        <span class="s1">defaults.NEWLINE_SEQUENCE</span><span class="s2">,</span>
        <span class="s1">getbool(options</span><span class="s2">, </span><span class="s4">&quot;keep_trailing_newline&quot;</span><span class="s2">, </span><span class="s1">defaults.KEEP_TRAILING_NEWLINE)</span><span class="s2">,</span>
        <span class="s1">tuple(extensions)</span><span class="s2">,</span>
        <span class="s1">cache_size=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">auto_reload=</span><span class="s2">False,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">getbool(options</span><span class="s2">, </span><span class="s4">&quot;trimmed&quot;</span><span class="s1">):</span>
        <span class="s1">environment.policies[</span><span class="s4">&quot;ext.i18n.trimmed&quot;</span><span class="s1">] = </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">getbool(options</span><span class="s2">, </span><span class="s4">&quot;newstyle_gettext&quot;</span><span class="s1">):</span>
        <span class="s1">environment.newstyle_gettext = </span><span class="s2">True  </span><span class="s3"># type: ignore</span>

    <span class="s1">source = fileobj.read().decode(options.get(</span><span class="s4">&quot;encoding&quot;</span><span class="s2">, </span><span class="s4">&quot;utf-8&quot;</span><span class="s1">))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">node = environment.parse(source)</span>
        <span class="s1">tokens = list(environment.lex(environment.preprocess(source)))</span>
    <span class="s2">except </span><span class="s1">TemplateSyntaxError:</span>
        <span class="s2">if not </span><span class="s1">silent:</span>
            <span class="s2">raise</span>
        <span class="s3"># skip templates with syntax errors</span>
        <span class="s2">return</span>

    <span class="s1">finder = _CommentFinder(tokens</span><span class="s2">, </span><span class="s1">comment_tags)</span>
    <span class="s2">for </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">message </span><span class="s2">in </span><span class="s1">extract_from_ast(node</span><span class="s2">, </span><span class="s1">keywords):</span>
        <span class="s2">yield </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">finder.find_comments(lineno)</span>


<span class="s3">#: nicer import names</span>
<span class="s1">i18n = InternationalizationExtension</span>
<span class="s1">do = ExprStmtExtension</span>
<span class="s1">loopcontrols = LoopControlExtension</span>
<span class="s1">with_ = WithExtension</span>
<span class="s1">autoescape = AutoEscapeExtension</span>
<span class="s1">debug = DebugExtension</span>
</pre>
</body>
</html>