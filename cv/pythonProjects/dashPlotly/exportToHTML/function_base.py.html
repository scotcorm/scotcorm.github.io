<html>
<head>
<title>function_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
function_base.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">types</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">numeric </span><span class="s0">as </span><span class="s1">_nx</span>
<span class="s0">from </span><span class="s1">.numeric </span><span class="s0">import </span><span class="s1">result_type</span><span class="s0">, </span><span class="s1">NaN</span><span class="s0">, </span><span class="s1">asanyarray</span><span class="s0">, </span><span class="s1">ndim</span>
<span class="s0">from </span><span class="s1">numpy.core.multiarray </span><span class="s0">import </span><span class="s1">add_docstring</span>
<span class="s0">from </span><span class="s1">numpy.core </span><span class="s0">import </span><span class="s1">overrides</span>

<span class="s1">__all__ = [</span><span class="s2">'logspace'</span><span class="s0">, </span><span class="s2">'linspace'</span><span class="s0">, </span><span class="s2">'geomspace'</span><span class="s1">]</span>


<span class="s1">array_function_dispatch = functools.partial(</span>
    <span class="s1">overrides.array_function_dispatch</span><span class="s0">, </span><span class="s1">module=</span><span class="s2">'numpy'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_linspace_dispatcher(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s0">None, </span><span class="s1">endpoint=</span><span class="s0">None, </span><span class="s1">retstep=</span><span class="s0">None,</span>
                         <span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">(start</span><span class="s0">, </span><span class="s1">stop)</span>


<span class="s1">@array_function_dispatch(_linspace_dispatcher)</span>
<span class="s0">def </span><span class="s1">linspace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True, </span><span class="s1">retstep=</span><span class="s0">False, </span><span class="s1">dtype=</span><span class="s0">None,</span>
             <span class="s1">axis=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return evenly spaced numbers over a specified interval. 
 
    Returns `num` evenly spaced samples, calculated over the 
    interval [`start`, `stop`]. 
 
    The endpoint of the interval can optionally be excluded. 
 
    .. versionchanged:: 1.16.0 
        Non-scalar `start` and `stop` are now supported. 
 
    .. versionchanged:: 1.20.0 
        Values are rounded towards ``-inf`` instead of ``0`` when an 
        integer ``dtype`` is specified. The old behavior can 
        still be obtained with ``np.linspace(start, stop, num).astype(int)`` 
 
    Parameters 
    ---------- 
    start : array_like 
        The starting value of the sequence. 
    stop : array_like 
        The end value of the sequence, unless `endpoint` is set to False. 
        In that case, the sequence consists of all but the last of ``num + 1`` 
        evenly spaced samples, so that `stop` is excluded.  Note that the step 
        size changes when `endpoint` is False. 
    num : int, optional 
        Number of samples to generate. Default is 50. Must be non-negative. 
    endpoint : bool, optional 
        If True, `stop` is the last sample. Otherwise, it is not included. 
        Default is True. 
    retstep : bool, optional 
        If True, return (`samples`, `step`), where `step` is the spacing 
        between samples. 
    dtype : dtype, optional 
        The type of the output array.  If `dtype` is not given, the data type 
        is inferred from `start` and `stop`. The inferred dtype will never be 
        an integer; `float` is chosen even if the arguments would produce an 
        array of integers. 
 
        .. versionadded:: 1.9.0 
 
    axis : int, optional 
        The axis in the result to store the samples.  Relevant only if start 
        or stop are array-like.  By default (0), the samples will be along a 
        new axis inserted at the beginning. Use -1 to get an axis at the end. 
 
        .. versionadded:: 1.16.0 
 
    Returns 
    ------- 
    samples : ndarray 
        There are `num` equally spaced samples in the closed interval 
        ``[start, stop]`` or the half-open interval ``[start, stop)`` 
        (depending on whether `endpoint` is True or False). 
    step : float, optional 
        Only returned if `retstep` is True 
 
        Size of spacing between samples. 
 
 
    See Also 
    -------- 
    arange : Similar to `linspace`, but uses a step size (instead of the 
             number of samples). 
    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log 
                scale (a geometric progression). 
    logspace : Similar to `geomspace`, but with the end points specified as 
               logarithms. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5) 
    array([2.  , 2.25, 2.5 , 2.75, 3.  ]) 
    &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False) 
    array([2. ,  2.2,  2.4,  2.6,  2.8]) 
    &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True) 
    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25) 
 
    Graphical illustration: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; N = 8 
    &gt;&gt;&gt; y = np.zeros(N) 
    &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True) 
    &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False) 
    &gt;&gt;&gt; plt.plot(x1, y, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.ylim([-0.5, 1]) 
    (-0.5, 1) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">num = operator.index(num)</span>
    <span class="s0">if </span><span class="s1">num &lt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Number of samples, %s, must be non-negative.&quot; </span><span class="s1">% num)</span>
    <span class="s1">div = (num - </span><span class="s3">1</span><span class="s1">) </span><span class="s0">if </span><span class="s1">endpoint </span><span class="s0">else </span><span class="s1">num</span>

    <span class="s5"># Convert float/complex array scalars to float, gh-3504</span>
    <span class="s5"># and make sure one can use variables that have an __array_interface__, gh-6634</span>
    <span class="s1">start = asanyarray(start) * </span><span class="s3">1.0</span>
    <span class="s1">stop  = asanyarray(stop)  * </span><span class="s3">1.0</span>

    <span class="s1">dt = result_type(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">float(num))</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = dt</span>

    <span class="s1">delta = stop - start</span>
    <span class="s1">y = _nx.arange(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">dtype=dt).reshape((-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) + (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * ndim(delta))</span>
    <span class="s5"># In-place multiplication y *= delta/div is faster, but prevents the multiplicant</span>
    <span class="s5"># from overriding what class is produced, and thus prevents, e.g. use of Quantities,</span>
    <span class="s5"># see gh-7142. Hence, we multiply in place only for standard scalar types.</span>
    <span class="s1">_mult_inplace = _nx.isscalar(delta)</span>
    <span class="s0">if </span><span class="s1">div &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">step = delta / div</span>
        <span class="s0">if </span><span class="s1">_nx.any(step == </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s5"># Special handling for denormal numbers, gh-5437</span>
            <span class="s1">y /= div</span>
            <span class="s0">if </span><span class="s1">_mult_inplace:</span>
                <span class="s1">y *= delta</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">y = y * delta</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">_mult_inplace:</span>
                <span class="s1">y *= step</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">y = y * step</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># sequences with 0 items or 1 item with endpoint=True (i.e. div &lt;= 0)</span>
        <span class="s5"># have an undefined step</span>
        <span class="s1">step = NaN</span>
        <span class="s5"># Multiply with delta to allow possible override of output class.</span>
        <span class="s1">y = y * delta</span>

    <span class="s1">y += start</span>

    <span class="s0">if </span><span class="s1">endpoint </span><span class="s0">and </span><span class="s1">num &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">y[-</span><span class="s3">1</span><span class="s1">] = stop</span>

    <span class="s0">if </span><span class="s1">axis != </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">y = _nx.moveaxis(y</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s0">if </span><span class="s1">_nx.issubdtype(dtype</span><span class="s0">, </span><span class="s1">_nx.integer):</span>
        <span class="s1">_nx.floor(y</span><span class="s0">, </span><span class="s1">out=y)</span>

    <span class="s0">if </span><span class="s1">retstep:</span>
        <span class="s0">return </span><span class="s1">y.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">step</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">y.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_logspace_dispatcher(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s0">None, </span><span class="s1">endpoint=</span><span class="s0">None, </span><span class="s1">base=</span><span class="s0">None,</span>
                         <span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">(start</span><span class="s0">, </span><span class="s1">stop)</span>


<span class="s1">@array_function_dispatch(_logspace_dispatcher)</span>
<span class="s0">def </span><span class="s1">logspace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True, </span><span class="s1">base=</span><span class="s3">10.0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None,</span>
             <span class="s1">axis=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return numbers spaced evenly on a log scale. 
 
    In linear space, the sequence starts at ``base ** start`` 
    (`base` to the power of `start`) and ends with ``base ** stop`` 
    (see `endpoint` below). 
 
    .. versionchanged:: 1.16.0 
        Non-scalar `start` and `stop` are now supported. 
 
    Parameters 
    ---------- 
    start : array_like 
        ``base ** start`` is the starting value of the sequence. 
    stop : array_like 
        ``base ** stop`` is the final value of the sequence, unless `endpoint` 
        is False.  In that case, ``num + 1`` values are spaced over the 
        interval in log-space, of which all but the last (a sequence of 
        length `num`) are returned. 
    num : integer, optional 
        Number of samples to generate.  Default is 50. 
    endpoint : boolean, optional 
        If true, `stop` is the last sample. Otherwise, it is not included. 
        Default is True. 
    base : array_like, optional 
        The base of the log space. The step size between the elements in 
        ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform. 
        Default is 10.0. 
    dtype : dtype 
        The type of the output array.  If `dtype` is not given, the data type 
        is inferred from `start` and `stop`. The inferred type will never be 
        an integer; `float` is chosen even if the arguments would produce an 
        array of integers. 
    axis : int, optional 
        The axis in the result to store the samples.  Relevant only if start 
        or stop are array-like.  By default (0), the samples will be along a 
        new axis inserted at the beginning. Use -1 to get an axis at the end. 
 
        .. versionadded:: 1.16.0 
 
 
    Returns 
    ------- 
    samples : ndarray 
        `num` samples, equally spaced on a log scale. 
 
    See Also 
    -------- 
    arange : Similar to linspace, with the step size specified instead of the 
             number of samples. Note that, when used with a float endpoint, the 
             endpoint may or may not be included. 
    linspace : Similar to logspace, but with the samples uniformly distributed 
               in linear space, instead of log space. 
    geomspace : Similar to logspace, but with endpoints specified directly. 
 
    Notes 
    ----- 
    Logspace is equivalent to the code 
 
    &gt;&gt;&gt; y = np.linspace(start, stop, num=num, endpoint=endpoint) 
    ... # doctest: +SKIP 
    &gt;&gt;&gt; power(base, y).astype(dtype) 
    ... # doctest: +SKIP 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.logspace(2.0, 3.0, num=4) 
    array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ]) 
    &gt;&gt;&gt; np.logspace(2.0, 3.0, num=4, endpoint=False) 
    array([100.        ,  177.827941  ,  316.22776602,  562.34132519]) 
    &gt;&gt;&gt; np.logspace(2.0, 3.0, num=4, base=2.0) 
    array([4.        ,  5.0396842 ,  6.34960421,  8.        ]) 
 
    Graphical illustration: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; N = 10 
    &gt;&gt;&gt; x1 = np.logspace(0.1, 1, N, endpoint=True) 
    &gt;&gt;&gt; x2 = np.logspace(0.1, 1, N, endpoint=False) 
    &gt;&gt;&gt; y = np.zeros(N) 
    &gt;&gt;&gt; plt.plot(x1, y, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.ylim([-0.5, 1]) 
    (-0.5, 1) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y = linspace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=num</span><span class="s0">, </span><span class="s1">endpoint=endpoint</span><span class="s0">, </span><span class="s1">axis=axis)</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_nx.power(base</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">return </span><span class="s1">_nx.power(base</span><span class="s0">, </span><span class="s1">y).astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_geomspace_dispatcher(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s0">None, </span><span class="s1">endpoint=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s0">None,</span>
                          <span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">(start</span><span class="s0">, </span><span class="s1">stop)</span>


<span class="s1">@array_function_dispatch(_geomspace_dispatcher)</span>
<span class="s0">def </span><span class="s1">geomspace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return numbers spaced evenly on a log scale (a geometric progression). 
 
    This is similar to `logspace`, but with endpoints specified directly. 
    Each output sample is a constant multiple of the previous. 
 
    .. versionchanged:: 1.16.0 
        Non-scalar `start` and `stop` are now supported. 
 
    Parameters 
    ---------- 
    start : array_like 
        The starting value of the sequence. 
    stop : array_like 
        The final value of the sequence, unless `endpoint` is False. 
        In that case, ``num + 1`` values are spaced over the 
        interval in log-space, of which all but the last (a sequence of 
        length `num`) are returned. 
    num : integer, optional 
        Number of samples to generate.  Default is 50. 
    endpoint : boolean, optional 
        If true, `stop` is the last sample. Otherwise, it is not included. 
        Default is True. 
    dtype : dtype 
        The type of the output array.  If `dtype` is not given, the data type 
        is inferred from `start` and `stop`. The inferred dtype will never be 
        an integer; `float` is chosen even if the arguments would produce an 
        array of integers. 
    axis : int, optional 
        The axis in the result to store the samples.  Relevant only if start 
        or stop are array-like.  By default (0), the samples will be along a 
        new axis inserted at the beginning. Use -1 to get an axis at the end. 
 
        .. versionadded:: 1.16.0 
 
    Returns 
    ------- 
    samples : ndarray 
        `num` samples, equally spaced on a log scale. 
 
    See Also 
    -------- 
    logspace : Similar to geomspace, but with endpoints specified using log 
               and base. 
    linspace : Similar to geomspace, but with arithmetic instead of geometric 
               progression. 
    arange : Similar to linspace, with the step size specified instead of the 
             number of samples. 
 
    Notes 
    ----- 
    If the inputs or dtype are complex, the output will follow a logarithmic 
    spiral in the complex plane.  (There are an infinite number of spirals 
    passing through two points; the output will follow the shortest such path.) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.geomspace(1, 1000, num=4) 
    array([    1.,    10.,   100.,  1000.]) 
    &gt;&gt;&gt; np.geomspace(1, 1000, num=3, endpoint=False) 
    array([   1.,   10.,  100.]) 
    &gt;&gt;&gt; np.geomspace(1, 1000, num=4, endpoint=False) 
    array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ]) 
    &gt;&gt;&gt; np.geomspace(1, 256, num=9) 
    array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.]) 
 
    Note that the above may not produce exact integers: 
 
    &gt;&gt;&gt; np.geomspace(1, 256, num=9, dtype=int) 
    array([  1,   2,   4,   7,  16,  32,  63, 127, 256]) 
    &gt;&gt;&gt; np.around(np.geomspace(1, 256, num=9)).astype(int) 
    array([  1,   2,   4,   8,  16,  32,  64, 128, 256]) 
 
    Negative, decreasing, and complex inputs are allowed: 
 
    &gt;&gt;&gt; np.geomspace(1000, 1, num=4) 
    array([1000.,  100.,   10.,    1.]) 
    &gt;&gt;&gt; np.geomspace(-1000, -1, num=4) 
    array([-1000.,  -100.,   -10.,    -1.]) 
    &gt;&gt;&gt; np.geomspace(1j, 1000j, num=4)  # Straight line 
    array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j]) 
    &gt;&gt;&gt; np.geomspace(-1+0j, 1+0j, num=5)  # Circle 
    array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j, 
            6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j, 
            1.00000000e+00+0.00000000e+00j]) 
 
    Graphical illustration of `endpoint` parameter: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; N = 10 
    &gt;&gt;&gt; y = np.zeros(N) 
    &gt;&gt;&gt; plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.axis([0.5, 2000, 0, 3]) 
    [0.5, 2000, 0, 3] 
    &gt;&gt;&gt; plt.grid(True, color='0.7', linestyle='-', which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">start = asanyarray(start)</span>
    <span class="s1">stop = asanyarray(stop)</span>
    <span class="s0">if </span><span class="s1">_nx.any(start == </span><span class="s3">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">_nx.any(stop == </span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Geometric sequence cannot include zero'</span><span class="s1">)</span>

    <span class="s1">dt = result_type(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">float(num)</span><span class="s0">, </span><span class="s1">_nx.zeros(()</span><span class="s0">, </span><span class="s1">dtype))</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = dt</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># complex to dtype('complex128'), for instance</span>
        <span class="s1">dtype = _nx.dtype(dtype)</span>

    <span class="s5"># Promote both arguments to the same dtype in case, for instance, one is</span>
    <span class="s5"># complex and another is negative and log would produce NaN otherwise.</span>
    <span class="s5"># Copy since we may change things in-place further down.</span>
    <span class="s1">start = start.astype(dt</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">stop = stop.astype(dt</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">out_sign = _nx.ones(_nx.broadcast(start</span><span class="s0">, </span><span class="s1">stop).shape</span><span class="s0">, </span><span class="s1">dt)</span>
    <span class="s5"># Avoid negligible real or imaginary parts in output by rotating to</span>
    <span class="s5"># positive real, calculating, then undoing rotation</span>
    <span class="s0">if </span><span class="s1">_nx.issubdtype(dt</span><span class="s0">, </span><span class="s1">_nx.complexfloating):</span>
        <span class="s1">all_imag = (start.real == </span><span class="s3">0.</span><span class="s1">) &amp; (stop.real == </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">_nx.any(all_imag):</span>
            <span class="s1">start[all_imag] = start[all_imag].imag</span>
            <span class="s1">stop[all_imag] = stop[all_imag].imag</span>
            <span class="s1">out_sign[all_imag] = </span><span class="s3">1j</span>

    <span class="s1">both_negative = (_nx.sign(start) == -</span><span class="s3">1</span><span class="s1">) &amp; (_nx.sign(stop) == -</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">_nx.any(both_negative):</span>
        <span class="s1">_nx.negative(start</span><span class="s0">, </span><span class="s1">out=start</span><span class="s0">, </span><span class="s1">where=both_negative)</span>
        <span class="s1">_nx.negative(stop</span><span class="s0">, </span><span class="s1">out=stop</span><span class="s0">, </span><span class="s1">where=both_negative)</span>
        <span class="s1">_nx.negative(out_sign</span><span class="s0">, </span><span class="s1">out=out_sign</span><span class="s0">, </span><span class="s1">where=both_negative)</span>

    <span class="s1">log_start = _nx.log10(start)</span>
    <span class="s1">log_stop = _nx.log10(stop)</span>
    <span class="s1">result = logspace(log_start</span><span class="s0">, </span><span class="s1">log_stop</span><span class="s0">, </span><span class="s1">num=num</span><span class="s0">,</span>
                      <span class="s1">endpoint=endpoint</span><span class="s0">, </span><span class="s1">base=</span><span class="s3">10.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s5"># Make sure the endpoints match the start and stop arguments. This is</span>
    <span class="s5"># necessary because np.exp(np.log(x)) is not necessarily equal to x.</span>
    <span class="s0">if </span><span class="s1">num &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">result[</span><span class="s3">0</span><span class="s1">] = start</span>
        <span class="s0">if </span><span class="s1">num &gt; </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">endpoint:</span>
            <span class="s1">result[-</span><span class="s3">1</span><span class="s1">] = stop</span>

    <span class="s1">result = out_sign * result</span>

    <span class="s0">if </span><span class="s1">axis != </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">result = _nx.moveaxis(result</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s0">return </span><span class="s1">result.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_needs_add_docstring(obj):</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns true if the only way to set the docstring of `obj` from python is 
    via add_docstring. 
 
    This function errs on the side of being overly conservative. 
    &quot;&quot;&quot;</span>
    <span class="s1">Py_TPFLAGS_HEAPTYPE = </span><span class="s3">1 </span><span class="s1">&lt;&lt; </span><span class="s3">9</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">(types.FunctionType</span><span class="s0">, </span><span class="s1">types.MethodType</span><span class="s0">, </span><span class="s1">property)):</span>
        <span class="s0">return False</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">type) </span><span class="s0">and </span><span class="s1">obj.__flags__ &amp; Py_TPFLAGS_HEAPTYPE:</span>
        <span class="s0">return False</span>

    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_add_docstring(obj</span><span class="s0">, </span><span class="s1">doc</span><span class="s0">, </span><span class="s1">warn_on_python):</span>
    <span class="s0">if </span><span class="s1">warn_on_python </span><span class="s0">and not </span><span class="s1">_needs_add_docstring(obj):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;add_newdoc was used on a pure-python object {}. &quot;</span>
            <span class="s2">&quot;Prefer to attach it directly to the source.&quot;</span>
            <span class="s1">.format(obj)</span><span class="s0">,</span>
            <span class="s1">UserWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">add_docstring(obj</span><span class="s0">, </span><span class="s1">doc)</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">add_newdoc(place</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">doc</span><span class="s0">, </span><span class="s1">warn_on_python=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Add documentation to an existing object, typically one defined in C 
 
    The purpose is to allow easier editing of the docstrings without requiring 
    a re-compile. This exists primarily for internal use within numpy itself. 
 
    Parameters 
    ---------- 
    place : str 
        The absolute name of the module to import from 
    obj : str 
        The name of the object to add documentation to, typically a class or 
        function name 
    doc : {str, Tuple[str, str], List[Tuple[str, str]]} 
        If a string, the documentation to apply to `obj` 
 
        If a tuple, then the first element is interpreted as an attribute of 
        `obj` and the second as the docstring to apply - ``(method, docstring)`` 
 
        If a list, then each element of the list should be a tuple of length 
        two - ``[(method1, docstring1), (method2, docstring2), ...]`` 
    warn_on_python : bool 
        If True, the default, emit `UserWarning` if this is used to attach 
        documentation to a pure-python object. 
 
    Notes 
    ----- 
    This routine never raises an error if the docstring can't be written, but 
    will raise an error if the object being documented does not exist. 
 
    This routine cannot modify read-only docstrings, as appear 
    in new-style classes or built-in functions. Because this 
    routine never raises an error the caller must check manually 
    that the docstrings were changed. 
 
    Since this function grabs the ``char *`` from a c-level str object and puts 
    it into the ``tp_doc`` slot of the type of `obj`, it violates a number of 
    C-API best-practices, by: 
 
    - modifying a `PyTypeObject` after calling `PyType_Ready` 
    - calling `Py_INCREF` on the str and losing the reference, so the str 
      will never be released 
 
    If possible it should be avoided. 
    &quot;&quot;&quot;</span>
    <span class="s1">new = getattr(__import__(place</span><span class="s0">, </span><span class="s1">globals()</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">[obj])</span><span class="s0">, </span><span class="s1">obj)</span>
    <span class="s0">if </span><span class="s1">isinstance(doc</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">_add_docstring(new</span><span class="s0">, </span><span class="s1">doc.strip()</span><span class="s0">, </span><span class="s1">warn_on_python)</span>
    <span class="s0">elif </span><span class="s1">isinstance(doc</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">attr</span><span class="s0">, </span><span class="s1">docstring = doc</span>
        <span class="s1">_add_docstring(getattr(new</span><span class="s0">, </span><span class="s1">attr)</span><span class="s0">, </span><span class="s1">docstring.strip()</span><span class="s0">, </span><span class="s1">warn_on_python)</span>
    <span class="s0">elif </span><span class="s1">isinstance(doc</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">for </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">docstring </span><span class="s0">in </span><span class="s1">doc:</span>
            <span class="s1">_add_docstring(getattr(new</span><span class="s0">, </span><span class="s1">attr)</span><span class="s0">, </span><span class="s1">docstring.strip()</span><span class="s0">, </span><span class="s1">warn_on_python)</span>
</pre>
</body>
</html>