<html>
<head>
<title>masked.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
masked.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">TypeVar</span><span class="s0">,</span>
    <span class="s1">overload</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">iNaT</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">missing </span><span class="s0">as </span><span class="s1">libmissing</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s0">,</span>
    <span class="s1">AstypeArg</span><span class="s0">,</span>
    <span class="s1">NpDtype</span><span class="s0">,</span>
    <span class="s1">PositionalIndexer</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">ScalarIndexer</span><span class="s0">,</span>
    <span class="s1">SequenceIndexer</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
    <span class="s1">type_t</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">cache_readonly</span><span class="s0">,</span>
    <span class="s1">doc</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._validators </span><span class="s0">import </span><span class="s1">validate_fillna_kwargs</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.base </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_dtype_equal</span><span class="s0">,</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_float_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s0">import </span><span class="s1">is_array_like</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_equivalent</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">notna</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">arraylike</span><span class="s0">,</span>
    <span class="s1">missing</span><span class="s0">,</span>
    <span class="s1">nanops</span><span class="s0">,</span>
    <span class="s1">ops</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">factorize_array</span><span class="s0">,</span>
    <span class="s1">isin</span><span class="s0">,</span>
    <span class="s1">take</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos </span><span class="s0">import </span><span class="s1">masked_reductions</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.quantile </span><span class="s0">import </span><span class="s1">quantile_with_mask</span>
<span class="s0">from </span><span class="s1">pandas.core.arraylike </span><span class="s0">import </span><span class="s1">OpsMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.indexers </span><span class="s0">import </span><span class="s1">check_array_indexer</span>
<span class="s0">from </span><span class="s1">pandas.core.ops </span><span class="s0">import </span><span class="s1">invalid_comparison</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>
    <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

<span class="s0">from </span><span class="s1">pandas.compat.numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>

<span class="s1">BaseMaskedArrayT = TypeVar(</span><span class="s2">&quot;BaseMaskedArrayT&quot;</span><span class="s0">, </span><span class="s1">bound=</span><span class="s2">&quot;BaseMaskedArray&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">BaseMaskedDtype(ExtensionDtype):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for dtypes for BasedMaskedArray subclasses. 
    &quot;&quot;&quot;</span>

    <span class="s1">name: str</span>
    <span class="s1">base = </span><span class="s0">None</span>
    <span class="s1">type: type</span>

    <span class="s1">na_value = libmissing.NA</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">numpy_dtype(self) -&gt; np.dtype:</span>
        <span class="s3">&quot;&quot;&quot;Return an instance of our numpy dtype&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.dtype(self.type)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.numpy_dtype.kind</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">itemsize(self) -&gt; int:</span>
        <span class="s3">&quot;&quot;&quot;Return the number of bytes in this dtype&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.numpy_dtype.itemsize</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[BaseMaskedArray]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>


<span class="s0">class </span><span class="s1">BaseMaskedArray(OpsMixin</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for masked arrays (which use _data and _mask to store the data). 
 
    numpy based 
    &quot;&quot;&quot;</span>

    <span class="s4"># The value used to fill '_data' to avoid upcasting</span>
    <span class="s1">_internal_fill_value: Scalar</span>
    <span class="s4"># our underlying data and mask are each ndarrays</span>
    <span class="s1">_data: np.ndarray</span>
    <span class="s1">_mask: np.ndarray</span>

    <span class="s4"># Fill values used for any/all</span>
    <span class="s1">_truthy_value = Scalar  </span><span class="s4"># bool(_truthy_value) = True</span>
    <span class="s1">_falsey_value = Scalar  </span><span class="s4"># bool(_falsey_value) = False</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values: np.ndarray</span><span class="s0">, </span><span class="s1">mask: np.ndarray</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s4"># values is supposed to already be validated in the subclass</span>
        <span class="s0">if not </span><span class="s1">(isinstance(mask</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">mask.dtype == np.bool_):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;mask should be boolean numpy array. Use &quot;</span>
                <span class="s2">&quot;the 'pd.array' function instead&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">values.shape != mask.shape:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;values.shape must match mask.shape&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">copy:</span>
            <span class="s1">values = values.copy()</span>
            <span class="s1">mask = mask.copy()</span>

        <span class="s1">self._data = values</span>
        <span class="s1">self._mask = mask</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; BaseMaskedDtype:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item: ScalarIndexer) -&gt; Any:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">item: SequenceIndexer) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">__getitem__(</span>
        <span class="s1">self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">item: PositionalIndexer</span>
    <span class="s1">) -&gt; BaseMaskedArrayT | Any:</span>
        <span class="s1">item = check_array_indexer(self</span><span class="s0">, </span><span class="s1">item)</span>

        <span class="s1">newmask = self._mask[item]</span>
        <span class="s0">if </span><span class="s1">is_bool(newmask):</span>
            <span class="s4"># This is a scalar indexing</span>
            <span class="s0">if </span><span class="s1">newmask:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>
            <span class="s0">return </span><span class="s1">self._data[item]</span>

        <span class="s0">return </span><span class="s1">type(self)(self._data[item]</span><span class="s0">, </span><span class="s1">newmask)</span>

    <span class="s1">@doc(ExtensionArray.fillna)</span>
    <span class="s0">def </span><span class="s1">fillna(</span>
        <span class="s1">self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">value=</span><span class="s0">None, </span><span class="s1">method=</span><span class="s0">None, </span><span class="s1">limit=</span><span class="s0">None</span>
    <span class="s1">) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">value</span><span class="s0">, </span><span class="s1">method = validate_fillna_kwargs(value</span><span class="s0">, </span><span class="s1">method)</span>

        <span class="s1">mask = self._mask</span>

        <span class="s0">if </span><span class="s1">is_array_like(value):</span>
            <span class="s0">if </span><span class="s1">len(value) != len(self):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;Length of 'value' does not match. Got (</span><span class="s0">{</span><span class="s1">len(value)</span><span class="s0">}</span><span class="s2">) &quot;</span>
                    <span class="s2">f&quot; expected </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">value = value[mask]</span>

        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">func = missing.get_fill_func(method</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>
                <span class="s1">new_values</span><span class="s0">, </span><span class="s1">new_mask = func(</span>
                    <span class="s1">self._data.copy().T</span><span class="s0">,</span>
                    <span class="s1">limit=limit</span><span class="s0">,</span>
                    <span class="s1">mask=mask.copy().T</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">return </span><span class="s1">type(self)(new_values.T</span><span class="s0">, </span><span class="s1">new_mask.view(np.bool_).T)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># fill with value</span>
                <span class="s1">new_values = self.copy()</span>
                <span class="s1">new_values[mask] = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_values = self.copy()</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s0">def </span><span class="s1">_coerce_to_array(self</span><span class="s0">, </span><span class="s1">values) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">np.ndarray]:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">_is_scalar = is_scalar(value)</span>
        <span class="s0">if </span><span class="s1">_is_scalar:</span>
            <span class="s1">value = [value]</span>
        <span class="s1">value</span><span class="s0">, </span><span class="s1">mask = self._coerce_to_array(value)</span>

        <span class="s0">if </span><span class="s1">_is_scalar:</span>
            <span class="s1">value = value[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">mask = mask[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">key = check_array_indexer(self</span><span class="s0">, </span><span class="s1">key)</span>
        <span class="s1">self._data[key] = value</span>
        <span class="s1">self._mask[key] = mask</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self)):</span>
                <span class="s0">if </span><span class="s1">self._mask[i]:</span>
                    <span class="s0">yield </span><span class="s1">self.dtype.na_value</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">self._data[i]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self)):</span>
                <span class="s0">yield </span><span class="s1">self[i]</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self._data)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">shape(self) -&gt; Shape:</span>
        <span class="s0">return </span><span class="s1">self._data.shape</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ndim(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._data.ndim</span>

    <span class="s0">def </span><span class="s1">swapaxes(self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">data = self._data.swapaxes(axis1</span><span class="s0">, </span><span class="s1">axis2)</span>
        <span class="s1">mask = self._mask.swapaxes(axis1</span><span class="s0">, </span><span class="s1">axis2)</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">delete(self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">data = np.delete(self._data</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">mask = np.delete(self._mask</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">reshape(self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">data = self._data.reshape(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mask = self._mask.reshape(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">ravel(self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; BaseMaskedArrayT:</span>
        <span class="s4"># TODO: need to make sure we have the same order for data/mask</span>
        <span class="s1">data = self._data.ravel(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mask = self._mask.ravel(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">T(self: BaseMaskedArrayT) -&gt; BaseMaskedArrayT:</span>
        <span class="s0">return </span><span class="s1">type(self)(self._data.T</span><span class="s0">, </span><span class="s1">self._mask.T)</span>

    <span class="s0">def </span><span class="s1">__invert__(self: BaseMaskedArrayT) -&gt; BaseMaskedArrayT:</span>
        <span class="s0">return </span><span class="s1">type(self)(~self._data</span><span class="s0">, </span><span class="s1">self._mask.copy())</span>

    <span class="s0">def </span><span class="s1">to_numpy(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dtype: npt.DTypeLike | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">na_value: Scalar = lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert to a NumPy Array. 
 
        By default converts to an object-dtype NumPy array. Specify the `dtype` and 
        `na_value` keywords to customize the conversion. 
 
        Parameters 
        ---------- 
        dtype : dtype, default object 
            The numpy dtype to convert to. 
        copy : bool, default False 
            Whether to ensure that the returned value is a not a view on 
            the array. Note that ``copy=False`` does not *ensure* that 
            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that 
            a copy is made, even if not strictly necessary. This is typically 
            only possible when no missing values are present and `dtype` 
            is the equivalent numpy dtype. 
        na_value : scalar, optional 
             Scalar missing value indicator to use in numpy array. Defaults 
             to the native missing value indicator of this array (pd.NA). 
 
        Returns 
        ------- 
        numpy.ndarray 
 
        Examples 
        -------- 
        An object-dtype is the default result 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a.to_numpy() 
        array([True, False, &lt;NA&gt;], dtype=object) 
 
        When no missing values are present, an equivalent dtype can be used. 
 
        &gt;&gt;&gt; pd.array([True, False], dtype=&quot;boolean&quot;).to_numpy(dtype=&quot;bool&quot;) 
        array([ True, False]) 
        &gt;&gt;&gt; pd.array([1, 2], dtype=&quot;Int64&quot;).to_numpy(&quot;int64&quot;) 
        array([1, 2]) 
 
        However, requesting such dtype will raise a ValueError if 
        missing values are present and the default missing value :attr:`NA` 
        is used. 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a 
        &lt;BooleanArray&gt; 
        [True, False, &lt;NA&gt;] 
        Length: 3, dtype: boolean 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;) 
        Traceback (most recent call last): 
        ... 
        ValueError: cannot convert to bool numpy array in presence of missing values 
 
        Specify a valid `na_value` instead 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;, na_value=False) 
        array([ True, False, False]) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">na_value = libmissing.NA</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = object</span>
        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s0">not </span><span class="s1">is_object_dtype(dtype)</span>
                <span class="s0">and not </span><span class="s1">is_string_dtype(dtype)</span>
                <span class="s0">and </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">libmissing.NA</span>
            <span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;cannot convert to '</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s2">'-dtype NumPy array &quot;</span>
                    <span class="s2">&quot;with missing values. Specify an appropriate 'na_value' &quot;</span>
                    <span class="s2">&quot;for this dtype.&quot;</span>
                <span class="s1">)</span>
            <span class="s4"># don't pass copy to astype -&gt; always need a copy since we are mutating</span>
            <span class="s1">data = self._data.astype(dtype)</span>
            <span class="s1">data[self._mask] = na_value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = self._data.astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: npt.DTypeLike</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; np.ndarray:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: ExtensionDtype</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; ExtensionArray:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: AstypeArg</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; ArrayLike:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: AstypeArg</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">) -&gt; ArrayLike:</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>

        <span class="s0">if </span><span class="s1">is_dtype_equal(dtype</span><span class="s0">, </span><span class="s1">self.dtype):</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy()</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s4"># if we are astyping to another nullable masked dtype, we can fastpath</span>
        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">BaseMaskedDtype):</span>
            <span class="s4"># TODO deal with NaNs for FloatingArray case</span>
            <span class="s1">data = self._data.astype(dtype.numpy_dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
            <span class="s4"># mask is copied depending on whether the data was copied, and</span>
            <span class="s4"># not directly depending on the `copy` keyword</span>
            <span class="s1">mask = self._mask </span><span class="s0">if </span><span class="s1">data </span><span class="s0">is </span><span class="s1">self._data </span><span class="s0">else </span><span class="s1">self._mask.copy()</span>
            <span class="s1">cls = dtype.construct_array_type()</span>
            <span class="s0">return </span><span class="s1">cls(data</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">eacls = dtype.construct_array_type()</span>
            <span class="s0">return </span><span class="s1">eacls._from_sequence(self</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;subclass must implement astype to np.dtype&quot;</span><span class="s1">)</span>

    <span class="s1">__array_priority__ = </span><span class="s5">1000  </span><span class="s4"># higher than ndarray so ops dispatch to us</span>

    <span class="s0">def </span><span class="s1">__array__(self</span><span class="s0">, </span><span class="s1">dtype: NpDtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s3">&quot;&quot;&quot; 
        the array interface, return my values 
        We return an object array here to preserve our scalar values 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.to_numpy(dtype=dtype)</span>

    <span class="s1">_HANDLED_TYPES: tuple[type</span><span class="s0">, </span><span class="s1">...]</span>

    <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc: np.ufunc</span><span class="s0">, </span><span class="s1">method: str</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># For MaskedArray inputs, we apply the ufunc to ._data</span>
        <span class="s4"># and mask the result.</span>

        <span class="s1">out = kwargs.get(</span><span class="s2">&quot;out&quot;</span><span class="s0">, </span><span class="s1">())</span>

        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs + out:</span>
            <span class="s0">if not </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">self._HANDLED_TYPES + (BaseMaskedArray</span><span class="s0">,</span><span class="s1">)):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s4"># for binary ops, use our custom dunder methods</span>
        <span class="s1">result = ops.maybe_dispatch_ufunc_to_dunder_op(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s2">&quot;out&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s4"># e.g. test_ufunc_with_out</span>
            <span class="s0">return </span><span class="s1">arraylike.dispatch_ufunc_with_out(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;reduce&quot;</span><span class="s1">:</span>
            <span class="s1">result = arraylike.dispatch_reduction_ufunc(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented:</span>
                <span class="s0">return </span><span class="s1">result</span>

        <span class="s1">mask = np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">inputs2 = []</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs:</span>
            <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
                <span class="s1">mask |= x._mask</span>
                <span class="s1">inputs2.append(x._data)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">inputs2.append(x)</span>

        <span class="s0">def </span><span class="s1">reconstruct(x):</span>
            <span class="s4"># we don't worry about scalar `x` here, since we</span>
            <span class="s4"># raise for reduce up above.</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
                <span class="s1">BooleanArray</span><span class="s0">,</span>
                <span class="s1">FloatingArray</span><span class="s0">,</span>
                <span class="s1">IntegerArray</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">is_bool_dtype(x.dtype):</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">return </span><span class="s1">BooleanArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">elif </span><span class="s1">is_integer_dtype(x.dtype):</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">return </span><span class="s1">IntegerArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">elif </span><span class="s1">is_float_dtype(x.dtype):</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">if </span><span class="s1">x.dtype == np.float16:</span>
                    <span class="s4"># reached in e.g. np.sqrt on BooleanArray</span>
                    <span class="s4"># we don't support float16</span>
                    <span class="s1">x = x.astype(np.float32)</span>
                <span class="s0">return </span><span class="s1">FloatingArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x[mask] = np.nan</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s1">result = getattr(ufunc</span><span class="s0">, </span><span class="s1">method)(*inputs2</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">ufunc.nout &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># e.g. np.divmod</span>
            <span class="s0">return </span><span class="s1">tuple(reconstruct(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result)</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s2">&quot;reduce&quot;</span><span class="s1">:</span>
            <span class="s4"># e.g. np.add.reduce; test_ufunc_reduce_raises</span>
            <span class="s0">if </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">self._na_value</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">reconstruct(result)</span>

    <span class="s0">def </span><span class="s1">__arrow_array__(self</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert myself into a pyarrow Array. 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>

        <span class="s0">return </span><span class="s1">pa.array(self._data</span><span class="s0">, </span><span class="s1">mask=self._mask</span><span class="s0">, </span><span class="s1">type=type)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_hasna(self) -&gt; bool:</span>
        <span class="s4"># Note: this is expensive right now! The hope is that we can</span>
        <span class="s4"># make this faster by having an optional mask, but not have to change</span>
        <span class="s4"># source code using it..</span>

        <span class="s4"># error: Incompatible return value type (got &quot;bool_&quot;, expected &quot;bool&quot;)</span>
        <span class="s0">return </span><span class="s1">self._mask.any()  </span><span class="s4"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">_cmp_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op) -&gt; BooleanArray:</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s1">mask = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s1">other</span><span class="s0">, </span><span class="s1">mask = other._data</span><span class="s0">, </span><span class="s1">other._mask</span>

        <span class="s0">elif </span><span class="s1">is_list_like(other):</span>
            <span class="s1">other = np.asarray(other)</span>
            <span class="s0">if </span><span class="s1">other.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;can only perform ops with 1-d structures&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(self) != len(other):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Lengths must match to compare&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing.NA:</span>
            <span class="s4"># numpy does not handle pd.NA well as &quot;other&quot; scalar (it returns</span>
            <span class="s4"># a scalar False instead of an array)</span>
            <span class="s4"># This may be fixed by NA.__array_ufunc__. Revisit this check</span>
            <span class="s4"># once that's implemented.</span>
            <span class="s1">result = np.zeros(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
            <span class="s1">mask = np.ones(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s4"># numpy may show a FutureWarning:</span>
                <span class="s4">#     elementwise comparison failed; returning scalar instead,</span>
                <span class="s4">#     but in the future will perform elementwise comparison</span>
                <span class="s4"># before returning NotImplemented. We fall back to the correct</span>
                <span class="s4"># behavior today, so that should be fine to ignore.</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s2">&quot;elementwise&quot;</span><span class="s0">, </span><span class="s1">FutureWarning)</span>
                <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s1">method = getattr(self._data</span><span class="s0">, </span><span class="s2">f&quot;__</span><span class="s0">{</span><span class="s1">op.__name__</span><span class="s0">}</span><span class="s2">__&quot;</span><span class="s1">)</span>
                    <span class="s1">result = method(other)</span>

                <span class="s0">if </span><span class="s1">result </span><span class="s0">is </span><span class="s1">NotImplemented:</span>
                    <span class="s1">result = invalid_comparison(self._data</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op)</span>

        <span class="s4"># nans propagate</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mask = self._mask.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mask = self._mask | mask</span>

        <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_maybe_mask_result(self</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op_name: str):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        result : array-like 
        mask : array-like bool 
        other : scalar or array-like 
        op_name : str 
        &quot;&quot;&quot;</span>
        <span class="s4"># if we have a float operand we are by-definition</span>
        <span class="s4"># a float result</span>
        <span class="s4"># or our op is a divide</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">(is_float_dtype(other) </span><span class="s0">or </span><span class="s1">is_float(other))</span>
            <span class="s0">or </span><span class="s1">(op_name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;rtruediv&quot;</span><span class="s0">, </span><span class="s2">&quot;truediv&quot;</span><span class="s1">])</span>
            <span class="s0">or </span><span class="s1">(is_float_dtype(self.dtype) </span><span class="s0">and </span><span class="s1">is_numeric_dtype(result.dtype))</span>
        <span class="s1">):</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">FloatingArray</span>

            <span class="s0">return </span><span class="s1">FloatingArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">is_bool_dtype(result):</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

            <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">result.dtype == </span><span class="s2">&quot;timedelta64[ns]&quot;</span><span class="s1">:</span>
            <span class="s4"># e.g. test_numeric_arr_mul_tdscalar_numexpr_path</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">TimedeltaArray</span>

            <span class="s1">result[mask] = iNaT</span>
            <span class="s0">return </span><span class="s1">TimedeltaArray._simple_new(result)</span>

        <span class="s0">elif </span><span class="s1">is_integer_dtype(result):</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

            <span class="s0">return </span><span class="s1">IntegerArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result[mask] = np.nan</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">isna(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">self._mask.copy()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_na_value(self):</span>
        <span class="s0">return </span><span class="s1">self.dtype.na_value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nbytes(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._data.nbytes + self._mask.nbytes</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_concat_same_type(</span>
        <span class="s1">cls: type[BaseMaskedArrayT]</span><span class="s0">,</span>
        <span class="s1">to_concat: Sequence[BaseMaskedArrayT]</span><span class="s0">,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s1">) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">data = np.concatenate([x._data </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">mask = np.concatenate([x._mask </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">cls(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">take(</span>
        <span class="s1">self: BaseMaskedArrayT</span><span class="s0">,</span>
        <span class="s1">indexer</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s0">False,</span>
        <span class="s1">fill_value: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">axis: int = </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s1">) -&gt; BaseMaskedArrayT:</span>
        <span class="s4"># we always fill with 1 internally</span>
        <span class="s4"># to avoid upcasting</span>
        <span class="s1">data_fill_value = self._internal_fill_value </span><span class="s0">if </span><span class="s1">isna(fill_value) </span><span class="s0">else </span><span class="s1">fill_value</span>
        <span class="s1">result = take(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">indexer</span><span class="s0">,</span>
            <span class="s1">fill_value=data_fill_value</span><span class="s0">,</span>
            <span class="s1">allow_fill=allow_fill</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">mask = take(</span>
            <span class="s1">self._mask</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">True, </span><span class="s1">allow_fill=allow_fill</span><span class="s0">, </span><span class="s1">axis=axis</span>
        <span class="s1">)</span>

        <span class="s4"># if we are filling</span>
        <span class="s4"># we only fill where the indexer is null</span>
        <span class="s4"># not existing missing values</span>
        <span class="s4"># TODO(jreback) what if we have a non-na float as a fill value?</span>
        <span class="s0">if </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">notna(fill_value):</span>
            <span class="s1">fill_mask = np.asarray(indexer) == -</span><span class="s5">1</span>
            <span class="s1">result[fill_mask] = fill_value</span>
            <span class="s1">mask = mask ^ fill_mask</span>

        <span class="s0">return </span><span class="s1">type(self)(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># error: Return type &quot;BooleanArray&quot; of &quot;isin&quot; incompatible with return type</span>
    <span class="s4"># &quot;ndarray&quot; in supertype &quot;ExtensionArray&quot;</span>
    <span class="s0">def </span><span class="s1">isin(self</span><span class="s0">, </span><span class="s1">values) -&gt; BooleanArray:  </span><span class="s4"># type: ignore[override]</span>

        <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s4"># algorithms.isin will eventually convert values to an ndarray, so no extra</span>
        <span class="s4"># cost to doing it here first</span>
        <span class="s1">values_arr = np.asarray(values)</span>
        <span class="s1">result = isin(self._data</span><span class="s0">, </span><span class="s1">values_arr)</span>

        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s1">values_have_NA = is_object_dtype(values_arr.dtype) </span><span class="s0">and </span><span class="s1">any(</span>
                <span class="s1">val </span><span class="s0">is </span><span class="s1">self.dtype.na_value </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">values_arr</span>
            <span class="s1">)</span>

            <span class="s4"># For now, NA does not propagate so set result according to presence of NA,</span>
            <span class="s4"># see https://github.com/pandas-dev/pandas/pull/38379 for some discussion</span>
            <span class="s1">result[self._mask] = values_have_NA</span>

        <span class="s1">mask = np.zeros(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">copy(self: BaseMaskedArrayT) -&gt; BaseMaskedArrayT:</span>
        <span class="s1">data</span><span class="s0">, </span><span class="s1">mask = self._data</span><span class="s0">, </span><span class="s1">self._mask</span>
        <span class="s1">data = data.copy()</span>
        <span class="s1">mask = mask.copy()</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@doc(ExtensionArray.factorize)</span>
    <span class="s0">def </span><span class="s1">factorize(self</span><span class="s0">, </span><span class="s1">na_sentinel: int = -</span><span class="s5">1</span><span class="s1">) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">ExtensionArray]:</span>
        <span class="s1">arr = self._data</span>
        <span class="s1">mask = self._mask</span>

        <span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques = factorize_array(arr</span><span class="s0">, </span><span class="s1">na_sentinel=na_sentinel</span><span class="s0">, </span><span class="s1">mask=mask)</span>

        <span class="s4"># the hashtables don't handle all different types of bits</span>
        <span class="s1">uniques = uniques.astype(self.dtype.numpy_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">uniques_ea = type(self)(uniques</span><span class="s0">, </span><span class="s1">np.zeros(len(uniques)</span><span class="s0">, </span><span class="s1">dtype=bool))</span>
        <span class="s0">return </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques_ea</span>

    <span class="s0">def </span><span class="s1">value_counts(self</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True</span><span class="s1">) -&gt; Series:</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a Series containing counts of each unique value. 
 
        Parameters 
        ---------- 
        dropna : bool, default True 
            Don't include counts of missing values. 
 
        Returns 
        ------- 
        counts : Series 
 
        See Also 
        -------- 
        Series.value_counts 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">Index</span><span class="s0">,</span>
            <span class="s1">Series</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">from </span><span class="s1">pandas.arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

        <span class="s4"># compute counts on the data with no nans</span>
        <span class="s1">data = self._data[~self._mask]</span>
        <span class="s1">value_counts = Index(data).value_counts()</span>

        <span class="s1">index = value_counts.index</span>

        <span class="s4"># if we want nans, count the mask</span>
        <span class="s0">if </span><span class="s1">dropna:</span>
            <span class="s1">counts = value_counts._values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">counts = np.empty(len(value_counts) + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
            <span class="s1">counts[:-</span><span class="s5">1</span><span class="s1">] = value_counts</span>
            <span class="s1">counts[-</span><span class="s5">1</span><span class="s1">] = self._mask.sum()</span>

            <span class="s1">index = index.insert(len(index)</span><span class="s0">, </span><span class="s1">self.dtype.na_value)</span>

        <span class="s1">index = index.astype(self.dtype)</span>

        <span class="s1">mask = np.zeros(len(counts)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s1">counts = IntegerArray(counts</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">return </span><span class="s1">Series(counts</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s1">@doc(ExtensionArray.equals)</span>
    <span class="s0">def </span><span class="s1">equals(self</span><span class="s0">, </span><span class="s1">other) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">type(self) != type(other):</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">other.dtype != self.dtype:</span>
            <span class="s0">return False</span>

        <span class="s4"># GH#44382 if e.g. self[1] is np.nan and other[1] is pd.NA, we are NOT</span>
        <span class="s4">#  equal.</span>
        <span class="s0">if not </span><span class="s1">np.array_equal(self._mask</span><span class="s0">, </span><span class="s1">other._mask):</span>
            <span class="s0">return False</span>

        <span class="s1">left = self._data[~self._mask]</span>
        <span class="s1">right = other._data[~other._mask]</span>
        <span class="s0">return </span><span class="s1">array_equivalent(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">dtype_equal=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_quantile(</span>
        <span class="s1">self: BaseMaskedArrayT</span><span class="s0">, </span><span class="s1">qs: npt.NDArray[np.float64]</span><span class="s0">, </span><span class="s1">interpolation: str</span>
    <span class="s1">) -&gt; BaseMaskedArrayT:</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch to quantile_with_mask, needed because we do not have 
        _from_factorized. 
 
        Notes 
        ----- 
        We assume that all impacted cases are 1D-only. 
        &quot;&quot;&quot;</span>
        <span class="s1">mask = np.atleast_2d(np.asarray(self.isna()))</span>
        <span class="s1">npvalues: np.ndarray = np.atleast_2d(np.asarray(self))</span>

        <span class="s1">res = quantile_with_mask(</span>
            <span class="s1">npvalues</span><span class="s0">,</span>
            <span class="s1">mask=mask</span><span class="s0">,</span>
            <span class="s1">fill_value=self.dtype.na_value</span><span class="s0">,</span>
            <span class="s1">qs=qs</span><span class="s0">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.ndim == </span><span class="s5">2</span>
        <span class="s0">assert </span><span class="s1">res.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span>
        <span class="s1">res = res[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">out = type(self)._from_sequence(res</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s4"># GH#42626: not able to safely cast Int64</span>
            <span class="s4"># for floating point output</span>
            <span class="s1">out = np.asarray(res</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">def </span><span class="s1">_reduce(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;any&quot;</span><span class="s0">, </span><span class="s2">&quot;all&quot;</span><span class="s0">, </span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;prod&quot;</span><span class="s1">}:</span>
            <span class="s0">return </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">name)(skipna=skipna</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">data = self._data</span>
        <span class="s1">mask = self._mask</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;mean&quot;</span><span class="s1">}:</span>
            <span class="s1">op = getattr(masked_reductions</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s1">result = op(data</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s4"># coerce to a nan-aware float if needed</span>
        <span class="s4"># (we explicitly use NaN within reductions)</span>
        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s1">data = self.to_numpy(</span><span class="s2">&quot;float64&quot;</span><span class="s0">, </span><span class="s1">na_value=np.nan)</span>

        <span class="s4"># median, var, std, skew, kurt, idxmin, idxmax</span>
        <span class="s1">op = getattr(nanops</span><span class="s0">, </span><span class="s2">&quot;nan&quot; </span><span class="s1">+ name)</span>
        <span class="s1">result = op(data</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if </span><span class="s1">np.isnan(result):</span>
            <span class="s0">return </span><span class="s1">libmissing.NA</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_wrap_reduction_result(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">axis = kwargs[</span><span class="s2">&quot;axis&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">skipna:</span>
                <span class="s4"># we only retain mask for all-NA rows/columns</span>
                <span class="s1">mask = self._mask.all(axis=axis)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mask = self._mask.any(axis=axis)</span>

            <span class="s0">return </span><span class="s1">self._maybe_mask_result(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">other=</span><span class="s0">None, </span><span class="s1">op_name=name)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">sum(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">min_count=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_sum(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s4"># TODO: do this in validate_sum?</span>
        <span class="s0">if </span><span class="s2">&quot;out&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s4"># np.sum; test_floating_array_numpy_sum</span>
            <span class="s0">if </span><span class="s1">kwargs[</span><span class="s2">&quot;out&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span>
            <span class="s1">kwargs.pop(</span><span class="s2">&quot;out&quot;</span><span class="s1">)</span>

        <span class="s1">result = masked_reductions.sum(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span>
            <span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">prod(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">min_count=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_prod(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">result = masked_reductions.prod(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span>
            <span class="s2">&quot;prod&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">min(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_min(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">masked_reductions.min(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">max(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_max(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">masked_reductions.max(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">any(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether any element is truthy. 
 
        Returns False unless there is at least one element that is truthy. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be False, as for an empty array. 
            If `skipna` is False, the result will still be True if there is 
            at least one element that is truthy, otherwise NA will be returned 
            if there are NA's present. 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.any : Numpy version of this method. 
        BaseMaskedArray.all : Return whether all elements are truthy. 
 
        Examples 
        -------- 
        The result indicates whether any element is truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, False, True]).any() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any() 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).any() 
        False 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([0, 0, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs.pop(</span><span class="s2">&quot;axis&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">nv.validate_any(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">values = self._data.copy()</span>
        <span class="s4"># Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;; expected</span>
        <span class="s4"># &quot;Union[_SupportsArray[dtype[Any]], _NestedSequence[</span>
        <span class="s4"># _SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _Nested</span>
        <span class="s4"># Sequence[Union[bool, int, float, complex, str, bytes]]]&quot;  [arg-type]</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">self._mask</span><span class="s0">, </span><span class="s1">self._falsey_value)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">result = values.any()</span>
        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len(self) == </span><span class="s5">0 </span><span class="s0">or not </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>

    <span class="s0">def </span><span class="s1">all(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether all elements are truthy. 
 
        Returns True unless there is at least one element that is falsey. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be True, as for an empty array. 
            If `skipna` is False, the result will still be False if there is 
            at least one element that is falsey, otherwise NA will be returned 
            if there are NA's present. 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.all : Numpy version of this method. 
        BooleanArray.any : Return whether any element is truthy. 
 
        Examples 
        -------- 
        The result indicates whether all elements are truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).all() 
        True 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all(skipna=False) 
        False 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).all(skipna=False) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs.pop(</span><span class="s2">&quot;axis&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">nv.validate_all(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">values = self._data.copy()</span>
        <span class="s4"># Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;; expected</span>
        <span class="s4"># &quot;Union[_SupportsArray[dtype[Any]], _NestedSequence[</span>
        <span class="s4"># _SupportsArray[dtype[Any]]], bool, int, float, complex, str, bytes, _Neste</span>
        <span class="s4"># dSequence[Union[bool, int, float, complex, str, bytes]]]&quot;  [arg-type]</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">self._mask</span><span class="s0">, </span><span class="s1">self._truthy_value)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">result = values.all()</span>

        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len(self) == </span><span class="s5">0 </span><span class="s0">or not </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>
</pre>
</body>
</html>