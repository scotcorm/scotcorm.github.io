<html>
<head>
<title>test_internals.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_internals.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s0">,</span>
    <span class="s1">datetime</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas._libs.internals </span><span class="s0">import </span><span class="s1">BlockPlacement</span>
<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">is_scalar</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timedelta</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">period_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s0">,</span>
    <span class="s1">SparseArray</span><span class="s0">,</span>
    <span class="s1">TimedeltaArray</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.internals </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BlockManager</span><span class="s0">,</span>
    <span class="s1">SingleBlockManager</span><span class="s0">,</span>
    <span class="s1">make_block</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.internals.blocks </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_block_shape</span><span class="s0">,</span>
    <span class="s1">new_block</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s2"># this file contains BlockManager specific tests</span>
<span class="s2"># TODO(ArrayManager) factor out interleave_dtype tests</span>
<span class="s1">pytestmark = td.skip_array_manager_invalid_test</span>


<span class="s1">@pytest.fixture(params=[new_block</span><span class="s0">, </span><span class="s1">make_block])</span>
<span class="s0">def </span><span class="s1">block_maker(request):</span>
    <span class="s3">&quot;&quot;&quot; 
    Fixture to test both the internal new_block and pseudo-public make_block. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">mgr():</span>
    <span class="s0">return </span><span class="s1">create_mgr(</span>
        <span class="s4">&quot;a: f8; b: object; c: f8; d: object; e: f8;&quot;</span>
        <span class="s4">&quot;f: bool; g: i8; h: complex; i: datetime-1; j: datetime-2;&quot;</span>
        <span class="s4">&quot;k: M8[ns, US/Eastern]; l: M8[ns, CET];&quot;</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_block_equal(left</span><span class="s0">, </span><span class="s1">right):</span>
    <span class="s1">tm.assert_numpy_array_equal(left.values</span><span class="s0">, </span><span class="s1">right.values)</span>
    <span class="s0">assert </span><span class="s1">left.dtype == right.dtype</span>
    <span class="s0">assert </span><span class="s1">isinstance(left.mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
    <span class="s0">assert </span><span class="s1">isinstance(right.mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
    <span class="s1">tm.assert_numpy_array_equal(left.mgr_locs.as_array</span><span class="s0">, </span><span class="s1">right.mgr_locs.as_array)</span>


<span class="s0">def </span><span class="s1">get_numeric_mat(shape):</span>
    <span class="s1">arr = np.arange(shape[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s0">return </span><span class="s1">np.lib.stride_tricks.as_strided(</span>
        <span class="s1">x=arr</span><span class="s0">, </span><span class="s1">shape=shape</span><span class="s0">, </span><span class="s1">strides=(arr.itemsize</span><span class="s0">,</span><span class="s1">) + (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">) * (len(shape) - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">).copy()</span>


<span class="s1">N = </span><span class="s5">10</span>


<span class="s0">def </span><span class="s1">create_block(typestr</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">item_shape=</span><span class="s0">None, </span><span class="s1">num_offset=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">maker=new_block):</span>
    <span class="s3">&quot;&quot;&quot; 
    Supported typestr: 
 
        * float, f8, f4, f2 
        * int, i8, i4, i2, i1 
        * uint, u8, u4, u2, u1 
        * complex, c16, c8 
        * bool 
        * object, string, O 
        * datetime, dt, M8[ns], M8[ns, tz] 
        * timedelta, td, m8[ns] 
        * sparse (SparseArray with fill_value=0.0) 
        * sparse_na (SparseArray with fill_value=np.nan) 
        * category, category2 
 
    &quot;&quot;&quot;</span>
    <span class="s1">placement = BlockPlacement(placement)</span>
    <span class="s1">num_items = len(placement)</span>

    <span class="s0">if </span><span class="s1">item_shape </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">item_shape = (N</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">shape = (num_items</span><span class="s0">,</span><span class="s1">) + item_shape</span>

    <span class="s1">mat = get_numeric_mat(shape)</span>

    <span class="s0">if </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span>
        <span class="s4">&quot;float&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;f8&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;f4&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;f2&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;int&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;i8&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;i4&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;i2&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;i1&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;uint&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;u8&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;u4&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;u2&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;u1&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">values = mat.astype(typestr) + num_offset</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s4">&quot;c16&quot;</span><span class="s0">, </span><span class="s4">&quot;c8&quot;</span><span class="s1">):</span>
        <span class="s1">values = </span><span class="s5">1.0j </span><span class="s1">* (mat.astype(typestr) + num_offset)</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;object&quot;</span><span class="s0">, </span><span class="s4">&quot;string&quot;</span><span class="s0">, </span><span class="s4">&quot;O&quot;</span><span class="s1">):</span>
        <span class="s1">values = np.reshape([</span><span class="s4">f&quot;A</span><span class="s0">{</span><span class="s1">i</span><span class="s0">:</span><span class="s4">d</span><span class="s0">}</span><span class="s4">&quot; </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">mat.ravel() + num_offset]</span><span class="s0">, </span><span class="s1">shape)</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;bool&quot;</span><span class="s1">):</span>
        <span class="s1">values = np.ones(shape</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;datetime&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s0">, </span><span class="s4">&quot;M8[ns]&quot;</span><span class="s1">):</span>
        <span class="s1">values = (mat * </span><span class="s5">1e9</span><span class="s1">).astype(</span><span class="s4">&quot;M8[ns]&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">typestr.startswith(</span><span class="s4">&quot;M8[ns&quot;</span><span class="s1">):</span>
        <span class="s2"># datetime with tz</span>
        <span class="s1">m = re.search(</span><span class="s4">r&quot;M8\[ns,\s*(\w+\/?\w*)\]&quot;</span><span class="s0">, </span><span class="s1">typestr)</span>
        <span class="s0">assert </span><span class="s1">m </span><span class="s0">is not None, </span><span class="s4">f&quot;incompatible typestr -&gt; </span><span class="s0">{</span><span class="s1">typestr</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">tz = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">num_items == </span><span class="s5">1</span><span class="s0">, </span><span class="s4">&quot;must have only 1 num items for a tz-aware&quot;</span>
        <span class="s1">values = DatetimeIndex(np.arange(N) * </span><span class="s5">1e9</span><span class="s0">, </span><span class="s1">tz=tz)._data</span>
        <span class="s1">values = ensure_block_shape(values</span><span class="s0">, </span><span class="s1">ndim=len(shape))</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;timedelta&quot;</span><span class="s0">, </span><span class="s4">&quot;td&quot;</span><span class="s0">, </span><span class="s4">&quot;m8[ns]&quot;</span><span class="s1">):</span>
        <span class="s1">values = (mat * </span><span class="s5">1</span><span class="s1">).astype(</span><span class="s4">&quot;m8[ns]&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;category&quot;</span><span class="s0">,</span><span class="s1">):</span>
        <span class="s1">values = Categorical([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">])</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;category2&quot;</span><span class="s0">,</span><span class="s1">):</span>
        <span class="s1">values = Categorical([</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s0">elif </span><span class="s1">typestr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">&quot;sparse&quot;</span><span class="s0">, </span><span class="s4">&quot;sparse_na&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">shape[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s2"># We also are implicitly assuming this in the category cases above</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>

        <span class="s0">assert </span><span class="s1">all(s == </span><span class="s5">1 </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">shape[:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">typestr.endswith(</span><span class="s4">&quot;_na&quot;</span><span class="s1">):</span>
            <span class="s1">fill_value = np.nan</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fill_value = </span><span class="s5">0.0</span>
        <span class="s1">values = SparseArray(</span>
            <span class="s1">[fill_value</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">arr = values.sp_values.view()</span>
        <span class="s1">arr += num_offset - </span><span class="s5">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f'Unsupported typestr: &quot;</span><span class="s0">{</span><span class="s1">typestr</span><span class="s0">}</span><span class="s4">&quot;'</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">maker(values</span><span class="s0">, </span><span class="s1">placement=placement</span><span class="s0">, </span><span class="s1">ndim=len(shape))</span>


<span class="s0">def </span><span class="s1">create_single_mgr(typestr</span><span class="s0">, </span><span class="s1">num_rows=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">num_rows </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">num_rows = N</span>

    <span class="s0">return </span><span class="s1">SingleBlockManager(</span>
        <span class="s1">create_block(typestr</span><span class="s0">, </span><span class="s1">placement=slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">num_rows)</span><span class="s0">, </span><span class="s1">item_shape=())</span><span class="s0">,</span>
        <span class="s1">Index(np.arange(num_rows))</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">create_mgr(descr</span><span class="s0">, </span><span class="s1">item_shape=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Construct BlockManager from string description. 
 
    String description syntax looks similar to np.matrix initializer.  It looks 
    like this:: 
 
        a,b,c: f8; d,e,f: i8 
 
    Rules are rather simple: 
 
    * see list of supported datatypes in `create_block` method 
    * components are semicolon-separated 
    * each component is `NAME,NAME,NAME: DTYPE_ID` 
    * whitespace around colons &amp; semicolons are removed 
    * components with same DTYPE_ID are combined into single block 
    * to force multiple blocks with same dtype, use '-SUFFIX':: 
 
        'a:f8-1; b:f8-2; c:f8-foobar' 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">item_shape </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">item_shape = (N</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">offset = </span><span class="s5">0</span>
    <span class="s1">mgr_items = []</span>
    <span class="s1">block_placements = {}</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">descr.split(</span><span class="s4">&quot;;&quot;</span><span class="s1">):</span>
        <span class="s1">d = d.strip()</span>
        <span class="s0">if not </span><span class="s1">len(d):</span>
            <span class="s0">continue</span>
        <span class="s1">names</span><span class="s0">, </span><span class="s1">blockstr = d.partition(</span><span class="s4">&quot;:&quot;</span><span class="s1">)[::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">blockstr = blockstr.strip()</span>
        <span class="s1">names = names.strip().split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>

        <span class="s1">mgr_items.extend(names)</span>
        <span class="s1">placement = list(np.arange(len(names)) + offset)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">block_placements[blockstr].extend(placement)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">block_placements[blockstr] = placement</span>
        <span class="s1">offset += len(names)</span>

    <span class="s1">mgr_items = Index(mgr_items)</span>

    <span class="s1">blocks = []</span>
    <span class="s1">num_offset = </span><span class="s5">0</span>
    <span class="s0">for </span><span class="s1">blockstr</span><span class="s0">, </span><span class="s1">placement </span><span class="s0">in </span><span class="s1">block_placements.items():</span>
        <span class="s1">typestr = blockstr.split(</span><span class="s4">&quot;-&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">blocks.append(</span>
            <span class="s1">create_block(</span>
                <span class="s1">typestr</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">item_shape=item_shape</span><span class="s0">, </span><span class="s1">num_offset=num_offset</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">num_offset += len(placement)</span>

    <span class="s1">sblocks = sorted(blocks</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">b: b.mgr_locs[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s0">return </span><span class="s1">BlockManager(</span>
        <span class="s1">tuple(sblocks)</span><span class="s0">,</span>
        <span class="s1">[mgr_items] + [Index(np.arange(n)) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">item_shape]</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestBlock:</span>
    <span class="s0">def </span><span class="s1">setup_method(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">self.fblock = create_block(</span><span class="s4">&quot;float&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">self.cblock = create_block(</span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">7</span><span class="s1">])</span>
        <span class="s1">self.oblock = create_block(</span><span class="s4">&quot;object&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">self.bool_block = create_block(</span><span class="s4">&quot;bool&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_constructor(self):</span>
        <span class="s1">int32block = create_block(</span><span class="s4">&quot;i4&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">int32block.dtype == np.int32</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;typ, data&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">&quot;float&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">7</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;object&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s4">&quot;bool&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_pickle(self</span><span class="s0">, </span><span class="s1">typ</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s1">blk = create_block(typ</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">assert_block_equal(tm.round_trip_pickle(blk)</span><span class="s0">, </span><span class="s1">blk)</span>

    <span class="s0">def </span><span class="s1">test_mgr_locs(self):</span>
        <span class="s0">assert </span><span class="s1">isinstance(self.fblock.mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">self.fblock.mgr_locs.as_array</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_attrs(self):</span>
        <span class="s0">assert </span><span class="s1">self.fblock.shape == self.fblock.values.shape</span>
        <span class="s0">assert </span><span class="s1">self.fblock.dtype == self.fblock.values.dtype</span>
        <span class="s0">assert </span><span class="s1">len(self.fblock) == len(self.fblock.values)</span>

    <span class="s0">def </span><span class="s1">test_copy(self):</span>
        <span class="s1">cop = self.fblock.copy()</span>
        <span class="s0">assert </span><span class="s1">cop </span><span class="s0">is not </span><span class="s1">self.fblock</span>
        <span class="s1">assert_block_equal(self.fblock</span><span class="s0">, </span><span class="s1">cop)</span>

    <span class="s0">def </span><span class="s1">test_delete(self):</span>
        <span class="s1">newb = self.fblock.copy()</span>
        <span class="s1">newb.delete(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(newb.mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">newb.mgr_locs.as_array</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(newb.values[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">).all()</span>

        <span class="s1">newb = self.fblock.copy()</span>
        <span class="s1">newb.delete(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(newb.mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">newb.mgr_locs.as_array</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(newb.values[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">).all()</span>

        <span class="s1">newb = self.fblock.copy()</span>
        <span class="s1">newb.delete(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">newb.mgr_locs.as_array</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(newb.values[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">).all()</span>

        <span class="s1">newb = self.fblock.copy()</span>

        <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">newb.delete(</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_delete_datetimelike(self):</span>
        <span class="s2"># dont use np.delete on values, as that will coerce from DTA/TDA to ndarray</span>
        <span class="s1">arr = np.arange(</span><span class="s5">20</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;i8&quot;</span><span class="s1">).reshape(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">).view(</span><span class="s4">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">df = DataFrame(arr)</span>
        <span class="s1">blk = df._mgr.blocks[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">isinstance(blk.values</span><span class="s0">, </span><span class="s1">TimedeltaArray)</span>

        <span class="s1">blk.delete(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(blk.values</span><span class="s0">, </span><span class="s1">TimedeltaArray)</span>

        <span class="s1">df = DataFrame(arr.view(</span><span class="s4">&quot;M8[ns]&quot;</span><span class="s1">))</span>
        <span class="s1">blk = df._mgr.blocks[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">isinstance(blk.values</span><span class="s0">, </span><span class="s1">DatetimeArray)</span>

        <span class="s1">blk.delete([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">isinstance(blk.values</span><span class="s0">, </span><span class="s1">DatetimeArray)</span>

    <span class="s0">def </span><span class="s1">test_split(self):</span>
        <span class="s2"># GH#37799</span>
        <span class="s1">values = np.random.randn(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">blk = new_block(values</span><span class="s0">, </span><span class="s1">placement=[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">result = blk._split()</span>

        <span class="s2"># check that we get views, not copies</span>
        <span class="s1">values[:] = -</span><span class="s5">9999</span>
        <span class="s0">assert </span><span class="s1">(blk.values == -</span><span class="s5">9999</span><span class="s1">).all()</span>

        <span class="s0">assert </span><span class="s1">len(result) == </span><span class="s5">3</span>
        <span class="s1">expected = [</span>
            <span class="s1">new_block(values[[</span><span class="s5">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">placement=[</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">new_block(values[[</span><span class="s5">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">placement=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">new_block(values[[</span><span class="s5">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">placement=[</span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s0">for </span><span class="s1">res</span><span class="s0">, </span><span class="s1">exp </span><span class="s0">in </span><span class="s1">zip(result</span><span class="s0">, </span><span class="s1">expected):</span>
            <span class="s1">assert_block_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s0">def </span><span class="s1">test_is_categorical_deprecated(self):</span>
        <span class="s2"># GH#40571</span>
        <span class="s1">blk = self.fblock</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(DeprecationWarning):</span>
            <span class="s1">blk.is_categorical</span>


<span class="s0">class </span><span class="s1">TestBlockManager:</span>
    <span class="s0">def </span><span class="s1">test_attrs(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a,b,c: f8-1; d,e,f: f8-2&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.nblocks == </span><span class="s5">2</span>
        <span class="s0">assert </span><span class="s1">len(mgr) == </span><span class="s5">6</span>

    <span class="s0">def </span><span class="s1">test_duplicate_ref_loc_failure(self):</span>
        <span class="s1">tmp_mgr = create_mgr(</span><span class="s4">&quot;a:bool; a: f8&quot;</span><span class="s1">)</span>

        <span class="s1">axes</span><span class="s0">, </span><span class="s1">blocks = tmp_mgr.axes</span><span class="s0">, </span><span class="s1">tmp_mgr.blocks</span>

        <span class="s1">blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs = BlockPlacement(np.array([</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">blocks[</span><span class="s5">1</span><span class="s1">].mgr_locs = BlockPlacement(np.array([</span><span class="s5">0</span><span class="s1">]))</span>

        <span class="s2"># test trying to create block manager with overlapping ref locs</span>

        <span class="s1">msg = </span><span class="s4">&quot;Gaps in blk ref_locs&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">mgr = BlockManager(blocks</span><span class="s0">, </span><span class="s1">axes)</span>
            <span class="s1">mgr._rebuild_blknos_and_blklocs()</span>

        <span class="s1">blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs = BlockPlacement(np.array([</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">blocks[</span><span class="s5">1</span><span class="s1">].mgr_locs = BlockPlacement(np.array([</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">mgr = BlockManager(blocks</span><span class="s0">, </span><span class="s1">axes)</span>
        <span class="s1">mgr.iget(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_pickle(self</span><span class="s0">, </span><span class="s1">mgr):</span>

        <span class="s1">mgr2 = tm.round_trip_pickle(mgr)</span>
        <span class="s1">tm.assert_frame_equal(DataFrame(mgr)</span><span class="s0">, </span><span class="s1">DataFrame(mgr2))</span>

        <span class="s2"># GH2431</span>
        <span class="s0">assert </span><span class="s1">hasattr(mgr2</span><span class="s0">, </span><span class="s4">&quot;_is_consolidated&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">hasattr(mgr2</span><span class="s0">, </span><span class="s4">&quot;_known_consolidated&quot;</span><span class="s1">)</span>

        <span class="s2"># reset to False on load</span>
        <span class="s0">assert not </span><span class="s1">mgr2._is_consolidated</span>
        <span class="s0">assert not </span><span class="s1">mgr2._known_consolidated</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mgr_string&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a,a,a:f8&quot;</span><span class="s0">, </span><span class="s4">&quot;a: f8; a: i8&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_non_unique_pickle(self</span><span class="s0">, </span><span class="s1">mgr_string):</span>
        <span class="s1">mgr = create_mgr(mgr_string)</span>
        <span class="s1">mgr2 = tm.round_trip_pickle(mgr)</span>
        <span class="s1">tm.assert_frame_equal(DataFrame(mgr)</span><span class="s0">, </span><span class="s1">DataFrame(mgr2))</span>

    <span class="s0">def </span><span class="s1">test_categorical_block_pickle(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: category&quot;</span><span class="s1">)</span>
        <span class="s1">mgr2 = tm.round_trip_pickle(mgr)</span>
        <span class="s1">tm.assert_frame_equal(DataFrame(mgr)</span><span class="s0">, </span><span class="s1">DataFrame(mgr2))</span>

        <span class="s1">smgr = create_single_mgr(</span><span class="s4">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s1">smgr2 = tm.round_trip_pickle(smgr)</span>
        <span class="s1">tm.assert_series_equal(Series(smgr)</span><span class="s0">, </span><span class="s1">Series(smgr2))</span>

    <span class="s0">def </span><span class="s1">test_iget(self):</span>
        <span class="s1">cols = Index(list(</span><span class="s4">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">values = np.random.rand(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">block = new_block(</span>
            <span class="s1">values=values.copy()</span><span class="s0">,</span>
            <span class="s1">placement=np.arange(</span><span class="s5">3</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">,</span>
            <span class="s1">ndim=values.ndim</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">mgr = BlockManager(blocks=(block</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axes=[cols</span><span class="s0">, </span><span class="s1">Index(np.arange(</span><span class="s5">3</span><span class="s1">))])</span>

        <span class="s1">tm.assert_almost_equal(mgr.iget(</span><span class="s5">0</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">values[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_almost_equal(mgr.iget(</span><span class="s5">1</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">values[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_almost_equal(mgr.iget(</span><span class="s5">2</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">values[</span><span class="s5">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_set(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a,b,c: int&quot;</span><span class="s0">, </span><span class="s1">item_shape=(</span><span class="s5">3</span><span class="s0">,</span><span class="s1">))</span>

        <span class="s1">mgr.insert(len(mgr.items)</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;foo&quot;</span><span class="s1">] * </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">mgr.iset(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;bar&quot;</span><span class="s1">] * </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">tm.assert_numpy_array_equal(mgr.iget(</span><span class="s5">0</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">1</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;bar&quot;</span><span class="s1">] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">dtype=np.object_)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(mgr.iget(</span><span class="s5">2</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">2</span><span class="s1">] * </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">3</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;foo&quot;</span><span class="s1">] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">dtype=np.object_)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_set_change_dtype(self</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s1">mgr.insert(len(mgr.items)</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s0">, </span><span class="s1">np.zeros(N</span><span class="s0">, </span><span class="s1">dtype=bool))</span>

        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.repeat(</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">N))</span>
        <span class="s1">idx = mgr.items.get_loc(</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.iget(idx).dtype == np.object_</span>

        <span class="s1">mgr2 = mgr.consolidate()</span>
        <span class="s1">mgr2.iset(mgr2.items.get_loc(</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.repeat(</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">N))</span>
        <span class="s1">idx = mgr2.items.get_loc(</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr2.iget(idx).dtype == np.object_</span>

        <span class="s1">mgr2.insert(len(mgr2.items)</span><span class="s0">, </span><span class="s4">&quot;quux&quot;</span><span class="s0">, </span><span class="s1">np.random.randn(N).astype(int))</span>
        <span class="s1">idx = mgr2.items.get_loc(</span><span class="s4">&quot;quux&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr2.iget(idx).dtype == np.int_</span>

        <span class="s1">mgr2.iset(mgr2.items.get_loc(</span><span class="s4">&quot;quux&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>
        <span class="s0">assert </span><span class="s1">mgr2.iget(idx).dtype == np.float_</span>

    <span class="s0">def </span><span class="s1">test_copy(self</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s1">cp = mgr.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">blk</span><span class="s0">, </span><span class="s1">cp_blk </span><span class="s0">in </span><span class="s1">zip(mgr.blocks</span><span class="s0">, </span><span class="s1">cp.blocks):</span>

            <span class="s2"># view assertion</span>
            <span class="s1">tm.assert_equal(cp_blk.values</span><span class="s0">, </span><span class="s1">blk.values)</span>
            <span class="s0">if </span><span class="s1">isinstance(blk.values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s0">assert </span><span class="s1">cp_blk.values.base </span><span class="s0">is </span><span class="s1">blk.values.base</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># DatetimeTZBlock has DatetimeIndex values</span>
                <span class="s0">assert </span><span class="s1">cp_blk.values._data.base </span><span class="s0">is </span><span class="s1">blk.values._data.base</span>

        <span class="s2"># copy(deep=True) consolidates, so the block-wise assertions will</span>
        <span class="s2">#  fail is mgr is not consolidated</span>
        <span class="s1">mgr._consolidate_inplace()</span>
        <span class="s1">cp = mgr.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">blk</span><span class="s0">, </span><span class="s1">cp_blk </span><span class="s0">in </span><span class="s1">zip(mgr.blocks</span><span class="s0">, </span><span class="s1">cp.blocks):</span>

            <span class="s1">bvals = blk.values</span>
            <span class="s1">cpvals = cp_blk.values</span>

            <span class="s1">tm.assert_equal(cpvals</span><span class="s0">, </span><span class="s1">bvals)</span>

            <span class="s0">if </span><span class="s1">isinstance(cpvals</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">lbase = cpvals.base</span>
                <span class="s1">rbase = bvals.base</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">lbase = cpvals._ndarray.base</span>
                <span class="s1">rbase = bvals._ndarray.base</span>

            <span class="s2"># copy assertion we either have a None for a base or in case of</span>
            <span class="s2"># some blocks it is an array (e.g. datetimetz), but was copied</span>
            <span class="s0">if </span><span class="s1">isinstance(cpvals</span><span class="s0">, </span><span class="s1">DatetimeArray):</span>
                <span class="s0">assert </span><span class="s1">(lbase </span><span class="s0">is None and </span><span class="s1">rbase </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(lbase </span><span class="s0">is not </span><span class="s1">rbase)</span>
            <span class="s0">elif not </span><span class="s1">isinstance(cpvals</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s0">assert </span><span class="s1">lbase </span><span class="s0">is not </span><span class="s1">rbase</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">lbase </span><span class="s0">is None and </span><span class="s1">rbase </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_sparse(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: sparse-1; b: sparse-2&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == np.float64</span>

    <span class="s0">def </span><span class="s1">test_sparse_mixed(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: sparse-1; b: sparse-2; c: f8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">len(mgr.blocks) == </span><span class="s5">3</span>
        <span class="s0">assert </span><span class="s1">isinstance(mgr</span><span class="s0">, </span><span class="s1">BlockManager)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;mgr_string, dtype&quot;</span><span class="s0">,</span>
        <span class="s1">[(</span><span class="s4">&quot;c: f4; d: f2&quot;</span><span class="s0">, </span><span class="s1">np.float32)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;c: f4; d: f2; e: f8&quot;</span><span class="s0">, </span><span class="s1">np.float64)]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_as_array_float(self</span><span class="s0">, </span><span class="s1">mgr_string</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">mgr = create_mgr(mgr_string)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == dtype</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;mgr_string, dtype&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;a: bool-1; b: bool-2&quot;</span><span class="s0">, </span><span class="s1">np.bool_)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: i8-1; b: i8-2; c: i4; d: i2; e: u1&quot;</span><span class="s0">, </span><span class="s1">np.int64)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;c: i4; d: i2; e: u1&quot;</span><span class="s0">, </span><span class="s1">np.int32)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_as_array_int_bool(self</span><span class="s0">, </span><span class="s1">mgr_string</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">mgr = create_mgr(mgr_string)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == dtype</span>

    <span class="s0">def </span><span class="s1">test_as_array_datetime(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;h: datetime-1; g: datetime-2&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;M8[ns]&quot;</span>

    <span class="s0">def </span><span class="s1">test_as_array_datetime_tz(self):</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;h: M8[ns, US/Eastern]; g: M8[ns, CET]&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.iget(</span><span class="s5">0</span><span class="s1">).dtype == </span><span class="s4">&quot;datetime64[ns, US/Eastern]&quot;</span>
        <span class="s0">assert </span><span class="s1">mgr.iget(</span><span class="s5">1</span><span class="s1">).dtype == </span><span class="s4">&quot;datetime64[ns, CET]&quot;</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;t&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;float16&quot;</span><span class="s0">, </span><span class="s4">&quot;float32&quot;</span><span class="s0">, </span><span class="s4">&quot;float64&quot;</span><span class="s0">, </span><span class="s4">&quot;int32&quot;</span><span class="s0">, </span><span class="s4">&quot;int64&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_astype(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s2"># coerce all</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;c: f4; d: f2; e: f8&quot;</span><span class="s1">)</span>

        <span class="s1">t = np.dtype(t)</span>
        <span class="s1">tmgr = mgr.astype(t)</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">0</span><span class="s1">).dtype.type == t</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">1</span><span class="s1">).dtype.type == t</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">2</span><span class="s1">).dtype.type == t</span>

        <span class="s2"># mixed</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a,b: object; c: bool; d: datetime; e: f4; f: f2; g: f8&quot;</span><span class="s1">)</span>

        <span class="s1">t = np.dtype(t)</span>
        <span class="s1">tmgr = mgr.astype(t</span><span class="s0">, </span><span class="s1">errors=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">2</span><span class="s1">).dtype.type == t</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">4</span><span class="s1">).dtype.type == t</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">5</span><span class="s1">).dtype.type == t</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">6</span><span class="s1">).dtype.type == t</span>

        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">0</span><span class="s1">).dtype.type == np.object_</span>
        <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">1</span><span class="s1">).dtype.type == np.object_</span>
        <span class="s0">if </span><span class="s1">t != np.int64:</span>
            <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">3</span><span class="s1">).dtype.type == np.datetime64</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">tmgr.iget(</span><span class="s5">3</span><span class="s1">).dtype.type == t</span>

    <span class="s0">def </span><span class="s1">test_convert(self):</span>
        <span class="s0">def </span><span class="s1">_compare(old_mgr</span><span class="s0">, </span><span class="s1">new_mgr):</span>
            <span class="s3">&quot;&quot;&quot;compare the blocks, numeric compare ==, object don't&quot;&quot;&quot;</span>
            <span class="s1">old_blocks = set(old_mgr.blocks)</span>
            <span class="s1">new_blocks = set(new_mgr.blocks)</span>
            <span class="s0">assert </span><span class="s1">len(old_blocks) == len(new_blocks)</span>

            <span class="s2"># compare non-numeric</span>
            <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">old_blocks:</span>
                <span class="s1">found = </span><span class="s0">False</span>
                <span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">new_blocks:</span>
                    <span class="s0">if </span><span class="s1">(b.values == nb.values).all():</span>
                        <span class="s1">found = </span><span class="s0">True</span>
                        <span class="s0">break</span>
                <span class="s0">assert </span><span class="s1">found</span>

            <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">new_blocks:</span>
                <span class="s1">found = </span><span class="s0">False</span>
                <span class="s0">for </span><span class="s1">ob </span><span class="s0">in </span><span class="s1">old_blocks:</span>
                    <span class="s0">if </span><span class="s1">(b.values == ob.values).all():</span>
                        <span class="s1">found = </span><span class="s0">True</span>
                        <span class="s0">break</span>
                <span class="s0">assert </span><span class="s1">found</span>

        <span class="s2"># noops</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;f: i8; g: f8&quot;</span><span class="s1">)</span>
        <span class="s1">new_mgr = mgr.convert()</span>
        <span class="s1">_compare(mgr</span><span class="s0">, </span><span class="s1">new_mgr)</span>

        <span class="s2"># convert</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a,b,foo: object; f: i8; g: f8&quot;</span><span class="s1">)</span>
        <span class="s1">mgr.iset(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;1&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">mgr.iset(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;2.&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">mgr.iset(</span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;foo.&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">new_mgr = mgr.convert(numeric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">0</span><span class="s1">).dtype == np.int64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">1</span><span class="s1">).dtype == np.float64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">2</span><span class="s1">).dtype == np.object_</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">3</span><span class="s1">).dtype == np.int64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">4</span><span class="s1">).dtype == np.float64</span>

        <span class="s1">mgr = create_mgr(</span>
            <span class="s4">&quot;a,b,foo: object; f: i4; bool: bool; dt: datetime; i: i8; g: f8; h: f2&quot;</span>
        <span class="s1">)</span>
        <span class="s1">mgr.iset(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;1&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">mgr.iset(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;2.&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">mgr.iset(</span><span class="s5">2</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">&quot;foo.&quot;</span><span class="s1">] * N</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>
        <span class="s1">new_mgr = mgr.convert(numeric=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">0</span><span class="s1">).dtype == np.int64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">1</span><span class="s1">).dtype == np.float64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">2</span><span class="s1">).dtype == np.object_</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">3</span><span class="s1">).dtype == np.int32</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">4</span><span class="s1">).dtype == np.bool_</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">5</span><span class="s1">).dtype.type</span><span class="s0">, </span><span class="s1">np.datetime64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">6</span><span class="s1">).dtype == np.int64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">7</span><span class="s1">).dtype == np.float64</span>
        <span class="s0">assert </span><span class="s1">new_mgr.iget(</span><span class="s5">8</span><span class="s1">).dtype == np.float16</span>

    <span class="s0">def </span><span class="s1">test_invalid_ea_block(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;need to split&quot;</span><span class="s1">):</span>
            <span class="s1">create_mgr(</span><span class="s4">&quot;a: category; b: category&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;need to split&quot;</span><span class="s1">):</span>
            <span class="s1">create_mgr(</span><span class="s4">&quot;a: category2; b: category2&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_interleave(self):</span>
        <span class="s2"># self</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;f8&quot;</span><span class="s0">, </span><span class="s4">&quot;i8&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s0">, </span><span class="s4">&quot;bool&quot;</span><span class="s0">, </span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s4">&quot;M8[ns]&quot;</span><span class="s0">, </span><span class="s4">&quot;m8[ns]&quot;</span><span class="s1">]:</span>
            <span class="s1">mgr = create_mgr(</span><span class="s4">f&quot;a: </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == dtype</span>
            <span class="s1">mgr = create_mgr(</span><span class="s4">f&quot;a: </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">; b: </span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == dtype</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;mgr_string, dtype&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;a: category&quot;</span><span class="s0">, </span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: category; b: category&quot;</span><span class="s0">, </span><span class="s4">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: category; b: category2&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: category2&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: category2; b: category2&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: f8&quot;</span><span class="s0">, </span><span class="s4">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: f8; b: i8&quot;</span><span class="s0">, </span><span class="s4">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: f4; b: i8&quot;</span><span class="s0">, </span><span class="s4">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: f4; b: i8; d: object&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: bool; b: i8&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: complex&quot;</span><span class="s0">, </span><span class="s4">&quot;complex&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: f8; b: category&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: M8[ns]; b: category&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: M8[ns]; b: bool&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: M8[ns]; b: i8&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: m8[ns]; b: bool&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: m8[ns]; b: i8&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;a: M8[ns]; b: m8[ns]&quot;</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interleave_dtype(self</span><span class="s0">, </span><span class="s1">mgr_string</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s2"># will be converted according the actual dtype of the underlying</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: category&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;i8&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: category; b: category2&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: category2&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>

        <span class="s2"># combinations</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;f8&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f8; b: i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;f8&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f4; b: i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;f8&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f4; b: i8; d: object&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: bool; b: i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: complex&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;complex&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f8; b: category&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;f8&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: M8[ns]; b: category&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: M8[ns]; b: bool&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: M8[ns]; b: i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: m8[ns]; b: bool&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: m8[ns]; b: i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: M8[ns]; b: m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.as_array().dtype == </span><span class="s4">&quot;object&quot;</span>

    <span class="s0">def </span><span class="s1">test_consolidate_ordering_issues(self</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;f&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>
        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;d&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>
        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;b&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>
        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;g&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>
        <span class="s1">mgr.iset(mgr.items.get_loc(</span><span class="s4">&quot;h&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.randn(N))</span>

        <span class="s2"># we have datetime/tz blocks in mgr</span>
        <span class="s1">cons = mgr.consolidate()</span>
        <span class="s0">assert </span><span class="s1">cons.nblocks == </span><span class="s5">4</span>
        <span class="s1">cons = mgr.consolidate().get_numeric_data()</span>
        <span class="s0">assert </span><span class="s1">cons.nblocks == </span><span class="s5">1</span>
        <span class="s0">assert </span><span class="s1">isinstance(cons.blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs</span><span class="s0">, </span><span class="s1">BlockPlacement)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">cons.blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs.as_array</span><span class="s0">, </span><span class="s1">np.arange(len(cons.items)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reindex_items(self):</span>
        <span class="s2"># mgr is not consolidated, f8 &amp; f8-2 blocks</span>
        <span class="s1">mgr = create_mgr(</span><span class="s4">&quot;a: f8; b: i8; c: f8; d: i8; e: f8; f: bool; g: f8-2&quot;</span><span class="s1">)</span>

        <span class="s1">reindexed = mgr.reindex_axis([</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">reindexed.nblocks == </span><span class="s5">2</span>
        <span class="s1">tm.assert_index_equal(reindexed.items</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;d&quot;</span><span class="s1">]))</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">6</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">reindexed.iget(</span><span class="s5">0</span><span class="s1">).internal_values()</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">2</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">reindexed.iget(</span><span class="s5">1</span><span class="s1">).internal_values()</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">0</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">reindexed.iget(</span><span class="s5">2</span><span class="s1">).internal_values()</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(</span><span class="s5">3</span><span class="s1">).internal_values()</span><span class="s0">, </span><span class="s1">reindexed.iget(</span><span class="s5">3</span><span class="s1">).internal_values()</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_get_numeric_data(self):</span>
        <span class="s1">mgr = create_mgr(</span>
            <span class="s4">&quot;int: int; float: float; complex: complex;&quot;</span>
            <span class="s4">&quot;str: object; bool: bool; obj: object; dt: datetime&quot;</span><span class="s0">,</span>
            <span class="s1">item_shape=(</span><span class="s5">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">mgr.iset(</span><span class="s5">5</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>

        <span class="s1">numeric = mgr.get_numeric_data()</span>
        <span class="s1">tm.assert_index_equal(numeric.items</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;int&quot;</span><span class="s0">, </span><span class="s4">&quot;float&quot;</span><span class="s0">, </span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s4">&quot;bool&quot;</span><span class="s1">]))</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">numeric.iget(numeric.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Check sharing</span>
        <span class="s1">numeric.iset(</span>
            <span class="s1">numeric.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s5">100.0</span><span class="s0">, </span><span class="s5">200.0</span><span class="s0">, </span><span class="s5">300.0</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s5">100.0</span><span class="s0">, </span><span class="s5">200.0</span><span class="s0">, </span><span class="s5">300.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">numeric2 = mgr.get_numeric_data(copy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(numeric.items</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;int&quot;</span><span class="s0">, </span><span class="s4">&quot;float&quot;</span><span class="s0">, </span><span class="s4">&quot;complex&quot;</span><span class="s0">, </span><span class="s4">&quot;bool&quot;</span><span class="s1">]))</span>
        <span class="s1">numeric2.iset(</span>
            <span class="s1">numeric2.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s5">1000.0</span><span class="s0">, </span><span class="s5">2000.0</span><span class="s0">, </span><span class="s5">3000.0</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;float&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s5">100.0</span><span class="s0">, </span><span class="s5">200.0</span><span class="s0">, </span><span class="s5">300.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_get_bool_data(self):</span>
        <span class="s1">mgr = create_mgr(</span>
            <span class="s4">&quot;int: int; float: float; complex: complex;&quot;</span>
            <span class="s4">&quot;str: object; bool: bool; obj: object; dt: datetime&quot;</span><span class="s0">,</span>
            <span class="s1">item_shape=(</span><span class="s5">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">mgr.iset(</span><span class="s5">6</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.object_))</span>

        <span class="s1">bools = mgr.get_bool_data()</span>
        <span class="s1">tm.assert_index_equal(bools.items</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;bool&quot;</span><span class="s0">, </span><span class="s4">&quot;dt&quot;</span><span class="s1">]))</span>
        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;bool&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">bools.iget(bools.items.get_loc(</span><span class="s4">&quot;bool&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">bools.iset(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True, False, True</span><span class="s1">])</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;bool&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s0">True, False, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s2"># Check sharing</span>
        <span class="s1">bools2 = mgr.get_bool_data(copy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">bools2.iset(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False, True, False</span><span class="s1">]))</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">mgr.iget(mgr.items.get_loc(</span><span class="s4">&quot;bool&quot;</span><span class="s1">)).internal_values()</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s0">True, False, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_unicode_repr_doesnt_raise(self):</span>
        <span class="s1">repr(create_mgr(</span><span class="s4">&quot;b,</span><span class="s0">\u05d0</span><span class="s4">: object&quot;</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;mgr_string&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;a,b,c: i8-1; d,e,f: i8-2&quot;</span><span class="s0">, </span><span class="s4">&quot;a,a,a: i8-1; b,b,b: i8-2&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_equals(self</span><span class="s0">, </span><span class="s1">mgr_string):</span>
        <span class="s2"># unique items</span>
        <span class="s1">bm1 = create_mgr(mgr_string)</span>
        <span class="s1">bm2 = BlockManager(bm1.blocks[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bm1.axes)</span>
        <span class="s0">assert </span><span class="s1">bm1.equals(bm2)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;mgr_string&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s4">&quot;a:i8;b:f8&quot;</span><span class="s0">,  </span><span class="s2"># basic case</span>
            <span class="s4">&quot;a:i8;b:f8;c:c8;d:b&quot;</span><span class="s0">,  </span><span class="s2"># many types</span>
            <span class="s4">&quot;a:i8;e:dt;f:td;g:string&quot;</span><span class="s0">,  </span><span class="s2"># more types</span>
            <span class="s4">&quot;a:i8;b:category;c:category2&quot;</span><span class="s0">,  </span><span class="s2"># categories</span>
            <span class="s4">&quot;c:sparse;d:sparse_na;b:f8&quot;</span><span class="s0">,  </span><span class="s2"># sparse</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_equals_block_order_different_dtypes(self</span><span class="s0">, </span><span class="s1">mgr_string):</span>
        <span class="s2"># GH 9330</span>
        <span class="s1">bm = create_mgr(mgr_string)</span>
        <span class="s1">block_perms = itertools.permutations(bm.blocks)</span>
        <span class="s0">for </span><span class="s1">bm_perm </span><span class="s0">in </span><span class="s1">block_perms:</span>
            <span class="s1">bm_this = BlockManager(tuple(bm_perm)</span><span class="s0">, </span><span class="s1">bm.axes)</span>
            <span class="s0">assert </span><span class="s1">bm.equals(bm_this)</span>
            <span class="s0">assert </span><span class="s1">bm_this.equals(bm)</span>

    <span class="s0">def </span><span class="s1">test_single_mgr_ctor(self):</span>
        <span class="s1">mgr = create_single_mgr(</span><span class="s4">&quot;f8&quot;</span><span class="s0">, </span><span class="s1">num_rows=</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">mgr.external_values().tolist() == [</span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s5">3.0</span><span class="s0">, </span><span class="s5">4.0</span><span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s4">&quot;True&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s5">5.0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_validate_bool_args(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">bm1 = create_mgr(</span><span class="s4">&quot;a,b,c: i8-1; d,e,f: i8-2&quot;</span><span class="s1">)</span>

        <span class="s1">msg = (</span>
            <span class="s4">'For argument &quot;inplace&quot; expected type bool, '</span>
            <span class="s4">f&quot;received type </span><span class="s0">{</span><span class="s1">type(value).__name__</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">bm1.replace_list([</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inplace=value)</span>


<span class="s0">def </span><span class="s1">_as_array(mgr):</span>
    <span class="s0">if </span><span class="s1">mgr.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">mgr.external_values()</span>
    <span class="s0">return </span><span class="s1">mgr.as_array().T</span>


<span class="s0">class </span><span class="s1">TestIndexing:</span>
    <span class="s2"># Nosetests-style data-driven tests.</span>
    <span class="s2">#</span>
    <span class="s2"># This test applies different indexing routines to block managers and</span>
    <span class="s2"># compares the outcome to the result of same operations on np.ndarray.</span>
    <span class="s2">#</span>
    <span class="s2"># NOTE: sparse (SparseBlock with fill_value != np.nan) fail a lot of tests</span>
    <span class="s2">#       and are disabled.</span>

    <span class="s1">MANAGERS = [</span>
        <span class="s1">create_single_mgr(</span><span class="s4">&quot;f8&quot;</span><span class="s0">, </span><span class="s1">N)</span><span class="s0">,</span>
        <span class="s1">create_single_mgr(</span><span class="s4">&quot;i8&quot;</span><span class="s0">, </span><span class="s1">N)</span><span class="s0">,</span>
        <span class="s2"># 2-dim</span>
        <span class="s1">create_mgr(</span><span class="s4">&quot;a,b,c,d,e,f: f8&quot;</span><span class="s0">, </span><span class="s1">item_shape=(N</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">create_mgr(</span><span class="s4">&quot;a,b,c,d,e,f: i8&quot;</span><span class="s0">, </span><span class="s1">item_shape=(N</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">create_mgr(</span><span class="s4">&quot;a,b: f8; c,d: i8; e,f: string&quot;</span><span class="s0">, </span><span class="s1">item_shape=(N</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">create_mgr(</span><span class="s4">&quot;a,b: f8; c,d: i8; e,f: f8&quot;</span><span class="s0">, </span><span class="s1">item_shape=(N</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mgr&quot;</span><span class="s0">, </span><span class="s1">MANAGERS)</span>
    <span class="s0">def </span><span class="s1">test_get_slice(self</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s0">def </span><span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">slobj):</span>
            <span class="s1">mat = _as_array(mgr)</span>

            <span class="s2"># we maybe using an ndarray to test slicing and</span>
            <span class="s2"># might not be the full length of the axis</span>
            <span class="s0">if </span><span class="s1">isinstance(slobj</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">ax = mgr.axes[axis]</span>
                <span class="s0">if </span><span class="s1">len(ax) </span><span class="s0">and </span><span class="s1">len(slobj) </span><span class="s0">and </span><span class="s1">len(slobj) != len(ax):</span>
                    <span class="s1">slobj = np.concatenate(</span>
                        <span class="s1">[slobj</span><span class="s0">, </span><span class="s1">np.zeros(len(ax) - len(slobj)</span><span class="s0">, </span><span class="s1">dtype=bool)]</span>
                    <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">isinstance(slobj</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">sliced = mgr.get_slice(slobj</span><span class="s0">, </span><span class="s1">axis=axis)</span>
            <span class="s0">elif </span><span class="s1">mgr.ndim == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">sliced = mgr.getitem_mgr(slobj)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># BlockManager doesn't support non-slice, SingleBlockManager</span>
                <span class="s2">#  doesn't support axis &gt; 0</span>
                <span class="s0">return</span>

            <span class="s1">mat_slobj = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis + (slobj</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">tm.assert_numpy_array_equal(</span>
                <span class="s1">mat[mat_slobj]</span><span class="s0">, </span><span class="s1">_as_array(sliced)</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(mgr.axes[axis][slobj]</span><span class="s0">, </span><span class="s1">sliced.axes[axis])</span>

        <span class="s0">assert </span><span class="s1">mgr.ndim &lt;= </span><span class="s5">2</span><span class="s0">, </span><span class="s1">mgr.ndim</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(mgr.ndim):</span>
            <span class="s2"># slice</span>
            <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span>
            <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">3</span><span class="s1">))</span>
            <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">100</span><span class="s1">))</span>
            <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
            <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">))</span>

            <span class="s0">if </span><span class="s1">mgr.ndim &lt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2"># 2D only support slice objects</span>

                <span class="s2"># boolean mask</span>
                <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.bool_))</span>
                <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">np.ones(mgr.shape[ax]</span><span class="s0">, </span><span class="s1">dtype=np.bool_))</span>
                <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">np.zeros(mgr.shape[ax]</span><span class="s0">, </span><span class="s1">dtype=np.bool_))</span>

                <span class="s0">if </span><span class="s1">mgr.shape[ax] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">np.arange(mgr.shape[ax]) % </span><span class="s5">3 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s1">assert_slice_ok(</span>
                        <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
                    <span class="s1">)</span>

                <span class="s2"># fancy indexer</span>
                <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">[])</span>
                <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">list(range(mgr.shape[ax])))</span>

                <span class="s0">if </span><span class="s1">mgr.shape[ax] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span>
                    <span class="s1">assert_slice_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mgr&quot;</span><span class="s0">, </span><span class="s1">MANAGERS)</span>
    <span class="s0">def </span><span class="s1">test_take(self</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s0">def </span><span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">indexer):</span>
            <span class="s1">mat = _as_array(mgr)</span>
            <span class="s1">taken = mgr.take(indexer</span><span class="s0">, </span><span class="s1">axis)</span>
            <span class="s1">tm.assert_numpy_array_equal(</span>
                <span class="s1">np.take(mat</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis)</span><span class="s0">, </span><span class="s1">_as_array(taken)</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(mgr.axes[axis].take(indexer)</span><span class="s0">, </span><span class="s1">taken.axes[axis])</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(mgr.ndim):</span>
            <span class="s2"># take/fancy indexer</span>
            <span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indexer=[])</span>
            <span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indexer=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indexer=list(range(mgr.shape[ax])))</span>

            <span class="s0">if </span><span class="s1">mgr.shape[ax] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indexer=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span>
                <span class="s1">assert_take_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indexer=[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mgr&quot;</span><span class="s0">, </span><span class="s1">MANAGERS)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;fill_value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">100.0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_reindex_axis(self</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s0">def </span><span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">new_labels</span><span class="s0">, </span><span class="s1">fill_value):</span>
            <span class="s1">mat = _as_array(mgr)</span>
            <span class="s1">indexer = mgr.axes[axis].get_indexer_for(new_labels)</span>

            <span class="s1">reindexed = mgr.reindex_axis(new_labels</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
            <span class="s1">tm.assert_numpy_array_equal(</span>
                <span class="s1">algos.take_nd(mat</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span><span class="s0">,</span>
                <span class="s1">_as_array(reindexed)</span><span class="s0">,</span>
                <span class="s1">check_dtype=</span><span class="s0">False,</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(reindexed.axes[axis]</span><span class="s0">, </span><span class="s1">new_labels)</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(mgr.ndim):</span>
            <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([])</span><span class="s0">, </span><span class="s1">fill_value)</span>
            <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax]</span><span class="s0">, </span><span class="s1">fill_value)</span>
            <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax][[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">fill_value)</span>
            <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">fill_value)</span>
            <span class="s1">assert_reindex_axis_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">mgr.axes[ax][</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">mgr.shape[ax] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax][:-</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fill_value)</span>
                <span class="s1">assert_reindex_axis_is_ok(mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax][-</span><span class="s5">3</span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fill_value)</span>
                <span class="s1">assert_reindex_axis_is_ok(</span>
                    <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax][[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">fill_value</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mgr&quot;</span><span class="s0">, </span><span class="s1">MANAGERS)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;fill_value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">100.0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_reindex_indexer(self</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">mgr):</span>
        <span class="s0">def </span><span class="s1">assert_reindex_indexer_is_ok(mgr</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">new_labels</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">fill_value):</span>
            <span class="s1">mat = _as_array(mgr)</span>
            <span class="s1">reindexed_mat = algos.take_nd(mat</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
            <span class="s1">reindexed = mgr.reindex_indexer(</span>
                <span class="s1">new_labels</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_numpy_array_equal(</span>
                <span class="s1">reindexed_mat</span><span class="s0">, </span><span class="s1">_as_array(reindexed)</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span>
            <span class="s1">)</span>
            <span class="s1">tm.assert_index_equal(reindexed.axes[axis]</span><span class="s0">, </span><span class="s1">new_labels)</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(mgr.ndim):</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([])</span><span class="s0">, </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax]</span><span class="s0">, </span><span class="s1">np.arange(mgr.shape[ax])</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">,</span>
                <span class="s1">ax</span><span class="s0">,</span>
                <span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s1">] * mgr.shape[ax])</span><span class="s0">,</span>
                <span class="s1">np.arange(mgr.shape[ax])</span><span class="s0">,</span>
                <span class="s1">fill_value</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax][::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(mgr.shape[ax])</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">mgr.axes[ax]</span><span class="s0">, </span><span class="s1">np.arange(mgr.shape[ax])[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">fill_value</span>
            <span class="s1">)</span>
            <span class="s1">assert_reindex_indexer_is_ok(</span>
                <span class="s1">mgr</span><span class="s0">,</span>
                <span class="s1">ax</span><span class="s0">,</span>
                <span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">mgr.axes[ax][</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">np.array([-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">fill_value</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">mgr.shape[ax] &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">assert_reindex_indexer_is_ok(</span>
                    <span class="s1">mgr</span><span class="s0">,</span>
                    <span class="s1">ax</span><span class="s0">,</span>
                    <span class="s1">Index([</span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s4">&quot;bar&quot;</span><span class="s0">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s1">np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s1">fill_value</span><span class="s0">,</span>
                <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestBlockPlacement:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;slc, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_slice_len(self</span><span class="s0">, </span><span class="s1">slc</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s0">assert </span><span class="s1">len(BlockPlacement(slc)) == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;slc&quot;</span><span class="s0">, </span><span class="s1">[slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_zero_step_raises(self</span><span class="s0">, </span><span class="s1">slc):</span>
        <span class="s1">msg = </span><span class="s4">&quot;slice step cannot be zero&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">BlockPlacement(slc)</span>

    <span class="s0">def </span><span class="s1">test_slice_canonize_negative_stop(self):</span>
        <span class="s2"># GH#37524 negative stop is OK with negative step and positive start</span>
        <span class="s1">slc = slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">bp = BlockPlacement(slc)</span>
        <span class="s0">assert </span><span class="s1">bp.indexer == slice(</span><span class="s5">3</span><span class="s0">, None, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;slc&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">slice(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s5">10</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s0">None, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2"># These are &quot;unbounded&quot; because negative index will</span>
            <span class="s2">#  change depending on container shape.</span>
            <span class="s1">slice(-</span><span class="s5">1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s0">None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(-</span><span class="s5">1</span><span class="s0">, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s0">None, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_unbounded_slice_raises(self</span><span class="s0">, </span><span class="s1">slc):</span>
        <span class="s1">msg = </span><span class="s4">&quot;unbounded slice&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">BlockPlacement(slc)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;slc&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_not_slice_like_slices(self</span><span class="s0">, </span><span class="s1">slc):</span>
        <span class="s0">assert not </span><span class="s1">BlockPlacement(slc).is_slice_like</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;arr, slc&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">101</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">200</span><span class="s0">, </span><span class="s5">100</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_array_to_slice_conversion(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">slc):</span>
        <span class="s0">assert </span><span class="s1">BlockPlacement(arr).as_slice == slc</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;arr&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_not_slice_like_arrays(self</span><span class="s0">, </span><span class="s1">arr):</span>
        <span class="s0">assert not </span><span class="s1">BlockPlacement(arr).is_slice_like</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;slc, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_slice_iter(self</span><span class="s0">, </span><span class="s1">slc</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s0">assert </span><span class="s1">list(BlockPlacement(slc)) == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;slc, arr&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_slice_to_array_conversion(self</span><span class="s0">, </span><span class="s1">slc</span><span class="s0">, </span><span class="s1">arr):</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">BlockPlacement(slc).as_array</span><span class="s0">, </span><span class="s1">np.asarray(arr</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_blockplacement_add(self):</span>
        <span class="s1">bpl = BlockPlacement(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">bpl.add(</span><span class="s5">1</span><span class="s1">).as_slice == slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">bpl.add(np.arange(</span><span class="s5">5</span><span class="s1">)).as_slice == slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">list(bpl.add(np.arange(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))) == [</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;val, inc, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">[</span><span class="s5">11</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">13</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">[</span><span class="s5">13</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">11</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s1">[</span><span class="s5">11</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">14</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">(slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_blockplacement_add_int(self</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s0">assert </span><span class="s1">list(BlockPlacement(val).add(inc)) == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;val&quot;</span><span class="s0">, </span><span class="s1">[slice(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_blockplacement_add_int_raises(self</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s1">msg = </span><span class="s4">&quot;iadd causes length change&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">BlockPlacement(val).add(-</span><span class="s5">10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestCanHoldElement:</span>
    <span class="s1">@pytest.fixture(</span>
        <span class="s1">params=[</span>
            <span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: x.to_series()</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: x._data</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: list(x)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: x.astype(object)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: np.asarray(x)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: x[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: x[:</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">element(self</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s3">&quot;&quot;&quot; 
        Functions that take an Index and return an element that should have 
        blk._can_hold_element(element) for a Block with this index's dtype. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">request.param</span>

    <span class="s0">def </span><span class="s1">test_datetime_block_can_hold_element(self):</span>
        <span class="s1">block = create_block(</span><span class="s4">&quot;datetime&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s0">assert </span><span class="s1">block._can_hold_element([])</span>

        <span class="s2"># We will check that block._can_hold_element iff arr.__setitem__ works</span>
        <span class="s1">arr = pd.array(block.values.ravel())</span>

        <span class="s2"># coerce None</span>
        <span class="s0">assert </span><span class="s1">block._can_hold_element(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">arr[</span><span class="s5">0</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s0">assert </span><span class="s1">arr[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">pd.NaT</span>

        <span class="s2"># coerce different types of datetime objects</span>
        <span class="s1">vals = [np.datetime64(</span><span class="s4">&quot;2010-10-10&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s5">2010</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">vals:</span>
            <span class="s0">assert </span><span class="s1">block._can_hold_element(val)</span>
            <span class="s1">arr[</span><span class="s5">0</span><span class="s1">] = val</span>

        <span class="s1">val = date(</span><span class="s5">2010</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">block._can_hold_element(val)</span>

        <span class="s1">msg = (</span>
            <span class="s4">&quot;value should be a 'Timestamp', 'NaT', &quot;</span>
            <span class="s4">&quot;or array of those. Got 'date' instead.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">arr[</span><span class="s5">0</span><span class="s1">] = val</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.int64</span><span class="s0">, </span><span class="s1">np.uint64</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_interval_can_hold_element_emptylist(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s1">arr = np.array([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ii = IntervalIndex.from_breaks(arr)</span>
        <span class="s1">blk = new_block(ii._data</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">blk._can_hold_element([])</span>
        <span class="s2"># TODO: check this holds for all blocks</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.int64</span><span class="s0">, </span><span class="s1">np.uint64</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_interval_can_hold_element(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s1">arr = np.array([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">ii = IntervalIndex.from_breaks(arr)</span>
        <span class="s1">blk = new_block(ii._data</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">elem = element(ii)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">ii</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">blk._can_hold_element(elem)</span>

        <span class="s2"># Careful: to get the expected Series-inplace behavior we need</span>
        <span class="s2"># `elem` to not have the same length as `arr`</span>
        <span class="s1">ii2 = IntervalIndex.from_breaks(arr[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">closed=</span><span class="s4">&quot;neither&quot;</span><span class="s1">)</span>
        <span class="s1">elem = element(ii2)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">ii</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">blk._can_hold_element(elem)</span>

        <span class="s1">ii3 = IntervalIndex.from_breaks([Timestamp(</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s5">4</span><span class="s1">)])</span>
        <span class="s1">elem = element(ii3)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">ii</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">blk._can_hold_element(elem)</span>

        <span class="s1">ii4 = IntervalIndex.from_breaks([Timedelta(</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timedelta(</span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timedelta(</span><span class="s5">4</span><span class="s1">)])</span>
        <span class="s1">elem = element(ii4)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">ii</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">blk._can_hold_element(elem)</span>

    <span class="s0">def </span><span class="s1">test_period_can_hold_element_emptylist(self):</span>
        <span class="s1">pi = period_range(</span><span class="s4">&quot;2016&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">blk = new_block(pi._data.reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">blk._can_hold_element([])</span>

    <span class="s0">def </span><span class="s1">test_period_can_hold_element(self</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s1">pi = period_range(</span><span class="s4">&quot;2016&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s4">&quot;A&quot;</span><span class="s1">)</span>

        <span class="s1">elem = element(pi)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s2"># Careful: to get the expected Series-inplace behavior we need</span>
        <span class="s2"># `elem` to not have the same length as `arr`</span>
        <span class="s1">pi2 = pi.asfreq(</span><span class="s4">&quot;D&quot;</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">elem = element(pi2)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">dti = pi.to_timestamp(</span><span class="s4">&quot;S&quot;</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">elem = element(dti)</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">pi</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">check_setting(self</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">index: Index</span><span class="s0">, </span><span class="s1">inplace: bool):</span>
        <span class="s1">self.check_series_setitem(elem</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">inplace)</span>
        <span class="s1">self.check_frame_setitem(elem</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">inplace)</span>

    <span class="s0">def </span><span class="s1">check_can_hold_element(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">inplace: bool):</span>
        <span class="s1">blk = obj._mgr.blocks[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s0">assert </span><span class="s1">blk._can_hold_element(elem)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">blk._can_hold_element(elem)</span>

    <span class="s0">def </span><span class="s1">check_series_setitem(self</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">index: Index</span><span class="s0">, </span><span class="s1">inplace: bool):</span>
        <span class="s1">arr = index._data.copy()</span>
        <span class="s1">ser = Series(arr)</span>

        <span class="s1">self.check_can_hold_element(ser</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">inplace)</span>

        <span class="s0">if </span><span class="s1">is_scalar(elem):</span>
            <span class="s1">ser[</span><span class="s5">0</span><span class="s1">] = elem</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ser[: len(elem)] = elem</span>

        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s0">assert </span><span class="s1">ser.array </span><span class="s0">is </span><span class="s1">arr  </span><span class="s2"># i.e. setting was done inplace</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">ser.dtype == object</span>

    <span class="s0">def </span><span class="s1">check_frame_setitem(self</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">index: Index</span><span class="s0">, </span><span class="s1">inplace: bool):</span>
        <span class="s1">arr = index._data.copy()</span>
        <span class="s1">df = DataFrame(arr)</span>

        <span class="s1">self.check_can_hold_element(df</span><span class="s0">, </span><span class="s1">elem</span><span class="s0">, </span><span class="s1">inplace)</span>

        <span class="s0">if </span><span class="s1">is_scalar(elem):</span>
            <span class="s1">df.iloc[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = elem</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">df.iloc[: len(elem)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = elem</span>

        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s2"># assertion here implies setting was done inplace</span>

            <span class="s2"># error: Item &quot;ArrayManager&quot; of &quot;Union[ArrayManager, BlockManager]&quot; has no</span>
            <span class="s2">#  attribute &quot;blocks&quot;</span>
            <span class="s0">assert </span><span class="s1">df._mgr.blocks[</span><span class="s5">0</span><span class="s1">].values </span><span class="s0">is </span><span class="s1">arr  </span><span class="s2"># type:ignore[union-attr]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">df.dtypes[</span><span class="s5">0</span><span class="s1">] == object</span>


<span class="s0">class </span><span class="s1">TestShouldStore:</span>
    <span class="s0">def </span><span class="s1">test_should_store_categorical(self):</span>
        <span class="s1">cat = Categorical([</span><span class="s4">&quot;A&quot;</span><span class="s0">, </span><span class="s4">&quot;B&quot;</span><span class="s0">, </span><span class="s4">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">df = DataFrame(cat)</span>
        <span class="s1">blk = df._mgr.blocks[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2"># matching dtype</span>
        <span class="s0">assert </span><span class="s1">blk.should_store(cat)</span>
        <span class="s0">assert </span><span class="s1">blk.should_store(cat[:-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s2"># different dtype</span>
        <span class="s0">assert not </span><span class="s1">blk.should_store(cat.as_ordered())</span>

        <span class="s2"># ndarray instead of Categorical</span>
        <span class="s0">assert not </span><span class="s1">blk.should_store(np.asarray(cat))</span>


<span class="s0">def </span><span class="s1">test_validate_ndim(block_maker):</span>
    <span class="s1">values = np.array([</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s1">])</span>
    <span class="s1">placement = slice(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s4">r&quot;Wrong number of dimensions. values.ndim != ndim \[1 != 2\]&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">block_maker(values</span><span class="s0">, </span><span class="s1">placement</span><span class="s0">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_block_shape():</span>
    <span class="s1">idx = Index([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">])</span>
    <span class="s1">a = Series([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]).reindex(idx)</span>
    <span class="s1">b = Series(Categorical([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])).reindex(idx)</span>

    <span class="s0">assert </span><span class="s1">a._mgr.blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs.indexer == b._mgr.blocks[</span><span class="s5">0</span><span class="s1">].mgr_locs.indexer</span>


<span class="s0">def </span><span class="s1">test_make_block_no_pandas_array(block_maker):</span>
    <span class="s2"># https://github.com/pandas-dev/pandas/pull/24866</span>
    <span class="s1">arr = pd.arrays.PandasArray(np.array([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]))</span>

    <span class="s2"># PandasArray, no dtype</span>
    <span class="s1">result = block_maker(arr</span><span class="s0">, </span><span class="s1">slice(len(arr))</span><span class="s0">, </span><span class="s1">ndim=arr.ndim)</span>
    <span class="s0">assert </span><span class="s1">result.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">block_maker </span><span class="s0">is </span><span class="s1">make_block:</span>
        <span class="s2"># new_block requires caller to unwrap PandasArray</span>
        <span class="s0">assert </span><span class="s1">result.is_extension </span><span class="s0">is False</span>

        <span class="s2"># PandasArray, PandasDtype</span>
        <span class="s1">result = block_maker(arr</span><span class="s0">, </span><span class="s1">slice(len(arr))</span><span class="s0">, </span><span class="s1">dtype=arr.dtype</span><span class="s0">, </span><span class="s1">ndim=arr.ndim)</span>
        <span class="s0">assert </span><span class="s1">result.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">result.is_extension </span><span class="s0">is False</span>

        <span class="s2"># new_block no longer taked dtype keyword</span>
        <span class="s2"># ndarray, PandasDtype</span>
        <span class="s1">result = block_maker(</span>
            <span class="s1">arr.to_numpy()</span><span class="s0">, </span><span class="s1">slice(len(arr))</span><span class="s0">, </span><span class="s1">dtype=arr.dtype</span><span class="s0">, </span><span class="s1">ndim=arr.ndim</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">result.is_extension </span><span class="s0">is False</span>


<span class="s0">def </span><span class="s1">test_single_block_manager_fastpath_deprecated():</span>
    <span class="s2"># GH#33092</span>
    <span class="s1">ser = Series(range(</span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">blk = ser._data.blocks[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">SingleBlockManager(blk</span><span class="s0">, </span><span class="s1">ser.index</span><span class="s0">, </span><span class="s1">fastpath=</span><span class="s0">True</span><span class="s1">)</span>
</pre>
</body>
</html>