<html>
<head>
<title>install.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
install.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.command.install 
 
Implements the Distutils 'install' command.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.core </span><span class="s2">import </span><span class="s1">Command</span>
<span class="s2">from </span><span class="s1">distutils.debug </span><span class="s2">import </span><span class="s1">DEBUG</span>
<span class="s2">from </span><span class="s1">distutils.sysconfig </span><span class="s2">import </span><span class="s1">get_config_vars</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsPlatformError</span>
<span class="s2">from </span><span class="s1">distutils.file_util </span><span class="s2">import </span><span class="s1">write_file</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">convert_path</span><span class="s2">, </span><span class="s1">subst_vars</span><span class="s2">, </span><span class="s1">change_root</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">get_platform</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsOptionError</span>

<span class="s2">from </span><span class="s1">site </span><span class="s2">import </span><span class="s1">USER_BASE</span>
<span class="s2">from </span><span class="s1">site </span><span class="s2">import </span><span class="s1">USER_SITE</span>
<span class="s1">HAS_USER_SITE = </span><span class="s2">True</span>

<span class="s1">WINDOWS_SCHEME = {</span>
    <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$base/Lib/site-packages'</span><span class="s2">,</span>
    <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$base/Lib/site-packages'</span><span class="s2">,</span>
    <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$base/Include/$dist_name'</span><span class="s2">,</span>
    <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$base/Scripts'</span><span class="s2">,</span>
    <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$base'</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">INSTALL_SCHEMES = {</span>
    <span class="s3">'unix_prefix'</span><span class="s1">: {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$base/lib/python$py_version_short/site-packages'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$platbase/$platlibdir/python$py_version_short/site-packages'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$base/include/python$py_version_short$abiflags/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$base/bin'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$base'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s3">'unix_home'</span><span class="s1">: {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$base/lib/python'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$base/$platlibdir/python'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$base/include/python/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$base/bin'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$base'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s3">'nt'</span><span class="s1">: WINDOWS_SCHEME</span><span class="s2">,</span>
    <span class="s3">'pypy'</span><span class="s1">: {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$base/site-packages'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$base/site-packages'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$base/include/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$base/bin'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$base'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s3">'pypy_nt'</span><span class="s1">: {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$base/site-packages'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$base/site-packages'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$base/include/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$base/Scripts'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$base'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">}</span>

<span class="s4"># user site schemes</span>
<span class="s2">if </span><span class="s1">HAS_USER_SITE:</span>
    <span class="s1">INSTALL_SCHEMES[</span><span class="s3">'nt_user'</span><span class="s1">] = {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$usersite'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$usersite'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">: </span><span class="s3">'$userbase/Python$py_version_nodot/Include/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$userbase/Python$py_version_nodot/Scripts'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$userbase'</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s1">INSTALL_SCHEMES[</span><span class="s3">'unix_user'</span><span class="s1">] = {</span>
        <span class="s3">'purelib'</span><span class="s1">: </span><span class="s3">'$usersite'</span><span class="s2">,</span>
        <span class="s3">'platlib'</span><span class="s1">: </span><span class="s3">'$usersite'</span><span class="s2">,</span>
        <span class="s3">'headers'</span><span class="s1">:</span>
            <span class="s3">'$userbase/include/python$py_version_short$abiflags/$dist_name'</span><span class="s2">,</span>
        <span class="s3">'scripts'</span><span class="s1">: </span><span class="s3">'$userbase/bin'</span><span class="s2">,</span>
        <span class="s3">'data'   </span><span class="s1">: </span><span class="s3">'$userbase'</span><span class="s2">,</span>
        <span class="s1">}</span>

<span class="s4"># The keys to an installation scheme; if any new types of files are to be</span>
<span class="s4"># installed, be sure to add an entry to every installation scheme above,</span>
<span class="s4"># and to SCHEME_KEYS here.</span>
<span class="s1">SCHEME_KEYS = (</span><span class="s3">'purelib'</span><span class="s2">, </span><span class="s3">'platlib'</span><span class="s2">, </span><span class="s3">'headers'</span><span class="s2">, </span><span class="s3">'scripts'</span><span class="s2">, </span><span class="s3">'data'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">install(Command):</span>

    <span class="s1">description = </span><span class="s3">&quot;install everything from build directory&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s4"># Select installation scheme and set base director(y|ies)</span>
        <span class="s1">(</span><span class="s3">'prefix='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation prefix&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'exec-prefix='</span><span class="s2">, None,</span>
         <span class="s3">&quot;(Unix only) prefix for platform-specific files&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'home='</span><span class="s2">, None,</span>
         <span class="s3">&quot;(Unix only) home directory to install under&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s4"># Or, just set the base director(y|ies)</span>
        <span class="s1">(</span><span class="s3">'install-base='</span><span class="s2">, None,</span>
         <span class="s3">&quot;base installation directory (instead of --prefix or --home)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'install-platbase='</span><span class="s2">, None,</span>
         <span class="s3">&quot;base installation directory for platform-specific files &quot; </span><span class="s1">+</span>
         <span class="s3">&quot;(instead of --exec-prefix or --home)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'root='</span><span class="s2">, None,</span>
         <span class="s3">&quot;install everything relative to this alternate root directory&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s4"># Or, explicitly set the installation scheme</span>
        <span class="s1">(</span><span class="s3">'install-purelib='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for pure Python module distributions&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'install-platlib='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for non-pure module distributions&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'install-lib='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for all module distributions &quot; </span><span class="s1">+</span>
         <span class="s3">&quot;(overrides --install-purelib and --install-platlib)&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s1">(</span><span class="s3">'install-headers='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for C/C++ headers&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'install-scripts='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for Python scripts&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'install-data='</span><span class="s2">, None,</span>
         <span class="s3">&quot;installation directory for data files&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s4"># Byte-compilation options -- see install_lib.py for details, as</span>
        <span class="s4"># these are duplicated from there (but only install_lib does</span>
        <span class="s4"># anything with them).</span>
        <span class="s1">(</span><span class="s3">'compile'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">&quot;compile .py to .pyc [default]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'no-compile'</span><span class="s2">, None, </span><span class="s3">&quot;don't compile .py files&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'optimize='</span><span class="s2">, </span><span class="s3">'O'</span><span class="s2">,</span>
         <span class="s3">&quot;also compile with optimization: -O1 for </span><span class="s2">\&quot;</span><span class="s3">python -O</span><span class="s2">\&quot;</span><span class="s3">, &quot;</span>
         <span class="s3">&quot;-O2 for </span><span class="s2">\&quot;</span><span class="s3">python -OO</span><span class="s2">\&quot;</span><span class="s3">, and -O0 to disable [default: -O0]&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s4"># Miscellaneous control options</span>
        <span class="s1">(</span><span class="s3">'force'</span><span class="s2">, </span><span class="s3">'f'</span><span class="s2">,</span>
         <span class="s3">&quot;force installation (overwrite any existing files)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'skip-build'</span><span class="s2">, None,</span>
         <span class="s3">&quot;skip rebuilding everything (for testing/debugging)&quot;</span><span class="s1">)</span><span class="s2">,</span>

        <span class="s4"># Where to install documentation (eventually!)</span>
        <span class="s4">#('doc-format=', None, &quot;format of documentation to generate&quot;),</span>
        <span class="s4">#('install-man=', None, &quot;directory for Unix man pages&quot;),</span>
        <span class="s4">#('install-html=', None, &quot;directory for HTML documentation&quot;),</span>
        <span class="s4">#('install-info=', None, &quot;directory for GNU info files&quot;),</span>

        <span class="s1">(</span><span class="s3">'record='</span><span class="s2">, None,</span>
         <span class="s3">&quot;filename in which to record list of installed files&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s1">boolean_options = [</span><span class="s3">'compile'</span><span class="s2">, </span><span class="s3">'force'</span><span class="s2">, </span><span class="s3">'skip-build'</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">HAS_USER_SITE:</span>
        <span class="s1">user_options.append((</span><span class="s3">'user'</span><span class="s2">, None,</span>
                             <span class="s3">&quot;install in user site-package '%s'&quot; </span><span class="s1">% USER_SITE))</span>
        <span class="s1">boolean_options.append(</span><span class="s3">'user'</span><span class="s1">)</span>

    <span class="s1">negative_opt = {</span><span class="s3">'no-compile' </span><span class="s1">: </span><span class="s3">'compile'</span><span class="s1">}</span>


    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s0">&quot;&quot;&quot;Initializes options.&quot;&quot;&quot;</span>
        <span class="s4"># High-level options: these select both an installation base</span>
        <span class="s4"># and scheme.</span>
        <span class="s1">self.prefix = </span><span class="s2">None</span>
        <span class="s1">self.exec_prefix = </span><span class="s2">None</span>
        <span class="s1">self.home = </span><span class="s2">None</span>
        <span class="s1">self.user = </span><span class="s5">0</span>

        <span class="s4"># These select only the installation base; it's up to the user to</span>
        <span class="s4"># specify the installation scheme (currently, that means supplying</span>
        <span class="s4"># the --install-{platlib,purelib,scripts,data} options).</span>
        <span class="s1">self.install_base = </span><span class="s2">None</span>
        <span class="s1">self.install_platbase = </span><span class="s2">None</span>
        <span class="s1">self.root = </span><span class="s2">None</span>

        <span class="s4"># These options are the actual installation directories; if not</span>
        <span class="s4"># supplied by the user, they are filled in using the installation</span>
        <span class="s4"># scheme implied by prefix/exec-prefix/home and the contents of</span>
        <span class="s4"># that installation scheme.</span>
        <span class="s1">self.install_purelib = </span><span class="s2">None     </span><span class="s4"># for pure module distributions</span>
        <span class="s1">self.install_platlib = </span><span class="s2">None     </span><span class="s4"># non-pure (dists w/ extensions)</span>
        <span class="s1">self.install_headers = </span><span class="s2">None     </span><span class="s4"># for C/C++ headers</span>
        <span class="s1">self.install_lib = </span><span class="s2">None         </span><span class="s4"># set to either purelib or platlib</span>
        <span class="s1">self.install_scripts = </span><span class="s2">None</span>
        <span class="s1">self.install_data = </span><span class="s2">None</span>
        <span class="s1">self.install_userbase = USER_BASE</span>
        <span class="s1">self.install_usersite = USER_SITE</span>

        <span class="s1">self.compile = </span><span class="s2">None</span>
        <span class="s1">self.optimize = </span><span class="s2">None</span>

        <span class="s4"># Deprecated</span>
        <span class="s4"># These two are for putting non-packagized distributions into their</span>
        <span class="s4"># own directory and creating a .pth file if it makes sense.</span>
        <span class="s4"># 'extra_path' comes from the setup file; 'install_path_file' can</span>
        <span class="s4"># be turned off if it makes no sense to install a .pth file.  (But</span>
        <span class="s4"># better to install it uselessly than to guess wrong and not</span>
        <span class="s4"># install it when it's necessary and would be used!)  Currently,</span>
        <span class="s4"># 'install_path_file' is always true unless some outsider meddles</span>
        <span class="s4"># with it.</span>
        <span class="s1">self.extra_path = </span><span class="s2">None</span>
        <span class="s1">self.install_path_file = </span><span class="s5">1</span>

        <span class="s4"># 'force' forces installation, even if target files are not</span>
        <span class="s4"># out-of-date.  'skip_build' skips running the &quot;build&quot; command,</span>
        <span class="s4"># handy if you know it's not necessary.  'warn_dir' (which is *not*</span>
        <span class="s4"># a user option, it's just there so the bdist_* commands can turn</span>
        <span class="s4"># it off) determines whether we warn about installing to a</span>
        <span class="s4"># directory not in sys.path.</span>
        <span class="s1">self.force = </span><span class="s5">0</span>
        <span class="s1">self.skip_build = </span><span class="s5">0</span>
        <span class="s1">self.warn_dir = </span><span class="s5">1</span>

        <span class="s4"># These are only here as a conduit from the 'build' command to the</span>
        <span class="s4"># 'install_*' commands that do the real work.  ('build_base' isn't</span>
        <span class="s4"># actually used anywhere, but it might be useful in future.)  They</span>
        <span class="s4"># are not user options, because if the user told the install</span>
        <span class="s4"># command where the build directory is, that wouldn't affect the</span>
        <span class="s4"># build command.</span>
        <span class="s1">self.build_base = </span><span class="s2">None</span>
        <span class="s1">self.build_lib = </span><span class="s2">None</span>

        <span class="s4"># Not defined yet because we don't know anything about</span>
        <span class="s4"># documentation yet.</span>
        <span class="s4">#self.install_man = None</span>
        <span class="s4">#self.install_html = None</span>
        <span class="s4">#self.install_info = None</span>

        <span class="s1">self.record = </span><span class="s2">None</span>


    <span class="s4"># -- Option finalizing methods -------------------------------------</span>
    <span class="s4"># (This is rather more involved than for most commands,</span>
    <span class="s4"># because this is where the policy for installing third-</span>
    <span class="s4"># party Python modules on various platforms given a wide</span>
    <span class="s4"># array of user input is decided.  Yes, it's quite complex!)</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s0">&quot;&quot;&quot;Finalizes options.&quot;&quot;&quot;</span>
        <span class="s4"># This method (and its helpers, like 'finalize_unix()',</span>
        <span class="s4"># 'finalize_other()', and 'select_scheme()') is where the default</span>
        <span class="s4"># installation directories for modules, extension modules, and</span>
        <span class="s4"># anything else we care to install from a Python module</span>
        <span class="s4"># distribution.  Thus, this code makes a pretty important policy</span>
        <span class="s4"># statement about how third-party stuff is added to a Python</span>
        <span class="s4"># installation!  Note that the actual work of installation is done</span>
        <span class="s4"># by the relatively simple 'install_*' commands; they just take</span>
        <span class="s4"># their orders from the installation directory options determined</span>
        <span class="s4"># here.</span>

        <span class="s4"># Check for errors/inconsistencies in the options; first, stuff</span>
        <span class="s4"># that's wrong on any platform.</span>

        <span class="s2">if </span><span class="s1">((self.prefix </span><span class="s2">or </span><span class="s1">self.exec_prefix </span><span class="s2">or </span><span class="s1">self.home) </span><span class="s2">and</span>
            <span class="s1">(self.install_base </span><span class="s2">or </span><span class="s1">self.install_platbase)):</span>
            <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                   <span class="s3">&quot;must supply either prefix/exec-prefix/home or &quot; </span><span class="s1">+</span>
                   <span class="s3">&quot;install-base/install-platbase -- not both&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.home </span><span class="s2">and </span><span class="s1">(self.prefix </span><span class="s2">or </span><span class="s1">self.exec_prefix):</span>
            <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                  <span class="s3">&quot;must supply either home or prefix/exec-prefix -- not both&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.user </span><span class="s2">and </span><span class="s1">(self.prefix </span><span class="s2">or </span><span class="s1">self.exec_prefix </span><span class="s2">or </span><span class="s1">self.home </span><span class="s2">or</span>
                <span class="s1">self.install_base </span><span class="s2">or </span><span class="s1">self.install_platbase):</span>
            <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span><span class="s3">&quot;can't combine user with prefix, &quot;</span>
                                       <span class="s3">&quot;exec_prefix/home, or install_(plat)base&quot;</span><span class="s1">)</span>

        <span class="s4"># Next, stuff that's wrong (or dubious) only on certain platforms.</span>
        <span class="s2">if </span><span class="s1">os.name != </span><span class="s3">&quot;posix&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.exec_prefix:</span>
                <span class="s1">self.warn(</span><span class="s3">&quot;exec-prefix option ignored on this platform&quot;</span><span class="s1">)</span>
                <span class="s1">self.exec_prefix = </span><span class="s2">None</span>

        <span class="s4"># Now the interesting logic -- so interesting that we farm it out</span>
        <span class="s4"># to other methods.  The goal of these methods is to set the final</span>
        <span class="s4"># values for the install_{lib,scripts,data,...}  options, using as</span>
        <span class="s4"># input a heady brew of prefix, exec_prefix, home, install_base,</span>
        <span class="s4"># install_platbase, user-supplied versions of</span>
        <span class="s4"># install_{purelib,platlib,lib,scripts,data,...}, and the</span>
        <span class="s4"># INSTALL_SCHEME dictionary above.  Phew!</span>

        <span class="s1">self.dump_dirs(</span><span class="s3">&quot;pre-finalize_{unix,other}&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix'</span><span class="s1">:</span>
            <span class="s1">self.finalize_unix()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.finalize_other()</span>

        <span class="s1">self.dump_dirs(</span><span class="s3">&quot;post-finalize_{unix,other}()&quot;</span><span class="s1">)</span>

        <span class="s4"># Expand configuration variables, tilde, etc. in self.install_base</span>
        <span class="s4"># and self.install_platbase -- that way, we can use $base or</span>
        <span class="s4"># $platbase in the other installation directories and not worry</span>
        <span class="s4"># about needing recursive variable expansion (shudder).</span>

        <span class="s1">py_version = sys.version.split()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">(prefix</span><span class="s2">, </span><span class="s1">exec_prefix) = get_config_vars(</span><span class="s3">'prefix'</span><span class="s2">, </span><span class="s3">'exec_prefix'</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">abiflags = sys.abiflags</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># sys.abiflags may not be defined on all platforms.</span>
            <span class="s1">abiflags = </span><span class="s3">''</span>
        <span class="s1">self.config_vars = {</span><span class="s3">'dist_name'</span><span class="s1">: self.distribution.get_name()</span><span class="s2">,</span>
                            <span class="s3">'dist_version'</span><span class="s1">: self.distribution.get_version()</span><span class="s2">,</span>
                            <span class="s3">'dist_fullname'</span><span class="s1">: self.distribution.get_fullname()</span><span class="s2">,</span>
                            <span class="s3">'py_version'</span><span class="s1">: py_version</span><span class="s2">,</span>
                            <span class="s3">'py_version_short'</span><span class="s1">: </span><span class="s3">'%d.%d' </span><span class="s1">% sys.version_info[:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s3">'py_version_nodot'</span><span class="s1">: </span><span class="s3">'%d%d' </span><span class="s1">% sys.version_info[:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s3">'sys_prefix'</span><span class="s1">: prefix</span><span class="s2">,</span>
                            <span class="s3">'prefix'</span><span class="s1">: prefix</span><span class="s2">,</span>
                            <span class="s3">'sys_exec_prefix'</span><span class="s1">: exec_prefix</span><span class="s2">,</span>
                            <span class="s3">'exec_prefix'</span><span class="s1">: exec_prefix</span><span class="s2">,</span>
                            <span class="s3">'abiflags'</span><span class="s1">: abiflags</span><span class="s2">,</span>
                            <span class="s3">'platlibdir'</span><span class="s1">: getattr(sys</span><span class="s2">, </span><span class="s3">'platlibdir'</span><span class="s2">, </span><span class="s3">'lib'</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">HAS_USER_SITE:</span>
            <span class="s1">self.config_vars[</span><span class="s3">'userbase'</span><span class="s1">] = self.install_userbase</span>
            <span class="s1">self.config_vars[</span><span class="s3">'usersite'</span><span class="s1">] = self.install_usersite</span>

        <span class="s1">self.expand_basedirs()</span>

        <span class="s1">self.dump_dirs(</span><span class="s3">&quot;post-expand_basedirs()&quot;</span><span class="s1">)</span>

        <span class="s4"># Now define config vars for the base directories so we can expand</span>
        <span class="s4"># everything else.</span>
        <span class="s1">self.config_vars[</span><span class="s3">'base'</span><span class="s1">] = self.install_base</span>
        <span class="s1">self.config_vars[</span><span class="s3">'platbase'</span><span class="s1">] = self.install_platbase</span>

        <span class="s2">if </span><span class="s1">DEBUG:</span>
            <span class="s2">from </span><span class="s1">pprint </span><span class="s2">import </span><span class="s1">pprint</span>
            <span class="s1">print(</span><span class="s3">&quot;config vars:&quot;</span><span class="s1">)</span>
            <span class="s1">pprint(self.config_vars)</span>

        <span class="s4"># Expand &quot;~&quot; and configuration variables in the installation</span>
        <span class="s4"># directories.</span>
        <span class="s1">self.expand_dirs()</span>

        <span class="s1">self.dump_dirs(</span><span class="s3">&quot;post-expand_dirs()&quot;</span><span class="s1">)</span>

        <span class="s4"># Create directories in the home dir:</span>
        <span class="s2">if </span><span class="s1">self.user:</span>
            <span class="s1">self.create_home_path()</span>

        <span class="s4"># Pick the actual directory to install all modules to: either</span>
        <span class="s4"># install_purelib or install_platlib, depending on whether this</span>
        <span class="s4"># module distribution is pure or not.  Of course, if the user</span>
        <span class="s4"># already specified install_lib, use their selection.</span>
        <span class="s2">if </span><span class="s1">self.install_lib </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.distribution.ext_modules: </span><span class="s4"># has extensions: non-pure</span>
                <span class="s1">self.install_lib = self.install_platlib</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.install_lib = self.install_purelib</span>


        <span class="s4"># Convert directories from Unix /-separated syntax to the local</span>
        <span class="s4"># convention.</span>
        <span class="s1">self.convert_paths(</span><span class="s3">'lib'</span><span class="s2">, </span><span class="s3">'purelib'</span><span class="s2">, </span><span class="s3">'platlib'</span><span class="s2">,</span>
                           <span class="s3">'scripts'</span><span class="s2">, </span><span class="s3">'data'</span><span class="s2">, </span><span class="s3">'headers'</span><span class="s2">,</span>
                           <span class="s3">'userbase'</span><span class="s2">, </span><span class="s3">'usersite'</span><span class="s1">)</span>

        <span class="s4"># Deprecated</span>
        <span class="s4"># Well, we're not actually fully completely finalized yet: we still</span>
        <span class="s4"># have to deal with 'extra_path', which is the hack for allowing</span>
        <span class="s4"># non-packagized module distributions (hello, Numerical Python!) to</span>
        <span class="s4"># get their own directories.</span>
        <span class="s1">self.handle_extra_path()</span>
        <span class="s1">self.install_libbase = self.install_lib </span><span class="s4"># needed for .pth file</span>
        <span class="s1">self.install_lib = os.path.join(self.install_lib</span><span class="s2">, </span><span class="s1">self.extra_dirs)</span>

        <span class="s4"># If a new root directory was supplied, make all the installation</span>
        <span class="s4"># dirs relative to it.</span>
        <span class="s2">if </span><span class="s1">self.root </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.change_roots(</span><span class="s3">'libbase'</span><span class="s2">, </span><span class="s3">'lib'</span><span class="s2">, </span><span class="s3">'purelib'</span><span class="s2">, </span><span class="s3">'platlib'</span><span class="s2">,</span>
                              <span class="s3">'scripts'</span><span class="s2">, </span><span class="s3">'data'</span><span class="s2">, </span><span class="s3">'headers'</span><span class="s1">)</span>

        <span class="s1">self.dump_dirs(</span><span class="s3">&quot;after prepending root&quot;</span><span class="s1">)</span>

        <span class="s4"># Find out the build directories, ie. where to install from.</span>
        <span class="s1">self.set_undefined_options(</span><span class="s3">'build'</span><span class="s2">,</span>
                                   <span class="s1">(</span><span class="s3">'build_base'</span><span class="s2">, </span><span class="s3">'build_base'</span><span class="s1">)</span><span class="s2">,</span>
                                   <span class="s1">(</span><span class="s3">'build_lib'</span><span class="s2">, </span><span class="s3">'build_lib'</span><span class="s1">))</span>

        <span class="s4"># Punt on doc directories for now -- after all, we're punting on</span>
        <span class="s4"># documentation completely!</span>

    <span class="s2">def </span><span class="s1">dump_dirs(self</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s0">&quot;&quot;&quot;Dumps the list of user options.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">DEBUG:</span>
            <span class="s2">return</span>
        <span class="s2">from </span><span class="s1">distutils.fancy_getopt </span><span class="s2">import </span><span class="s1">longopt_xlate</span>
        <span class="s1">log.debug(msg + </span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">self.user_options:</span>
            <span class="s1">opt_name = opt[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">opt_name[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;=&quot;</span><span class="s1">:</span>
                <span class="s1">opt_name = opt_name[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">opt_name </span><span class="s2">in </span><span class="s1">self.negative_opt:</span>
                <span class="s1">opt_name = self.negative_opt[opt_name]</span>
                <span class="s1">opt_name = opt_name.translate(longopt_xlate)</span>
                <span class="s1">val = </span><span class="s2">not </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">opt_name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">opt_name = opt_name.translate(longopt_xlate)</span>
                <span class="s1">val = getattr(self</span><span class="s2">, </span><span class="s1">opt_name)</span>
            <span class="s1">log.debug(</span><span class="s3">&quot;  %s: %s&quot;</span><span class="s2">, </span><span class="s1">opt_name</span><span class="s2">, </span><span class="s1">val)</span>

    <span class="s2">def </span><span class="s1">finalize_unix(self):</span>
        <span class="s0">&quot;&quot;&quot;Finalizes options for posix platforms.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.install_base </span><span class="s2">is not None or </span><span class="s1">self.install_platbase </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">((self.install_lib </span><span class="s2">is None and</span>
                 <span class="s1">self.install_purelib </span><span class="s2">is None and</span>
                 <span class="s1">self.install_platlib </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">or</span>
                <span class="s1">self.install_headers </span><span class="s2">is None or</span>
                <span class="s1">self.install_scripts </span><span class="s2">is None or</span>
                <span class="s1">self.install_data </span><span class="s2">is None</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                      <span class="s3">&quot;install-base or install-platbase supplied, but &quot;</span>
                      <span class="s3">&quot;installation scheme is incomplete&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.user:</span>
            <span class="s2">if </span><span class="s1">self.install_userbase </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
                    <span class="s3">&quot;User base directory is not specified&quot;</span><span class="s1">)</span>
            <span class="s1">self.install_base = self.install_platbase = self.install_userbase</span>
            <span class="s1">self.select_scheme(</span><span class="s3">&quot;unix_user&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.home </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.install_base = self.install_platbase = self.home</span>
            <span class="s1">self.select_scheme(</span><span class="s3">&quot;unix_home&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.prefix </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.exec_prefix </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                          <span class="s3">&quot;must not supply exec-prefix without prefix&quot;</span><span class="s1">)</span>

                <span class="s1">self.prefix = os.path.normpath(sys.prefix)</span>
                <span class="s1">self.exec_prefix = os.path.normpath(sys.exec_prefix)</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self.exec_prefix </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self.exec_prefix = self.prefix</span>

            <span class="s1">self.install_base = self.prefix</span>
            <span class="s1">self.install_platbase = self.exec_prefix</span>
            <span class="s1">self.select_scheme(</span><span class="s3">&quot;unix_prefix&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">finalize_other(self):</span>
        <span class="s0">&quot;&quot;&quot;Finalizes options for non-posix platforms&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.user:</span>
            <span class="s2">if </span><span class="s1">self.install_userbase </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
                    <span class="s3">&quot;User base directory is not specified&quot;</span><span class="s1">)</span>
            <span class="s1">self.install_base = self.install_platbase = self.install_userbase</span>
            <span class="s1">self.select_scheme(os.name + </span><span class="s3">&quot;_user&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.home </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.install_base = self.install_platbase = self.home</span>
            <span class="s1">self.select_scheme(</span><span class="s3">&quot;unix_home&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.prefix </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.prefix = os.path.normpath(sys.prefix)</span>

            <span class="s1">self.install_base = self.install_platbase = self.prefix</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.select_scheme(os.name)</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span>
                      <span class="s3">&quot;I don't know how to install stuff on '%s'&quot; </span><span class="s1">% os.name)</span>

    <span class="s2">def </span><span class="s1">select_scheme(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot;Sets the install directories by applying the install schemes.&quot;&quot;&quot;</span>
        <span class="s4"># it's the caller's problem if they supply a bad name!</span>
        <span class="s2">if </span><span class="s1">(hasattr(sys</span><span class="s2">, </span><span class="s3">'pypy_version_info'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">name.endswith((</span><span class="s3">'_user'</span><span class="s2">, </span><span class="s3">'_home'</span><span class="s1">))):</span>
            <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s3">'pypy_nt'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s3">'pypy'</span>
        <span class="s1">scheme = INSTALL_SCHEMES[name]</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">SCHEME_KEYS:</span>
            <span class="s1">attrname = </span><span class="s3">'install_' </span><span class="s1">+ key</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attrname) </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attrname</span><span class="s2">, </span><span class="s1">scheme[key])</span>

    <span class="s2">def </span><span class="s1">_expand_attrs(self</span><span class="s2">, </span><span class="s1">attrs):</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s1">val = getattr(self</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix' </span><span class="s2">or </span><span class="s1">os.name == </span><span class="s3">'nt'</span><span class="s1">:</span>
                    <span class="s1">val = os.path.expanduser(val)</span>
                <span class="s1">val = subst_vars(val</span><span class="s2">, </span><span class="s1">self.config_vars)</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>

    <span class="s2">def </span><span class="s1">expand_basedirs(self):</span>
        <span class="s0">&quot;&quot;&quot;Calls `os.path.expanduser` on install_base, install_platbase and 
        root.&quot;&quot;&quot;</span>
        <span class="s1">self._expand_attrs([</span><span class="s3">'install_base'</span><span class="s2">, </span><span class="s3">'install_platbase'</span><span class="s2">, </span><span class="s3">'root'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">expand_dirs(self):</span>
        <span class="s0">&quot;&quot;&quot;Calls `os.path.expanduser` on install dirs.&quot;&quot;&quot;</span>
        <span class="s1">self._expand_attrs([</span><span class="s3">'install_purelib'</span><span class="s2">, </span><span class="s3">'install_platlib'</span><span class="s2">,</span>
                            <span class="s3">'install_lib'</span><span class="s2">, </span><span class="s3">'install_headers'</span><span class="s2">,</span>
                            <span class="s3">'install_scripts'</span><span class="s2">, </span><span class="s3">'install_data'</span><span class="s2">,</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">convert_paths(self</span><span class="s2">, </span><span class="s1">*names):</span>
        <span class="s0">&quot;&quot;&quot;Call `convert_path` over `names`.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">attr = </span><span class="s3">&quot;install_&quot; </span><span class="s1">+ name</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">convert_path(getattr(self</span><span class="s2">, </span><span class="s1">attr)))</span>

    <span class="s2">def </span><span class="s1">handle_extra_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Set `path_file` and `extra_dirs` using `extra_path`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.extra_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.extra_path = self.distribution.extra_path</span>

        <span class="s2">if </span><span class="s1">self.extra_path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">log.warn(</span>
                <span class="s3">&quot;Distribution option extra_path is deprecated. &quot;</span>
                <span class="s3">&quot;See issue27919 for details.&quot;</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(self.extra_path</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">self.extra_path = self.extra_path.split(</span><span class="s3">','</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">len(self.extra_path) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">path_file = extra_dirs = self.extra_path[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">len(self.extra_path) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">path_file</span><span class="s2">, </span><span class="s1">extra_dirs = self.extra_path</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                      <span class="s3">&quot;'extra_path' option must be a list, tuple, or &quot;</span>
                      <span class="s3">&quot;comma-separated string with 1 or 2 elements&quot;</span><span class="s1">)</span>

            <span class="s4"># convert to local form in case Unix notation used (as it</span>
            <span class="s4"># should be in setup scripts)</span>
            <span class="s1">extra_dirs = convert_path(extra_dirs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">path_file = </span><span class="s2">None</span>
            <span class="s1">extra_dirs = </span><span class="s3">''</span>

        <span class="s4"># XXX should we warn if path_file and not extra_dirs? (in which</span>
        <span class="s4"># case the path file would be harmless but pointless)</span>
        <span class="s1">self.path_file = path_file</span>
        <span class="s1">self.extra_dirs = extra_dirs</span>

    <span class="s2">def </span><span class="s1">change_roots(self</span><span class="s2">, </span><span class="s1">*names):</span>
        <span class="s0">&quot;&quot;&quot;Change the install directories pointed by name using root.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">attr = </span><span class="s3">&quot;install_&quot; </span><span class="s1">+ name</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">change_root(self.root</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attr)))</span>

    <span class="s2">def </span><span class="s1">create_home_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Create directories under ~.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.user:</span>
            <span class="s2">return</span>
        <span class="s1">home = convert_path(os.path.expanduser(</span><span class="s3">&quot;~&quot;</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.config_vars.items():</span>
            <span class="s2">if </span><span class="s1">path.startswith(home) </span><span class="s2">and not </span><span class="s1">os.path.isdir(path):</span>
                <span class="s1">self.debug_print(</span><span class="s3">&quot;os.makedirs('%s', 0o700)&quot; </span><span class="s1">% path)</span>
                <span class="s1">os.makedirs(path</span><span class="s2">, </span><span class="s5">0o700</span><span class="s1">)</span>

    <span class="s4"># -- Command execution methods -------------------------------------</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s0">&quot;&quot;&quot;Runs the command.&quot;&quot;&quot;</span>
        <span class="s4"># Obviously have to build before we can install</span>
        <span class="s2">if not </span><span class="s1">self.skip_build:</span>
            <span class="s1">self.run_command(</span><span class="s3">'build'</span><span class="s1">)</span>
            <span class="s4"># If we built for any other platform, we can't install.</span>
            <span class="s1">build_plat = self.distribution.get_command_obj(</span><span class="s3">'build'</span><span class="s1">).plat_name</span>
            <span class="s4"># check warn_dir - it is a clue that the 'install' is happening</span>
            <span class="s4"># internally, and not to sys.path, so we don't check the platform</span>
            <span class="s4"># matches what we are running.</span>
            <span class="s2">if </span><span class="s1">self.warn_dir </span><span class="s2">and </span><span class="s1">build_plat != get_platform():</span>
                <span class="s2">raise </span><span class="s1">DistutilsPlatformError(</span><span class="s3">&quot;Can't install when &quot;</span>
                                             <span class="s3">&quot;cross-compiling&quot;</span><span class="s1">)</span>

        <span class="s4"># Run all sub-commands (at least those that need to be run)</span>
        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">self.get_sub_commands():</span>
            <span class="s1">self.run_command(cmd_name)</span>

        <span class="s2">if </span><span class="s1">self.path_file:</span>
            <span class="s1">self.create_path_file()</span>

        <span class="s4"># write list of installed files, if requested.</span>
        <span class="s2">if </span><span class="s1">self.record:</span>
            <span class="s1">outputs = self.get_outputs()</span>
            <span class="s2">if </span><span class="s1">self.root:               </span><span class="s4"># strip any package prefix</span>
                <span class="s1">root_len = len(self.root)</span>
                <span class="s2">for </span><span class="s1">counter </span><span class="s2">in </span><span class="s1">range(len(outputs)):</span>
                    <span class="s1">outputs[counter] = outputs[counter][root_len:]</span>
            <span class="s1">self.execute(write_file</span><span class="s2">,</span>
                         <span class="s1">(self.record</span><span class="s2">, </span><span class="s1">outputs)</span><span class="s2">,</span>
                         <span class="s3">&quot;writing list of installed files to '%s'&quot; </span><span class="s1">%</span>
                         <span class="s1">self.record)</span>

        <span class="s1">sys_path = map(os.path.normpath</span><span class="s2">, </span><span class="s1">sys.path)</span>
        <span class="s1">sys_path = map(os.path.normcase</span><span class="s2">, </span><span class="s1">sys_path)</span>
        <span class="s1">install_lib = os.path.normcase(os.path.normpath(self.install_lib))</span>
        <span class="s2">if </span><span class="s1">(self.warn_dir </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">(self.path_file </span><span class="s2">and </span><span class="s1">self.install_path_file) </span><span class="s2">and</span>
            <span class="s1">install_lib </span><span class="s2">not in </span><span class="s1">sys_path):</span>
            <span class="s1">log.debug((</span><span class="s3">&quot;modules installed to '%s', which is not in &quot;</span>
                       <span class="s3">&quot;Python's module search path (sys.path) -- &quot;</span>
                       <span class="s3">&quot;you'll have to change the search path yourself&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">self.install_lib)</span>

    <span class="s2">def </span><span class="s1">create_path_file(self):</span>
        <span class="s0">&quot;&quot;&quot;Creates the .pth file&quot;&quot;&quot;</span>
        <span class="s1">filename = os.path.join(self.install_libbase</span><span class="s2">,</span>
                                <span class="s1">self.path_file + </span><span class="s3">&quot;.pth&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.install_path_file:</span>
            <span class="s1">self.execute(write_file</span><span class="s2">,</span>
                         <span class="s1">(filename</span><span class="s2">, </span><span class="s1">[self.extra_dirs])</span><span class="s2">,</span>
                         <span class="s3">&quot;creating %s&quot; </span><span class="s1">% filename)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.warn(</span><span class="s3">&quot;path file '%s' not created&quot; </span><span class="s1">% filename)</span>


    <span class="s4"># -- Reporting methods ---------------------------------------------</span>

    <span class="s2">def </span><span class="s1">get_outputs(self):</span>
        <span class="s0">&quot;&quot;&quot;Assembles the outputs of all the sub-commands.&quot;&quot;&quot;</span>
        <span class="s1">outputs = []</span>
        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">self.get_sub_commands():</span>
            <span class="s1">cmd = self.get_finalized_command(cmd_name)</span>
            <span class="s4"># Add the contents of cmd.get_outputs(), ensuring</span>
            <span class="s4"># that outputs doesn't contain duplicate entries</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">cmd.get_outputs():</span>
                <span class="s2">if </span><span class="s1">filename </span><span class="s2">not in </span><span class="s1">outputs:</span>
                    <span class="s1">outputs.append(filename)</span>

        <span class="s2">if </span><span class="s1">self.path_file </span><span class="s2">and </span><span class="s1">self.install_path_file:</span>
            <span class="s1">outputs.append(os.path.join(self.install_libbase</span><span class="s2">,</span>
                                        <span class="s1">self.path_file + </span><span class="s3">&quot;.pth&quot;</span><span class="s1">))</span>

        <span class="s2">return </span><span class="s1">outputs</span>

    <span class="s2">def </span><span class="s1">get_inputs(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the inputs of all the sub-commands&quot;&quot;&quot;</span>
        <span class="s4"># XXX gee, this looks familiar ;-(</span>
        <span class="s1">inputs = []</span>
        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">self.get_sub_commands():</span>
            <span class="s1">cmd = self.get_finalized_command(cmd_name)</span>
            <span class="s1">inputs.extend(cmd.get_inputs())</span>

        <span class="s2">return </span><span class="s1">inputs</span>

    <span class="s4"># -- Predicates for sub-command list -------------------------------</span>

    <span class="s2">def </span><span class="s1">has_lib(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns true if the current distribution has any Python 
        modules to install.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self.distribution.has_pure_modules() </span><span class="s2">or</span>
                <span class="s1">self.distribution.has_ext_modules())</span>

    <span class="s2">def </span><span class="s1">has_headers(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns true if the current distribution has any headers to 
        install.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.distribution.has_headers()</span>

    <span class="s2">def </span><span class="s1">has_scripts(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns true if the current distribution has any scripts to. 
        install.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.distribution.has_scripts()</span>

    <span class="s2">def </span><span class="s1">has_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns true if the current distribution has any data to. 
        install.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.distribution.has_data_files()</span>

    <span class="s4"># 'sub_commands': a list of commands this command might have to run to</span>
    <span class="s4"># get its work done.  See cmd.py for more info.</span>
    <span class="s1">sub_commands = [(</span><span class="s3">'install_lib'</span><span class="s2">,     </span><span class="s1">has_lib)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">'install_headers'</span><span class="s2">, </span><span class="s1">has_headers)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">'install_scripts'</span><span class="s2">, </span><span class="s1">has_scripts)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">'install_data'</span><span class="s2">,    </span><span class="s1">has_data)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">'install_egg_info'</span><span class="s2">, lambda </span><span class="s1">self:</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s1">]</span>
</pre>
</body>
</html>